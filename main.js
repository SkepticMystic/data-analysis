/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/json2csv/dist/json2csv.umd.js
var require_json2csv_umd = __commonJS({
  "node_modules/json2csv/dist/json2csv.umd.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.json2csv = {}));
    })(exports, function(exports2) {
      "use strict";
      var domain;
      function EventHandlers() {
      }
      EventHandlers.prototype = Object.create(null);
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.usingDomains = false;
      EventEmitter.prototype.domain = void 0;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._maxListeners = void 0;
      EventEmitter.defaultMaxListeners = 10;
      EventEmitter.init = function() {
        this.domain = null;
        if (EventEmitter.usingDomains) {
          if (domain.active && !(this instanceof domain.Domain))
            ;
        }
        if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || isNaN(n))
          throw new TypeError('"n" argument must be a positive number');
        this._maxListeners = n;
        return this;
      };
      function $getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return $getMaxListeners(this);
      };
      function emitNone(handler, isFn, self2) {
        if (isFn)
          handler.call(self2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2);
        }
      }
      function emitOne(handler, isFn, self2, arg1) {
        if (isFn)
          handler.call(self2, arg1);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2, arg1);
        }
      }
      function emitTwo(handler, isFn, self2, arg1, arg2) {
        if (isFn)
          handler.call(self2, arg1, arg2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2, arg1, arg2);
        }
      }
      function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
        if (isFn)
          handler.call(self2, arg1, arg2, arg3);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2, arg1, arg2, arg3);
        }
      }
      function emitMany(handler, isFn, self2, args) {
        if (isFn)
          handler.apply(self2, args);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].apply(self2, args);
        }
      }
      EventEmitter.prototype.emit = function emit(type2) {
        var er, handler, len, args, i, events, domain2;
        var doError = type2 === "error";
        events = this._events;
        if (events)
          doError = doError && events.error == null;
        else if (!doError)
          return false;
        domain2 = this.domain;
        if (doError) {
          er = arguments[1];
          if (domain2) {
            if (!er)
              er = new Error('Uncaught, unspecified "error" event');
            er.domainEmitter = this;
            er.domain = domain2;
            er.domainThrown = false;
            domain2.emit("error", er);
          } else if (er instanceof Error) {
            throw er;
          } else {
            var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
            err.context = er;
            throw err;
          }
          return false;
        }
        handler = events[type2];
        if (!handler)
          return false;
        var isFn = typeof handler === "function";
        len = arguments.length;
        switch (len) {
          case 1:
            emitNone(handler, isFn, this);
            break;
          case 2:
            emitOne(handler, isFn, this, arguments[1]);
            break;
          case 3:
            emitTwo(handler, isFn, this, arguments[1], arguments[2]);
            break;
          case 4:
            emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
            break;
          default:
            args = new Array(len - 1);
            for (i = 1; i < len; i++)
              args[i - 1] = arguments[i];
            emitMany(handler, isFn, this, args);
        }
        return true;
      };
      function _addListener(target, type2, listener, prepend) {
        var m;
        var events;
        var existing;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = target._events;
        if (!events) {
          events = target._events = new EventHandlers();
          target._eventsCount = 0;
        } else {
          if (events.newListener) {
            target.emit("newListener", type2, listener.listener ? listener.listener : listener);
            events = target._events;
          }
          existing = events[type2];
        }
        if (!existing) {
          existing = events[type2] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type2] = prepend ? [listener, existing] : [existing, listener];
          } else {
            if (prepend) {
              existing.unshift(listener);
            } else {
              existing.push(listener);
            }
          }
          if (!existing.warned) {
            m = $getMaxListeners(target);
            if (m && m > 0 && existing.length > m) {
              existing.warned = true;
              var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
              w.name = "MaxListenersExceededWarning";
              w.emitter = target;
              w.type = type2;
              w.count = existing.length;
              emitWarning(w);
            }
          }
        }
        return target;
      }
      function emitWarning(e) {
        typeof console.warn === "function" ? console.warn(e) : console.log(e);
      }
      EventEmitter.prototype.addListener = function addListener2(type2, listener) {
        return _addListener(this, type2, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener2(type2, listener) {
        return _addListener(this, type2, listener, true);
      };
      function _onceWrap(target, type2, listener) {
        var fired = false;
        function g() {
          target.removeListener(type2, g);
          if (!fired) {
            fired = true;
            listener.apply(target, arguments);
          }
        }
        g.listener = listener;
        return g;
      }
      EventEmitter.prototype.once = function once(type2, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.on(type2, _onceWrap(this, type2, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type2, _onceWrap(this, type2, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener2(type2, listener) {
        var list, events, position, i, originalListener;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = this._events;
        if (!events)
          return this;
        list = events[type2];
        if (!list)
          return this;
        if (list === listener || list.listener && list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else {
            delete events[type2];
            if (events.removeListener)
              this.emit("removeListener", type2, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length; i-- > 0; ) {
            if (list[i] === listener || list[i].listener && list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (list.length === 1) {
            list[0] = void 0;
            if (--this._eventsCount === 0) {
              this._events = new EventHandlers();
              return this;
            } else {
              delete events[type2];
            }
          } else {
            spliceOne(list, position);
          }
          if (events.removeListener)
            this.emit("removeListener", type2, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type2) {
        var listeners, events;
        events = this._events;
        if (!events)
          return this;
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = new EventHandlers();
            this._eventsCount = 0;
          } else if (events[type2]) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else
              delete events[type2];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys2 = Object.keys(events);
          for (var i = 0, key; i < keys2.length; ++i) {
            key = keys2[i];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = new EventHandlers();
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type2];
        if (typeof listeners === "function") {
          this.removeListener(type2, listeners);
        } else if (listeners) {
          do {
            this.removeListener(type2, listeners[listeners.length - 1]);
          } while (listeners[0]);
        }
        return this;
      };
      EventEmitter.prototype.listeners = function listeners(type2) {
        var evlistener;
        var ret;
        var events = this._events;
        if (!events)
          ret = [];
        else {
          evlistener = events[type2];
          if (!evlistener)
            ret = [];
          else if (typeof evlistener === "function")
            ret = [evlistener.listener || evlistener];
          else
            ret = unwrapListeners(evlistener);
        }
        return ret;
      };
      EventEmitter.listenerCount = function(emitter, type2) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type2);
        } else {
          return listenerCount.call(emitter, type2);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type2) {
        var events = this._events;
        if (events) {
          var evlistener = events[type2];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
      };
      function spliceOne(list, index) {
        for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
          list[i] = list[k];
        list.pop();
      }
      function arrayClone(arr, i) {
        var copy2 = new Array(i);
        while (i--)
          copy2[i] = arr[i];
        return copy2;
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var inited = false;
      function init2() {
        inited = true;
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i];
          revLookup[code.charCodeAt(i)] = i;
        }
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
      }
      function toByteArray(b64) {
        if (!inited) {
          init2();
        }
        var i, j, l, tmp, placeHolders, arr;
        var len = b64.length;
        if (len % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
        arr = new Arr(len * 3 / 4 - placeHolders);
        l = placeHolders > 0 ? len - 4 : len;
        var L = 0;
        for (i = 0, j = 0; i < l; i += 4, j += 3) {
          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
          arr[L++] = tmp >> 16 & 255;
          arr[L++] = tmp >> 8 & 255;
          arr[L++] = tmp & 255;
        }
        if (placeHolders === 2) {
          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
          arr[L++] = tmp & 255;
        } else if (placeHolders === 1) {
          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
          arr[L++] = tmp >> 8 & 255;
          arr[L++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i = start; i < end; i += 3) {
          tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        if (!inited) {
          init2();
        }
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3;
        var output = "";
        var parts = [];
        var maxChunkLength = 16383;
        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len - 1];
          output += lookup[tmp >> 2];
          output += lookup[tmp << 4 & 63];
          output += "==";
        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + uint8[len - 1];
          output += lookup[tmp >> 10];
          output += lookup[tmp >> 4 & 63];
          output += lookup[tmp << 2 & 63];
          output += "=";
        }
        parts.push(output);
        return parts.join("");
      }
      function read(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      }
      function write(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      }
      var toString = {}.toString;
      var isArray2 = Array.isArray || function(arr) {
        return toString.call(arr) == "[object Array]";
      };
      var INSPECT_MAX_BYTES = 50;
      Buffer2.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
      function kMaxLength() {
        return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
      }
      function createBuffer(that, length) {
        if (kMaxLength() < length) {
          throw new RangeError("Invalid typed array length");
        }
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          that = new Uint8Array(length);
          that.__proto__ = Buffer2.prototype;
        } else {
          if (that === null) {
            that = new Buffer2(length);
          }
          that.length = length;
        }
        return that;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
          return new Buffer2(arg, encodingOrOffset, length);
        }
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new Error("If encoding is specified then the first argument must be a string");
          }
          return allocUnsafe(this, arg);
        }
        return from(this, arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      Buffer2._augment = function(arr) {
        arr.__proto__ = Buffer2.prototype;
        return arr;
      };
      function from(that, value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('"value" argument must not be a number');
        }
        if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
          return fromArrayBuffer(that, value, encodingOrOffset, length);
        }
        if (typeof value === "string") {
          return fromString(that, value, encodingOrOffset);
        }
        return fromObject2(that, value);
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(null, value, encodingOrOffset, length);
      };
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        Buffer2.prototype.__proto__ = Uint8Array.prototype;
        Buffer2.__proto__ = Uint8Array;
      }
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be a number');
        } else if (size < 0) {
          throw new RangeError('"size" argument must not be negative');
        }
      }
      function alloc(that, size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(that, size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
        }
        return createBuffer(that, size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(null, size, fill, encoding);
      };
      function allocUnsafe(that, size) {
        assertSize(size);
        that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
        if (!Buffer2.TYPED_ARRAY_SUPPORT) {
          for (var i = 0; i < size; ++i) {
            that[i] = 0;
          }
        }
        return that;
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(null, size);
      };
      function fromString(that, string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError('"encoding" must be a valid string encoding');
        }
        var length = byteLength(string, encoding) | 0;
        that = createBuffer(that, length);
        var actual = that.write(string, encoding);
        if (actual !== length) {
          that = that.slice(0, actual);
        }
        return that;
      }
      function fromArrayLike(that, array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0;
        that = createBuffer(that, length);
        for (var i = 0; i < length; i += 1) {
          that[i] = array[i] & 255;
        }
        return that;
      }
      function fromArrayBuffer(that, array, byteOffset, length) {
        array.byteLength;
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError("'offset' is out of bounds");
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError("'length' is out of bounds");
        }
        if (byteOffset === void 0 && length === void 0) {
          array = new Uint8Array(array);
        } else if (length === void 0) {
          array = new Uint8Array(array, byteOffset);
        } else {
          array = new Uint8Array(array, byteOffset, length);
        }
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          that = array;
          that.__proto__ = Buffer2.prototype;
        } else {
          that = fromArrayLike(that, array);
        }
        return that;
      }
      function fromObject2(that, obj) {
        if (internalIsBuffer(obj)) {
          var len = checked(obj.length) | 0;
          that = createBuffer(that, len);
          if (that.length === 0) {
            return that;
          }
          obj.copy(that, 0, 0, len);
          return that;
        }
        if (obj) {
          if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
            if (typeof obj.length !== "number" || isnan(obj.length)) {
              return createBuffer(that, 0);
            }
            return fromArrayLike(that, obj);
          }
          if (obj.type === "Buffer" && isArray2(obj.data)) {
            return fromArrayLike(that, obj.data);
          }
        }
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
      }
      function checked(length) {
        if (length >= kMaxLength()) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
        }
        return length | 0;
      }
      Buffer2.isBuffer = isBuffer;
      function internalIsBuffer(b) {
        return !!(b != null && b._isBuffer);
      }
      Buffer2.compare = function compare(a, b) {
        if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
          throw new TypeError("Arguments must be Buffers");
        }
        if (a === b)
          return 0;
        var x = a.length;
        var y = b.length;
        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!isArray2(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        var i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        var buffer = Buffer2.allocUnsafe(length);
        var pos = 0;
        for (i = 0; i < list.length; ++i) {
          var buf = list[i];
          if (!internalIsBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          buf.copy(buffer, pos);
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (internalIsBuffer(string)) {
          return string.length;
        }
        if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          string = "" + string;
        }
        var len = string.length;
        if (len === 0)
          return 0;
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
            case void 0:
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase)
                return utf8ToBytes(string).length;
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        var loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap2(b, n, m) {
        var i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i = 0; i < len; i += 2) {
          swap2(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i = 0; i < len; i += 4) {
          swap2(this, i, i + 3);
          swap2(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i = 0; i < len; i += 8) {
          swap2(this, i, i + 7);
          swap2(this, i + 1, i + 6);
          swap2(this, i + 2, i + 5);
          swap2(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString2() {
        var length = this.length | 0;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.equals = function equals(b) {
        if (!internalIsBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect2() {
        var str = "";
        var max = INSPECT_MAX_BYTES;
        if (this.length > 0) {
          str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
          if (this.length > max)
            str += " ... ";
        }
        return "<Buffer " + str + ">";
      };
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (!internalIsBuffer(target)) {
          throw new TypeError("Argument must be a Buffer");
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        var x = thisEnd - thisStart;
        var y = end - start;
        var len = Math.min(x, y);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (isNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (internalIsBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read2(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        var i;
        if (dir) {
          var foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            var found = true;
            for (var j = 0; j < valLength; j++) {
              if (read2(arr, i + j) !== read2(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        var strLen = string.length;
        if (strLen % 2 !== 0)
          throw new TypeError("Invalid hex string");
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        for (var i = 0; i < length; ++i) {
          var parsed = parseInt(string.substr(i * 2, 2), 16);
          if (isNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function latin1Write(buf, string, offset, length) {
        return asciiWrite(buf, string, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write2(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset | 0;
          if (isFinite(length)) {
            length = length | 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        }
        var remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
              return asciiWrite(this, string, offset, length);
            case "latin1":
            case "binary":
              return latin1Write(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return fromByteArray(buf);
        } else {
          return fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i = start;
        while (i < end) {
          var firstByte = buf[i];
          var codePoint = null;
          var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        var res = "";
        var i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        var out = "";
        for (var i = start; i < end; ++i) {
          out += toHex(buf[i]);
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = "";
        for (var i = 0; i < bytes.length; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end);
          newBuf.__proto__ = Buffer2.prototype;
        } else {
          var sliceLen = end - start;
          newBuf = new Buffer2(sliceLen, void 0);
          for (var i = 0; i < sliceLen; ++i) {
            newBuf[i] = this[i + start];
          }
        }
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        var val = this[offset + --byteLength2];
        var mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var i = byteLength2;
        var mul = 1;
        var val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!internalIsBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var mul = 1;
        var i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var i = byteLength2 - 1;
        var mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        if (!Buffer2.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        this[offset] = value & 255;
        return offset + 1;
      };
      function objectWriteUInt16(buf, value, offset, littleEndian) {
        if (value < 0)
          value = 65535 + value + 1;
        for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
          buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
        }
      }
      Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      function objectWriteUInt32(buf, value, offset, littleEndian) {
        if (value < 0)
          value = 4294967295 + value + 1;
        for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
          buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
        }
      }
      Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset + 3] = value >>> 24;
          this[offset + 2] = value >>> 16;
          this[offset + 1] = value >>> 8;
          this[offset] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i = byteLength2 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (!Buffer2.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
          this[offset + 2] = value >>> 16;
          this[offset + 3] = value >>> 24;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4);
        }
        write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8);
        }
        write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        var i;
        if (this === target && start < targetStart && targetStart < end) {
          for (i = len - 1; i >= 0; --i) {
            target[i + targetStart] = this[i + start];
          }
        } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
          for (i = 0; i < len; ++i) {
            target[i + targetStart] = this[i + start];
          }
        } else {
          Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (code < 256) {
              val = code;
            }
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
        } else if (typeof val === "number") {
          val = val & 255;
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        var i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
          var len = bytes.length;
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = stringtrim(str).replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function stringtrim(str) {
        if (str.trim)
          return str.trim();
        return str.replace(/^\s+|\s+$/g, "");
      }
      function toHex(n) {
        if (n < 16)
          return "0" + n.toString(16);
        return n.toString(16);
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        var codePoint;
        var length = string.length;
        var leadSurrogate = null;
        var bytes = [];
        for (var i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        var c, hi, lo;
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        for (var i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isnan(val) {
        return val !== val;
      }
      function isBuffer(obj) {
        return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
      }
      function isFastBuffer(obj) {
        return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
      }
      function isSlowBuffer(obj) {
        return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
      }
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      var cachedSetTimeout = defaultSetTimout;
      var cachedClearTimeout = defaultClearTimeout;
      if (typeof global$1.setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      }
      if (typeof global$1.clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      }
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      }
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      var performance = global$1.performance || {};
      var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
        return new Date().getTime();
      };
      var inherits;
      if (typeof Object.create === "function") {
        inherits = function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        };
      } else {
        inherits = function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        };
      }
      var inherits$1 = inherits;
      var formatRegExp = /%[sdj%]/g;
      function format(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(" ");
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%")
            return "%";
          if (i >= len)
            return x2;
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject2(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      }
      function deprecate(fn, msg) {
        if (isUndefined(global$1.process)) {
          return function() {
            return deprecate(fn, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      }
      var debugs = {};
      var debugEnviron;
      function debuglog(set2) {
        if (isUndefined(debugEnviron))
          debugEnviron = "";
        set2 = set2.toUpperCase();
        if (!debugs[set2]) {
          if (new RegExp("\\b" + set2 + "\\b", "i").test(debugEnviron)) {
            var pid = 0;
            debugs[set2] = function() {
              var msg = format.apply(null, arguments);
              console.error("%s %d: %s", set2, pid, msg);
            };
          } else {
            debugs[set2] = function() {
            };
          }
        }
        return debugs[set2];
      }
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          _extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction2(value.inspect) && value.inspect !== inspect && !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys2 = Object.keys(value);
        var visibleKeys = arrayToHash(keys2);
        if (ctx.showHidden) {
          keys2 = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys2.length === 0) {
          if (isFunction2(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = "", array = false, braces = ["{", "}"];
        if (isArray$1(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction2(value)) {
          var n = value.name ? ": " + value.name : "";
          base = " [Function" + n + "]";
        }
        if (isRegExp(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = " " + formatError(value);
        }
        if (keys2.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
        } else {
          output = keys2.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber2(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
          } else {
            output.push("");
          }
        }
        keys2.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = "[" + key + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").substr(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      function reduceToSingleString(output, base, braces) {
        var length = output.reduce(function(prev, cur) {
          if (cur.indexOf("\n") >= 0)
            ;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output.join(", ") + " " + braces[1];
      }
      function isArray$1(ar) {
        return Array.isArray(ar);
      }
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      function isNull(arg) {
        return arg === null;
      }
      function isNumber2(arg) {
        return typeof arg === "number";
      }
      function isString(arg) {
        return typeof arg === "string";
      }
      function isUndefined(arg) {
        return arg === void 0;
      }
      function isRegExp(re) {
        return isObject2(re) && objectToString(re) === "[object RegExp]";
      }
      function isObject2(arg) {
        return typeof arg === "object" && arg !== null;
      }
      function isDate(d) {
        return isObject2(d) && objectToString(d) === "[object Date]";
      }
      function isError(e) {
        return isObject2(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
      }
      function isFunction2(arg) {
        return typeof arg === "function";
      }
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function _extend(origin, add) {
        if (!add || !isObject2(add))
          return origin;
        var keys2 = Object.keys(add);
        var i = keys2.length;
        while (i--) {
          origin[keys2[i]] = add[keys2[i]];
        }
        return origin;
      }
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      function BufferList() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function(v2) {
        var entry = { data: v2, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function(v2) {
        var entry = { data: v2, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          p.data.copy(ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function assertEncoding(encoding) {
        if (encoding && !isBufferEncoding(encoding)) {
          throw new Error("Unknown encoding: " + encoding);
        }
      }
      function StringDecoder(encoding) {
        this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
        assertEncoding(encoding);
        switch (this.encoding) {
          case "utf8":
            this.surrogateSize = 3;
            break;
          case "ucs2":
          case "utf16le":
            this.surrogateSize = 2;
            this.detectIncompleteChar = utf16DetectIncompleteChar;
            break;
          case "base64":
            this.surrogateSize = 3;
            this.detectIncompleteChar = base64DetectIncompleteChar;
            break;
          default:
            this.write = passThroughWrite;
            return;
        }
        this.charBuffer = new Buffer2(6);
        this.charReceived = 0;
        this.charLength = 0;
      }
      StringDecoder.prototype.write = function(buffer) {
        var charStr = "";
        while (this.charLength) {
          var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
          buffer.copy(this.charBuffer, this.charReceived, 0, available);
          this.charReceived += available;
          if (this.charReceived < this.charLength) {
            return "";
          }
          buffer = buffer.slice(available, buffer.length);
          charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
          var charCode = charStr.charCodeAt(charStr.length - 1);
          if (charCode >= 55296 && charCode <= 56319) {
            this.charLength += this.surrogateSize;
            charStr = "";
            continue;
          }
          this.charReceived = this.charLength = 0;
          if (buffer.length === 0) {
            return charStr;
          }
          break;
        }
        this.detectIncompleteChar(buffer);
        var end = buffer.length;
        if (this.charLength) {
          buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
          end -= this.charReceived;
        }
        charStr += buffer.toString(this.encoding, 0, end);
        var end = charStr.length - 1;
        var charCode = charStr.charCodeAt(end);
        if (charCode >= 55296 && charCode <= 56319) {
          var size = this.surrogateSize;
          this.charLength += size;
          this.charReceived += size;
          this.charBuffer.copy(this.charBuffer, size, 0, size);
          buffer.copy(this.charBuffer, 0, 0, size);
          return charStr.substring(0, end);
        }
        return charStr;
      };
      StringDecoder.prototype.detectIncompleteChar = function(buffer) {
        var i = buffer.length >= 3 ? 3 : buffer.length;
        for (; i > 0; i--) {
          var c = buffer[buffer.length - i];
          if (i == 1 && c >> 5 == 6) {
            this.charLength = 2;
            break;
          }
          if (i <= 2 && c >> 4 == 14) {
            this.charLength = 3;
            break;
          }
          if (i <= 3 && c >> 3 == 30) {
            this.charLength = 4;
            break;
          }
        }
        this.charReceived = i;
      };
      StringDecoder.prototype.end = function(buffer) {
        var res = "";
        if (buffer && buffer.length)
          res = this.write(buffer);
        if (this.charReceived) {
          var cr = this.charReceived;
          var buf = this.charBuffer;
          var enc = this.encoding;
          res += buf.slice(0, cr).toString(enc);
        }
        return res;
      };
      function passThroughWrite(buffer) {
        return buffer.toString(this.encoding);
      }
      function utf16DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 2;
        this.charLength = this.charReceived ? 2 : 0;
      }
      function base64DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 3;
        this.charLength = this.charReceived ? 3 : 0;
      }
      Readable.ReadableState = ReadableState;
      var debug = debuglog("stream");
      inherits$1(Readable, EventEmitter);
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function") {
          return emitter.prependListener(event, fn);
        } else {
          if (!emitter._events || !emitter._events[event])
            emitter.on(event, fn);
          else if (Array.isArray(emitter._events[event]))
            emitter._events[event].unshift(fn);
          else
            emitter._events[event] = [fn, emitter._events[event]];
        }
      }
      function listenerCount$1(emitter, type2) {
        return emitter.listeners(type2).length;
      }
      function ReadableState(options, stream) {
        options = options || {};
        this.objectMode = !!options.objectMode;
        if (stream instanceof Duplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        var hwm = options.highWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
        this.highWaterMark = ~~this.highWaterMark;
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.ranOut = false;
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable(options) {
        if (!(this instanceof Readable))
          return new Readable(options);
        this._readableState = new ReadableState(options, this);
        this.readable = true;
        if (options && typeof options.read === "function")
          this._read = options.read;
        EventEmitter.call(this);
      }
      Readable.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        if (!state.objectMode && typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
        }
        return readableAddChunk(this, state, chunk, encoding, false);
      };
      Readable.prototype.unshift = function(chunk) {
        var state = this._readableState;
        return readableAddChunk(this, state, chunk, "", true);
      };
      Readable.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      function readableAddChunk(stream, state, chunk, encoding, addToFront) {
        var er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (state.ended && !addToFront) {
            var e = new Error("stream.push() after EOF");
            stream.emit("error", e);
          } else if (state.endEmitted && addToFront) {
            var _e = new Error("stream.unshift() after end event");
            stream.emit("error", _e);
          } else {
            var skipAdd;
            if (state.decoder && !addToFront && !encoding) {
              chunk = state.decoder.write(chunk);
              skipAdd = !state.objectMode && chunk.length === 0;
            }
            if (!addToFront)
              state.reading = false;
            if (!skipAdd) {
              if (state.flowing && state.length === 0 && !state.sync) {
                stream.emit("data", chunk);
                stream.read(0);
              } else {
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront)
                  state.buffer.unshift(chunk);
                else
                  state.buffer.push(chunk);
                if (state.needReadable)
                  emitReadable(stream);
              }
            }
            maybeReadMore(stream, state);
          }
        } else if (!addToFront) {
          state.reading = false;
        }
        return needMoreData(state);
      }
      function needMoreData(state) {
        return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
      }
      Readable.prototype.setEncoding = function(enc) {
        this._readableState.decoder = new StringDecoder(enc);
        this._readableState.encoding = enc;
        return this;
      };
      var MAX_HWM = 8388608;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = true;
          n = 0;
        } else {
          state.length -= n;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function chunkInvalid(state, chunk) {
        var er = null;
        if (!isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
          er = new TypeError("Invalid non-string/buffer chunk");
        }
        return er;
      }
      function onEofChunk(stream, state) {
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        emitReadable(stream);
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          if (state.sync)
            nextTick(emitReadable_, stream);
          else
            emitReadable_(stream);
        }
      }
      function emitReadable_(stream) {
        debug("emit readable");
        stream.emit("readable");
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        var len = state.length;
        while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
          else
            len = state.length;
        }
        state.readingMore = false;
      }
      Readable.prototype._read = function(n) {
        this.emit("error", new Error("not implemented"));
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = !pipeOpts || pipeOpts.end !== false;
        var endFn = doEnd ? onend2 : cleanup;
        if (state.endEmitted)
          nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable) {
          debug("onunpipe");
          if (readable === src) {
            cleanup();
          }
        }
        function onend2() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", cleanup);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        var increasedAwaitDrain = false;
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          increasedAwaitDrain = false;
          var ret = dest.write(chunk);
          if (ret === false && !increasedAwaitDrain) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", src._readableState.awaitDrain);
              src._readableState.awaitDrain++;
              increasedAwaitDrain = true;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (listenerCount$1(dest, "error") === 0)
            dest.emit("error", er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && src.listeners("data").length) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable.prototype.unpipe = function(dest) {
        var state = this._readableState;
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var _i = 0; _i < len; _i++) {
            dests[_i].emit("unpipe", this);
          }
          return this;
        }
        var i = indexOf(state.pipes, dest);
        if (i === -1)
          return this;
        state.pipes.splice(i, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this);
        return this;
      };
      Readable.prototype.on = function(ev, fn) {
        var res = EventEmitter.prototype.on.call(this, ev, fn);
        if (ev === "data") {
          if (this._readableState.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          var state = this._readableState;
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) {
              nextTick(nReadingNextTick, this);
            } else if (state.length) {
              emitReadable(this);
            }
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = true;
          resume(this, state);
        }
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        if (!state.reading) {
          debug("resume read 0");
          stream.read(0);
        }
        state.resumeScheduled = false;
        state.awaitDrain = 0;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
        }
      }
      Readable.prototype.wrap = function(stream) {
        var state = this._readableState;
        var paused = false;
        var self2 = this;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              self2.push(chunk);
          }
          self2.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = self2.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function(method2) {
              return function() {
                return stream[method2].apply(stream, arguments);
              };
            }(i);
          }
        }
        var events = ["error", "close", "destroy", "pause", "resume"];
        forEach(events, function(ev) {
          stream.on(ev, self2.emit.bind(self2, ev));
        });
        self2._read = function(n) {
          debug("wrapped _read", n);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return self2;
      };
      Readable._fromList = fromList;
      function fromList(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.head.data;
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = fromListPartial(n, state.buffer, state.decoder);
        }
        return ret;
      }
      function fromListPartial(n, list, hasStrings) {
        var ret;
        if (n < list.head.data.length) {
          ret = list.head.data.slice(0, n);
          list.head.data = list.head.data.slice(n);
        } else if (n === list.head.data.length) {
          ret = list.shift();
        } else {
          ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
        }
        return ret;
      }
      function copyFromBufferString(n, list) {
        var p = list.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                list.head = p.next;
              else
                list.head = list.tail = null;
            } else {
              list.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        list.length -= c;
        return ret;
      }
      function copyFromBuffer(n, list) {
        var ret = Buffer2.allocUnsafe(n);
        var p = list.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                list.head = p.next;
              else
                list.head = list.tail = null;
            } else {
              list.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        list.length -= c;
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        if (state.length > 0)
          throw new Error('"endReadable()" called on non-empty stream');
        if (!state.endEmitted) {
          state.ended = true;
          nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
        }
      }
      function forEach(xs, f) {
        for (var i = 0, l = xs.length; i < l; i++) {
          f(xs[i], i);
        }
      }
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
      Writable.WritableState = WritableState;
      inherits$1(Writable, EventEmitter);
      function nop() {
      }
      function WriteReq(chunk, encoding, cb) {
        this.chunk = chunk;
        this.encoding = encoding;
        this.callback = cb;
        this.next = null;
      }
      function WritableState(options, stream) {
        Object.defineProperty(this, "buffer", {
          get: deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
        });
        options = options || {};
        this.objectMode = !!options.objectMode;
        if (stream instanceof Duplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        var hwm = options.highWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
        this.highWaterMark = ~~this.highWaterMark;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function writableStateGetBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      function Writable(options) {
        if (!(this instanceof Writable) && !(this instanceof Duplex))
          return new Writable(options);
        this._writableState = new WritableState(options, this);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
        }
        EventEmitter.call(this);
      }
      Writable.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"));
      };
      function writeAfterEnd(stream, cb) {
        var er = new Error("write after end");
        stream.emit("error", er);
        nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var valid = true;
        var er = false;
        if (chunk === null) {
          er = new TypeError("May not write null values to stream");
        } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new TypeError("Invalid non-string/buffer chunk");
        }
        if (er) {
          stream.emit("error", er);
          nextTick(cb, er);
          valid = false;
        }
        return valid;
      }
      Writable.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (Buffer2.isBuffer(chunk))
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ended)
          writeAfterEnd(this, cb);
        else if (validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, chunk, encoding, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        var state = this._writableState;
        state.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new TypeError("Unknown encoding: " + encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      function decodeChunk(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer2.from(chunk, encoding);
        }
        return chunk;
      }
      function writeOrBuffer(stream, state, chunk, encoding, cb) {
        chunk = decodeChunk(state, chunk, encoding);
        if (Buffer2.isBuffer(chunk))
          encoding = "buffer";
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync)
          nextTick(cb, er);
        else
          cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        onwriteStateUpdate(state);
        if (er)
          onwriteError(stream, state, sync, er, cb);
        else {
          var finished = needFinish(state);
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            nextTick(afterWrite, stream, state, finished, cb);
          } else {
            afterWrite(stream, state, finished, cb);
          }
        }
      }
      function afterWrite(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          while (entry) {
            buffer[count] = entry;
            entry = entry.next;
            count += 1;
          }
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequestCount = 0;
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding, cb) {
        cb(new Error("not implemented"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending && !state.finished)
          endWritable(this, state, cb);
      };
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function prefinish(stream, state) {
        if (!state.prefinished) {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          if (state.pendingcb === 0) {
            prefinish(stream, state);
            state.finished = true;
            stream.emit("finish");
          } else {
            prefinish(stream, state);
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function(err) {
          var entry = _this.entry;
          _this.entry = null;
          while (entry) {
            var cb = entry.callback;
            state.pendingcb--;
            cb(err);
            entry = entry.next;
          }
          if (state.corkedRequestsFree) {
            state.corkedRequestsFree.next = _this;
          } else {
            state.corkedRequestsFree = _this;
          }
        };
      }
      inherits$1(Duplex, Readable);
      var keys = Object.keys(Writable.prototype);
      for (var v = 0; v < keys.length; v++) {
        var method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        if (options && options.readable === false)
          this.readable = false;
        if (options && options.writable === false)
          this.writable = false;
        this.allowHalfOpen = true;
        if (options && options.allowHalfOpen === false)
          this.allowHalfOpen = false;
        this.once("end", onend);
      }
      function onend() {
        if (this.allowHalfOpen || this._writableState.ended)
          return;
        nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      inherits$1(Transform, Duplex);
      function TransformState(stream) {
        this.afterTransform = function(er, data) {
          return afterTransform(stream, er, data);
        };
        this.needTransform = false;
        this.transforming = false;
        this.writecb = null;
        this.writechunk = null;
        this.writeencoding = null;
      }
      function afterTransform(stream, er, data) {
        var ts = stream._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (!cb)
          return stream.emit("error", new Error("no writecb in Transform class"));
        ts.writechunk = null;
        ts.writecb = null;
        if (data !== null && data !== void 0)
          stream.push(data);
        cb(er);
        var rs = stream._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          stream._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = new TransformState(this);
        var stream = this;
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.once("prefinish", function() {
          if (typeof this._flush === "function")
            this._flush(function(er) {
              done(stream, er);
            });
          else
            done(stream);
        });
      }
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        throw new Error("Not implemented");
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      function done(stream, er) {
        if (er)
          return stream.emit("error", er);
        var ws = stream._writableState;
        var ts = stream._transformState;
        if (ws.length)
          throw new Error("Calling transform done when ws.length != 0");
        if (ts.transforming)
          throw new Error("Calling transform done when still transforming");
        return stream.push(null);
      }
      inherits$1(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
      inherits$1(Stream, EventEmitter);
      Stream.Readable = Readable;
      Stream.Writable = Writable;
      Stream.Duplex = Duplex;
      Stream.Transform = Transform;
      Stream.PassThrough = PassThrough;
      Stream.Stream = Stream;
      function Stream() {
        EventEmitter.call(this);
      }
      Stream.prototype.pipe = function(dest, options) {
        var source = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (dest.write(chunk) === false && source.pause) {
              source.pause();
            }
          }
        }
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on("end", onend2);
          source.on("close", onclose);
        }
        var didOnEnd = false;
        function onend2() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          if (typeof dest.destroy === "function")
            dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (EventEmitter.listenerCount(this, "error") === 0) {
            throw er;
          }
        }
        source.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
          source.removeListener("data", ondata);
          dest.removeListener("drain", ondrain);
          source.removeListener("end", onend2);
          source.removeListener("close", onclose);
          source.removeListener("error", onerror);
          dest.removeListener("error", onerror);
          source.removeListener("end", cleanup);
          source.removeListener("close", cleanup);
          dest.removeListener("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
      };
      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance10, Constructor) {
        if (!(instance10 instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (typeof call === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _toArray(arr) {
        return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();
      }
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        }
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function _iterableToArray(iter) {
        if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
          return Array.from(iter);
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance");
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
      var _endianness;
      function endianness() {
        if (typeof _endianness === "undefined") {
          var a = new ArrayBuffer(2);
          var b = new Uint8Array(a);
          var c = new Uint16Array(a);
          b[0] = 1;
          b[1] = 2;
          if (c[0] === 258) {
            _endianness = "BE";
          } else if (c[0] === 513) {
            _endianness = "LE";
          } else {
            throw new Error("unable to figure out endianess");
          }
        }
        return _endianness;
      }
      function hostname() {
        if (typeof global$1.location !== "undefined") {
          return global$1.location.hostname;
        } else
          return "";
      }
      function loadavg() {
        return [];
      }
      function uptime() {
        return 0;
      }
      function freemem() {
        return Number.MAX_VALUE;
      }
      function totalmem() {
        return Number.MAX_VALUE;
      }
      function cpus() {
        return [];
      }
      function type() {
        return "Browser";
      }
      function release() {
        if (typeof global$1.navigator !== "undefined") {
          return global$1.navigator.appVersion;
        }
        return "";
      }
      function networkInterfaces() {
      }
      function getNetworkInterfaces() {
      }
      function tmpDir() {
        return "/tmp";
      }
      var tmpdir = tmpDir;
      var EOL = "\n";
      var os = {
        EOL,
        tmpdir,
        tmpDir,
        networkInterfaces,
        getNetworkInterfaces,
        release,
        type,
        cpus,
        totalmem,
        freemem,
        uptime,
        loadavg,
        hostname,
        endianness
      };
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      var FUNC_ERROR_TEXT = "Expected a function";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var INFINITY2 = 1 / 0;
      var funcTag = "[object Function]", genTag = "[object GeneratorFunction]", symbolTag = "[object Symbol]";
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reEscapeChar = /\\(\\)?/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      function isHostObject(value) {
        var result = false;
        if (value != null && typeof value.toString != "function") {
          try {
            result = !!(value + "");
          } catch (e) {
          }
        }
        return result;
      }
      var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      var funcToString = funcProto.toString;
      var hasOwnProperty$1 = objectProto.hasOwnProperty;
      var objectToString$1 = objectProto.toString;
      var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$1).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Symbol$1 = root.Symbol, splice = arrayProto.splice;
      var Map2 = getNative(root, "Map"), nativeCreate = getNative(Object, "create");
      var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
      function Hash(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
      }
      function hashDelete(key) {
        return this.has(key) && delete this.__data__[key];
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty$1.call(data, key) ? data[key] : void 0;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty$1.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        return getMapData(this, key)["delete"](key);
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        getMapData(this, key).set(key, value);
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq2(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseGet(object, path) {
        path = isKey(path, object) ? [path] : castPath(path);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : void 0;
      }
      function baseIsNative(value) {
        if (!isObject$1(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction$1(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
      }
      function castPath(value) {
        return isArray$2(value) ? value : stringToPath(value);
      }
      function getMapData(map3, key) {
        var data = map3.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      function isKey(value, object) {
        if (isArray$2(value)) {
          return false;
        }
        var type2 = typeof value;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      function isKeyable(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var stringToPath = memoize(function(string) {
        string = toString$1(string);
        var result = [];
        if (reLeadingDot.test(string)) {
          result.push("");
        }
        string.replace(rePropName, function(match, number, quote, string2) {
          result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result);
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      var isArray$2 = Array.isArray;
      function isFunction$1(value) {
        var tag = isObject$1(value) ? objectToString$1.call(value) : "";
        return tag == funcTag || tag == genTag;
      }
      function isObject$1(value) {
        var type2 = typeof value;
        return !!value && (type2 == "object" || type2 == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString$1.call(value) == symbolTag;
      }
      function toString$1(value) {
        return value == null ? "" : baseToString(value);
      }
      function get(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      var lodash_get = get;
      function getProp(obj, path, defaultValue) {
        return obj[path] === void 0 ? defaultValue : obj[path];
      }
      function setProp(obj, path, value) {
        var pathArray = Array.isArray(path) ? path : path.split(".");
        var _pathArray = _toArray(pathArray), key = _pathArray[0], restPath = _pathArray.slice(1);
        var newValue = pathArray.length > 1 ? setProp(obj[key] || {}, restPath, value) : value;
        return Object.assign({}, obj, _defineProperty({}, key, newValue));
      }
      function unsetProp(obj, path) {
        var pathArray = Array.isArray(path) ? path : path.split(".");
        var _pathArray2 = _toArray(pathArray), key = _pathArray2[0], restPath = _pathArray2.slice(1);
        if (_typeof(obj[key]) !== "object") {
          return obj;
        }
        if (pathArray.length === 1) {
          return Object.keys(obj).filter(function(prop) {
            return prop !== key;
          }).reduce(function(acc, prop) {
            return Object.assign(acc, _defineProperty({}, prop, obj[prop]));
          }, {});
        }
        return unsetProp(obj[key], restPath);
      }
      function flattenReducer(acc, arr) {
        try {
          acc.push.apply(acc, _toConsumableArray(arr));
          return acc;
        } catch (err) {
          return acc.concat(arr);
        }
      }
      function fastJoin(arr, separator) {
        var isFirst = true;
        return arr.reduce(function(acc, elem) {
          if (elem === null || elem === void 0) {
            elem = "";
          }
          if (isFirst) {
            isFirst = false;
            return "".concat(elem);
          }
          return "".concat(acc).concat(separator).concat(elem);
        }, "");
      }
      var utils = {
        getProp,
        setProp,
        unsetProp,
        fastJoin,
        flattenReducer
      };
      var getProp$1 = utils.getProp, fastJoin$1 = utils.fastJoin, flattenReducer$1 = utils.flattenReducer;
      var JSON2CSVBase = /* @__PURE__ */ function() {
        function JSON2CSVBase2(opts) {
          _classCallCheck(this, JSON2CSVBase2);
          this.opts = this.preprocessOpts(opts);
        }
        _createClass(JSON2CSVBase2, [{
          key: "preprocessOpts",
          value: function preprocessOpts(opts) {
            var processedOpts = Object.assign({}, opts);
            processedOpts.transforms = !Array.isArray(processedOpts.transforms) ? processedOpts.transforms ? [processedOpts.transforms] : [] : processedOpts.transforms;
            processedOpts.delimiter = processedOpts.delimiter || ",";
            processedOpts.eol = processedOpts.eol || os.EOL;
            processedOpts.quote = typeof processedOpts.quote === "string" ? processedOpts.quote : '"';
            processedOpts.escapedQuote = typeof processedOpts.escapedQuote === "string" ? processedOpts.escapedQuote : "".concat(processedOpts.quote).concat(processedOpts.quote);
            processedOpts.header = processedOpts.header !== false;
            processedOpts.includeEmptyRows = processedOpts.includeEmptyRows || false;
            processedOpts.withBOM = processedOpts.withBOM || false;
            return processedOpts;
          }
        }, {
          key: "preprocessFieldsInfo",
          value: function preprocessFieldsInfo(fields) {
            var _this = this;
            return fields.map(function(fieldInfo) {
              if (typeof fieldInfo === "string") {
                return {
                  label: fieldInfo,
                  value: fieldInfo.includes(".") || fieldInfo.includes("[") ? function(row) {
                    return lodash_get(row, fieldInfo, _this.opts.defaultValue);
                  } : function(row) {
                    return getProp$1(row, fieldInfo, _this.opts.defaultValue);
                  }
                };
              }
              if (_typeof(fieldInfo) === "object") {
                var defaultValue = "default" in fieldInfo ? fieldInfo.default : _this.opts.defaultValue;
                if (typeof fieldInfo.value === "string") {
                  return {
                    label: fieldInfo.label || fieldInfo.value,
                    value: fieldInfo.value.includes(".") || fieldInfo.value.includes("[") ? function(row) {
                      return lodash_get(row, fieldInfo.value, defaultValue);
                    } : function(row) {
                      return getProp$1(row, fieldInfo.value, defaultValue);
                    }
                  };
                }
                if (typeof fieldInfo.value === "function") {
                  var label = fieldInfo.label || fieldInfo.value.name || "";
                  var field = {
                    label,
                    default: defaultValue
                  };
                  return {
                    label,
                    value: function value(row) {
                      var value2 = fieldInfo.value(row, field);
                      return value2 === null || value2 === void 0 ? defaultValue : value2;
                    }
                  };
                }
              }
              throw new Error("Invalid field info option. " + JSON.stringify(fieldInfo));
            });
          }
        }, {
          key: "getHeader",
          value: function getHeader() {
            var _this2 = this;
            return fastJoin$1(this.opts.fields.map(function(fieldInfo) {
              return _this2.processValue(fieldInfo.label);
            }), this.opts.delimiter);
          }
        }, {
          key: "preprocessRow",
          value: function preprocessRow(row) {
            return this.opts.transforms.reduce(function(rows, transform) {
              return rows.map(function(row2) {
                return transform(row2);
              }).reduce(flattenReducer$1, []);
            }, [row]);
          }
        }, {
          key: "processRow",
          value: function processRow(row) {
            var _this3 = this;
            if (!row) {
              return void 0;
            }
            var processedRow = this.opts.fields.map(function(fieldInfo) {
              return _this3.processCell(row, fieldInfo);
            });
            if (!this.opts.includeEmptyRows && processedRow.every(function(field) {
              return field === void 0;
            })) {
              return void 0;
            }
            return fastJoin$1(processedRow, this.opts.delimiter);
          }
        }, {
          key: "processCell",
          value: function processCell(row, fieldInfo) {
            return this.processValue(fieldInfo.value(row));
          }
        }, {
          key: "processValue",
          value: function processValue(value) {
            if (value === null || value === void 0) {
              return void 0;
            }
            var valueType = _typeof(value);
            if (valueType !== "boolean" && valueType !== "number" && valueType !== "string") {
              value = JSON.stringify(value);
              if (value === void 0) {
                return void 0;
              }
              if (value[0] === '"') {
                value = value.replace(/^"(.+)"$/, "$1");
              }
            }
            if (typeof value === "string") {
              if (this.opts.excelStrings) {
                if (value.includes(this.opts.quote)) {
                  value = value.replace(new RegExp(this.opts.quote, "g"), "".concat(this.opts.escapedQuote).concat(this.opts.escapedQuote));
                }
                value = '"=""'.concat(value, '"""');
              } else {
                if (value.includes(this.opts.quote)) {
                  value = value.replace(new RegExp(this.opts.quote, "g"), this.opts.escapedQuote);
                }
                value = "".concat(this.opts.quote).concat(value).concat(this.opts.quote);
              }
            }
            return value;
          }
        }]);
        return JSON2CSVBase2;
      }();
      var JSON2CSVBase_1 = JSON2CSVBase;
      var fastJoin$2 = utils.fastJoin, flattenReducer$2 = utils.flattenReducer;
      var JSON2CSVParser = /* @__PURE__ */ function(_JSON2CSVBase) {
        _inherits(JSON2CSVParser2, _JSON2CSVBase);
        function JSON2CSVParser2(opts) {
          var _this;
          _classCallCheck(this, JSON2CSVParser2);
          _this = _possibleConstructorReturn(this, _getPrototypeOf(JSON2CSVParser2).call(this, opts));
          if (_this.opts.fields) {
            _this.opts.fields = _this.preprocessFieldsInfo(_this.opts.fields);
          }
          return _this;
        }
        _createClass(JSON2CSVParser2, [{
          key: "parse",
          value: function parse3(data) {
            var processedData = this.preprocessData(data);
            if (!this.opts.fields) {
              this.opts.fields = processedData.reduce(function(fields, item) {
                Object.keys(item).forEach(function(field) {
                  if (!fields.includes(field)) {
                    fields.push(field);
                  }
                });
                return fields;
              }, []);
              this.opts.fields = this.preprocessFieldsInfo(this.opts.fields);
            }
            var header = this.opts.header ? this.getHeader() : "";
            var rows = this.processData(processedData);
            var csv = (this.opts.withBOM ? "\uFEFF" : "") + header + (header && rows ? this.opts.eol : "") + rows;
            return csv;
          }
        }, {
          key: "preprocessData",
          value: function preprocessData(data) {
            var _this2 = this;
            var processedData = Array.isArray(data) ? data : [data];
            if (!this.opts.fields && (processedData.length === 0 || _typeof(processedData[0]) !== "object")) {
              throw new Error('Data should not be empty or the "fields" option should be included');
            }
            if (this.opts.transforms.length === 0)
              return processedData;
            return processedData.map(function(row) {
              return _this2.preprocessRow(row);
            }).reduce(flattenReducer$2, []);
          }
        }, {
          key: "processData",
          value: function processData(data) {
            var _this3 = this;
            return fastJoin$2(data.map(function(row) {
              return _this3.processRow(row);
            }).filter(function(row) {
              return row;
            }), this.opts.eol);
          }
        }]);
        return JSON2CSVParser2;
      }(JSON2CSVBase_1);
      var JSON2CSVParser_1 = JSON2CSVParser;
      var C = {};
      var LEFT_BRACE = C.LEFT_BRACE = 1;
      var RIGHT_BRACE = C.RIGHT_BRACE = 2;
      var LEFT_BRACKET = C.LEFT_BRACKET = 3;
      var RIGHT_BRACKET = C.RIGHT_BRACKET = 4;
      var COLON = C.COLON = 5;
      var COMMA = C.COMMA = 6;
      var TRUE = C.TRUE = 7;
      var FALSE = C.FALSE = 8;
      var NULL = C.NULL = 9;
      var STRING = C.STRING = 10;
      var NUMBER = C.NUMBER = 11;
      var START = C.START = 17;
      var STOP = C.STOP = 18;
      var TRUE1 = C.TRUE1 = 33;
      var TRUE2 = C.TRUE2 = 34;
      var TRUE3 = C.TRUE3 = 35;
      var FALSE1 = C.FALSE1 = 49;
      var FALSE2 = C.FALSE2 = 50;
      var FALSE3 = C.FALSE3 = 51;
      var FALSE4 = C.FALSE4 = 52;
      var NULL1 = C.NULL1 = 65;
      var NULL2 = C.NULL2 = 66;
      var NULL3 = C.NULL3 = 67;
      var NUMBER1 = C.NUMBER1 = 81;
      var NUMBER3 = C.NUMBER3 = 83;
      var STRING1 = C.STRING1 = 97;
      var STRING2 = C.STRING2 = 98;
      var STRING3 = C.STRING3 = 99;
      var STRING4 = C.STRING4 = 100;
      var STRING5 = C.STRING5 = 101;
      var STRING6 = C.STRING6 = 102;
      var VALUE = C.VALUE = 113;
      var KEY = C.KEY = 114;
      var OBJECT = C.OBJECT = 129;
      var ARRAY = C.ARRAY = 130;
      var BACK_SLASH = "\\".charCodeAt(0);
      var FORWARD_SLASH = "/".charCodeAt(0);
      var BACKSPACE = "\b".charCodeAt(0);
      var FORM_FEED = "\f".charCodeAt(0);
      var NEWLINE = "\n".charCodeAt(0);
      var CARRIAGE_RETURN = "\r".charCodeAt(0);
      var TAB = "	".charCodeAt(0);
      var STRING_BUFFER_SIZE = 64 * 1024;
      function Parser2() {
        this.tState = START;
        this.value = void 0;
        this.string = void 0;
        this.stringBuffer = Buffer2.alloc ? Buffer2.alloc(STRING_BUFFER_SIZE) : new Buffer2(STRING_BUFFER_SIZE);
        this.stringBufferOffset = 0;
        this.unicode = void 0;
        this.highSurrogate = void 0;
        this.key = void 0;
        this.mode = void 0;
        this.stack = [];
        this.state = VALUE;
        this.bytes_remaining = 0;
        this.bytes_in_sequence = 0;
        this.temp_buffs = { "2": new Buffer2(2), "3": new Buffer2(3), "4": new Buffer2(4) };
        this.offset = -1;
      }
      Parser2.toknam = function(code) {
        var keys2 = Object.keys(C);
        for (var i = 0, l = keys2.length; i < l; i++) {
          var key = keys2[i];
          if (C[key] === code) {
            return key;
          }
        }
        return code && "0x" + code.toString(16);
      };
      var proto = Parser2.prototype;
      proto.onError = function(err) {
        throw err;
      };
      proto.charError = function(buffer, i) {
        this.tState = STOP;
        this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(buffer[i])) + " at position " + i + " in state " + Parser2.toknam(this.tState)));
      };
      proto.appendStringChar = function(char) {
        if (this.stringBufferOffset >= STRING_BUFFER_SIZE) {
          this.string += this.stringBuffer.toString("utf8");
          this.stringBufferOffset = 0;
        }
        this.stringBuffer[this.stringBufferOffset++] = char;
      };
      proto.appendStringBuf = function(buf, start, end) {
        var size = buf.length;
        if (typeof start === "number") {
          if (typeof end === "number") {
            if (end < 0) {
              size = buf.length - start + end;
            } else {
              size = end - start;
            }
          } else {
            size = buf.length - start;
          }
        }
        if (size < 0) {
          size = 0;
        }
        if (this.stringBufferOffset + size > STRING_BUFFER_SIZE) {
          this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset);
          this.stringBufferOffset = 0;
        }
        buf.copy(this.stringBuffer, this.stringBufferOffset, start, end);
        this.stringBufferOffset += size;
      };
      proto.write = function(buffer) {
        if (typeof buffer === "string")
          buffer = new Buffer2(buffer);
        var n;
        for (var i = 0, l = buffer.length; i < l; i++) {
          if (this.tState === START) {
            n = buffer[i];
            this.offset++;
            if (n === 123) {
              this.onToken(LEFT_BRACE, "{");
            } else if (n === 125) {
              this.onToken(RIGHT_BRACE, "}");
            } else if (n === 91) {
              this.onToken(LEFT_BRACKET, "[");
            } else if (n === 93) {
              this.onToken(RIGHT_BRACKET, "]");
            } else if (n === 58) {
              this.onToken(COLON, ":");
            } else if (n === 44) {
              this.onToken(COMMA, ",");
            } else if (n === 116) {
              this.tState = TRUE1;
            } else if (n === 102) {
              this.tState = FALSE1;
            } else if (n === 110) {
              this.tState = NULL1;
            } else if (n === 34) {
              this.string = "";
              this.stringBufferOffset = 0;
              this.tState = STRING1;
            } else if (n === 45) {
              this.string = "-";
              this.tState = NUMBER1;
            } else {
              if (n >= 48 && n < 64) {
                this.string = String.fromCharCode(n);
                this.tState = NUMBER3;
              } else if (n === 32 || n === 9 || n === 10 || n === 13)
                ;
              else {
                return this.charError(buffer, i);
              }
            }
          } else if (this.tState === STRING1) {
            n = buffer[i];
            if (this.bytes_remaining > 0) {
              for (var j = 0; j < this.bytes_remaining; j++) {
                this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];
              }
              this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]);
              this.bytes_in_sequence = this.bytes_remaining = 0;
              i = i + j - 1;
            } else if (this.bytes_remaining === 0 && n >= 128) {
              if (n <= 193 || n > 244) {
                return this.onError(new Error("Invalid UTF-8 character at position " + i + " in state " + Parser2.toknam(this.tState)));
              }
              if (n >= 194 && n <= 223)
                this.bytes_in_sequence = 2;
              if (n >= 224 && n <= 239)
                this.bytes_in_sequence = 3;
              if (n >= 240 && n <= 244)
                this.bytes_in_sequence = 4;
              if (this.bytes_in_sequence + i > buffer.length) {
                for (var k = 0; k <= buffer.length - 1 - i; k++) {
                  this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k];
                }
                this.bytes_remaining = i + this.bytes_in_sequence - buffer.length;
                i = buffer.length - 1;
              } else {
                this.appendStringBuf(buffer, i, i + this.bytes_in_sequence);
                i = i + this.bytes_in_sequence - 1;
              }
            } else if (n === 34) {
              this.tState = START;
              this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset);
              this.stringBufferOffset = 0;
              this.onToken(STRING, this.string);
              this.offset += Buffer2.byteLength(this.string, "utf8") + 1;
              this.string = void 0;
            } else if (n === 92) {
              this.tState = STRING2;
            } else if (n >= 32) {
              this.appendStringChar(n);
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === STRING2) {
            n = buffer[i];
            if (n === 34) {
              this.appendStringChar(n);
              this.tState = STRING1;
            } else if (n === 92) {
              this.appendStringChar(BACK_SLASH);
              this.tState = STRING1;
            } else if (n === 47) {
              this.appendStringChar(FORWARD_SLASH);
              this.tState = STRING1;
            } else if (n === 98) {
              this.appendStringChar(BACKSPACE);
              this.tState = STRING1;
            } else if (n === 102) {
              this.appendStringChar(FORM_FEED);
              this.tState = STRING1;
            } else if (n === 110) {
              this.appendStringChar(NEWLINE);
              this.tState = STRING1;
            } else if (n === 114) {
              this.appendStringChar(CARRIAGE_RETURN);
              this.tState = STRING1;
            } else if (n === 116) {
              this.appendStringChar(TAB);
              this.tState = STRING1;
            } else if (n === 117) {
              this.unicode = "";
              this.tState = STRING3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6) {
            n = buffer[i];
            if (n >= 48 && n < 64 || n > 64 && n <= 70 || n > 96 && n <= 102) {
              this.unicode += String.fromCharCode(n);
              if (this.tState++ === STRING6) {
                var intVal = parseInt(this.unicode, 16);
                this.unicode = void 0;
                if (this.highSurrogate !== void 0 && intVal >= 56320 && intVal < 57343 + 1) {
                  this.appendStringBuf(new Buffer2(String.fromCharCode(this.highSurrogate, intVal)));
                  this.highSurrogate = void 0;
                } else if (this.highSurrogate === void 0 && intVal >= 55296 && intVal < 56319 + 1) {
                  this.highSurrogate = intVal;
                } else {
                  if (this.highSurrogate !== void 0) {
                    this.appendStringBuf(new Buffer2(String.fromCharCode(this.highSurrogate)));
                    this.highSurrogate = void 0;
                  }
                  this.appendStringBuf(new Buffer2(String.fromCharCode(intVal)));
                }
                this.tState = STRING1;
              }
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NUMBER1 || this.tState === NUMBER3) {
            n = buffer[i];
            switch (n) {
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
              case 46:
              case 101:
              case 69:
              case 43:
              case 45:
                this.string += String.fromCharCode(n);
                this.tState = NUMBER3;
                break;
              default:
                this.tState = START;
                var result = Number(this.string);
                if (isNaN(result)) {
                  return this.charError(buffer, i);
                }
                if (this.string.match(/[0-9]+/) == this.string && result.toString() != this.string) {
                  this.onToken(STRING, this.string);
                } else {
                  this.onToken(NUMBER, result);
                }
                this.offset += this.string.length - 1;
                this.string = void 0;
                i--;
                break;
            }
          } else if (this.tState === TRUE1) {
            if (buffer[i] === 114) {
              this.tState = TRUE2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === TRUE2) {
            if (buffer[i] === 117) {
              this.tState = TRUE3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === TRUE3) {
            if (buffer[i] === 101) {
              this.tState = START;
              this.onToken(TRUE, true);
              this.offset += 3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE1) {
            if (buffer[i] === 97) {
              this.tState = FALSE2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE2) {
            if (buffer[i] === 108) {
              this.tState = FALSE3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE3) {
            if (buffer[i] === 115) {
              this.tState = FALSE4;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE4) {
            if (buffer[i] === 101) {
              this.tState = START;
              this.onToken(FALSE, false);
              this.offset += 4;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL1) {
            if (buffer[i] === 117) {
              this.tState = NULL2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL2) {
            if (buffer[i] === 108) {
              this.tState = NULL3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL3) {
            if (buffer[i] === 108) {
              this.tState = START;
              this.onToken(NULL, null);
              this.offset += 3;
            } else {
              return this.charError(buffer, i);
            }
          }
        }
      };
      proto.onToken = function(token, value) {
      };
      proto.parseError = function(token, value) {
        this.tState = STOP;
        this.onError(new Error("Unexpected " + Parser2.toknam(token) + (value ? "(" + JSON.stringify(value) + ")" : "") + " in state " + Parser2.toknam(this.state)));
      };
      proto.push = function() {
        this.stack.push({ value: this.value, key: this.key, mode: this.mode });
      };
      proto.pop = function() {
        var value = this.value;
        var parent = this.stack.pop();
        this.value = parent.value;
        this.key = parent.key;
        this.mode = parent.mode;
        this.emit(value);
        if (!this.mode) {
          this.state = VALUE;
        }
      };
      proto.emit = function(value) {
        if (this.mode) {
          this.state = COMMA;
        }
        this.onValue(value);
      };
      proto.onValue = function(value) {
      };
      proto.onToken = function(token, value) {
        if (this.state === VALUE) {
          if (token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL) {
            if (this.value) {
              this.value[this.key] = value;
            }
            this.emit(value);
          } else if (token === LEFT_BRACE) {
            this.push();
            if (this.value) {
              this.value = this.value[this.key] = {};
            } else {
              this.value = {};
            }
            this.key = void 0;
            this.state = KEY;
            this.mode = OBJECT;
          } else if (token === LEFT_BRACKET) {
            this.push();
            if (this.value) {
              this.value = this.value[this.key] = [];
            } else {
              this.value = [];
            }
            this.key = 0;
            this.mode = ARRAY;
            this.state = VALUE;
          } else if (token === RIGHT_BRACE) {
            if (this.mode === OBJECT) {
              this.pop();
            } else {
              return this.parseError(token, value);
            }
          } else if (token === RIGHT_BRACKET) {
            if (this.mode === ARRAY) {
              this.pop();
            } else {
              return this.parseError(token, value);
            }
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === KEY) {
          if (token === STRING) {
            this.key = value;
            this.state = COLON;
          } else if (token === RIGHT_BRACE) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === COLON) {
          if (token === COLON) {
            this.state = VALUE;
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === COMMA) {
          if (token === COMMA) {
            if (this.mode === ARRAY) {
              this.key++;
              this.state = VALUE;
            } else if (this.mode === OBJECT) {
              this.state = KEY;
            }
          } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else {
          return this.parseError(token, value);
        }
      };
      Parser2.C = C;
      var jsonparse = Parser2;
      var Transform$1 = Stream.Transform;
      var JSON2CSVTransform = /* @__PURE__ */ function(_Transform) {
        _inherits(JSON2CSVTransform2, _Transform);
        function JSON2CSVTransform2(opts, transformOpts) {
          var _this;
          _classCallCheck(this, JSON2CSVTransform2);
          _this = _possibleConstructorReturn(this, _getPrototypeOf(JSON2CSVTransform2).call(this, transformOpts));
          Object.getOwnPropertyNames(JSON2CSVBase_1.prototype).forEach(function(key) {
            return _this[key] = JSON2CSVBase_1.prototype[key];
          });
          _this.opts = _this.preprocessOpts(opts);
          _this._data = "";
          _this._hasWritten = false;
          if (_this._readableState.objectMode) {
            _this.initObjectModeParse();
          } else if (_this.opts.ndjson) {
            _this.initNDJSONParse();
          } else {
            _this.initJSONParser();
          }
          if (_this.opts.withBOM) {
            _this.push("\uFEFF");
          }
          if (_this.opts.fields) {
            _this.opts.fields = _this.preprocessFieldsInfo(_this.opts.fields);
            _this.pushHeader();
          }
          return _this;
        }
        _createClass(JSON2CSVTransform2, [{
          key: "initObjectModeParse",
          value: function initObjectModeParse() {
            var transform = this;
            this.parser = {
              write: function write2(line) {
                transform.pushLine(line);
              },
              getPendingData: function getPendingData() {
                return void 0;
              }
            };
          }
        }, {
          key: "initNDJSONParse",
          value: function initNDJSONParse() {
            var transform = this;
            this.parser = {
              _data: "",
              write: function write2(chunk) {
                this._data += chunk.toString();
                var lines = this._data.split("\n").map(function(line) {
                  return line.trim();
                }).filter(function(line) {
                  return line !== "";
                });
                var pendingData = false;
                lines.forEach(function(line, i) {
                  try {
                    transform.pushLine(JSON.parse(line));
                  } catch (e) {
                    if (i === lines.length - 1) {
                      pendingData = true;
                    } else {
                      e.message = "Invalid JSON (".concat(line, ")");
                      transform.emit("error", e);
                    }
                  }
                });
                this._data = pendingData ? this._data.slice(this._data.lastIndexOf("\n")) : "";
              },
              getPendingData: function getPendingData() {
                return this._data;
              }
            };
          }
        }, {
          key: "initJSONParser",
          value: function initJSONParser() {
            var transform = this;
            this.parser = new jsonparse();
            this.parser.onValue = function(value) {
              if (this.stack.length !== this.depthToEmit)
                return;
              transform.pushLine(value);
            };
            this.parser._onToken = this.parser.onToken;
            this.parser.onToken = function(token, value) {
              transform.parser._onToken(token, value);
              if (this.stack.length === 0 && !transform.opts.fields && this.mode !== jsonparse.C.ARRAY && this.mode !== jsonparse.C.OBJECT) {
                this.onError(new Error('Data should not be empty or the "fields" option should be included'));
              }
              if (this.stack.length === 1) {
                if (this.depthToEmit === void 0) {
                  this.depthToEmit = this.mode === jsonparse.C.ARRAY ? 1 : 0;
                }
                if (this.depthToEmit !== 0 && this.stack.length === 1) {
                  this.value = void 0;
                }
              }
            };
            this.parser.getPendingData = function() {
              return this.value;
            };
            this.parser.onError = function(err) {
              if (err.message.includes("Unexpected")) {
                err.message = "Invalid JSON (".concat(err.message, ")");
              }
              transform.emit("error", err);
            };
          }
        }, {
          key: "_transform",
          value: function _transform(chunk, encoding, done2) {
            this.parser.write(chunk);
            done2();
          }
        }, {
          key: "_flush",
          value: function _flush(done2) {
            if (this.parser.getPendingData()) {
              done2(new Error("Invalid data received from stdin", this.parser.getPendingData()));
            }
            done2();
          }
        }, {
          key: "pushHeader",
          value: function pushHeader() {
            if (this.opts.header) {
              var header = this.getHeader();
              this.emit("header", header);
              this.push(header);
              this._hasWritten = true;
            }
          }
        }, {
          key: "pushLine",
          value: function pushLine(data) {
            var _this2 = this;
            var processedData = this.preprocessRow(data);
            if (!this._hasWritten) {
              this.opts.fields = this.opts.fields || this.preprocessFieldsInfo(Object.keys(processedData[0]));
              this.pushHeader();
            }
            processedData.forEach(function(row) {
              var line = _this2.processRow(row, _this2.opts);
              if (line === void 0)
                return;
              _this2.emit("line", line);
              _this2.push(_this2._hasWritten ? _this2.opts.eol + line : line);
              _this2._hasWritten = true;
            });
          }
        }]);
        return JSON2CSVTransform2;
      }(Transform$1);
      var JSON2CSVTransform_1 = JSON2CSVTransform;
      var Transform$2 = Stream.Transform;
      var fastJoin$3 = utils.fastJoin;
      var JSON2CSVAsyncParser = /* @__PURE__ */ function() {
        function JSON2CSVAsyncParser2(opts, transformOpts) {
          _classCallCheck(this, JSON2CSVAsyncParser2);
          this.input = new Transform$2(transformOpts);
          this.input._read = function() {
          };
          this.transform = new JSON2CSVTransform_1(opts, transformOpts);
          this.processor = this.input.pipe(this.transform);
        }
        _createClass(JSON2CSVAsyncParser2, [{
          key: "fromInput",
          value: function fromInput(input) {
            if (this._input) {
              throw new Error("Async parser already has an input.");
            }
            this._input = input;
            this.input = this._input.pipe(this.processor);
            return this;
          }
        }, {
          key: "throughTransform",
          value: function throughTransform(transform) {
            if (this._output) {
              throw new Error("Can't add transforms once an output has been added.");
            }
            this.processor = this.processor.pipe(transform);
            return this;
          }
        }, {
          key: "toOutput",
          value: function toOutput(output) {
            if (this._output) {
              throw new Error("Async parser already has an output.");
            }
            this._output = output;
            this.processor = this.processor.pipe(output);
            return this;
          }
        }, {
          key: "promise",
          value: function promise() {
            var _this = this;
            var returnCSV = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
            return new Promise(function(resolve2, reject) {
              if (!returnCSV) {
                _this.processor.on("finish", function() {
                  return resolve2();
                }).on("error", function(err) {
                  return reject(err);
                });
                return;
              }
              var csvBuffer = [];
              _this.processor.on("data", function(chunk) {
                return csvBuffer.push(chunk.toString());
              }).on("finish", function() {
                return resolve2(fastJoin$3(csvBuffer, ""));
              }).on("error", function(err) {
                return reject(err);
              });
            });
          }
        }]);
        return JSON2CSVAsyncParser2;
      }();
      var JSON2CSVAsyncParser_1 = JSON2CSVAsyncParser;
      function flatten() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$objects = _ref.objects, objects = _ref$objects === void 0 ? true : _ref$objects, _ref$arrays = _ref.arrays, arrays = _ref$arrays === void 0 ? false : _ref$arrays, _ref$separator = _ref.separator, separator = _ref$separator === void 0 ? "." : _ref$separator;
        function step(obj, flatDataRow, currentPath) {
          Object.keys(obj).forEach(function(key) {
            var newPath = currentPath ? "".concat(currentPath).concat(separator).concat(key) : key;
            var value = obj[key];
            if (objects && _typeof(value) === "object" && value !== null && !Array.isArray(value) && Object.prototype.toString.call(value.toJSON) !== "[object Function]" && Object.keys(value).length) {
              step(value, flatDataRow, newPath);
              return;
            }
            if (arrays && Array.isArray(value)) {
              step(value, flatDataRow, newPath);
              return;
            }
            flatDataRow[newPath] = value;
          });
          return flatDataRow;
        }
        return function(dataRow) {
          return step(dataRow, {});
        };
      }
      var flatten_1 = flatten;
      var setProp$1 = utils.setProp, unsetProp$1 = utils.unsetProp, flattenReducer$3 = utils.flattenReducer;
      function getUnwindablePaths(obj, currentPath) {
        return Object.keys(obj).reduce(function(unwindablePaths, key) {
          var newPath = currentPath ? "".concat(currentPath, ".").concat(key) : key;
          var value = obj[key];
          if (_typeof(value) === "object" && value !== null && !Array.isArray(value) && Object.prototype.toString.call(value.toJSON) !== "[object Function]" && Object.keys(value).length) {
            unwindablePaths = unwindablePaths.concat(getUnwindablePaths(value, newPath));
          } else if (Array.isArray(value)) {
            unwindablePaths.push(newPath);
            unwindablePaths = unwindablePaths.concat(value.map(function(arrObj) {
              return getUnwindablePaths(arrObj, newPath);
            }).reduce(flattenReducer$3, []).filter(function(item, index, arr) {
              return arr.indexOf(item) !== index;
            }));
          }
          return unwindablePaths;
        }, []);
      }
      function unwind() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$paths = _ref.paths, paths = _ref$paths === void 0 ? void 0 : _ref$paths, _ref$blankOut = _ref.blankOut, blankOut = _ref$blankOut === void 0 ? false : _ref$blankOut;
        function unwindReducer(rows, unwindPath) {
          return rows.map(function(row) {
            var unwindArray = lodash_get(row, unwindPath);
            if (!Array.isArray(unwindArray)) {
              return row;
            }
            if (!unwindArray.length) {
              return unsetProp$1(row, unwindPath);
            }
            return unwindArray.map(function(unwindRow, index) {
              var clonedRow = blankOut && index > 0 ? {} : row;
              return setProp$1(clonedRow, unwindPath, unwindRow);
            });
          }).reduce(flattenReducer$3, []);
        }
        paths = Array.isArray(paths) ? paths : paths ? [paths] : void 0;
        return function(dataRow) {
          return (paths || getUnwindablePaths(dataRow)).reduce(unwindReducer, [dataRow]);
        };
      }
      var unwind_1 = unwind;
      var Readable$1 = Stream.Readable;
      var Parser$1 = JSON2CSVParser_1;
      var AsyncParser = JSON2CSVAsyncParser_1;
      var Transform$3 = JSON2CSVTransform_1;
      var parse2 = function parse3(data, opts) {
        return new JSON2CSVParser_1(opts).parse(data);
      };
      var parseAsync = function parseAsync2(data, opts, transformOpts) {
        try {
          if (!(data instanceof Readable$1)) {
            transformOpts = Object.assign({}, transformOpts, {
              objectMode: true
            });
          }
          var asyncParser = new JSON2CSVAsyncParser_1(opts, transformOpts);
          var promise = asyncParser.promise();
          if (Array.isArray(data)) {
            data.forEach(function(item) {
              return asyncParser.input.push(item);
            });
            asyncParser.input.push(null);
          } else if (data instanceof Readable$1) {
            asyncParser.fromInput(data);
          } else {
            asyncParser.input.push(data);
            asyncParser.input.push(null);
          }
          return promise;
        } catch (err) {
          return Promise.reject(err);
        }
      };
      var transforms2 = {
        flatten: flatten_1,
        unwind: unwind_1
      };
      var json2csv = {
        Parser: Parser$1,
        AsyncParser,
        Transform: Transform$3,
        parse: parse2,
        parseAsync,
        transforms: transforms2
      };
      exports2.AsyncParser = AsyncParser;
      exports2.Parser = Parser$1;
      exports2.Transform = Transform$3;
      exports2.default = json2csv;
      exports2.parse = parse2;
      exports2.parseAsync = parseAsync;
      exports2.transforms = transforms2;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/luxon/build/cjs-browser/luxon.js
var require_luxon = __commonJS({
  "node_modules/luxon/build/cjs-browser/luxon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance10 = new Constructor();
          if (Class2)
            _setPrototypeOf(instance10, Class2.prototype);
          return instance10;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it)
        return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        return function() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var LuxonError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose(LuxonError2, _Error);
      function LuxonError2() {
        return _Error.apply(this, arguments) || this;
      }
      return LuxonError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    var InvalidDateTimeError = /* @__PURE__ */ function(_LuxonError) {
      _inheritsLoose(InvalidDateTimeError2, _LuxonError);
      function InvalidDateTimeError2(reason) {
        return _LuxonError.call(this, "Invalid DateTime: " + reason.toMessage()) || this;
      }
      return InvalidDateTimeError2;
    }(LuxonError);
    var InvalidIntervalError = /* @__PURE__ */ function(_LuxonError2) {
      _inheritsLoose(InvalidIntervalError2, _LuxonError2);
      function InvalidIntervalError2(reason) {
        return _LuxonError2.call(this, "Invalid Interval: " + reason.toMessage()) || this;
      }
      return InvalidIntervalError2;
    }(LuxonError);
    var InvalidDurationError = /* @__PURE__ */ function(_LuxonError3) {
      _inheritsLoose(InvalidDurationError2, _LuxonError3);
      function InvalidDurationError2(reason) {
        return _LuxonError3.call(this, "Invalid Duration: " + reason.toMessage()) || this;
      }
      return InvalidDurationError2;
    }(LuxonError);
    var ConflictingSpecificationError = /* @__PURE__ */ function(_LuxonError4) {
      _inheritsLoose(ConflictingSpecificationError2, _LuxonError4);
      function ConflictingSpecificationError2() {
        return _LuxonError4.apply(this, arguments) || this;
      }
      return ConflictingSpecificationError2;
    }(LuxonError);
    var InvalidUnitError = /* @__PURE__ */ function(_LuxonError5) {
      _inheritsLoose(InvalidUnitError2, _LuxonError5);
      function InvalidUnitError2(unit) {
        return _LuxonError5.call(this, "Invalid unit " + unit) || this;
      }
      return InvalidUnitError2;
    }(LuxonError);
    var InvalidArgumentError = /* @__PURE__ */ function(_LuxonError6) {
      _inheritsLoose(InvalidArgumentError2, _LuxonError6);
      function InvalidArgumentError2() {
        return _LuxonError6.apply(this, arguments) || this;
      }
      return InvalidArgumentError2;
    }(LuxonError);
    var ZoneIsAbstractError = /* @__PURE__ */ function(_LuxonError7) {
      _inheritsLoose(ZoneIsAbstractError2, _LuxonError7);
      function ZoneIsAbstractError2() {
        return _LuxonError7.call(this, "Zone is an abstract class") || this;
      }
      return ZoneIsAbstractError2;
    }(LuxonError);
    var n = "numeric";
    var s = "short";
    var l = "long";
    var DATE_SHORT = {
      year: n,
      month: n,
      day: n
    };
    var DATE_MED = {
      year: n,
      month: s,
      day: n
    };
    var DATE_MED_WITH_WEEKDAY = {
      year: n,
      month: s,
      day: n,
      weekday: s
    };
    var DATE_FULL = {
      year: n,
      month: l,
      day: n
    };
    var DATE_HUGE = {
      year: n,
      month: l,
      day: n,
      weekday: l
    };
    var TIME_SIMPLE = {
      hour: n,
      minute: n
    };
    var TIME_WITH_SECONDS = {
      hour: n,
      minute: n,
      second: n
    };
    var TIME_WITH_SHORT_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      timeZoneName: s
    };
    var TIME_WITH_LONG_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      timeZoneName: l
    };
    var TIME_24_SIMPLE = {
      hour: n,
      minute: n,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SECONDS = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SHORT_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23",
      timeZoneName: s
    };
    var TIME_24_WITH_LONG_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23",
      timeZoneName: l
    };
    var DATETIME_SHORT = {
      year: n,
      month: n,
      day: n,
      hour: n,
      minute: n
    };
    var DATETIME_SHORT_WITH_SECONDS = {
      year: n,
      month: n,
      day: n,
      hour: n,
      minute: n,
      second: n
    };
    var DATETIME_MED = {
      year: n,
      month: s,
      day: n,
      hour: n,
      minute: n
    };
    var DATETIME_MED_WITH_SECONDS = {
      year: n,
      month: s,
      day: n,
      hour: n,
      minute: n,
      second: n
    };
    var DATETIME_MED_WITH_WEEKDAY = {
      year: n,
      month: s,
      day: n,
      weekday: s,
      hour: n,
      minute: n
    };
    var DATETIME_FULL = {
      year: n,
      month: l,
      day: n,
      hour: n,
      minute: n,
      timeZoneName: s
    };
    var DATETIME_FULL_WITH_SECONDS = {
      year: n,
      month: l,
      day: n,
      hour: n,
      minute: n,
      second: n,
      timeZoneName: s
    };
    var DATETIME_HUGE = {
      year: n,
      month: l,
      day: n,
      weekday: l,
      hour: n,
      minute: n,
      timeZoneName: l
    };
    var DATETIME_HUGE_WITH_SECONDS = {
      year: n,
      month: l,
      day: n,
      weekday: l,
      hour: n,
      minute: n,
      second: n,
      timeZoneName: l
    };
    function isUndefined(o) {
      return typeof o === "undefined";
    }
    function isNumber2(o) {
      return typeof o === "number";
    }
    function isInteger(o) {
      return typeof o === "number" && o % 1 === 0;
    }
    function isString(o) {
      return typeof o === "string";
    }
    function isDate(o) {
      return Object.prototype.toString.call(o) === "[object Date]";
    }
    function hasRelative() {
      try {
        return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
      } catch (e) {
        return false;
      }
    }
    function maybeArray(thing) {
      return Array.isArray(thing) ? thing : [thing];
    }
    function bestBy(arr, by, compare) {
      if (arr.length === 0) {
        return void 0;
      }
      return arr.reduce(function(best, next) {
        var pair = [by(next), next];
        if (!best) {
          return pair;
        } else if (compare(best[0], pair[0]) === best[0]) {
          return best;
        } else {
          return pair;
        }
      }, null)[1];
    }
    function pick(obj, keys) {
      return keys.reduce(function(a, k) {
        a[k] = obj[k];
        return a;
      }, {});
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function integerBetween(thing, bottom, top) {
      return isInteger(thing) && thing >= bottom && thing <= top;
    }
    function floorMod(x, n2) {
      return x - n2 * Math.floor(x / n2);
    }
    function padStart(input, n2) {
      if (n2 === void 0) {
        n2 = 2;
      }
      var isNeg = input < 0;
      var padded;
      if (isNeg) {
        padded = "-" + ("" + -input).padStart(n2, "0");
      } else {
        padded = ("" + input).padStart(n2, "0");
      }
      return padded;
    }
    function parseInteger(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseInt(string, 10);
      }
    }
    function parseFloating(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseFloat(string);
      }
    }
    function parseMillis(fraction) {
      if (isUndefined(fraction) || fraction === null || fraction === "") {
        return void 0;
      } else {
        var f = parseFloat("0." + fraction) * 1e3;
        return Math.floor(f);
      }
    }
    function roundTo(number, digits, towardZero) {
      if (towardZero === void 0) {
        towardZero = false;
      }
      var factor = Math.pow(10, digits), rounder = towardZero ? Math.trunc : Math.round;
      return rounder(number * factor) / factor;
    }
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    function daysInMonth(year, month) {
      var modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
      if (modMonth === 2) {
        return isLeapYear(modYear) ? 29 : 28;
      } else {
        return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
      }
    }
    function objToLocalTS(obj) {
      var d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
      if (obj.year < 100 && obj.year >= 0) {
        d = new Date(d);
        d.setUTCFullYear(d.getUTCFullYear() - 1900);
      }
      return +d;
    }
    function weeksInWeekYear(weekYear) {
      var p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
      return p1 === 4 || p2 === 3 ? 53 : 52;
    }
    function untruncateYear(year) {
      if (year > 99) {
        return year;
      } else
        return year > 60 ? 1900 + year : 2e3 + year;
    }
    function parseZoneInfo(ts, offsetFormat, locale, timeZone) {
      if (timeZone === void 0) {
        timeZone = null;
      }
      var date = new Date(ts), intlOpts = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      };
      if (timeZone) {
        intlOpts.timeZone = timeZone;
      }
      var modified = _extends({
        timeZoneName: offsetFormat
      }, intlOpts);
      var parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find(function(m) {
        return m.type.toLowerCase() === "timezonename";
      });
      return parsed ? parsed.value : null;
    }
    function signedOffset(offHourStr, offMinuteStr) {
      var offHour = parseInt(offHourStr, 10);
      if (Number.isNaN(offHour)) {
        offHour = 0;
      }
      var offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
      return offHour * 60 + offMinSigned;
    }
    function asNumber(value) {
      var numericValue = Number(value);
      if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
        throw new InvalidArgumentError("Invalid unit value " + value);
      return numericValue;
    }
    function normalizeObject(obj, normalizer) {
      var normalized = {};
      for (var u in obj) {
        if (hasOwnProperty(obj, u)) {
          var v = obj[u];
          if (v === void 0 || v === null)
            continue;
          normalized[normalizer(u)] = asNumber(v);
        }
      }
      return normalized;
    }
    function formatOffset(offset2, format) {
      var hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign2 = offset2 >= 0 ? "+" : "-";
      switch (format) {
        case "short":
          return "" + sign2 + padStart(hours, 2) + ":" + padStart(minutes, 2);
        case "narrow":
          return "" + sign2 + hours + (minutes > 0 ? ":" + minutes : "");
        case "techie":
          return "" + sign2 + padStart(hours, 2) + padStart(minutes, 2);
        default:
          throw new RangeError("Value format " + format + " is out of range for property format");
      }
    }
    function timeObject(obj) {
      return pick(obj, ["hour", "minute", "second", "millisecond"]);
    }
    var ianaRegex = /[A-Za-z_+-]{1,256}(:?\/[A-Za-z0-9_+-]{1,256}(\/[A-Za-z0-9_+-]{1,256})?)?/;
    var monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    var monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
    function months(length) {
      switch (length) {
        case "narrow":
          return [].concat(monthsNarrow);
        case "short":
          return [].concat(monthsShort);
        case "long":
          return [].concat(monthsLong);
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
        case "2-digit":
          return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
        default:
          return null;
      }
    }
    var weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
    var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
    function weekdays(length) {
      switch (length) {
        case "narrow":
          return [].concat(weekdaysNarrow);
        case "short":
          return [].concat(weekdaysShort);
        case "long":
          return [].concat(weekdaysLong);
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7"];
        default:
          return null;
      }
    }
    var meridiems = ["AM", "PM"];
    var erasLong = ["Before Christ", "Anno Domini"];
    var erasShort = ["BC", "AD"];
    var erasNarrow = ["B", "A"];
    function eras(length) {
      switch (length) {
        case "narrow":
          return [].concat(erasNarrow);
        case "short":
          return [].concat(erasShort);
        case "long":
          return [].concat(erasLong);
        default:
          return null;
      }
    }
    function meridiemForDateTime(dt) {
      return meridiems[dt.hour < 12 ? 0 : 1];
    }
    function weekdayForDateTime(dt, length) {
      return weekdays(length)[dt.weekday - 1];
    }
    function monthForDateTime(dt, length) {
      return months(length)[dt.month - 1];
    }
    function eraForDateTime(dt, length) {
      return eras(length)[dt.year < 0 ? 0 : 1];
    }
    function formatRelativeTime(unit, count, numeric, narrow) {
      if (numeric === void 0) {
        numeric = "always";
      }
      if (narrow === void 0) {
        narrow = false;
      }
      var units = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
      };
      var lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
      if (numeric === "auto" && lastable) {
        var isDay = unit === "days";
        switch (count) {
          case 1:
            return isDay ? "tomorrow" : "next " + units[unit][0];
          case -1:
            return isDay ? "yesterday" : "last " + units[unit][0];
          case 0:
            return isDay ? "today" : "this " + units[unit][0];
        }
      }
      var isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
      return isInPast ? fmtValue + " " + fmtUnit + " ago" : "in " + fmtValue + " " + fmtUnit;
    }
    function stringifyTokens(splits, tokenToString) {
      var s2 = "";
      for (var _iterator = _createForOfIteratorHelperLoose(splits), _step; !(_step = _iterator()).done; ) {
        var token = _step.value;
        if (token.literal) {
          s2 += token.val;
        } else {
          s2 += tokenToString(token.val);
        }
      }
      return s2;
    }
    var _macroTokenToFormatOpts = {
      D: DATE_SHORT,
      DD: DATE_MED,
      DDD: DATE_FULL,
      DDDD: DATE_HUGE,
      t: TIME_SIMPLE,
      tt: TIME_WITH_SECONDS,
      ttt: TIME_WITH_SHORT_OFFSET,
      tttt: TIME_WITH_LONG_OFFSET,
      T: TIME_24_SIMPLE,
      TT: TIME_24_WITH_SECONDS,
      TTT: TIME_24_WITH_SHORT_OFFSET,
      TTTT: TIME_24_WITH_LONG_OFFSET,
      f: DATETIME_SHORT,
      ff: DATETIME_MED,
      fff: DATETIME_FULL,
      ffff: DATETIME_HUGE,
      F: DATETIME_SHORT_WITH_SECONDS,
      FF: DATETIME_MED_WITH_SECONDS,
      FFF: DATETIME_FULL_WITH_SECONDS,
      FFFF: DATETIME_HUGE_WITH_SECONDS
    };
    var Formatter = /* @__PURE__ */ function() {
      Formatter2.create = function create(locale, opts) {
        if (opts === void 0) {
          opts = {};
        }
        return new Formatter2(locale, opts);
      };
      Formatter2.parseFormat = function parseFormat(fmt) {
        var current = null, currentFull = "", bracketed = false;
        var splits = [];
        for (var i = 0; i < fmt.length; i++) {
          var c = fmt.charAt(i);
          if (c === "'") {
            if (currentFull.length > 0) {
              splits.push({
                literal: bracketed,
                val: currentFull
              });
            }
            current = null;
            currentFull = "";
            bracketed = !bracketed;
          } else if (bracketed) {
            currentFull += c;
          } else if (c === current) {
            currentFull += c;
          } else {
            if (currentFull.length > 0) {
              splits.push({
                literal: false,
                val: currentFull
              });
            }
            currentFull = c;
            current = c;
          }
        }
        if (currentFull.length > 0) {
          splits.push({
            literal: bracketed,
            val: currentFull
          });
        }
        return splits;
      };
      Formatter2.macroTokenToFormatOpts = function macroTokenToFormatOpts(token) {
        return _macroTokenToFormatOpts[token];
      };
      function Formatter2(locale, formatOpts) {
        this.opts = formatOpts;
        this.loc = locale;
        this.systemLoc = null;
      }
      var _proto = Formatter2.prototype;
      _proto.formatWithSystemDefault = function formatWithSystemDefault(dt, opts) {
        if (this.systemLoc === null) {
          this.systemLoc = this.loc.redefaultToSystem();
        }
        var df = this.systemLoc.dtFormatter(dt, _extends({}, this.opts, opts));
        return df.format();
      };
      _proto.formatDateTime = function formatDateTime(dt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var df = this.loc.dtFormatter(dt, _extends({}, this.opts, opts));
        return df.format();
      };
      _proto.formatDateTimeParts = function formatDateTimeParts(dt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var df = this.loc.dtFormatter(dt, _extends({}, this.opts, opts));
        return df.formatToParts();
      };
      _proto.resolvedOptions = function resolvedOptions(dt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var df = this.loc.dtFormatter(dt, _extends({}, this.opts, opts));
        return df.resolvedOptions();
      };
      _proto.num = function num(n2, p) {
        if (p === void 0) {
          p = 0;
        }
        if (this.opts.forceSimple) {
          return padStart(n2, p);
        }
        var opts = _extends({}, this.opts);
        if (p > 0) {
          opts.padTo = p;
        }
        return this.loc.numberFormatter(opts).format(n2);
      };
      _proto.formatDateTimeFromString = function formatDateTimeFromString(dt, fmt) {
        var _this = this;
        var knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = function string2(opts, extract) {
          return _this.loc.extract(dt, opts, extract);
        }, formatOffset2 = function formatOffset3(opts) {
          if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
            return "Z";
          }
          return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
        }, meridiem = function meridiem2() {
          return knownEnglish ? meridiemForDateTime(dt) : string({
            hour: "numeric",
            hourCycle: "h12"
          }, "dayperiod");
        }, month = function month2(length, standalone) {
          return knownEnglish ? monthForDateTime(dt, length) : string(standalone ? {
            month: length
          } : {
            month: length,
            day: "numeric"
          }, "month");
        }, weekday = function weekday2(length, standalone) {
          return knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? {
            weekday: length
          } : {
            weekday: length,
            month: "long",
            day: "numeric"
          }, "weekday");
        }, maybeMacro = function maybeMacro2(token) {
          var formatOpts = Formatter2.macroTokenToFormatOpts(token);
          if (formatOpts) {
            return _this.formatWithSystemDefault(dt, formatOpts);
          } else {
            return token;
          }
        }, era = function era2(length) {
          return knownEnglish ? eraForDateTime(dt, length) : string({
            era: length
          }, "era");
        }, tokenToString = function tokenToString2(token) {
          switch (token) {
            case "S":
              return _this.num(dt.millisecond);
            case "u":
            case "SSS":
              return _this.num(dt.millisecond, 3);
            case "s":
              return _this.num(dt.second);
            case "ss":
              return _this.num(dt.second, 2);
            case "uu":
              return _this.num(Math.floor(dt.millisecond / 10), 2);
            case "uuu":
              return _this.num(Math.floor(dt.millisecond / 100));
            case "m":
              return _this.num(dt.minute);
            case "mm":
              return _this.num(dt.minute, 2);
            case "h":
              return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
            case "hh":
              return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
            case "H":
              return _this.num(dt.hour);
            case "HH":
              return _this.num(dt.hour, 2);
            case "Z":
              return formatOffset2({
                format: "narrow",
                allowZ: _this.opts.allowZ
              });
            case "ZZ":
              return formatOffset2({
                format: "short",
                allowZ: _this.opts.allowZ
              });
            case "ZZZ":
              return formatOffset2({
                format: "techie",
                allowZ: _this.opts.allowZ
              });
            case "ZZZZ":
              return dt.zone.offsetName(dt.ts, {
                format: "short",
                locale: _this.loc.locale
              });
            case "ZZZZZ":
              return dt.zone.offsetName(dt.ts, {
                format: "long",
                locale: _this.loc.locale
              });
            case "z":
              return dt.zoneName;
            case "a":
              return meridiem();
            case "d":
              return useDateTimeFormatter ? string({
                day: "numeric"
              }, "day") : _this.num(dt.day);
            case "dd":
              return useDateTimeFormatter ? string({
                day: "2-digit"
              }, "day") : _this.num(dt.day, 2);
            case "c":
              return _this.num(dt.weekday);
            case "ccc":
              return weekday("short", true);
            case "cccc":
              return weekday("long", true);
            case "ccccc":
              return weekday("narrow", true);
            case "E":
              return _this.num(dt.weekday);
            case "EEE":
              return weekday("short", false);
            case "EEEE":
              return weekday("long", false);
            case "EEEEE":
              return weekday("narrow", false);
            case "L":
              return useDateTimeFormatter ? string({
                month: "numeric",
                day: "numeric"
              }, "month") : _this.num(dt.month);
            case "LL":
              return useDateTimeFormatter ? string({
                month: "2-digit",
                day: "numeric"
              }, "month") : _this.num(dt.month, 2);
            case "LLL":
              return month("short", true);
            case "LLLL":
              return month("long", true);
            case "LLLLL":
              return month("narrow", true);
            case "M":
              return useDateTimeFormatter ? string({
                month: "numeric"
              }, "month") : _this.num(dt.month);
            case "MM":
              return useDateTimeFormatter ? string({
                month: "2-digit"
              }, "month") : _this.num(dt.month, 2);
            case "MMM":
              return month("short", false);
            case "MMMM":
              return month("long", false);
            case "MMMMM":
              return month("narrow", false);
            case "y":
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : _this.num(dt.year);
            case "yy":
              return useDateTimeFormatter ? string({
                year: "2-digit"
              }, "year") : _this.num(dt.year.toString().slice(-2), 2);
            case "yyyy":
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : _this.num(dt.year, 4);
            case "yyyyyy":
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : _this.num(dt.year, 6);
            case "G":
              return era("short");
            case "GG":
              return era("long");
            case "GGGGG":
              return era("narrow");
            case "kk":
              return _this.num(dt.weekYear.toString().slice(-2), 2);
            case "kkkk":
              return _this.num(dt.weekYear, 4);
            case "W":
              return _this.num(dt.weekNumber);
            case "WW":
              return _this.num(dt.weekNumber, 2);
            case "o":
              return _this.num(dt.ordinal);
            case "ooo":
              return _this.num(dt.ordinal, 3);
            case "q":
              return _this.num(dt.quarter);
            case "qq":
              return _this.num(dt.quarter, 2);
            case "X":
              return _this.num(Math.floor(dt.ts / 1e3));
            case "x":
              return _this.num(dt.ts);
            default:
              return maybeMacro(token);
          }
        };
        return stringifyTokens(Formatter2.parseFormat(fmt), tokenToString);
      };
      _proto.formatDurationFromString = function formatDurationFromString(dur, fmt) {
        var _this2 = this;
        var tokenToField = function tokenToField2(token) {
          switch (token[0]) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
              return "hour";
            case "d":
              return "day";
            case "M":
              return "month";
            case "y":
              return "year";
            default:
              return null;
          }
        }, tokenToString = function tokenToString2(lildur) {
          return function(token) {
            var mapped = tokenToField(token);
            if (mapped) {
              return _this2.num(lildur.get(mapped), token.length);
            } else {
              return token;
            }
          };
        }, tokens = Formatter2.parseFormat(fmt), realTokens = tokens.reduce(function(found, _ref) {
          var literal = _ref.literal, val = _ref.val;
          return literal ? found : found.concat(val);
        }, []), collapsed = dur.shiftTo.apply(dur, realTokens.map(tokenToField).filter(function(t) {
          return t;
        }));
        return stringifyTokens(tokens, tokenToString(collapsed));
      };
      return Formatter2;
    }();
    var Invalid = /* @__PURE__ */ function() {
      function Invalid2(reason, explanation) {
        this.reason = reason;
        this.explanation = explanation;
      }
      var _proto = Invalid2.prototype;
      _proto.toMessage = function toMessage() {
        if (this.explanation) {
          return this.reason + ": " + this.explanation;
        } else {
          return this.reason;
        }
      };
      return Invalid2;
    }();
    var Zone = /* @__PURE__ */ function() {
      function Zone2() {
      }
      var _proto = Zone2.prototype;
      _proto.offsetName = function offsetName(ts, opts) {
        throw new ZoneIsAbstractError();
      };
      _proto.formatOffset = function formatOffset2(ts, format) {
        throw new ZoneIsAbstractError();
      };
      _proto.offset = function offset2(ts) {
        throw new ZoneIsAbstractError();
      };
      _proto.equals = function equals(otherZone) {
        throw new ZoneIsAbstractError();
      };
      _createClass(Zone2, [{
        key: "type",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
      }, {
        key: "name",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
      }, {
        key: "isUniversal",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
      }, {
        key: "isValid",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
      }]);
      return Zone2;
    }();
    var singleton$1 = null;
    var SystemZone = /* @__PURE__ */ function(_Zone) {
      _inheritsLoose(SystemZone2, _Zone);
      function SystemZone2() {
        return _Zone.apply(this, arguments) || this;
      }
      var _proto = SystemZone2.prototype;
      _proto.offsetName = function offsetName(ts, _ref) {
        var format = _ref.format, locale = _ref.locale;
        return parseZoneInfo(ts, format, locale);
      };
      _proto.formatOffset = function formatOffset$1(ts, format) {
        return formatOffset(this.offset(ts), format);
      };
      _proto.offset = function offset2(ts) {
        return -new Date(ts).getTimezoneOffset();
      };
      _proto.equals = function equals(otherZone) {
        return otherZone.type === "system";
      };
      _createClass(SystemZone2, [{
        key: "type",
        get: function get() {
          return "system";
        }
      }, {
        key: "name",
        get: function get() {
          return new Intl.DateTimeFormat().resolvedOptions().timeZone;
        }
      }, {
        key: "isUniversal",
        get: function get() {
          return false;
        }
      }, {
        key: "isValid",
        get: function get() {
          return true;
        }
      }], [{
        key: "instance",
        get: function get() {
          if (singleton$1 === null) {
            singleton$1 = new SystemZone2();
          }
          return singleton$1;
        }
      }]);
      return SystemZone2;
    }(Zone);
    var matchingRegex = RegExp("^" + ianaRegex.source + "$");
    var dtfCache = {};
    function makeDTF(zone) {
      if (!dtfCache[zone]) {
        dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
          hour12: false,
          timeZone: zone,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        });
      }
      return dtfCache[zone];
    }
    var typeToPos = {
      year: 0,
      month: 1,
      day: 2,
      hour: 3,
      minute: 4,
      second: 5
    };
    function hackyOffset(dtf, date) {
      var formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted), fMonth = parsed[1], fDay = parsed[2], fYear = parsed[3], fHour = parsed[4], fMinute = parsed[5], fSecond = parsed[6];
      return [fYear, fMonth, fDay, fHour, fMinute, fSecond];
    }
    function partsOffset(dtf, date) {
      var formatted = dtf.formatToParts(date), filled = [];
      for (var i = 0; i < formatted.length; i++) {
        var _formatted$i = formatted[i], type = _formatted$i.type, value = _formatted$i.value, pos = typeToPos[type];
        if (!isUndefined(pos)) {
          filled[pos] = parseInt(value, 10);
        }
      }
      return filled;
    }
    var ianaZoneCache = {};
    var IANAZone = /* @__PURE__ */ function(_Zone) {
      _inheritsLoose(IANAZone2, _Zone);
      IANAZone2.create = function create(name) {
        if (!ianaZoneCache[name]) {
          ianaZoneCache[name] = new IANAZone2(name);
        }
        return ianaZoneCache[name];
      };
      IANAZone2.resetCache = function resetCache() {
        ianaZoneCache = {};
        dtfCache = {};
      };
      IANAZone2.isValidSpecifier = function isValidSpecifier(s2) {
        return !!(s2 && s2.match(matchingRegex));
      };
      IANAZone2.isValidZone = function isValidZone(zone) {
        if (!zone) {
          return false;
        }
        try {
          new Intl.DateTimeFormat("en-US", {
            timeZone: zone
          }).format();
          return true;
        } catch (e) {
          return false;
        }
      };
      function IANAZone2(name) {
        var _this;
        _this = _Zone.call(this) || this;
        _this.zoneName = name;
        _this.valid = IANAZone2.isValidZone(name);
        return _this;
      }
      var _proto = IANAZone2.prototype;
      _proto.offsetName = function offsetName(ts, _ref) {
        var format = _ref.format, locale = _ref.locale;
        return parseZoneInfo(ts, format, locale, this.name);
      };
      _proto.formatOffset = function formatOffset$1(ts, format) {
        return formatOffset(this.offset(ts), format);
      };
      _proto.offset = function offset2(ts) {
        var date = new Date(ts);
        if (isNaN(date))
          return NaN;
        var dtf = makeDTF(this.name), _ref2 = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date), year = _ref2[0], month = _ref2[1], day = _ref2[2], hour = _ref2[3], minute = _ref2[4], second = _ref2[5];
        var adjustedHour = hour === 24 ? 0 : hour;
        var asUTC = objToLocalTS({
          year,
          month,
          day,
          hour: adjustedHour,
          minute,
          second,
          millisecond: 0
        });
        var asTS = +date;
        var over = asTS % 1e3;
        asTS -= over >= 0 ? over : 1e3 + over;
        return (asUTC - asTS) / (60 * 1e3);
      };
      _proto.equals = function equals(otherZone) {
        return otherZone.type === "iana" && otherZone.name === this.name;
      };
      _createClass(IANAZone2, [{
        key: "type",
        get: function get() {
          return "iana";
        }
      }, {
        key: "name",
        get: function get() {
          return this.zoneName;
        }
      }, {
        key: "isUniversal",
        get: function get() {
          return false;
        }
      }, {
        key: "isValid",
        get: function get() {
          return this.valid;
        }
      }]);
      return IANAZone2;
    }(Zone);
    var singleton = null;
    var FixedOffsetZone = /* @__PURE__ */ function(_Zone) {
      _inheritsLoose(FixedOffsetZone2, _Zone);
      FixedOffsetZone2.instance = function instance10(offset2) {
        return offset2 === 0 ? FixedOffsetZone2.utcInstance : new FixedOffsetZone2(offset2);
      };
      FixedOffsetZone2.parseSpecifier = function parseSpecifier(s2) {
        if (s2) {
          var r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
          if (r) {
            return new FixedOffsetZone2(signedOffset(r[1], r[2]));
          }
        }
        return null;
      };
      function FixedOffsetZone2(offset2) {
        var _this;
        _this = _Zone.call(this) || this;
        _this.fixed = offset2;
        return _this;
      }
      var _proto = FixedOffsetZone2.prototype;
      _proto.offsetName = function offsetName() {
        return this.name;
      };
      _proto.formatOffset = function formatOffset$1(ts, format) {
        return formatOffset(this.fixed, format);
      };
      _proto.offset = function offset2() {
        return this.fixed;
      };
      _proto.equals = function equals(otherZone) {
        return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
      };
      _createClass(FixedOffsetZone2, [{
        key: "type",
        get: function get() {
          return "fixed";
        }
      }, {
        key: "name",
        get: function get() {
          return this.fixed === 0 ? "UTC" : "UTC" + formatOffset(this.fixed, "narrow");
        }
      }, {
        key: "isUniversal",
        get: function get() {
          return true;
        }
      }, {
        key: "isValid",
        get: function get() {
          return true;
        }
      }], [{
        key: "utcInstance",
        get: function get() {
          if (singleton === null) {
            singleton = new FixedOffsetZone2(0);
          }
          return singleton;
        }
      }]);
      return FixedOffsetZone2;
    }(Zone);
    var InvalidZone = /* @__PURE__ */ function(_Zone) {
      _inheritsLoose(InvalidZone2, _Zone);
      function InvalidZone2(zoneName) {
        var _this;
        _this = _Zone.call(this) || this;
        _this.zoneName = zoneName;
        return _this;
      }
      var _proto = InvalidZone2.prototype;
      _proto.offsetName = function offsetName() {
        return null;
      };
      _proto.formatOffset = function formatOffset2() {
        return "";
      };
      _proto.offset = function offset2() {
        return NaN;
      };
      _proto.equals = function equals() {
        return false;
      };
      _createClass(InvalidZone2, [{
        key: "type",
        get: function get() {
          return "invalid";
        }
      }, {
        key: "name",
        get: function get() {
          return this.zoneName;
        }
      }, {
        key: "isUniversal",
        get: function get() {
          return false;
        }
      }, {
        key: "isValid",
        get: function get() {
          return false;
        }
      }]);
      return InvalidZone2;
    }(Zone);
    function normalizeZone(input, defaultZone2) {
      if (isUndefined(input) || input === null) {
        return defaultZone2;
      } else if (input instanceof Zone) {
        return input;
      } else if (isString(input)) {
        var lowered = input.toLowerCase();
        if (lowered === "local" || lowered === "system")
          return defaultZone2;
        else if (lowered === "utc" || lowered === "gmt")
          return FixedOffsetZone.utcInstance;
        else if (IANAZone.isValidSpecifier(lowered))
          return IANAZone.create(input);
        else
          return FixedOffsetZone.parseSpecifier(lowered) || new InvalidZone(input);
      } else if (isNumber2(input)) {
        return FixedOffsetZone.instance(input);
      } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
        return input;
      } else {
        return new InvalidZone(input);
      }
    }
    var now = function now2() {
      return Date.now();
    };
    var defaultZone = "system";
    var defaultLocale = null;
    var defaultNumberingSystem = null;
    var defaultOutputCalendar = null;
    var throwOnInvalid;
    var Settings = /* @__PURE__ */ function() {
      function Settings2() {
      }
      Settings2.resetCaches = function resetCaches() {
        Locale.resetCache();
        IANAZone.resetCache();
      };
      _createClass(Settings2, null, [{
        key: "now",
        get: function get() {
          return now;
        },
        set: function set2(n2) {
          now = n2;
        }
      }, {
        key: "defaultZone",
        get: function get() {
          return normalizeZone(defaultZone, SystemZone.instance);
        },
        set: function set2(zone) {
          defaultZone = zone;
        }
      }, {
        key: "defaultLocale",
        get: function get() {
          return defaultLocale;
        },
        set: function set2(locale) {
          defaultLocale = locale;
        }
      }, {
        key: "defaultNumberingSystem",
        get: function get() {
          return defaultNumberingSystem;
        },
        set: function set2(numberingSystem) {
          defaultNumberingSystem = numberingSystem;
        }
      }, {
        key: "defaultOutputCalendar",
        get: function get() {
          return defaultOutputCalendar;
        },
        set: function set2(outputCalendar) {
          defaultOutputCalendar = outputCalendar;
        }
      }, {
        key: "throwOnInvalid",
        get: function get() {
          return throwOnInvalid;
        },
        set: function set2(t) {
          throwOnInvalid = t;
        }
      }]);
      return Settings2;
    }();
    var _excluded = ["base"];
    var _excluded2 = ["padTo", "floor"];
    var intlLFCache = {};
    function getCachedLF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var key = JSON.stringify([locString, opts]);
      var dtf = intlLFCache[key];
      if (!dtf) {
        dtf = new Intl.ListFormat(locString, opts);
        intlLFCache[key] = dtf;
      }
      return dtf;
    }
    var intlDTCache = {};
    function getCachedDTF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var key = JSON.stringify([locString, opts]);
      var dtf = intlDTCache[key];
      if (!dtf) {
        dtf = new Intl.DateTimeFormat(locString, opts);
        intlDTCache[key] = dtf;
      }
      return dtf;
    }
    var intlNumCache = {};
    function getCachedINF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var key = JSON.stringify([locString, opts]);
      var inf = intlNumCache[key];
      if (!inf) {
        inf = new Intl.NumberFormat(locString, opts);
        intlNumCache[key] = inf;
      }
      return inf;
    }
    var intlRelCache = {};
    function getCachedRTF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var _opts = opts;
      _opts.base;
      var cacheKeyOpts = _objectWithoutPropertiesLoose(_opts, _excluded);
      var key = JSON.stringify([locString, cacheKeyOpts]);
      var inf = intlRelCache[key];
      if (!inf) {
        inf = new Intl.RelativeTimeFormat(locString, opts);
        intlRelCache[key] = inf;
      }
      return inf;
    }
    var sysLocaleCache = null;
    function systemLocale() {
      if (sysLocaleCache) {
        return sysLocaleCache;
      } else {
        sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
        return sysLocaleCache;
      }
    }
    function parseLocaleString(localeStr) {
      var uIndex = localeStr.indexOf("-u-");
      if (uIndex === -1) {
        return [localeStr];
      } else {
        var options;
        var smaller = localeStr.substring(0, uIndex);
        try {
          options = getCachedDTF(localeStr).resolvedOptions();
        } catch (e) {
          options = getCachedDTF(smaller).resolvedOptions();
        }
        var _options = options, numberingSystem = _options.numberingSystem, calendar = _options.calendar;
        return [smaller, numberingSystem, calendar];
      }
    }
    function intlConfigString(localeStr, numberingSystem, outputCalendar) {
      if (outputCalendar || numberingSystem) {
        localeStr += "-u";
        if (outputCalendar) {
          localeStr += "-ca-" + outputCalendar;
        }
        if (numberingSystem) {
          localeStr += "-nu-" + numberingSystem;
        }
        return localeStr;
      } else {
        return localeStr;
      }
    }
    function mapMonths(f) {
      var ms = [];
      for (var i = 1; i <= 12; i++) {
        var dt = DateTime4.utc(2016, i, 1);
        ms.push(f(dt));
      }
      return ms;
    }
    function mapWeekdays(f) {
      var ms = [];
      for (var i = 1; i <= 7; i++) {
        var dt = DateTime4.utc(2016, 11, 13 + i);
        ms.push(f(dt));
      }
      return ms;
    }
    function listStuff(loc, length, defaultOK, englishFn, intlFn) {
      var mode = loc.listingMode(defaultOK);
      if (mode === "error") {
        return null;
      } else if (mode === "en") {
        return englishFn(length);
      } else {
        return intlFn(length);
      }
    }
    function supportsFastNumbers(loc) {
      if (loc.numberingSystem && loc.numberingSystem !== "latn") {
        return false;
      } else {
        return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
      }
    }
    var PolyNumberFormatter = /* @__PURE__ */ function() {
      function PolyNumberFormatter2(intl, forceSimple, opts) {
        this.padTo = opts.padTo || 0;
        this.floor = opts.floor || false;
        opts.padTo;
        opts.floor;
        var otherOpts = _objectWithoutPropertiesLoose(opts, _excluded2);
        if (!forceSimple || Object.keys(otherOpts).length > 0) {
          var intlOpts = _extends({
            useGrouping: false
          }, opts);
          if (opts.padTo > 0)
            intlOpts.minimumIntegerDigits = opts.padTo;
          this.inf = getCachedINF(intl, intlOpts);
        }
      }
      var _proto = PolyNumberFormatter2.prototype;
      _proto.format = function format(i) {
        if (this.inf) {
          var fixed = this.floor ? Math.floor(i) : i;
          return this.inf.format(fixed);
        } else {
          var _fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
          return padStart(_fixed, this.padTo);
        }
      };
      return PolyNumberFormatter2;
    }();
    var PolyDateFormatter = /* @__PURE__ */ function() {
      function PolyDateFormatter2(dt, intl, opts) {
        this.opts = opts;
        var z;
        if (dt.zone.isUniversal) {
          var gmtOffset = -1 * (dt.offset / 60);
          var offsetZ = gmtOffset >= 0 ? "Etc/GMT+" + gmtOffset : "Etc/GMT" + gmtOffset;
          if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
            z = offsetZ;
            this.dt = dt;
          } else {
            z = "UTC";
            if (opts.timeZoneName) {
              this.dt = dt;
            } else {
              this.dt = dt.offset === 0 ? dt : DateTime4.fromMillis(dt.ts + dt.offset * 60 * 1e3);
            }
          }
        } else if (dt.zone.type === "system") {
          this.dt = dt;
        } else {
          this.dt = dt;
          z = dt.zone.name;
        }
        var intlOpts = _extends({}, this.opts);
        if (z) {
          intlOpts.timeZone = z;
        }
        this.dtf = getCachedDTF(intl, intlOpts);
      }
      var _proto2 = PolyDateFormatter2.prototype;
      _proto2.format = function format() {
        return this.dtf.format(this.dt.toJSDate());
      };
      _proto2.formatToParts = function formatToParts() {
        return this.dtf.formatToParts(this.dt.toJSDate());
      };
      _proto2.resolvedOptions = function resolvedOptions() {
        return this.dtf.resolvedOptions();
      };
      return PolyDateFormatter2;
    }();
    var PolyRelFormatter = /* @__PURE__ */ function() {
      function PolyRelFormatter2(intl, isEnglish, opts) {
        this.opts = _extends({
          style: "long"
        }, opts);
        if (!isEnglish && hasRelative()) {
          this.rtf = getCachedRTF(intl, opts);
        }
      }
      var _proto3 = PolyRelFormatter2.prototype;
      _proto3.format = function format(count, unit) {
        if (this.rtf) {
          return this.rtf.format(count, unit);
        } else {
          return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
        }
      };
      _proto3.formatToParts = function formatToParts(count, unit) {
        if (this.rtf) {
          return this.rtf.formatToParts(count, unit);
        } else {
          return [];
        }
      };
      return PolyRelFormatter2;
    }();
    var Locale = /* @__PURE__ */ function() {
      Locale2.fromOpts = function fromOpts(opts) {
        return Locale2.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
      };
      Locale2.create = function create(locale, numberingSystem, outputCalendar, defaultToEN) {
        if (defaultToEN === void 0) {
          defaultToEN = false;
        }
        var specifiedLocale = locale || Settings.defaultLocale;
        var localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
        var numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
        var outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
        return new Locale2(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
      };
      Locale2.resetCache = function resetCache() {
        sysLocaleCache = null;
        intlDTCache = {};
        intlNumCache = {};
        intlRelCache = {};
      };
      Locale2.fromObject = function fromObject2(_temp) {
        var _ref = _temp === void 0 ? {} : _temp, locale = _ref.locale, numberingSystem = _ref.numberingSystem, outputCalendar = _ref.outputCalendar;
        return Locale2.create(locale, numberingSystem, outputCalendar);
      };
      function Locale2(locale, numbering, outputCalendar, specifiedLocale) {
        var _parseLocaleString = parseLocaleString(locale), parsedLocale = _parseLocaleString[0], parsedNumberingSystem = _parseLocaleString[1], parsedOutputCalendar = _parseLocaleString[2];
        this.locale = parsedLocale;
        this.numberingSystem = numbering || parsedNumberingSystem || null;
        this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
        this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
        this.weekdaysCache = {
          format: {},
          standalone: {}
        };
        this.monthsCache = {
          format: {},
          standalone: {}
        };
        this.meridiemCache = null;
        this.eraCache = {};
        this.specifiedLocale = specifiedLocale;
        this.fastNumbersCached = null;
      }
      var _proto4 = Locale2.prototype;
      _proto4.listingMode = function listingMode() {
        var isActuallyEn = this.isEnglish();
        var hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return isActuallyEn && hasNoWeirdness ? "en" : "intl";
      };
      _proto4.clone = function clone3(alts) {
        if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
          return this;
        } else {
          return Locale2.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);
        }
      };
      _proto4.redefaultToEN = function redefaultToEN(alts) {
        if (alts === void 0) {
          alts = {};
        }
        return this.clone(_extends({}, alts, {
          defaultToEN: true
        }));
      };
      _proto4.redefaultToSystem = function redefaultToSystem(alts) {
        if (alts === void 0) {
          alts = {};
        }
        return this.clone(_extends({}, alts, {
          defaultToEN: false
        }));
      };
      _proto4.months = function months$1(length, format, defaultOK) {
        var _this = this;
        if (format === void 0) {
          format = false;
        }
        if (defaultOK === void 0) {
          defaultOK = true;
        }
        return listStuff(this, length, defaultOK, months, function() {
          var intl = format ? {
            month: length,
            day: "numeric"
          } : {
            month: length
          }, formatStr = format ? "format" : "standalone";
          if (!_this.monthsCache[formatStr][length]) {
            _this.monthsCache[formatStr][length] = mapMonths(function(dt) {
              return _this.extract(dt, intl, "month");
            });
          }
          return _this.monthsCache[formatStr][length];
        });
      };
      _proto4.weekdays = function weekdays$1(length, format, defaultOK) {
        var _this2 = this;
        if (format === void 0) {
          format = false;
        }
        if (defaultOK === void 0) {
          defaultOK = true;
        }
        return listStuff(this, length, defaultOK, weekdays, function() {
          var intl = format ? {
            weekday: length,
            year: "numeric",
            month: "long",
            day: "numeric"
          } : {
            weekday: length
          }, formatStr = format ? "format" : "standalone";
          if (!_this2.weekdaysCache[formatStr][length]) {
            _this2.weekdaysCache[formatStr][length] = mapWeekdays(function(dt) {
              return _this2.extract(dt, intl, "weekday");
            });
          }
          return _this2.weekdaysCache[formatStr][length];
        });
      };
      _proto4.meridiems = function meridiems$1(defaultOK) {
        var _this3 = this;
        if (defaultOK === void 0) {
          defaultOK = true;
        }
        return listStuff(this, void 0, defaultOK, function() {
          return meridiems;
        }, function() {
          if (!_this3.meridiemCache) {
            var intl = {
              hour: "numeric",
              hourCycle: "h12"
            };
            _this3.meridiemCache = [DateTime4.utc(2016, 11, 13, 9), DateTime4.utc(2016, 11, 13, 19)].map(function(dt) {
              return _this3.extract(dt, intl, "dayperiod");
            });
          }
          return _this3.meridiemCache;
        });
      };
      _proto4.eras = function eras$1(length, defaultOK) {
        var _this4 = this;
        if (defaultOK === void 0) {
          defaultOK = true;
        }
        return listStuff(this, length, defaultOK, eras, function() {
          var intl = {
            era: length
          };
          if (!_this4.eraCache[length]) {
            _this4.eraCache[length] = [DateTime4.utc(-40, 1, 1), DateTime4.utc(2017, 1, 1)].map(function(dt) {
              return _this4.extract(dt, intl, "era");
            });
          }
          return _this4.eraCache[length];
        });
      };
      _proto4.extract = function extract(dt, intlOpts, field) {
        var df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find(function(m) {
          return m.type.toLowerCase() === field;
        });
        return matching ? matching.value : null;
      };
      _proto4.numberFormatter = function numberFormatter(opts) {
        if (opts === void 0) {
          opts = {};
        }
        return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
      };
      _proto4.dtFormatter = function dtFormatter(dt, intlOpts) {
        if (intlOpts === void 0) {
          intlOpts = {};
        }
        return new PolyDateFormatter(dt, this.intl, intlOpts);
      };
      _proto4.relFormatter = function relFormatter(opts) {
        if (opts === void 0) {
          opts = {};
        }
        return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
      };
      _proto4.listFormatter = function listFormatter(opts) {
        if (opts === void 0) {
          opts = {};
        }
        return getCachedLF(this.intl, opts);
      };
      _proto4.isEnglish = function isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
      };
      _proto4.equals = function equals(other) {
        return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
      };
      _createClass(Locale2, [{
        key: "fastNumbers",
        get: function get() {
          if (this.fastNumbersCached == null) {
            this.fastNumbersCached = supportsFastNumbers(this);
          }
          return this.fastNumbersCached;
        }
      }]);
      return Locale2;
    }();
    function combineRegexes() {
      for (var _len = arguments.length, regexes = new Array(_len), _key = 0; _key < _len; _key++) {
        regexes[_key] = arguments[_key];
      }
      var full = regexes.reduce(function(f, r) {
        return f + r.source;
      }, "");
      return RegExp("^" + full + "$");
    }
    function combineExtractors() {
      for (var _len2 = arguments.length, extractors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        extractors[_key2] = arguments[_key2];
      }
      return function(m) {
        return extractors.reduce(function(_ref, ex) {
          var mergedVals = _ref[0], mergedZone = _ref[1], cursor = _ref[2];
          var _ex = ex(m, cursor), val = _ex[0], zone = _ex[1], next = _ex[2];
          return [_extends({}, mergedVals, val), mergedZone || zone, next];
        }, [{}, null, 1]).slice(0, 2);
      };
    }
    function parse2(s2) {
      if (s2 == null) {
        return [null, null];
      }
      for (var _len3 = arguments.length, patterns = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        patterns[_key3 - 1] = arguments[_key3];
      }
      for (var _i = 0, _patterns = patterns; _i < _patterns.length; _i++) {
        var _patterns$_i = _patterns[_i], regex = _patterns$_i[0], extractor = _patterns$_i[1];
        var m = regex.exec(s2);
        if (m) {
          return extractor(m);
        }
      }
      return [null, null];
    }
    function simpleParse() {
      for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        keys[_key4] = arguments[_key4];
      }
      return function(match2, cursor) {
        var ret = {};
        var i;
        for (i = 0; i < keys.length; i++) {
          ret[keys[i]] = parseInteger(match2[cursor + i]);
        }
        return [ret, null, cursor + i];
      };
    }
    var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
    var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
    var isoTimeRegex = RegExp("" + isoTimeBaseRegex.source + offsetRegex.source + "?");
    var isoTimeExtensionRegex = RegExp("(?:T" + isoTimeRegex.source + ")?");
    var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
    var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
    var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
    var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
    var extractISOOrdinalData = simpleParse("year", "ordinal");
    var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
    var sqlTimeRegex = RegExp(isoTimeBaseRegex.source + " ?(?:" + offsetRegex.source + "|(" + ianaRegex.source + "))?");
    var sqlTimeExtensionRegex = RegExp("(?: " + sqlTimeRegex.source + ")?");
    function int(match2, pos, fallback) {
      var m = match2[pos];
      return isUndefined(m) ? fallback : parseInteger(m);
    }
    function extractISOYmd(match2, cursor) {
      var item = {
        year: int(match2, cursor),
        month: int(match2, cursor + 1, 1),
        day: int(match2, cursor + 2, 1)
      };
      return [item, null, cursor + 3];
    }
    function extractISOTime(match2, cursor) {
      var item = {
        hours: int(match2, cursor, 0),
        minutes: int(match2, cursor + 1, 0),
        seconds: int(match2, cursor + 2, 0),
        milliseconds: parseMillis(match2[cursor + 3])
      };
      return [item, null, cursor + 4];
    }
    function extractISOOffset(match2, cursor) {
      var local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
      return [{}, zone, cursor + 3];
    }
    function extractIANAZone(match2, cursor) {
      var zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
      return [{}, zone, cursor + 1];
    }
    var isoTimeOnly = RegExp("^T?" + isoTimeBaseRegex.source + "$");
    var isoDuration = /^-?P(?:(?:(-?\d{1,9}(?:\.\d{1,9})?)Y)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,9}(?:\.\d{1,9})?)W)?(?:(-?\d{1,9}(?:\.\d{1,9})?)D)?(?:T(?:(-?\d{1,9}(?:\.\d{1,9})?)H)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,9}))?S)?)?)$/;
    function extractISODuration(match2) {
      var s2 = match2[0], yearStr = match2[1], monthStr = match2[2], weekStr = match2[3], dayStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], millisecondsStr = match2[8];
      var hasNegativePrefix = s2[0] === "-";
      var negativeSeconds = secondStr && secondStr[0] === "-";
      var maybeNegate = function maybeNegate2(num, force) {
        if (force === void 0) {
          force = false;
        }
        return num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
      };
      return [{
        years: maybeNegate(parseFloating(yearStr)),
        months: maybeNegate(parseFloating(monthStr)),
        weeks: maybeNegate(parseFloating(weekStr)),
        days: maybeNegate(parseFloating(dayStr)),
        hours: maybeNegate(parseFloating(hourStr)),
        minutes: maybeNegate(parseFloating(minuteStr)),
        seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
        milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
      }];
    }
    var obsOffsets = {
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = {
        year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
        month: monthsShort.indexOf(monthStr) + 1,
        day: parseInteger(dayStr),
        hour: parseInteger(hourStr),
        minute: parseInteger(minuteStr)
      };
      if (secondStr)
        result.second = parseInteger(secondStr);
      if (weekdayStr) {
        result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
      }
      return result;
    }
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
    function extractRFC2822(match2) {
      var weekdayStr = match2[1], dayStr = match2[2], monthStr = match2[3], yearStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], obsOffset = match2[8], milOffset = match2[9], offHourStr = match2[10], offMinuteStr = match2[11], result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      var offset2;
      if (obsOffset) {
        offset2 = obsOffsets[obsOffset];
      } else if (milOffset) {
        offset2 = 0;
      } else {
        offset2 = signedOffset(offHourStr, offMinuteStr);
      }
      return [result, new FixedOffsetZone(offset2)];
    }
    function preprocessRFC2822(s2) {
      return s2.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
    }
    var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
    var rfc850 = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
    var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
    function extractRFC1123Or850(match2) {
      var weekdayStr = match2[1], dayStr = match2[2], monthStr = match2[3], yearStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    function extractASCII(match2) {
      var weekdayStr = match2[1], monthStr = match2[2], dayStr = match2[3], hourStr = match2[4], minuteStr = match2[5], secondStr = match2[6], yearStr = match2[7], result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
    var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
    var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
    var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
    var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset);
    var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset);
    var extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset);
    var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset);
    function parseISODate(s2) {
      return parse2(s2, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
    }
    function parseRFC2822Date(s2) {
      return parse2(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
    }
    function parseHTTPDate(s2) {
      return parse2(s2, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
    }
    function parseISODuration(s2) {
      return parse2(s2, [isoDuration, extractISODuration]);
    }
    var extractISOTimeOnly = combineExtractors(extractISOTime);
    function parseISOTimeOnly(s2) {
      return parse2(s2, [isoTimeOnly, extractISOTimeOnly]);
    }
    var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
    var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
    var extractISOYmdTimeOffsetAndIANAZone = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
    var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
    function parseSQL(s2) {
      return parse2(s2, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeOffsetAndIANAZone], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
    }
    var INVALID$2 = "Invalid Duration";
    var lowOrderMatrix = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1e3
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1e3
      },
      hours: {
        minutes: 60,
        seconds: 60 * 60,
        milliseconds: 60 * 60 * 1e3
      },
      minutes: {
        seconds: 60,
        milliseconds: 60 * 1e3
      },
      seconds: {
        milliseconds: 1e3
      }
    };
    var casualMatrix = _extends({
      years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1e3
      },
      months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1e3
      }
    }, lowOrderMatrix);
    var daysInYearAccurate = 146097 / 400;
    var daysInMonthAccurate = 146097 / 4800;
    var accurateMatrix = _extends({
      years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate / 7,
        days: daysInYearAccurate,
        hours: daysInYearAccurate * 24,
        minutes: daysInYearAccurate * 24 * 60,
        seconds: daysInYearAccurate * 24 * 60 * 60,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: daysInYearAccurate / 28,
        days: daysInYearAccurate / 4,
        hours: daysInYearAccurate * 24 / 4,
        minutes: daysInYearAccurate * 24 * 60 / 4,
        seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
      },
      months: {
        weeks: daysInMonthAccurate / 7,
        days: daysInMonthAccurate,
        hours: daysInMonthAccurate * 24,
        minutes: daysInMonthAccurate * 24 * 60,
        seconds: daysInMonthAccurate * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
      }
    }, lowOrderMatrix);
    var orderedUnits$1 = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
    var reverseUnits = orderedUnits$1.slice(0).reverse();
    function clone$12(dur, alts, clear) {
      if (clear === void 0) {
        clear = false;
      }
      var conf = {
        values: clear ? alts.values : _extends({}, dur.values, alts.values || {}),
        loc: dur.loc.clone(alts.loc),
        conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy
      };
      return new Duration(conf);
    }
    function antiTrunc(n2) {
      return n2 < 0 ? Math.floor(n2) : Math.ceil(n2);
    }
    function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
      var conv = matrix[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
      toMap[toUnit] += added;
      fromMap[fromUnit] -= added * conv;
    }
    function normalizeValues(matrix, vals) {
      reverseUnits.reduce(function(previous, current) {
        if (!isUndefined(vals[current])) {
          if (previous) {
            convert(matrix, vals, previous, vals, current);
          }
          return current;
        } else {
          return previous;
        }
      }, null);
    }
    var Duration = /* @__PURE__ */ function() {
      function Duration2(config) {
        var accurate = config.conversionAccuracy === "longterm" || false;
        this.values = config.values;
        this.loc = config.loc || Locale.create();
        this.conversionAccuracy = accurate ? "longterm" : "casual";
        this.invalid = config.invalid || null;
        this.matrix = accurate ? accurateMatrix : casualMatrix;
        this.isLuxonDuration = true;
      }
      Duration2.fromMillis = function fromMillis(count, opts) {
        return Duration2.fromObject({
          milliseconds: count
        }, opts);
      };
      Duration2.fromObject = function fromObject2(obj, opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (obj == null || typeof obj !== "object") {
          throw new InvalidArgumentError("Duration.fromObject: argument expected to be an object, got " + (obj === null ? "null" : typeof obj));
        }
        return new Duration2({
          values: normalizeObject(obj, Duration2.normalizeUnit),
          loc: Locale.fromObject(opts),
          conversionAccuracy: opts.conversionAccuracy
        });
      };
      Duration2.fromDurationLike = function fromDurationLike(durationLike) {
        if (isNumber2(durationLike)) {
          return Duration2.fromMillis(durationLike);
        } else if (Duration2.isDuration(durationLike)) {
          return durationLike;
        } else if (typeof durationLike === "object") {
          return Duration2.fromObject(durationLike);
        } else {
          throw new InvalidArgumentError("Unknown duration argument " + durationLike + " of type " + typeof durationLike);
        }
      };
      Duration2.fromISO = function fromISO(text2, opts) {
        var _parseISODuration = parseISODuration(text2), parsed = _parseISODuration[0];
        if (parsed) {
          return Duration2.fromObject(parsed, opts);
        } else {
          return Duration2.invalid("unparsable", 'the input "' + text2 + `" can't be parsed as ISO 8601`);
        }
      };
      Duration2.fromISOTime = function fromISOTime(text2, opts) {
        var _parseISOTimeOnly = parseISOTimeOnly(text2), parsed = _parseISOTimeOnly[0];
        if (parsed) {
          return Duration2.fromObject(parsed, opts);
        } else {
          return Duration2.invalid("unparsable", 'the input "' + text2 + `" can't be parsed as ISO 8601`);
        }
      };
      Duration2.invalid = function invalid(reason, explanation) {
        if (explanation === void 0) {
          explanation = null;
        }
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
        }
        var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDurationError(invalid2);
        } else {
          return new Duration2({
            invalid: invalid2
          });
        }
      };
      Duration2.normalizeUnit = function normalizeUnit2(unit) {
        var normalized = {
          year: "years",
          years: "years",
          quarter: "quarters",
          quarters: "quarters",
          month: "months",
          months: "months",
          week: "weeks",
          weeks: "weeks",
          day: "days",
          days: "days",
          hour: "hours",
          hours: "hours",
          minute: "minutes",
          minutes: "minutes",
          second: "seconds",
          seconds: "seconds",
          millisecond: "milliseconds",
          milliseconds: "milliseconds"
        }[unit ? unit.toLowerCase() : unit];
        if (!normalized)
          throw new InvalidUnitError(unit);
        return normalized;
      };
      Duration2.isDuration = function isDuration(o) {
        return o && o.isLuxonDuration || false;
      };
      var _proto = Duration2.prototype;
      _proto.toFormat = function toFormat(fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var fmtOpts = _extends({}, opts, {
          floor: opts.round !== false && opts.floor !== false
        });
        return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
      };
      _proto.toHuman = function toHuman(opts) {
        var _this = this;
        if (opts === void 0) {
          opts = {};
        }
        var l2 = orderedUnits$1.map(function(unit) {
          var val = _this.values[unit];
          if (isUndefined(val)) {
            return null;
          }
          return _this.loc.numberFormatter(_extends({
            style: "unit",
            unitDisplay: "long"
          }, opts, {
            unit: unit.slice(0, -1)
          })).format(val);
        }).filter(function(n2) {
          return n2;
        });
        return this.loc.listFormatter(_extends({
          type: "conjunction",
          style: opts.listStyle || "narrow"
        }, opts)).format(l2);
      };
      _proto.toObject = function toObject() {
        if (!this.isValid)
          return {};
        return _extends({}, this.values);
      };
      _proto.toISO = function toISO() {
        if (!this.isValid)
          return null;
        var s2 = "P";
        if (this.years !== 0)
          s2 += this.years + "Y";
        if (this.months !== 0 || this.quarters !== 0)
          s2 += this.months + this.quarters * 3 + "M";
        if (this.weeks !== 0)
          s2 += this.weeks + "W";
        if (this.days !== 0)
          s2 += this.days + "D";
        if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
          s2 += "T";
        if (this.hours !== 0)
          s2 += this.hours + "H";
        if (this.minutes !== 0)
          s2 += this.minutes + "M";
        if (this.seconds !== 0 || this.milliseconds !== 0)
          s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
        if (s2 === "P")
          s2 += "T0S";
        return s2;
      };
      _proto.toISOTime = function toISOTime(opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid)
          return null;
        var millis = this.toMillis();
        if (millis < 0 || millis >= 864e5)
          return null;
        opts = _extends({
          suppressMilliseconds: false,
          suppressSeconds: false,
          includePrefix: false,
          format: "extended"
        }, opts);
        var value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
        var fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
        if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
          fmt += opts.format === "basic" ? "ss" : ":ss";
          if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
            fmt += ".SSS";
          }
        }
        var str = value.toFormat(fmt);
        if (opts.includePrefix) {
          str = "T" + str;
        }
        return str;
      };
      _proto.toJSON = function toJSON() {
        return this.toISO();
      };
      _proto.toString = function toString() {
        return this.toISO();
      };
      _proto.toMillis = function toMillis() {
        return this.as("milliseconds");
      };
      _proto.valueOf = function valueOf() {
        return this.toMillis();
      };
      _proto.plus = function plus(duration) {
        if (!this.isValid)
          return this;
        var dur = Duration2.fromDurationLike(duration), result = {};
        for (var _iterator = _createForOfIteratorHelperLoose(orderedUnits$1), _step; !(_step = _iterator()).done; ) {
          var k = _step.value;
          if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
            result[k] = dur.get(k) + this.get(k);
          }
        }
        return clone$12(this, {
          values: result
        }, true);
      };
      _proto.minus = function minus(duration) {
        if (!this.isValid)
          return this;
        var dur = Duration2.fromDurationLike(duration);
        return this.plus(dur.negate());
      };
      _proto.mapUnits = function mapUnits(fn) {
        if (!this.isValid)
          return this;
        var result = {};
        for (var _i = 0, _Object$keys = Object.keys(this.values); _i < _Object$keys.length; _i++) {
          var k = _Object$keys[_i];
          result[k] = asNumber(fn(this.values[k], k));
        }
        return clone$12(this, {
          values: result
        }, true);
      };
      _proto.get = function get(unit) {
        return this[Duration2.normalizeUnit(unit)];
      };
      _proto.set = function set2(values) {
        if (!this.isValid)
          return this;
        var mixed = _extends({}, this.values, normalizeObject(values, Duration2.normalizeUnit));
        return clone$12(this, {
          values: mixed
        });
      };
      _proto.reconfigure = function reconfigure(_temp) {
        var _ref = _temp === void 0 ? {} : _temp, locale = _ref.locale, numberingSystem = _ref.numberingSystem, conversionAccuracy = _ref.conversionAccuracy;
        var loc = this.loc.clone({
          locale,
          numberingSystem
        }), opts = {
          loc
        };
        if (conversionAccuracy) {
          opts.conversionAccuracy = conversionAccuracy;
        }
        return clone$12(this, opts);
      };
      _proto.as = function as(unit) {
        return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
      };
      _proto.normalize = function normalize() {
        if (!this.isValid)
          return this;
        var vals = this.toObject();
        normalizeValues(this.matrix, vals);
        return clone$12(this, {
          values: vals
        }, true);
      };
      _proto.shiftTo = function shiftTo() {
        for (var _len = arguments.length, units = new Array(_len), _key = 0; _key < _len; _key++) {
          units[_key] = arguments[_key];
        }
        if (!this.isValid)
          return this;
        if (units.length === 0) {
          return this;
        }
        units = units.map(function(u) {
          return Duration2.normalizeUnit(u);
        });
        var built = {}, accumulated = {}, vals = this.toObject();
        var lastUnit;
        for (var _iterator2 = _createForOfIteratorHelperLoose(orderedUnits$1), _step2; !(_step2 = _iterator2()).done; ) {
          var k = _step2.value;
          if (units.indexOf(k) >= 0) {
            lastUnit = k;
            var own = 0;
            for (var ak in accumulated) {
              own += this.matrix[ak][k] * accumulated[ak];
              accumulated[ak] = 0;
            }
            if (isNumber2(vals[k])) {
              own += vals[k];
            }
            var i = Math.trunc(own);
            built[k] = i;
            accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
            for (var down in vals) {
              if (orderedUnits$1.indexOf(down) > orderedUnits$1.indexOf(k)) {
                convert(this.matrix, vals, down, built, k);
              }
            }
          } else if (isNumber2(vals[k])) {
            accumulated[k] = vals[k];
          }
        }
        for (var key in accumulated) {
          if (accumulated[key] !== 0) {
            built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
          }
        }
        return clone$12(this, {
          values: built
        }, true).normalize();
      };
      _proto.negate = function negate() {
        if (!this.isValid)
          return this;
        var negated = {};
        for (var _i2 = 0, _Object$keys2 = Object.keys(this.values); _i2 < _Object$keys2.length; _i2++) {
          var k = _Object$keys2[_i2];
          negated[k] = -this.values[k];
        }
        return clone$12(this, {
          values: negated
        }, true);
      };
      _proto.equals = function equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        if (!this.loc.equals(other.loc)) {
          return false;
        }
        function eq2(v1, v2) {
          if (v1 === void 0 || v1 === 0)
            return v2 === void 0 || v2 === 0;
          return v1 === v2;
        }
        for (var _iterator3 = _createForOfIteratorHelperLoose(orderedUnits$1), _step3; !(_step3 = _iterator3()).done; ) {
          var u = _step3.value;
          if (!eq2(this.values[u], other.values[u])) {
            return false;
          }
        }
        return true;
      };
      _createClass(Duration2, [{
        key: "locale",
        get: function get() {
          return this.isValid ? this.loc.locale : null;
        }
      }, {
        key: "numberingSystem",
        get: function get() {
          return this.isValid ? this.loc.numberingSystem : null;
        }
      }, {
        key: "years",
        get: function get() {
          return this.isValid ? this.values.years || 0 : NaN;
        }
      }, {
        key: "quarters",
        get: function get() {
          return this.isValid ? this.values.quarters || 0 : NaN;
        }
      }, {
        key: "months",
        get: function get() {
          return this.isValid ? this.values.months || 0 : NaN;
        }
      }, {
        key: "weeks",
        get: function get() {
          return this.isValid ? this.values.weeks || 0 : NaN;
        }
      }, {
        key: "days",
        get: function get() {
          return this.isValid ? this.values.days || 0 : NaN;
        }
      }, {
        key: "hours",
        get: function get() {
          return this.isValid ? this.values.hours || 0 : NaN;
        }
      }, {
        key: "minutes",
        get: function get() {
          return this.isValid ? this.values.minutes || 0 : NaN;
        }
      }, {
        key: "seconds",
        get: function get() {
          return this.isValid ? this.values.seconds || 0 : NaN;
        }
      }, {
        key: "milliseconds",
        get: function get() {
          return this.isValid ? this.values.milliseconds || 0 : NaN;
        }
      }, {
        key: "isValid",
        get: function get() {
          return this.invalid === null;
        }
      }, {
        key: "invalidReason",
        get: function get() {
          return this.invalid ? this.invalid.reason : null;
        }
      }, {
        key: "invalidExplanation",
        get: function get() {
          return this.invalid ? this.invalid.explanation : null;
        }
      }]);
      return Duration2;
    }();
    var INVALID$1 = "Invalid Interval";
    function validateStartEnd(start, end) {
      if (!start || !start.isValid) {
        return Interval.invalid("missing or invalid start");
      } else if (!end || !end.isValid) {
        return Interval.invalid("missing or invalid end");
      } else if (end < start) {
        return Interval.invalid("end before start", "The end of an interval must be after its start, but you had start=" + start.toISO() + " and end=" + end.toISO());
      } else {
        return null;
      }
    }
    var Interval = /* @__PURE__ */ function() {
      function Interval2(config) {
        this.s = config.start;
        this.e = config.end;
        this.invalid = config.invalid || null;
        this.isLuxonInterval = true;
      }
      Interval2.invalid = function invalid(reason, explanation) {
        if (explanation === void 0) {
          explanation = null;
        }
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
        }
        var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidIntervalError(invalid2);
        } else {
          return new Interval2({
            invalid: invalid2
          });
        }
      };
      Interval2.fromDateTimes = function fromDateTimes(start, end) {
        var builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
        var validateError = validateStartEnd(builtStart, builtEnd);
        if (validateError == null) {
          return new Interval2({
            start: builtStart,
            end: builtEnd
          });
        } else {
          return validateError;
        }
      };
      Interval2.after = function after(start, duration) {
        var dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
        return Interval2.fromDateTimes(dt, dt.plus(dur));
      };
      Interval2.before = function before(end, duration) {
        var dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
        return Interval2.fromDateTimes(dt.minus(dur), dt);
      };
      Interval2.fromISO = function fromISO(text2, opts) {
        var _split = (text2 || "").split("/", 2), s2 = _split[0], e = _split[1];
        if (s2 && e) {
          var start, startIsValid;
          try {
            start = DateTime4.fromISO(s2, opts);
            startIsValid = start.isValid;
          } catch (e2) {
            startIsValid = false;
          }
          var end, endIsValid;
          try {
            end = DateTime4.fromISO(e, opts);
            endIsValid = end.isValid;
          } catch (e2) {
            endIsValid = false;
          }
          if (startIsValid && endIsValid) {
            return Interval2.fromDateTimes(start, end);
          }
          if (startIsValid) {
            var dur = Duration.fromISO(e, opts);
            if (dur.isValid) {
              return Interval2.after(start, dur);
            }
          } else if (endIsValid) {
            var _dur = Duration.fromISO(s2, opts);
            if (_dur.isValid) {
              return Interval2.before(end, _dur);
            }
          }
        }
        return Interval2.invalid("unparsable", 'the input "' + text2 + `" can't be parsed as ISO 8601`);
      };
      Interval2.isInterval = function isInterval(o) {
        return o && o.isLuxonInterval || false;
      };
      var _proto = Interval2.prototype;
      _proto.length = function length(unit) {
        if (unit === void 0) {
          unit = "milliseconds";
        }
        return this.isValid ? this.toDuration.apply(this, [unit]).get(unit) : NaN;
      };
      _proto.count = function count(unit) {
        if (unit === void 0) {
          unit = "milliseconds";
        }
        if (!this.isValid)
          return NaN;
        var start = this.start.startOf(unit), end = this.end.startOf(unit);
        return Math.floor(end.diff(start, unit).get(unit)) + 1;
      };
      _proto.hasSame = function hasSame(unit) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
      };
      _proto.isEmpty = function isEmpty() {
        return this.s.valueOf() === this.e.valueOf();
      };
      _proto.isAfter = function isAfter(dateTime) {
        if (!this.isValid)
          return false;
        return this.s > dateTime;
      };
      _proto.isBefore = function isBefore(dateTime) {
        if (!this.isValid)
          return false;
        return this.e <= dateTime;
      };
      _proto.contains = function contains(dateTime) {
        if (!this.isValid)
          return false;
        return this.s <= dateTime && this.e > dateTime;
      };
      _proto.set = function set2(_temp) {
        var _ref = _temp === void 0 ? {} : _temp, start = _ref.start, end = _ref.end;
        if (!this.isValid)
          return this;
        return Interval2.fromDateTimes(start || this.s, end || this.e);
      };
      _proto.splitAt = function splitAt() {
        var _this = this;
        if (!this.isValid)
          return [];
        for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
          dateTimes[_key] = arguments[_key];
        }
        var sorted = dateTimes.map(friendlyDateTime).filter(function(d) {
          return _this.contains(d);
        }).sort(), results = [];
        var s2 = this.s, i = 0;
        while (s2 < this.e) {
          var added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
          results.push(Interval2.fromDateTimes(s2, next));
          s2 = next;
          i += 1;
        }
        return results;
      };
      _proto.splitBy = function splitBy(duration) {
        var dur = Duration.fromDurationLike(duration);
        if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
          return [];
        }
        var s2 = this.s, idx = 1, next;
        var results = [];
        while (s2 < this.e) {
          var added = this.start.plus(dur.mapUnits(function(x) {
            return x * idx;
          }));
          next = +added > +this.e ? this.e : added;
          results.push(Interval2.fromDateTimes(s2, next));
          s2 = next;
          idx += 1;
        }
        return results;
      };
      _proto.divideEqually = function divideEqually(numberOfParts) {
        if (!this.isValid)
          return [];
        return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
      };
      _proto.overlaps = function overlaps(other) {
        return this.e > other.s && this.s < other.e;
      };
      _proto.abutsStart = function abutsStart(other) {
        if (!this.isValid)
          return false;
        return +this.e === +other.s;
      };
      _proto.abutsEnd = function abutsEnd(other) {
        if (!this.isValid)
          return false;
        return +other.e === +this.s;
      };
      _proto.engulfs = function engulfs(other) {
        if (!this.isValid)
          return false;
        return this.s <= other.s && this.e >= other.e;
      };
      _proto.equals = function equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        return this.s.equals(other.s) && this.e.equals(other.e);
      };
      _proto.intersection = function intersection(other) {
        if (!this.isValid)
          return this;
        var s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
        if (s2 >= e) {
          return null;
        } else {
          return Interval2.fromDateTimes(s2, e);
        }
      };
      _proto.union = function union(other) {
        if (!this.isValid)
          return this;
        var s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
        return Interval2.fromDateTimes(s2, e);
      };
      Interval2.merge = function merge2(intervals) {
        var _intervals$sort$reduc = intervals.sort(function(a, b) {
          return a.s - b.s;
        }).reduce(function(_ref2, item) {
          var sofar = _ref2[0], current = _ref2[1];
          if (!current) {
            return [sofar, item];
          } else if (current.overlaps(item) || current.abutsStart(item)) {
            return [sofar, current.union(item)];
          } else {
            return [sofar.concat([current]), item];
          }
        }, [[], null]), found = _intervals$sort$reduc[0], final = _intervals$sort$reduc[1];
        if (final) {
          found.push(final);
        }
        return found;
      };
      Interval2.xor = function xor(intervals) {
        var _Array$prototype;
        var start = null, currentCount = 0;
        var results = [], ends = intervals.map(function(i2) {
          return [{
            time: i2.s,
            type: "s"
          }, {
            time: i2.e,
            type: "e"
          }];
        }), flattened = (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, ends), arr = flattened.sort(function(a, b) {
          return a.time - b.time;
        });
        for (var _iterator = _createForOfIteratorHelperLoose(arr), _step; !(_step = _iterator()).done; ) {
          var i = _step.value;
          currentCount += i.type === "s" ? 1 : -1;
          if (currentCount === 1) {
            start = i.time;
          } else {
            if (start && +start !== +i.time) {
              results.push(Interval2.fromDateTimes(start, i.time));
            }
            start = null;
          }
        }
        return Interval2.merge(results);
      };
      _proto.difference = function difference() {
        var _this2 = this;
        for (var _len2 = arguments.length, intervals = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          intervals[_key2] = arguments[_key2];
        }
        return Interval2.xor([this].concat(intervals)).map(function(i) {
          return _this2.intersection(i);
        }).filter(function(i) {
          return i && !i.isEmpty();
        });
      };
      _proto.toString = function toString() {
        if (!this.isValid)
          return INVALID$1;
        return "[" + this.s.toISO() + " \u2013 " + this.e.toISO() + ")";
      };
      _proto.toISO = function toISO(opts) {
        if (!this.isValid)
          return INVALID$1;
        return this.s.toISO(opts) + "/" + this.e.toISO(opts);
      };
      _proto.toISODate = function toISODate() {
        if (!this.isValid)
          return INVALID$1;
        return this.s.toISODate() + "/" + this.e.toISODate();
      };
      _proto.toISOTime = function toISOTime(opts) {
        if (!this.isValid)
          return INVALID$1;
        return this.s.toISOTime(opts) + "/" + this.e.toISOTime(opts);
      };
      _proto.toFormat = function toFormat(dateFormat, _temp2) {
        var _ref3 = _temp2 === void 0 ? {} : _temp2, _ref3$separator = _ref3.separator, separator = _ref3$separator === void 0 ? " \u2013 " : _ref3$separator;
        if (!this.isValid)
          return INVALID$1;
        return "" + this.s.toFormat(dateFormat) + separator + this.e.toFormat(dateFormat);
      };
      _proto.toDuration = function toDuration(unit, opts) {
        if (!this.isValid) {
          return Duration.invalid(this.invalidReason);
        }
        return this.e.diff(this.s, unit, opts);
      };
      _proto.mapEndpoints = function mapEndpoints(mapFn) {
        return Interval2.fromDateTimes(mapFn(this.s), mapFn(this.e));
      };
      _createClass(Interval2, [{
        key: "start",
        get: function get() {
          return this.isValid ? this.s : null;
        }
      }, {
        key: "end",
        get: function get() {
          return this.isValid ? this.e : null;
        }
      }, {
        key: "isValid",
        get: function get() {
          return this.invalidReason === null;
        }
      }, {
        key: "invalidReason",
        get: function get() {
          return this.invalid ? this.invalid.reason : null;
        }
      }, {
        key: "invalidExplanation",
        get: function get() {
          return this.invalid ? this.invalid.explanation : null;
        }
      }]);
      return Interval2;
    }();
    var Info = /* @__PURE__ */ function() {
      function Info2() {
      }
      Info2.hasDST = function hasDST(zone) {
        if (zone === void 0) {
          zone = Settings.defaultZone;
        }
        var proto = DateTime4.now().setZone(zone).set({
          month: 12
        });
        return !zone.isUniversal && proto.offset !== proto.set({
          month: 6
        }).offset;
      };
      Info2.isValidIANAZone = function isValidIANAZone(zone) {
        return IANAZone.isValidSpecifier(zone) && IANAZone.isValidZone(zone);
      };
      Info2.normalizeZone = function normalizeZone$1(input) {
        return normalizeZone(input, Settings.defaultZone);
      };
      Info2.months = function months2(length, _temp) {
        if (length === void 0) {
          length = "long";
        }
        var _ref = _temp === void 0 ? {} : _temp, _ref$locale = _ref.locale, locale = _ref$locale === void 0 ? null : _ref$locale, _ref$numberingSystem = _ref.numberingSystem, numberingSystem = _ref$numberingSystem === void 0 ? null : _ref$numberingSystem, _ref$locObj = _ref.locObj, locObj = _ref$locObj === void 0 ? null : _ref$locObj, _ref$outputCalendar = _ref.outputCalendar, outputCalendar = _ref$outputCalendar === void 0 ? "gregory" : _ref$outputCalendar;
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
      };
      Info2.monthsFormat = function monthsFormat(length, _temp2) {
        if (length === void 0) {
          length = "long";
        }
        var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$locale = _ref2.locale, locale = _ref2$locale === void 0 ? null : _ref2$locale, _ref2$numberingSystem = _ref2.numberingSystem, numberingSystem = _ref2$numberingSystem === void 0 ? null : _ref2$numberingSystem, _ref2$locObj = _ref2.locObj, locObj = _ref2$locObj === void 0 ? null : _ref2$locObj, _ref2$outputCalendar = _ref2.outputCalendar, outputCalendar = _ref2$outputCalendar === void 0 ? "gregory" : _ref2$outputCalendar;
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
      };
      Info2.weekdays = function weekdays2(length, _temp3) {
        if (length === void 0) {
          length = "long";
        }
        var _ref3 = _temp3 === void 0 ? {} : _temp3, _ref3$locale = _ref3.locale, locale = _ref3$locale === void 0 ? null : _ref3$locale, _ref3$numberingSystem = _ref3.numberingSystem, numberingSystem = _ref3$numberingSystem === void 0 ? null : _ref3$numberingSystem, _ref3$locObj = _ref3.locObj, locObj = _ref3$locObj === void 0 ? null : _ref3$locObj;
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
      };
      Info2.weekdaysFormat = function weekdaysFormat(length, _temp4) {
        if (length === void 0) {
          length = "long";
        }
        var _ref4 = _temp4 === void 0 ? {} : _temp4, _ref4$locale = _ref4.locale, locale = _ref4$locale === void 0 ? null : _ref4$locale, _ref4$numberingSystem = _ref4.numberingSystem, numberingSystem = _ref4$numberingSystem === void 0 ? null : _ref4$numberingSystem, _ref4$locObj = _ref4.locObj, locObj = _ref4$locObj === void 0 ? null : _ref4$locObj;
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
      };
      Info2.meridiems = function meridiems2(_temp5) {
        var _ref5 = _temp5 === void 0 ? {} : _temp5, _ref5$locale = _ref5.locale, locale = _ref5$locale === void 0 ? null : _ref5$locale;
        return Locale.create(locale).meridiems();
      };
      Info2.eras = function eras2(length, _temp6) {
        if (length === void 0) {
          length = "short";
        }
        var _ref6 = _temp6 === void 0 ? {} : _temp6, _ref6$locale = _ref6.locale, locale = _ref6$locale === void 0 ? null : _ref6$locale;
        return Locale.create(locale, null, "gregory").eras(length);
      };
      Info2.features = function features() {
        return {
          relative: hasRelative()
        };
      };
      return Info2;
    }();
    function dayDiff(earlier, later) {
      var utcDayStart = function utcDayStart2(dt) {
        return dt.toUTC(0, {
          keepLocalTime: true
        }).startOf("day").valueOf();
      }, ms = utcDayStart(later) - utcDayStart(earlier);
      return Math.floor(Duration.fromMillis(ms).as("days"));
    }
    function highOrderDiffs(cursor, later, units) {
      var differs = [["years", function(a, b) {
        return b.year - a.year;
      }], ["quarters", function(a, b) {
        return b.quarter - a.quarter;
      }], ["months", function(a, b) {
        return b.month - a.month + (b.year - a.year) * 12;
      }], ["weeks", function(a, b) {
        var days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }], ["days", dayDiff]];
      var results = {};
      var lowestOrder, highWater;
      for (var _i = 0, _differs = differs; _i < _differs.length; _i++) {
        var _differs$_i = _differs[_i], unit = _differs$_i[0], differ = _differs$_i[1];
        if (units.indexOf(unit) >= 0) {
          var _cursor$plus;
          lowestOrder = unit;
          var delta = differ(cursor, later);
          highWater = cursor.plus((_cursor$plus = {}, _cursor$plus[unit] = delta, _cursor$plus));
          if (highWater > later) {
            var _cursor$plus2;
            cursor = cursor.plus((_cursor$plus2 = {}, _cursor$plus2[unit] = delta - 1, _cursor$plus2));
            delta -= 1;
          } else {
            cursor = highWater;
          }
          results[unit] = delta;
        }
      }
      return [cursor, results, highWater, lowestOrder];
    }
    function _diff(earlier, later, units, opts) {
      var _highOrderDiffs = highOrderDiffs(earlier, later, units), cursor = _highOrderDiffs[0], results = _highOrderDiffs[1], highWater = _highOrderDiffs[2], lowestOrder = _highOrderDiffs[3];
      var remainingMillis = later - cursor;
      var lowerOrderUnits = units.filter(function(u) {
        return ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0;
      });
      if (lowerOrderUnits.length === 0) {
        if (highWater < later) {
          var _cursor$plus3;
          highWater = cursor.plus((_cursor$plus3 = {}, _cursor$plus3[lowestOrder] = 1, _cursor$plus3));
        }
        if (highWater !== cursor) {
          results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
        }
      }
      var duration = Duration.fromObject(results, opts);
      if (lowerOrderUnits.length > 0) {
        var _Duration$fromMillis;
        return (_Duration$fromMillis = Duration.fromMillis(remainingMillis, opts)).shiftTo.apply(_Duration$fromMillis, lowerOrderUnits).plus(duration);
      } else {
        return duration;
      }
    }
    var numberingSystems = {
      arab: "[\u0660-\u0669]",
      arabext: "[\u06F0-\u06F9]",
      bali: "[\u1B50-\u1B59]",
      beng: "[\u09E6-\u09EF]",
      deva: "[\u0966-\u096F]",
      fullwide: "[\uFF10-\uFF19]",
      gujr: "[\u0AE6-\u0AEF]",
      hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
      khmr: "[\u17E0-\u17E9]",
      knda: "[\u0CE6-\u0CEF]",
      laoo: "[\u0ED0-\u0ED9]",
      limb: "[\u1946-\u194F]",
      mlym: "[\u0D66-\u0D6F]",
      mong: "[\u1810-\u1819]",
      mymr: "[\u1040-\u1049]",
      orya: "[\u0B66-\u0B6F]",
      tamldec: "[\u0BE6-\u0BEF]",
      telu: "[\u0C66-\u0C6F]",
      thai: "[\u0E50-\u0E59]",
      tibt: "[\u0F20-\u0F29]",
      latn: "\\d"
    };
    var numberingSystemsUTF16 = {
      arab: [1632, 1641],
      arabext: [1776, 1785],
      bali: [6992, 7001],
      beng: [2534, 2543],
      deva: [2406, 2415],
      fullwide: [65296, 65303],
      gujr: [2790, 2799],
      khmr: [6112, 6121],
      knda: [3302, 3311],
      laoo: [3792, 3801],
      limb: [6470, 6479],
      mlym: [3430, 3439],
      mong: [6160, 6169],
      mymr: [4160, 4169],
      orya: [2918, 2927],
      tamldec: [3046, 3055],
      telu: [3174, 3183],
      thai: [3664, 3673],
      tibt: [3872, 3881]
    };
    var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
    function parseDigits(str) {
      var value = parseInt(str, 10);
      if (isNaN(value)) {
        value = "";
        for (var i = 0; i < str.length; i++) {
          var code = str.charCodeAt(i);
          if (str[i].search(numberingSystems.hanidec) !== -1) {
            value += hanidecChars.indexOf(str[i]);
          } else {
            for (var key in numberingSystemsUTF16) {
              var _numberingSystemsUTF = numberingSystemsUTF16[key], min = _numberingSystemsUTF[0], max = _numberingSystemsUTF[1];
              if (code >= min && code <= max) {
                value += code - min;
              }
            }
          }
        }
        return parseInt(value, 10);
      } else {
        return value;
      }
    }
    function digitRegex(_ref, append2) {
      var numberingSystem = _ref.numberingSystem;
      if (append2 === void 0) {
        append2 = "";
      }
      return new RegExp("" + numberingSystems[numberingSystem || "latn"] + append2);
    }
    var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
    function intUnit(regex, post) {
      if (post === void 0) {
        post = function post2(i) {
          return i;
        };
      }
      return {
        regex,
        deser: function deser(_ref) {
          var s2 = _ref[0];
          return post(parseDigits(s2));
        }
      };
    }
    var NBSP = String.fromCharCode(160);
    var spaceOrNBSP = "( |" + NBSP + ")";
    var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
    function fixListRegex(s2) {
      return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
    }
    function stripInsensitivities(s2) {
      return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
    }
    function oneOf(strings, startIndex) {
      if (strings === null) {
        return null;
      } else {
        return {
          regex: RegExp(strings.map(fixListRegex).join("|")),
          deser: function deser(_ref2) {
            var s2 = _ref2[0];
            return strings.findIndex(function(i) {
              return stripInsensitivities(s2) === stripInsensitivities(i);
            }) + startIndex;
          }
        };
      }
    }
    function offset(regex, groups) {
      return {
        regex,
        deser: function deser(_ref3) {
          var h = _ref3[1], m = _ref3[2];
          return signedOffset(h, m);
        },
        groups
      };
    }
    function simple(regex) {
      return {
        regex,
        deser: function deser(_ref4) {
          var s2 = _ref4[0];
          return s2;
        }
      };
    }
    function escapeToken(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function unitForToken(token, loc) {
      var one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = function literal2(t) {
        return {
          regex: RegExp(escapeToken(t.val)),
          deser: function deser(_ref5) {
            var s2 = _ref5[0];
            return s2;
          },
          literal: true
        };
      }, unitate = function unitate2(t) {
        if (token.literal) {
          return literal(t);
        }
        switch (t.val) {
          case "G":
            return oneOf(loc.eras("short", false), 0);
          case "GG":
            return oneOf(loc.eras("long", false), 0);
          case "y":
            return intUnit(oneToSix);
          case "yy":
            return intUnit(twoToFour, untruncateYear);
          case "yyyy":
            return intUnit(four);
          case "yyyyy":
            return intUnit(fourToSix);
          case "yyyyyy":
            return intUnit(six);
          case "M":
            return intUnit(oneOrTwo);
          case "MM":
            return intUnit(two);
          case "MMM":
            return oneOf(loc.months("short", true, false), 1);
          case "MMMM":
            return oneOf(loc.months("long", true, false), 1);
          case "L":
            return intUnit(oneOrTwo);
          case "LL":
            return intUnit(two);
          case "LLL":
            return oneOf(loc.months("short", false, false), 1);
          case "LLLL":
            return oneOf(loc.months("long", false, false), 1);
          case "d":
            return intUnit(oneOrTwo);
          case "dd":
            return intUnit(two);
          case "o":
            return intUnit(oneToThree);
          case "ooo":
            return intUnit(three);
          case "HH":
            return intUnit(two);
          case "H":
            return intUnit(oneOrTwo);
          case "hh":
            return intUnit(two);
          case "h":
            return intUnit(oneOrTwo);
          case "mm":
            return intUnit(two);
          case "m":
            return intUnit(oneOrTwo);
          case "q":
            return intUnit(oneOrTwo);
          case "qq":
            return intUnit(two);
          case "s":
            return intUnit(oneOrTwo);
          case "ss":
            return intUnit(two);
          case "S":
            return intUnit(oneToThree);
          case "SSS":
            return intUnit(three);
          case "u":
            return simple(oneToNine);
          case "uu":
            return simple(oneOrTwo);
          case "uuu":
            return intUnit(one);
          case "a":
            return oneOf(loc.meridiems(), 0);
          case "kkkk":
            return intUnit(four);
          case "kk":
            return intUnit(twoToFour, untruncateYear);
          case "W":
            return intUnit(oneOrTwo);
          case "WW":
            return intUnit(two);
          case "E":
          case "c":
            return intUnit(one);
          case "EEE":
            return oneOf(loc.weekdays("short", false, false), 1);
          case "EEEE":
            return oneOf(loc.weekdays("long", false, false), 1);
          case "ccc":
            return oneOf(loc.weekdays("short", true, false), 1);
          case "cccc":
            return oneOf(loc.weekdays("long", true, false), 1);
          case "Z":
          case "ZZ":
            return offset(new RegExp("([+-]" + oneOrTwo.source + ")(?::(" + two.source + "))?"), 2);
          case "ZZZ":
            return offset(new RegExp("([+-]" + oneOrTwo.source + ")(" + two.source + ")?"), 2);
          case "z":
            return simple(/[a-z_+-/]{1,256}?/i);
          default:
            return literal(t);
        }
      };
      var unit = unitate(token) || {
        invalidReason: MISSING_FTP
      };
      unit.token = token;
      return unit;
    }
    var partTypeStyleToTokenVal = {
      year: {
        "2-digit": "yy",
        numeric: "yyyyy"
      },
      month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
      },
      day: {
        numeric: "d",
        "2-digit": "dd"
      },
      weekday: {
        short: "EEE",
        long: "EEEE"
      },
      dayperiod: "a",
      dayPeriod: "a",
      hour: {
        numeric: "h",
        "2-digit": "hh"
      },
      minute: {
        numeric: "m",
        "2-digit": "mm"
      },
      second: {
        numeric: "s",
        "2-digit": "ss"
      }
    };
    function tokenForPart(part, locale, formatOpts) {
      var type = part.type, value = part.value;
      if (type === "literal") {
        return {
          literal: true,
          val: value
        };
      }
      var style = formatOpts[type];
      var val = partTypeStyleToTokenVal[type];
      if (typeof val === "object") {
        val = val[style];
      }
      if (val) {
        return {
          literal: false,
          val
        };
      }
      return void 0;
    }
    function buildRegex(units) {
      var re = units.map(function(u) {
        return u.regex;
      }).reduce(function(f, r) {
        return f + "(" + r.source + ")";
      }, "");
      return ["^" + re + "$", units];
    }
    function match(input, regex, handlers) {
      var matches = input.match(regex);
      if (matches) {
        var all = {};
        var matchIndex = 1;
        for (var i in handlers) {
          if (hasOwnProperty(handlers, i)) {
            var h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
            if (!h.literal && h.token) {
              all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
            }
            matchIndex += groups;
          }
        }
        return [matches, all];
      } else {
        return [matches, {}];
      }
    }
    function dateTimeFromMatches(matches) {
      var toField = function toField2(token) {
        switch (token) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
          case "H":
            return "hour";
          case "d":
            return "day";
          case "o":
            return "ordinal";
          case "L":
          case "M":
            return "month";
          case "y":
            return "year";
          case "E":
          case "c":
            return "weekday";
          case "W":
            return "weekNumber";
          case "k":
            return "weekYear";
          case "q":
            return "quarter";
          default:
            return null;
        }
      };
      var zone = null;
      var specificOffset;
      if (!isUndefined(matches.z)) {
        zone = IANAZone.create(matches.z);
      }
      if (!isUndefined(matches.Z)) {
        if (!zone) {
          zone = new FixedOffsetZone(matches.Z);
        }
        specificOffset = matches.Z;
      }
      if (!isUndefined(matches.q)) {
        matches.M = (matches.q - 1) * 3 + 1;
      }
      if (!isUndefined(matches.h)) {
        if (matches.h < 12 && matches.a === 1) {
          matches.h += 12;
        } else if (matches.h === 12 && matches.a === 0) {
          matches.h = 0;
        }
      }
      if (matches.G === 0 && matches.y) {
        matches.y = -matches.y;
      }
      if (!isUndefined(matches.u)) {
        matches.S = parseMillis(matches.u);
      }
      var vals = Object.keys(matches).reduce(function(r, k) {
        var f = toField(k);
        if (f) {
          r[f] = matches[k];
        }
        return r;
      }, {});
      return [vals, zone, specificOffset];
    }
    var dummyDateTimeCache = null;
    function getDummyDateTime() {
      if (!dummyDateTimeCache) {
        dummyDateTimeCache = DateTime4.fromMillis(1555555555555);
      }
      return dummyDateTimeCache;
    }
    function maybeExpandMacroToken(token, locale) {
      if (token.literal) {
        return token;
      }
      var formatOpts = Formatter.macroTokenToFormatOpts(token.val);
      if (!formatOpts) {
        return token;
      }
      var formatter = Formatter.create(locale, formatOpts);
      var parts = formatter.formatDateTimeParts(getDummyDateTime());
      var tokens = parts.map(function(p) {
        return tokenForPart(p, locale, formatOpts);
      });
      if (tokens.includes(void 0)) {
        return token;
      }
      return tokens;
    }
    function expandMacroTokens(tokens, locale) {
      var _Array$prototype;
      return (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, tokens.map(function(t) {
        return maybeExpandMacroToken(t, locale);
      }));
    }
    function explainFromTokens(locale, input, format) {
      var tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map(function(t) {
        return unitForToken(t, locale);
      }), disqualifyingUnit = units.find(function(t) {
        return t.invalidReason;
      });
      if (disqualifyingUnit) {
        return {
          input,
          tokens,
          invalidReason: disqualifyingUnit.invalidReason
        };
      } else {
        var _buildRegex = buildRegex(units), regexString = _buildRegex[0], handlers = _buildRegex[1], regex = RegExp(regexString, "i"), _match = match(input, regex, handlers), rawMatches = _match[0], matches = _match[1], _ref6 = matches ? dateTimeFromMatches(matches) : [null, null, void 0], result = _ref6[0], zone = _ref6[1], specificOffset = _ref6[2];
        if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
          throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
        }
        return {
          input,
          tokens,
          regex,
          rawMatches,
          matches,
          result,
          zone,
          specificOffset
        };
      }
    }
    function parseFromTokens(locale, input, format) {
      var _explainFromTokens = explainFromTokens(locale, input, format), result = _explainFromTokens.result, zone = _explainFromTokens.zone, specificOffset = _explainFromTokens.specificOffset, invalidReason = _explainFromTokens.invalidReason;
      return [result, zone, specificOffset, invalidReason];
    }
    var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    function unitOutOfRange(unit, value) {
      return new Invalid("unit out of range", "you specified " + value + " (of type " + typeof value + ") as a " + unit + ", which is invalid");
    }
    function dayOfWeek(year, month, day) {
      var js = new Date(Date.UTC(year, month - 1, day)).getUTCDay();
      return js === 0 ? 7 : js;
    }
    function computeOrdinal(year, month, day) {
      return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
    }
    function uncomputeOrdinal(year, ordinal) {
      var table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex(function(i) {
        return i < ordinal;
      }), day = ordinal - table[month0];
      return {
        month: month0 + 1,
        day
      };
    }
    function gregorianToWeek(gregObj) {
      var year = gregObj.year, month = gregObj.month, day = gregObj.day, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
      var weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
      if (weekNumber < 1) {
        weekYear = year - 1;
        weekNumber = weeksInWeekYear(weekYear);
      } else if (weekNumber > weeksInWeekYear(year)) {
        weekYear = year + 1;
        weekNumber = 1;
      } else {
        weekYear = year;
      }
      return _extends({
        weekYear,
        weekNumber,
        weekday
      }, timeObject(gregObj));
    }
    function weekToGregorian(weekData) {
      var weekYear = weekData.weekYear, weekNumber = weekData.weekNumber, weekday = weekData.weekday, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
      var ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
      if (ordinal < 1) {
        year = weekYear - 1;
        ordinal += daysInYear(year);
      } else if (ordinal > yearInDays) {
        year = weekYear + 1;
        ordinal -= daysInYear(weekYear);
      } else {
        year = weekYear;
      }
      var _uncomputeOrdinal = uncomputeOrdinal(year, ordinal), month = _uncomputeOrdinal.month, day = _uncomputeOrdinal.day;
      return _extends({
        year,
        month,
        day
      }, timeObject(weekData));
    }
    function gregorianToOrdinal(gregData) {
      var year = gregData.year, month = gregData.month, day = gregData.day;
      var ordinal = computeOrdinal(year, month, day);
      return _extends({
        year,
        ordinal
      }, timeObject(gregData));
    }
    function ordinalToGregorian(ordinalData) {
      var year = ordinalData.year, ordinal = ordinalData.ordinal;
      var _uncomputeOrdinal2 = uncomputeOrdinal(year, ordinal), month = _uncomputeOrdinal2.month, day = _uncomputeOrdinal2.day;
      return _extends({
        year,
        month,
        day
      }, timeObject(ordinalData));
    }
    function hasInvalidWeekData(obj) {
      var validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
      if (!validYear) {
        return unitOutOfRange("weekYear", obj.weekYear);
      } else if (!validWeek) {
        return unitOutOfRange("week", obj.week);
      } else if (!validWeekday) {
        return unitOutOfRange("weekday", obj.weekday);
      } else
        return false;
    }
    function hasInvalidOrdinalData(obj) {
      var validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validOrdinal) {
        return unitOutOfRange("ordinal", obj.ordinal);
      } else
        return false;
    }
    function hasInvalidGregorianData(obj) {
      var validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validMonth) {
        return unitOutOfRange("month", obj.month);
      } else if (!validDay) {
        return unitOutOfRange("day", obj.day);
      } else
        return false;
    }
    function hasInvalidTimeData(obj) {
      var hour = obj.hour, minute = obj.minute, second = obj.second, millisecond = obj.millisecond;
      var validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
      if (!validHour) {
        return unitOutOfRange("hour", hour);
      } else if (!validMinute) {
        return unitOutOfRange("minute", minute);
      } else if (!validSecond) {
        return unitOutOfRange("second", second);
      } else if (!validMillisecond) {
        return unitOutOfRange("millisecond", millisecond);
      } else
        return false;
    }
    var INVALID = "Invalid DateTime";
    var MAX_DATE = 864e13;
    function unsupportedZone(zone) {
      return new Invalid("unsupported zone", 'the zone "' + zone.name + '" is not supported');
    }
    function possiblyCachedWeekData(dt) {
      if (dt.weekData === null) {
        dt.weekData = gregorianToWeek(dt.c);
      }
      return dt.weekData;
    }
    function clone2(inst, alts) {
      var current = {
        ts: inst.ts,
        zone: inst.zone,
        c: inst.c,
        o: inst.o,
        loc: inst.loc,
        invalid: inst.invalid
      };
      return new DateTime4(_extends({}, current, alts, {
        old: current
      }));
    }
    function fixOffset(localTS, o, tz) {
      var utcGuess = localTS - o * 60 * 1e3;
      var o2 = tz.offset(utcGuess);
      if (o === o2) {
        return [utcGuess, o];
      }
      utcGuess -= (o2 - o) * 60 * 1e3;
      var o3 = tz.offset(utcGuess);
      if (o2 === o3) {
        return [utcGuess, o2];
      }
      return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
    }
    function tsToObj(ts, offset2) {
      ts += offset2 * 60 * 1e3;
      var d = new Date(ts);
      return {
        year: d.getUTCFullYear(),
        month: d.getUTCMonth() + 1,
        day: d.getUTCDate(),
        hour: d.getUTCHours(),
        minute: d.getUTCMinutes(),
        second: d.getUTCSeconds(),
        millisecond: d.getUTCMilliseconds()
      };
    }
    function objToTS(obj, offset2, zone) {
      return fixOffset(objToLocalTS(obj), offset2, zone);
    }
    function adjustTime(inst, dur) {
      var oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = _extends({}, inst.c, {
        year,
        month,
        day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
      }), millisToAdd = Duration.fromObject({
        years: dur.years - Math.trunc(dur.years),
        quarters: dur.quarters - Math.trunc(dur.quarters),
        months: dur.months - Math.trunc(dur.months),
        weeks: dur.weeks - Math.trunc(dur.weeks),
        days: dur.days - Math.trunc(dur.days),
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds
      }).as("milliseconds"), localTS = objToLocalTS(c);
      var _fixOffset = fixOffset(localTS, oPre, inst.zone), ts = _fixOffset[0], o = _fixOffset[1];
      if (millisToAdd !== 0) {
        ts += millisToAdd;
        o = inst.zone.offset(ts);
      }
      return {
        ts,
        o
      };
    }
    function parseDataToDateTime(parsed, parsedZone, opts, format, text2, specificOffset) {
      var setZone = opts.setZone, zone = opts.zone;
      if (parsed && Object.keys(parsed).length !== 0) {
        var interpretationZone = parsedZone || zone, inst = DateTime4.fromObject(parsed, _extends({}, opts, {
          zone: interpretationZone,
          specificOffset
        }));
        return setZone ? inst : inst.setZone(zone);
      } else {
        return DateTime4.invalid(new Invalid("unparsable", 'the input "' + text2 + `" can't be parsed as ` + format));
      }
    }
    function toTechFormat(dt, format, allowZ) {
      if (allowZ === void 0) {
        allowZ = true;
      }
      return dt.isValid ? Formatter.create(Locale.create("en-US"), {
        allowZ,
        forceSimple: true
      }).formatDateTimeFromString(dt, format) : null;
    }
    function _toISODate(o, extended) {
      var longFormat = o.c.year > 9999 || o.c.year < 0;
      var c = "";
      if (longFormat && o.c.year >= 0)
        c += "+";
      c += padStart(o.c.year, longFormat ? 6 : 4);
      if (extended) {
        c += "-";
        c += padStart(o.c.month);
        c += "-";
        c += padStart(o.c.day);
      } else {
        c += padStart(o.c.month);
        c += padStart(o.c.day);
      }
      return c;
    }
    function _toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset) {
      var c = padStart(o.c.hour);
      if (extended) {
        c += ":";
        c += padStart(o.c.minute);
        if (o.c.second !== 0 || !suppressSeconds) {
          c += ":";
        }
      } else {
        c += padStart(o.c.minute);
      }
      if (o.c.second !== 0 || !suppressSeconds) {
        c += padStart(o.c.second);
        if (o.c.millisecond !== 0 || !suppressMilliseconds) {
          c += ".";
          c += padStart(o.c.millisecond, 3);
        }
      }
      if (includeOffset) {
        if (o.isOffsetFixed && o.offset === 0) {
          c += "Z";
        } else if (o.o < 0) {
          c += "-";
          c += padStart(Math.trunc(-o.o / 60));
          c += ":";
          c += padStart(Math.trunc(-o.o % 60));
        } else {
          c += "+";
          c += padStart(Math.trunc(o.o / 60));
          c += ":";
          c += padStart(Math.trunc(o.o % 60));
        }
      }
      return c;
    }
    var defaultUnitValues = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultWeekUnitValues = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultOrdinalUnitValues = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
    var orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"];
    var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
    function normalizeUnit(unit) {
      var normalized = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
      }[unit.toLowerCase()];
      if (!normalized)
        throw new InvalidUnitError(unit);
      return normalized;
    }
    function quickDT(obj, opts) {
      var zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
      var ts, o;
      if (!isUndefined(obj.year)) {
        for (var _iterator = _createForOfIteratorHelperLoose(orderedUnits), _step; !(_step = _iterator()).done; ) {
          var u = _step.value;
          if (isUndefined(obj[u])) {
            obj[u] = defaultUnitValues[u];
          }
        }
        var invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
        if (invalid) {
          return DateTime4.invalid(invalid);
        }
        var offsetProvis = zone.offset(tsNow);
        var _objToTS = objToTS(obj, offsetProvis, zone);
        ts = _objToTS[0];
        o = _objToTS[1];
      } else {
        ts = tsNow;
      }
      return new DateTime4({
        ts,
        zone,
        loc,
        o
      });
    }
    function diffRelative(start, end, opts) {
      var round2 = isUndefined(opts.round) ? true : opts.round, format = function format2(c, unit2) {
        c = roundTo(c, round2 || opts.calendary ? 0 : 2, true);
        var formatter = end.loc.clone(opts).relFormatter(opts);
        return formatter.format(c, unit2);
      }, differ = function differ2(unit2) {
        if (opts.calendary) {
          if (!end.hasSame(start, unit2)) {
            return end.startOf(unit2).diff(start.startOf(unit2), unit2).get(unit2);
          } else
            return 0;
        } else {
          return end.diff(start, unit2).get(unit2);
        }
      };
      if (opts.unit) {
        return format(differ(opts.unit), opts.unit);
      }
      for (var _iterator2 = _createForOfIteratorHelperLoose(opts.units), _step2; !(_step2 = _iterator2()).done; ) {
        var unit = _step2.value;
        var count = differ(unit);
        if (Math.abs(count) >= 1) {
          return format(count, unit);
        }
      }
      return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
    }
    function lastOpts(argList) {
      var opts = {}, args;
      if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
        opts = argList[argList.length - 1];
        args = Array.from(argList).slice(0, argList.length - 1);
      } else {
        args = Array.from(argList);
      }
      return [opts, args];
    }
    var DateTime4 = /* @__PURE__ */ function() {
      function DateTime5(config) {
        var zone = config.zone || Settings.defaultZone;
        var invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
        this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
        var c = null, o = null;
        if (!invalid) {
          var unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
          if (unchanged) {
            var _ref = [config.old.c, config.old.o];
            c = _ref[0];
            o = _ref[1];
          } else {
            var ot = zone.offset(this.ts);
            c = tsToObj(this.ts, ot);
            invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
            c = invalid ? null : c;
            o = invalid ? null : ot;
          }
        }
        this._zone = zone;
        this.loc = config.loc || Locale.create();
        this.invalid = invalid;
        this.weekData = null;
        this.c = c;
        this.o = o;
        this.isLuxonDateTime = true;
      }
      DateTime5.now = function now2() {
        return new DateTime5({});
      };
      DateTime5.local = function local() {
        var _lastOpts = lastOpts(arguments), opts = _lastOpts[0], args = _lastOpts[1], year = args[0], month = args[1], day = args[2], hour = args[3], minute = args[4], second = args[5], millisecond = args[6];
        return quickDT({
          year,
          month,
          day,
          hour,
          minute,
          second,
          millisecond
        }, opts);
      };
      DateTime5.utc = function utc() {
        var _lastOpts2 = lastOpts(arguments), opts = _lastOpts2[0], args = _lastOpts2[1], year = args[0], month = args[1], day = args[2], hour = args[3], minute = args[4], second = args[5], millisecond = args[6];
        opts.zone = FixedOffsetZone.utcInstance;
        return quickDT({
          year,
          month,
          day,
          hour,
          minute,
          second,
          millisecond
        }, opts);
      };
      DateTime5.fromJSDate = function fromJSDate(date, options) {
        if (options === void 0) {
          options = {};
        }
        var ts = isDate(date) ? date.valueOf() : NaN;
        if (Number.isNaN(ts)) {
          return DateTime5.invalid("invalid input");
        }
        var zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime5.invalid(unsupportedZone(zoneToUse));
        }
        return new DateTime5({
          ts,
          zone: zoneToUse,
          loc: Locale.fromObject(options)
        });
      };
      DateTime5.fromMillis = function fromMillis(milliseconds, options) {
        if (options === void 0) {
          options = {};
        }
        if (!isNumber2(milliseconds)) {
          throw new InvalidArgumentError("fromMillis requires a numerical input, but received a " + typeof milliseconds + " with value " + milliseconds);
        } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
          return DateTime5.invalid("Timestamp out of range");
        } else {
          return new DateTime5({
            ts: milliseconds,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      };
      DateTime5.fromSeconds = function fromSeconds(seconds, options) {
        if (options === void 0) {
          options = {};
        }
        if (!isNumber2(seconds)) {
          throw new InvalidArgumentError("fromSeconds requires a numerical input");
        } else {
          return new DateTime5({
            ts: seconds * 1e3,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      };
      DateTime5.fromObject = function fromObject2(obj, opts) {
        if (opts === void 0) {
          opts = {};
        }
        obj = obj || {};
        var zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime5.invalid(unsupportedZone(zoneToUse));
        }
        var tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        var useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
        var units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
        if (useWeekData) {
          units = orderedWeekUnits;
          defaultValues = defaultWeekUnitValues;
          objNow = gregorianToWeek(objNow);
        } else if (containsOrdinal) {
          units = orderedOrdinalUnits;
          defaultValues = defaultOrdinalUnitValues;
          objNow = gregorianToOrdinal(objNow);
        } else {
          units = orderedUnits;
          defaultValues = defaultUnitValues;
        }
        var foundFirst = false;
        for (var _iterator3 = _createForOfIteratorHelperLoose(units), _step3; !(_step3 = _iterator3()).done; ) {
          var u = _step3.value;
          var v = normalized[u];
          if (!isUndefined(v)) {
            foundFirst = true;
          } else if (foundFirst) {
            normalized[u] = defaultValues[u];
          } else {
            normalized[u] = objNow[u];
          }
        }
        var higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
        if (invalid) {
          return DateTime5.invalid(invalid);
        }
        var gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, _objToTS2 = objToTS(gregorian, offsetProvis, zoneToUse), tsFinal = _objToTS2[0], offsetFinal = _objToTS2[1], inst = new DateTime5({
          ts: tsFinal,
          zone: zoneToUse,
          o: offsetFinal,
          loc
        });
        if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
          return DateTime5.invalid("mismatched weekday", "you can't specify both a weekday of " + normalized.weekday + " and a date of " + inst.toISO());
        }
        return inst;
      };
      DateTime5.fromISO = function fromISO(text2, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _parseISODate = parseISODate(text2), vals = _parseISODate[0], parsedZone = _parseISODate[1];
        return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text2);
      };
      DateTime5.fromRFC2822 = function fromRFC2822(text2, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _parseRFC2822Date = parseRFC2822Date(text2), vals = _parseRFC2822Date[0], parsedZone = _parseRFC2822Date[1];
        return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text2);
      };
      DateTime5.fromHTTP = function fromHTTP(text2, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _parseHTTPDate = parseHTTPDate(text2), vals = _parseHTTPDate[0], parsedZone = _parseHTTPDate[1];
        return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
      };
      DateTime5.fromFormat = function fromFormat(text2, fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (isUndefined(text2) || isUndefined(fmt)) {
          throw new InvalidArgumentError("fromFormat requires an input string and a format");
        }
        var _opts = opts, _opts$locale = _opts.locale, locale = _opts$locale === void 0 ? null : _opts$locale, _opts$numberingSystem = _opts.numberingSystem, numberingSystem = _opts$numberingSystem === void 0 ? null : _opts$numberingSystem, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        }), _parseFromTokens = parseFromTokens(localeToUse, text2, fmt), vals = _parseFromTokens[0], parsedZone = _parseFromTokens[1], specificOffset = _parseFromTokens[2], invalid = _parseFromTokens[3];
        if (invalid) {
          return DateTime5.invalid(invalid);
        } else {
          return parseDataToDateTime(vals, parsedZone, opts, "format " + fmt, text2, specificOffset);
        }
      };
      DateTime5.fromString = function fromString(text2, fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        return DateTime5.fromFormat(text2, fmt, opts);
      };
      DateTime5.fromSQL = function fromSQL(text2, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _parseSQL = parseSQL(text2), vals = _parseSQL[0], parsedZone = _parseSQL[1];
        return parseDataToDateTime(vals, parsedZone, opts, "SQL", text2);
      };
      DateTime5.invalid = function invalid(reason, explanation) {
        if (explanation === void 0) {
          explanation = null;
        }
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
        }
        var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDateTimeError(invalid2);
        } else {
          return new DateTime5({
            invalid: invalid2
          });
        }
      };
      DateTime5.isDateTime = function isDateTime(o) {
        return o && o.isLuxonDateTime || false;
      };
      var _proto = DateTime5.prototype;
      _proto.get = function get(unit) {
        return this[unit];
      };
      _proto.resolvedLocaleOptions = function resolvedLocaleOptions(opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _Formatter$create$res = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this), locale = _Formatter$create$res.locale, numberingSystem = _Formatter$create$res.numberingSystem, calendar = _Formatter$create$res.calendar;
        return {
          locale,
          numberingSystem,
          outputCalendar: calendar
        };
      };
      _proto.toUTC = function toUTC(offset2, opts) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        if (opts === void 0) {
          opts = {};
        }
        return this.setZone(FixedOffsetZone.instance(offset2), opts);
      };
      _proto.toLocal = function toLocal() {
        return this.setZone(Settings.defaultZone);
      };
      _proto.setZone = function setZone(zone, _temp) {
        var _ref2 = _temp === void 0 ? {} : _temp, _ref2$keepLocalTime = _ref2.keepLocalTime, keepLocalTime = _ref2$keepLocalTime === void 0 ? false : _ref2$keepLocalTime, _ref2$keepCalendarTim = _ref2.keepCalendarTime, keepCalendarTime = _ref2$keepCalendarTim === void 0 ? false : _ref2$keepCalendarTim;
        zone = normalizeZone(zone, Settings.defaultZone);
        if (zone.equals(this.zone)) {
          return this;
        } else if (!zone.isValid) {
          return DateTime5.invalid(unsupportedZone(zone));
        } else {
          var newTS = this.ts;
          if (keepLocalTime || keepCalendarTime) {
            var offsetGuess = zone.offset(this.ts);
            var asObj = this.toObject();
            var _objToTS3 = objToTS(asObj, offsetGuess, zone);
            newTS = _objToTS3[0];
          }
          return clone2(this, {
            ts: newTS,
            zone
          });
        }
      };
      _proto.reconfigure = function reconfigure(_temp2) {
        var _ref3 = _temp2 === void 0 ? {} : _temp2, locale = _ref3.locale, numberingSystem = _ref3.numberingSystem, outputCalendar = _ref3.outputCalendar;
        var loc = this.loc.clone({
          locale,
          numberingSystem,
          outputCalendar
        });
        return clone2(this, {
          loc
        });
      };
      _proto.setLocale = function setLocale(locale) {
        return this.reconfigure({
          locale
        });
      };
      _proto.set = function set2(values) {
        if (!this.isValid)
          return this;
        var normalized = normalizeObject(values, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        var mixed;
        if (settingWeekStuff) {
          mixed = weekToGregorian(_extends({}, gregorianToWeek(this.c), normalized));
        } else if (!isUndefined(normalized.ordinal)) {
          mixed = ordinalToGregorian(_extends({}, gregorianToOrdinal(this.c), normalized));
        } else {
          mixed = _extends({}, this.toObject(), normalized);
          if (isUndefined(normalized.day)) {
            mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
          }
        }
        var _objToTS4 = objToTS(mixed, this.o, this.zone), ts = _objToTS4[0], o = _objToTS4[1];
        return clone2(this, {
          ts,
          o
        });
      };
      _proto.plus = function plus(duration) {
        if (!this.isValid)
          return this;
        var dur = Duration.fromDurationLike(duration);
        return clone2(this, adjustTime(this, dur));
      };
      _proto.minus = function minus(duration) {
        if (!this.isValid)
          return this;
        var dur = Duration.fromDurationLike(duration).negate();
        return clone2(this, adjustTime(this, dur));
      };
      _proto.startOf = function startOf(unit) {
        if (!this.isValid)
          return this;
        var o = {}, normalizedUnit = Duration.normalizeUnit(unit);
        switch (normalizedUnit) {
          case "years":
            o.month = 1;
          case "quarters":
          case "months":
            o.day = 1;
          case "weeks":
          case "days":
            o.hour = 0;
          case "hours":
            o.minute = 0;
          case "minutes":
            o.second = 0;
          case "seconds":
            o.millisecond = 0;
            break;
        }
        if (normalizedUnit === "weeks") {
          o.weekday = 1;
        }
        if (normalizedUnit === "quarters") {
          var q = Math.ceil(this.month / 3);
          o.month = (q - 1) * 3 + 1;
        }
        return this.set(o);
      };
      _proto.endOf = function endOf(unit) {
        var _this$plus;
        return this.isValid ? this.plus((_this$plus = {}, _this$plus[unit] = 1, _this$plus)).startOf(unit).minus(1) : this;
      };
      _proto.toFormat = function toFormat(fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
      };
      _proto.toLocaleString = function toLocaleString(formatOpts, opts) {
        if (formatOpts === void 0) {
          formatOpts = DATE_SHORT;
        }
        if (opts === void 0) {
          opts = {};
        }
        return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
      };
      _proto.toLocaleParts = function toLocaleParts(opts) {
        if (opts === void 0) {
          opts = {};
        }
        return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
      };
      _proto.toISO = function toISO(_temp3) {
        var _ref4 = _temp3 === void 0 ? {} : _temp3, _ref4$format = _ref4.format, format = _ref4$format === void 0 ? "extended" : _ref4$format, _ref4$suppressSeconds = _ref4.suppressSeconds, suppressSeconds = _ref4$suppressSeconds === void 0 ? false : _ref4$suppressSeconds, _ref4$suppressMillise = _ref4.suppressMilliseconds, suppressMilliseconds = _ref4$suppressMillise === void 0 ? false : _ref4$suppressMillise, _ref4$includeOffset = _ref4.includeOffset, includeOffset = _ref4$includeOffset === void 0 ? true : _ref4$includeOffset;
        if (!this.isValid) {
          return null;
        }
        var ext = format === "extended";
        var c = _toISODate(this, ext);
        c += "T";
        c += _toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset);
        return c;
      };
      _proto.toISODate = function toISODate(_temp4) {
        var _ref5 = _temp4 === void 0 ? {} : _temp4, _ref5$format = _ref5.format, format = _ref5$format === void 0 ? "extended" : _ref5$format;
        if (!this.isValid) {
          return null;
        }
        return _toISODate(this, format === "extended");
      };
      _proto.toISOWeekDate = function toISOWeekDate() {
        return toTechFormat(this, "kkkk-'W'WW-c");
      };
      _proto.toISOTime = function toISOTime(_temp5) {
        var _ref6 = _temp5 === void 0 ? {} : _temp5, _ref6$suppressMillise = _ref6.suppressMilliseconds, suppressMilliseconds = _ref6$suppressMillise === void 0 ? false : _ref6$suppressMillise, _ref6$suppressSeconds = _ref6.suppressSeconds, suppressSeconds = _ref6$suppressSeconds === void 0 ? false : _ref6$suppressSeconds, _ref6$includeOffset = _ref6.includeOffset, includeOffset = _ref6$includeOffset === void 0 ? true : _ref6$includeOffset, _ref6$includePrefix = _ref6.includePrefix, includePrefix = _ref6$includePrefix === void 0 ? false : _ref6$includePrefix, _ref6$format = _ref6.format, format = _ref6$format === void 0 ? "extended" : _ref6$format;
        if (!this.isValid) {
          return null;
        }
        var c = includePrefix ? "T" : "";
        return c + _toISOTime(this, format === "extended", suppressSeconds, suppressMilliseconds, includeOffset);
      };
      _proto.toRFC2822 = function toRFC2822() {
        return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
      };
      _proto.toHTTP = function toHTTP() {
        return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
      };
      _proto.toSQLDate = function toSQLDate() {
        if (!this.isValid) {
          return null;
        }
        return _toISODate(this, true);
      };
      _proto.toSQLTime = function toSQLTime(_temp6) {
        var _ref7 = _temp6 === void 0 ? {} : _temp6, _ref7$includeOffset = _ref7.includeOffset, includeOffset = _ref7$includeOffset === void 0 ? true : _ref7$includeOffset, _ref7$includeZone = _ref7.includeZone, includeZone = _ref7$includeZone === void 0 ? false : _ref7$includeZone;
        var fmt = "HH:mm:ss.SSS";
        if (includeZone || includeOffset) {
          fmt += " ";
          if (includeZone) {
            fmt += "z";
          } else if (includeOffset) {
            fmt += "ZZ";
          }
        }
        return toTechFormat(this, fmt, true);
      };
      _proto.toSQL = function toSQL(opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid) {
          return null;
        }
        return this.toSQLDate() + " " + this.toSQLTime(opts);
      };
      _proto.toString = function toString() {
        return this.isValid ? this.toISO() : INVALID;
      };
      _proto.valueOf = function valueOf() {
        return this.toMillis();
      };
      _proto.toMillis = function toMillis() {
        return this.isValid ? this.ts : NaN;
      };
      _proto.toSeconds = function toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN;
      };
      _proto.toJSON = function toJSON() {
        return this.toISO();
      };
      _proto.toBSON = function toBSON() {
        return this.toJSDate();
      };
      _proto.toObject = function toObject(opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid)
          return {};
        var base = _extends({}, this.c);
        if (opts.includeConfig) {
          base.outputCalendar = this.outputCalendar;
          base.numberingSystem = this.loc.numberingSystem;
          base.locale = this.loc.locale;
        }
        return base;
      };
      _proto.toJSDate = function toJSDate() {
        return new Date(this.isValid ? this.ts : NaN);
      };
      _proto.diff = function diff(otherDateTime, unit, opts) {
        if (unit === void 0) {
          unit = "milliseconds";
        }
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid || !otherDateTime.isValid) {
          return Duration.invalid("created by diffing an invalid DateTime");
        }
        var durOpts = _extends({
          locale: this.locale,
          numberingSystem: this.numberingSystem
        }, opts);
        var units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = _diff(earlier, later, units, durOpts);
        return otherIsLater ? diffed.negate() : diffed;
      };
      _proto.diffNow = function diffNow(unit, opts) {
        if (unit === void 0) {
          unit = "milliseconds";
        }
        if (opts === void 0) {
          opts = {};
        }
        return this.diff(DateTime5.now(), unit, opts);
      };
      _proto.until = function until(otherDateTime) {
        return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
      };
      _proto.hasSame = function hasSame(otherDateTime, unit) {
        if (!this.isValid)
          return false;
        var inputMs = otherDateTime.valueOf();
        var adjustedToZone = this.setZone(otherDateTime.zone, {
          keepLocalTime: true
        });
        return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
      };
      _proto.equals = function equals(other) {
        return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
      };
      _proto.toRelative = function toRelative(options) {
        if (options === void 0) {
          options = {};
        }
        if (!this.isValid)
          return null;
        var base = options.base || DateTime5.fromObject({}, {
          zone: this.zone
        }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
        var units = ["years", "months", "days", "hours", "minutes", "seconds"];
        var unit = options.unit;
        if (Array.isArray(options.unit)) {
          units = options.unit;
          unit = void 0;
        }
        return diffRelative(base, this.plus(padding), _extends({}, options, {
          numeric: "always",
          units,
          unit
        }));
      };
      _proto.toRelativeCalendar = function toRelativeCalendar(options) {
        if (options === void 0) {
          options = {};
        }
        if (!this.isValid)
          return null;
        return diffRelative(options.base || DateTime5.fromObject({}, {
          zone: this.zone
        }), this, _extends({}, options, {
          numeric: "auto",
          units: ["years", "months", "days"],
          calendary: true
        }));
      };
      DateTime5.min = function min() {
        for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
          dateTimes[_key] = arguments[_key];
        }
        if (!dateTimes.every(DateTime5.isDateTime)) {
          throw new InvalidArgumentError("min requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, function(i) {
          return i.valueOf();
        }, Math.min);
      };
      DateTime5.max = function max() {
        for (var _len2 = arguments.length, dateTimes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          dateTimes[_key2] = arguments[_key2];
        }
        if (!dateTimes.every(DateTime5.isDateTime)) {
          throw new InvalidArgumentError("max requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, function(i) {
          return i.valueOf();
        }, Math.max);
      };
      DateTime5.fromFormatExplain = function fromFormatExplain(text2, fmt, options) {
        if (options === void 0) {
          options = {};
        }
        var _options = options, _options$locale = _options.locale, locale = _options$locale === void 0 ? null : _options$locale, _options$numberingSys = _options.numberingSystem, numberingSystem = _options$numberingSys === void 0 ? null : _options$numberingSys, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        });
        return explainFromTokens(localeToUse, text2, fmt);
      };
      DateTime5.fromStringExplain = function fromStringExplain(text2, fmt, options) {
        if (options === void 0) {
          options = {};
        }
        return DateTime5.fromFormatExplain(text2, fmt, options);
      };
      _createClass(DateTime5, [{
        key: "isValid",
        get: function get() {
          return this.invalid === null;
        }
      }, {
        key: "invalidReason",
        get: function get() {
          return this.invalid ? this.invalid.reason : null;
        }
      }, {
        key: "invalidExplanation",
        get: function get() {
          return this.invalid ? this.invalid.explanation : null;
        }
      }, {
        key: "locale",
        get: function get() {
          return this.isValid ? this.loc.locale : null;
        }
      }, {
        key: "numberingSystem",
        get: function get() {
          return this.isValid ? this.loc.numberingSystem : null;
        }
      }, {
        key: "outputCalendar",
        get: function get() {
          return this.isValid ? this.loc.outputCalendar : null;
        }
      }, {
        key: "zone",
        get: function get() {
          return this._zone;
        }
      }, {
        key: "zoneName",
        get: function get() {
          return this.isValid ? this.zone.name : null;
        }
      }, {
        key: "year",
        get: function get() {
          return this.isValid ? this.c.year : NaN;
        }
      }, {
        key: "quarter",
        get: function get() {
          return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
        }
      }, {
        key: "month",
        get: function get() {
          return this.isValid ? this.c.month : NaN;
        }
      }, {
        key: "day",
        get: function get() {
          return this.isValid ? this.c.day : NaN;
        }
      }, {
        key: "hour",
        get: function get() {
          return this.isValid ? this.c.hour : NaN;
        }
      }, {
        key: "minute",
        get: function get() {
          return this.isValid ? this.c.minute : NaN;
        }
      }, {
        key: "second",
        get: function get() {
          return this.isValid ? this.c.second : NaN;
        }
      }, {
        key: "millisecond",
        get: function get() {
          return this.isValid ? this.c.millisecond : NaN;
        }
      }, {
        key: "weekYear",
        get: function get() {
          return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
        }
      }, {
        key: "weekNumber",
        get: function get() {
          return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
        }
      }, {
        key: "weekday",
        get: function get() {
          return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
        }
      }, {
        key: "ordinal",
        get: function get() {
          return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
        }
      }, {
        key: "monthShort",
        get: function get() {
          return this.isValid ? Info.months("short", {
            locObj: this.loc
          })[this.month - 1] : null;
        }
      }, {
        key: "monthLong",
        get: function get() {
          return this.isValid ? Info.months("long", {
            locObj: this.loc
          })[this.month - 1] : null;
        }
      }, {
        key: "weekdayShort",
        get: function get() {
          return this.isValid ? Info.weekdays("short", {
            locObj: this.loc
          })[this.weekday - 1] : null;
        }
      }, {
        key: "weekdayLong",
        get: function get() {
          return this.isValid ? Info.weekdays("long", {
            locObj: this.loc
          })[this.weekday - 1] : null;
        }
      }, {
        key: "offset",
        get: function get() {
          return this.isValid ? +this.o : NaN;
        }
      }, {
        key: "offsetNameShort",
        get: function get() {
          if (this.isValid) {
            return this.zone.offsetName(this.ts, {
              format: "short",
              locale: this.locale
            });
          } else {
            return null;
          }
        }
      }, {
        key: "offsetNameLong",
        get: function get() {
          if (this.isValid) {
            return this.zone.offsetName(this.ts, {
              format: "long",
              locale: this.locale
            });
          } else {
            return null;
          }
        }
      }, {
        key: "isOffsetFixed",
        get: function get() {
          return this.isValid ? this.zone.isUniversal : null;
        }
      }, {
        key: "isInDST",
        get: function get() {
          if (this.isOffsetFixed) {
            return false;
          } else {
            return this.offset > this.set({
              month: 1
            }).offset || this.offset > this.set({
              month: 5
            }).offset;
          }
        }
      }, {
        key: "isInLeapYear",
        get: function get() {
          return isLeapYear(this.year);
        }
      }, {
        key: "daysInMonth",
        get: function get() {
          return daysInMonth(this.year, this.month);
        }
      }, {
        key: "daysInYear",
        get: function get() {
          return this.isValid ? daysInYear(this.year) : NaN;
        }
      }, {
        key: "weeksInWeekYear",
        get: function get() {
          return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
        }
      }], [{
        key: "DATE_SHORT",
        get: function get() {
          return DATE_SHORT;
        }
      }, {
        key: "DATE_MED",
        get: function get() {
          return DATE_MED;
        }
      }, {
        key: "DATE_MED_WITH_WEEKDAY",
        get: function get() {
          return DATE_MED_WITH_WEEKDAY;
        }
      }, {
        key: "DATE_FULL",
        get: function get() {
          return DATE_FULL;
        }
      }, {
        key: "DATE_HUGE",
        get: function get() {
          return DATE_HUGE;
        }
      }, {
        key: "TIME_SIMPLE",
        get: function get() {
          return TIME_SIMPLE;
        }
      }, {
        key: "TIME_WITH_SECONDS",
        get: function get() {
          return TIME_WITH_SECONDS;
        }
      }, {
        key: "TIME_WITH_SHORT_OFFSET",
        get: function get() {
          return TIME_WITH_SHORT_OFFSET;
        }
      }, {
        key: "TIME_WITH_LONG_OFFSET",
        get: function get() {
          return TIME_WITH_LONG_OFFSET;
        }
      }, {
        key: "TIME_24_SIMPLE",
        get: function get() {
          return TIME_24_SIMPLE;
        }
      }, {
        key: "TIME_24_WITH_SECONDS",
        get: function get() {
          return TIME_24_WITH_SECONDS;
        }
      }, {
        key: "TIME_24_WITH_SHORT_OFFSET",
        get: function get() {
          return TIME_24_WITH_SHORT_OFFSET;
        }
      }, {
        key: "TIME_24_WITH_LONG_OFFSET",
        get: function get() {
          return TIME_24_WITH_LONG_OFFSET;
        }
      }, {
        key: "DATETIME_SHORT",
        get: function get() {
          return DATETIME_SHORT;
        }
      }, {
        key: "DATETIME_SHORT_WITH_SECONDS",
        get: function get() {
          return DATETIME_SHORT_WITH_SECONDS;
        }
      }, {
        key: "DATETIME_MED",
        get: function get() {
          return DATETIME_MED;
        }
      }, {
        key: "DATETIME_MED_WITH_SECONDS",
        get: function get() {
          return DATETIME_MED_WITH_SECONDS;
        }
      }, {
        key: "DATETIME_MED_WITH_WEEKDAY",
        get: function get() {
          return DATETIME_MED_WITH_WEEKDAY;
        }
      }, {
        key: "DATETIME_FULL",
        get: function get() {
          return DATETIME_FULL;
        }
      }, {
        key: "DATETIME_FULL_WITH_SECONDS",
        get: function get() {
          return DATETIME_FULL_WITH_SECONDS;
        }
      }, {
        key: "DATETIME_HUGE",
        get: function get() {
          return DATETIME_HUGE;
        }
      }, {
        key: "DATETIME_HUGE_WITH_SECONDS",
        get: function get() {
          return DATETIME_HUGE_WITH_SECONDS;
        }
      }]);
      return DateTime5;
    }();
    function friendlyDateTime(dateTimeish) {
      if (DateTime4.isDateTime(dateTimeish)) {
        return dateTimeish;
      } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
        return DateTime4.fromJSDate(dateTimeish);
      } else if (dateTimeish && typeof dateTimeish === "object") {
        return DateTime4.fromObject(dateTimeish);
      } else {
        throw new InvalidArgumentError("Unknown datetime argument: " + dateTimeish + ", of type " + typeof dateTimeish);
      }
    }
    var VERSION = "2.3.0";
    exports.DateTime = DateTime4;
    exports.Duration = Duration;
    exports.FixedOffsetZone = FixedOffsetZone;
    exports.IANAZone = IANAZone;
    exports.Info = Info;
    exports.Interval = Interval;
    exports.InvalidZone = InvalidZone;
    exports.Settings = Settings;
    exports.SystemZone = SystemZone;
    exports.VERSION = VERSION;
    exports.Zone = Zone;
  }
});

// node_modules/feather-icons/dist/feather.js
var require_feather = __commonJS({
  "node_modules/feather-icons/dist/feather.js"(exports, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["feather"] = factory();
      else
        root["feather"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module3 = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          module3.l = true;
          return module3.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name, getter) {
          if (!__webpack_require__.o(exports2, name)) {
            Object.defineProperty(exports2, name, {
              configurable: false,
              enumerable: true,
              get: getter
            });
          }
        };
        __webpack_require__.r = function(exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
        __webpack_require__.n = function(module3) {
          var getter = module3 && module3.__esModule ? function getDefault() {
            return module3["default"];
          } : function getModuleExports() {
            return module3;
          };
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 0);
      }({
        "./dist/icons.json": function(module3) {
          module3.exports = { "activity": '<polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>', "airplay": '<path d="M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1"></path><polygon points="12 15 17 21 7 21 12 15"></polygon>', "alert-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>', "alert-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>', "alert-triangle": '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line>', "align-center": '<line x1="18" y1="10" x2="6" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="18" y1="18" x2="6" y2="18"></line>', "align-justify": '<line x1="21" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="3" y2="18"></line>', "align-left": '<line x1="17" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="17" y1="18" x2="3" y2="18"></line>', "align-right": '<line x1="21" y1="10" x2="7" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="7" y2="18"></line>', "anchor": '<circle cx="12" cy="5" r="3"></circle><line x1="12" y1="22" x2="12" y2="8"></line><path d="M5 12H2a10 10 0 0 0 20 0h-3"></path>', "aperture": '<circle cx="12" cy="12" r="10"></circle><line x1="14.31" y1="8" x2="20.05" y2="17.94"></line><line x1="9.69" y1="8" x2="21.17" y2="8"></line><line x1="7.38" y1="12" x2="13.12" y2="2.06"></line><line x1="9.69" y1="16" x2="3.95" y2="6.06"></line><line x1="14.31" y1="16" x2="2.83" y2="16"></line><line x1="16.62" y1="12" x2="10.88" y2="21.94"></line>', "archive": '<polyline points="21 8 21 21 3 21 3 8"></polyline><rect x="1" y="3" width="22" height="5"></rect><line x1="10" y1="12" x2="14" y2="12"></line>', "arrow-down-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="8 12 12 16 16 12"></polyline><line x1="12" y1="8" x2="12" y2="16"></line>', "arrow-down-left": '<line x1="17" y1="7" x2="7" y2="17"></line><polyline points="17 17 7 17 7 7"></polyline>', "arrow-down-right": '<line x1="7" y1="7" x2="17" y2="17"></line><polyline points="17 7 17 17 7 17"></polyline>', "arrow-down": '<line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline>', "arrow-left-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 8 8 12 12 16"></polyline><line x1="16" y1="12" x2="8" y2="12"></line>', "arrow-left": '<line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline>', "arrow-right-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 16 16 12 12 8"></polyline><line x1="8" y1="12" x2="16" y2="12"></line>', "arrow-right": '<line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline>', "arrow-up-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="16 12 12 8 8 12"></polyline><line x1="12" y1="16" x2="12" y2="8"></line>', "arrow-up-left": '<line x1="17" y1="17" x2="7" y2="7"></line><polyline points="7 17 7 7 17 7"></polyline>', "arrow-up-right": '<line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline>', "arrow-up": '<line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline>', "at-sign": '<circle cx="12" cy="12" r="4"></circle><path d="M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94"></path>', "award": '<circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>', "bar-chart-2": '<line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line>', "bar-chart": '<line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line>', "battery-charging": '<path d="M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19"></path><line x1="23" y1="13" x2="23" y2="11"></line><polyline points="11 6 7 12 13 12 9 18"></polyline>', "battery": '<rect x="1" y="6" width="18" height="12" rx="2" ry="2"></rect><line x1="23" y1="13" x2="23" y2="11"></line>', "bell-off": '<path d="M13.73 21a2 2 0 0 1-3.46 0"></path><path d="M18.63 13A17.89 17.89 0 0 1 18 8"></path><path d="M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14"></path><path d="M18 8a6 6 0 0 0-9.33-5"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "bell": '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path>', "bluetooth": '<polyline points="6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5"></polyline>', "bold": '<path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>', "book-open": '<path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>', "book": '<path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>', "bookmark": '<path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>', "box": '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', "briefcase": '<rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path>', "calendar": '<rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>', "camera-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56"></path>', "camera": '<path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle>', "cast": '<path d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"></path><line x1="2" y1="20" x2="2.01" y2="20"></line>', "check-circle": '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>', "check-square": '<polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>', "check": '<polyline points="20 6 9 17 4 12"></polyline>', "chevron-down": '<polyline points="6 9 12 15 18 9"></polyline>', "chevron-left": '<polyline points="15 18 9 12 15 6"></polyline>', "chevron-right": '<polyline points="9 18 15 12 9 6"></polyline>', "chevron-up": '<polyline points="18 15 12 9 6 15"></polyline>', "chevrons-down": '<polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline>', "chevrons-left": '<polyline points="11 17 6 12 11 7"></polyline><polyline points="18 17 13 12 18 7"></polyline>', "chevrons-right": '<polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline>', "chevrons-up": '<polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline>', "chrome": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="21.17" y1="8" x2="12" y2="8"></line><line x1="3.95" y1="6.06" x2="8.54" y2="14"></line><line x1="10.88" y1="21.94" x2="15.46" y2="14"></line>', "circle": '<circle cx="12" cy="12" r="10"></circle>', "clipboard": '<path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>', "clock": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>', "cloud-drizzle": '<line x1="8" y1="19" x2="8" y2="21"></line><line x1="8" y1="13" x2="8" y2="15"></line><line x1="16" y1="19" x2="16" y2="21"></line><line x1="16" y1="13" x2="16" y2="15"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="12" y1="15" x2="12" y2="17"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>', "cloud-lightning": '<path d="M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9"></path><polyline points="13 11 9 17 15 17 11 23"></polyline>', "cloud-off": '<path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "cloud-rain": '<line x1="16" y1="13" x2="16" y2="21"></line><line x1="8" y1="13" x2="8" y2="21"></line><line x1="12" y1="15" x2="12" y2="23"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>', "cloud-snow": '<path d="M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25"></path><line x1="8" y1="16" x2="8.01" y2="16"></line><line x1="8" y1="20" x2="8.01" y2="20"></line><line x1="12" y1="18" x2="12.01" y2="18"></line><line x1="12" y1="22" x2="12.01" y2="22"></line><line x1="16" y1="16" x2="16.01" y2="16"></line><line x1="16" y1="20" x2="16.01" y2="20"></line>', "cloud": '<path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path>', "code": '<polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline>', "codepen": '<polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"></polygon><line x1="12" y1="22" x2="12" y2="15.5"></line><polyline points="22 8.5 12 15.5 2 8.5"></polyline><polyline points="2 15.5 12 8.5 22 15.5"></polyline><line x1="12" y1="2" x2="12" y2="8.5"></line>', "codesandbox": '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', "coffee": '<path d="M18 8h1a4 4 0 0 1 0 8h-1"></path><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path><line x1="6" y1="1" x2="6" y2="4"></line><line x1="10" y1="1" x2="10" y2="4"></line><line x1="14" y1="1" x2="14" y2="4"></line>', "columns": '<path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"></path>', "command": '<path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path>', "compass": '<circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon>', "copy": '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>', "corner-down-left": '<polyline points="9 10 4 15 9 20"></polyline><path d="M20 4v7a4 4 0 0 1-4 4H4"></path>', "corner-down-right": '<polyline points="15 10 20 15 15 20"></polyline><path d="M4 4v7a4 4 0 0 0 4 4h12"></path>', "corner-left-down": '<polyline points="14 15 9 20 4 15"></polyline><path d="M20 4h-7a4 4 0 0 0-4 4v12"></path>', "corner-left-up": '<polyline points="14 9 9 4 4 9"></polyline><path d="M20 20h-7a4 4 0 0 1-4-4V4"></path>', "corner-right-down": '<polyline points="10 15 15 20 20 15"></polyline><path d="M4 4h7a4 4 0 0 1 4 4v12"></path>', "corner-right-up": '<polyline points="10 9 15 4 20 9"></polyline><path d="M4 20h7a4 4 0 0 0 4-4V4"></path>', "corner-up-left": '<polyline points="9 14 4 9 9 4"></polyline><path d="M20 20v-7a4 4 0 0 0-4-4H4"></path>', "corner-up-right": '<polyline points="15 14 20 9 15 4"></polyline><path d="M4 20v-7a4 4 0 0 1 4-4h12"></path>', "cpu": '<rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line>', "credit-card": '<rect x="1" y="4" width="22" height="16" rx="2" ry="2"></rect><line x1="1" y1="10" x2="23" y2="10"></line>', "crop": '<path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"></path><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"></path>', "crosshair": '<circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line>', "database": '<ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>', "delete": '<path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line>', "disc": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle>', "divide-circle": '<line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line><circle cx="12" cy="12" r="10"></circle>', "divide-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line>', "divide": '<circle cx="12" cy="6" r="2"></circle><line x1="5" y1="12" x2="19" y2="12"></line><circle cx="12" cy="18" r="2"></circle>', "dollar-sign": '<line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>', "download-cloud": '<polyline points="8 17 12 21 16 17"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"></path>', "download": '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line>', "dribbble": '<circle cx="12" cy="12" r="10"></circle><path d="M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32"></path>', "droplet": '<path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>', "edit-2": '<path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>', "edit-3": '<path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>', "edit": '<path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>', "external-link": '<path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line>', "eye-off": '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "eye": '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle>', "facebook": '<path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>', "fast-forward": '<polygon points="13 19 22 12 13 5 13 19"></polygon><polygon points="2 19 11 12 2 5 2 19"></polygon>', "feather": '<path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path><line x1="16" y1="8" x2="2" y2="22"></line><line x1="17.5" y1="15" x2="9" y2="15"></line>', "figma": '<path d="M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z"></path><path d="M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z"></path><path d="M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z"></path><path d="M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z"></path><path d="M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z"></path>', "file-minus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="9" y1="15" x2="15" y2="15"></line>', "file-plus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line>', "file-text": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline>', "file": '<path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>', "film": '<rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect><line x1="7" y1="2" x2="7" y2="22"></line><line x1="17" y1="2" x2="17" y2="22"></line><line x1="2" y1="12" x2="22" y2="12"></line><line x1="2" y1="7" x2="7" y2="7"></line><line x1="2" y1="17" x2="7" y2="17"></line><line x1="17" y1="17" x2="22" y2="17"></line><line x1="17" y1="7" x2="22" y2="7"></line>', "filter": '<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>', "flag": '<path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line>', "folder-minus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="9" y1="14" x2="15" y2="14"></line>', "folder-plus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="12" y1="11" x2="12" y2="17"></line><line x1="9" y1="14" x2="15" y2="14"></line>', "folder": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>', "framer": '<path d="M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7"></path>', "frown": '<circle cx="12" cy="12" r="10"></circle><path d="M16 16s-1.5-2-4-2-4 2-4 2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', "gift": '<polyline points="20 12 20 22 4 22 4 12"></polyline><rect x="2" y="7" width="20" height="5"></rect><line x1="12" y1="22" x2="12" y2="7"></line><path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z"></path><path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z"></path>', "git-branch": '<line x1="6" y1="3" x2="6" y2="15"></line><circle cx="18" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><path d="M18 9a9 9 0 0 1-9 9"></path>', "git-commit": '<circle cx="12" cy="12" r="4"></circle><line x1="1.05" y1="12" x2="7" y2="12"></line><line x1="17.01" y1="12" x2="22.96" y2="12"></line>', "git-merge": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M6 21V9a9 9 0 0 0 9 9"></path>', "git-pull-request": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M13 6h3a2 2 0 0 1 2 2v7"></path><line x1="6" y1="9" x2="6" y2="21"></line>', "github": '<path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>', "gitlab": '<path d="M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z"></path>', "globe": '<circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>', "grid": '<rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect>', "hard-drive": '<line x1="22" y1="12" x2="2" y2="12"></line><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path><line x1="6" y1="16" x2="6.01" y2="16"></line><line x1="10" y1="16" x2="10.01" y2="16"></line>', "hash": '<line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>', "headphones": '<path d="M3 18v-6a9 9 0 0 1 18 0v6"></path><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"></path>', "heart": '<path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>', "help-circle": '<circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line>', "hexagon": '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>', "home": '<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline>', "image": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline>', "inbox": '<polyline points="22 12 16 12 14 15 10 15 8 12 2 12"></polyline><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path>', "info": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line>', "instagram": '<rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>', "italic": '<line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line>', "key": '<path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path>', "layers": '<polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline>', "layout": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line>', "life-buoy": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="4.93" y1="4.93" x2="9.17" y2="9.17"></line><line x1="14.83" y1="14.83" x2="19.07" y2="19.07"></line><line x1="14.83" y1="9.17" x2="19.07" y2="4.93"></line><line x1="14.83" y1="9.17" x2="18.36" y2="5.64"></line><line x1="4.93" y1="19.07" x2="9.17" y2="14.83"></line>', "link-2": '<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line>', "link": '<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>', "linkedin": '<path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>', "list": '<line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line>', "loader": '<line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>', "lock": '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path>', "log-in": '<path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"></path><polyline points="10 17 15 12 10 7"></polyline><line x1="15" y1="12" x2="3" y2="12"></line>', "log-out": '<path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line>', "mail": '<path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>', "map-pin": '<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle>', "map": '<polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line>', "maximize-2": '<polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line>', "maximize": '<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>', "meh": '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', "menu": '<line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>', "message-circle": '<path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>', "message-square": '<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>', "mic-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>', "mic": '<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>', "minimize-2": '<polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline><line x1="14" y1="10" x2="21" y2="3"></line><line x1="3" y1="21" x2="10" y2="14"></line>', "minimize": '<path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>', "minus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="12" x2="16" y2="12"></line>', "minus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line>', "minus": '<line x1="5" y1="12" x2="19" y2="12"></line>', "monitor": '<rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line>', "moon": '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>', "more-horizontal": '<circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle>', "more-vertical": '<circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle>', "mouse-pointer": '<path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path><path d="M13 13l6 6"></path>', "move": '<polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 9 22 12 19 15"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line>', "music": '<path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle>', "navigation-2": '<polygon points="12 2 19 21 12 17 5 21 12 2"></polygon>', "navigation": '<polygon points="3 11 22 2 13 21 11 13 3 11"></polygon>', "octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon>', "package": '<line x1="16.5" y1="9.4" x2="7.5" y2="4.21"></line><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', "paperclip": '<path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>', "pause-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="10" y1="15" x2="10" y2="9"></line><line x1="14" y1="15" x2="14" y2="9"></line>', "pause": '<rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect>', "pen-tool": '<path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle>', "percent": '<line x1="19" y1="5" x2="5" y2="19"></line><circle cx="6.5" cy="6.5" r="2.5"></circle><circle cx="17.5" cy="17.5" r="2.5"></circle>', "phone-call": '<path d="M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-forwarded": '<polyline points="19 1 23 5 19 9"></polyline><line x1="15" y1="5" x2="23" y2="5"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-incoming": '<polyline points="16 2 16 8 22 8"></polyline><line x1="23" y1="1" x2="16" y2="8"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-missed": '<line x1="23" y1="1" x2="17" y2="7"></line><line x1="17" y1="1" x2="23" y2="7"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-off": '<path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"></path><line x1="23" y1="1" x2="1" y2="23"></line>', "phone-outgoing": '<polyline points="23 7 23 1 17 1"></polyline><line x1="16" y1="8" x2="23" y2="1"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone": '<path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "pie-chart": '<path d="M21.21 15.89A10 10 0 1 1 8 2.83"></path><path d="M22 12A10 10 0 0 0 12 2v10z"></path>', "play-circle": '<circle cx="12" cy="12" r="10"></circle><polygon points="10 8 16 12 10 16 10 8"></polygon>', "play": '<polygon points="5 3 19 12 5 21 5 3"></polygon>', "plus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>', "plus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>', "plus": '<line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line>', "pocket": '<path d="M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z"></path><polyline points="8 10 12 14 16 10"></polyline>', "power": '<path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line>', "printer": '<polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect>', "radio": '<circle cx="12" cy="12" r="2"></circle><path d="M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14"></path>', "refresh-ccw": '<polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>', "refresh-cw": '<polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>', "repeat": '<polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path>', "rewind": '<polygon points="11 19 2 12 11 5 11 19"></polygon><polygon points="22 19 13 12 22 5 22 19"></polygon>', "rotate-ccw": '<polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>', "rotate-cw": '<polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>', "rss": '<path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>', "save": '<path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline>', "scissors": '<circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line>', "search": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>', "send": '<line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>', "server": '<rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line>', "settings": '<circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>', "share-2": '<circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>', "share": '<path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line>', "shield-off": '<path d="M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18"></path><path d="M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "shield": '<path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>', "shopping-bag": '<path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path>', "shopping-cart": '<circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>', "shuffle": '<polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line>', "sidebar": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line>', "skip-back": '<polygon points="19 20 9 12 19 4 19 20"></polygon><line x1="5" y1="19" x2="5" y2="5"></line>', "skip-forward": '<polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line>', "slack": '<path d="M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z"></path><path d="M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path><path d="M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z"></path><path d="M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z"></path><path d="M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z"></path><path d="M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path><path d="M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z"></path><path d="M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z"></path>', "slash": '<circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>', "sliders": '<line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line>', "smartphone": '<rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>', "smile": '<circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', "speaker": '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><circle cx="12" cy="14" r="4"></circle><line x1="12" y1="6" x2="12.01" y2="6"></line>', "square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>', "star": '<polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>', "stop-circle": '<circle cx="12" cy="12" r="10"></circle><rect x="9" y="9" width="6" height="6"></rect>', "sun": '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>', "sunrise": '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="2" x2="12" y2="9"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="8 6 12 2 16 6"></polyline>', "sunset": '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="9" x2="12" y2="2"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="16 5 12 9 8 5"></polyline>', "tablet": '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>', "tag": '<path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>', "target": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle>', "terminal": '<polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line>', "thermometer": '<path d="M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z"></path>', "thumbs-down": '<path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>', "thumbs-up": '<path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>', "toggle-left": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="8" cy="12" r="3"></circle>', "toggle-right": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="16" cy="12" r="3"></circle>', "tool": '<path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path>', "trash-2": '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line>', "trash": '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>', "trello": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><rect x="7" y="7" width="3" height="9"></rect><rect x="14" y="7" width="3" height="5"></rect>', "trending-down": '<polyline points="23 18 13.5 8.5 8.5 13.5 1 6"></polyline><polyline points="17 18 23 18 23 12"></polyline>', "trending-up": '<polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline>', "triangle": '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>', "truck": '<rect x="1" y="3" width="15" height="13"></rect><polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon><circle cx="5.5" cy="18.5" r="2.5"></circle><circle cx="18.5" cy="18.5" r="2.5"></circle>', "tv": '<rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect><polyline points="17 2 12 7 7 2"></polyline>', "twitch": '<path d="M21 2H3v16h5v4l4-4h5l4-4V2zm-10 9V7m5 4V7"></path>', "twitter": '<path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>', "type": '<polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line>', "umbrella": '<path d="M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7"></path>', "underline": '<path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"></path><line x1="4" y1="21" x2="20" y2="21"></line>', "unlock": '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path>', "upload-cloud": '<polyline points="16 16 12 12 8 16"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"></path><polyline points="16 16 12 12 8 16"></polyline>', "upload": '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line>', "user-check": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><polyline points="17 11 19 13 23 9"></polyline>', "user-minus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="23" y1="11" x2="17" y2="11"></line>', "user-plus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="23" y1="11" x2="17" y2="11"></line>', "user-x": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="18" y1="8" x2="23" y2="13"></line><line x1="23" y1="8" x2="18" y2="13"></line>', "user": '<path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle>', "users": '<path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path>', "video-off": '<path d="M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "video": '<polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>', "voicemail": '<circle cx="5.5" cy="11.5" r="4.5"></circle><circle cx="18.5" cy="11.5" r="4.5"></circle><line x1="5.5" y1="16" x2="18.5" y2="16"></line>', "volume-1": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>', "volume-2": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>', "volume-x": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line>', "volume": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>', "watch": '<circle cx="12" cy="12" r="7"></circle><polyline points="12 9 12 12 13.5 13.5"></polyline><path d="M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83"></path>', "wifi-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"></path><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"></path><path d="M10.71 5.05A16 16 0 0 1 22.58 9"></path><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>', "wifi": '<path d="M5 12.55a11 11 0 0 1 14.08 0"></path><path d="M1.42 9a16 16 0 0 1 21.16 0"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>', "wind": '<path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"></path>', "x-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>', "x-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>', "x-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="9" x2="15" y2="15"></line><line x1="15" y1="9" x2="9" y2="15"></line>', "x": '<line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>', "youtube": '<path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"></path><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"></polygon>', "zap-off": '<polyline points="12.41 6.75 13 2 10.57 4.92"></polyline><polyline points="18.57 12.91 21 10 15.66 10"></polyline><polyline points="8 8 3 14 12 14 11 22 16 16"></polyline><line x1="1" y1="1" x2="23" y2="23"></line>', "zap": '<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>', "zoom-in": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line>', "zoom-out": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line>' };
        },
        "./node_modules/classnames/dedupe.js": function(module3, exports2, __webpack_require__) {
          var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
          (function() {
            "use strict";
            var classNames = function() {
              function StorageObject() {
              }
              StorageObject.prototype = Object.create(null);
              function _parseArray(resultSet, array) {
                var length = array.length;
                for (var i = 0; i < length; ++i) {
                  _parse(resultSet, array[i]);
                }
              }
              var hasOwn = {}.hasOwnProperty;
              function _parseNumber(resultSet, num) {
                resultSet[num] = true;
              }
              function _parseObject(resultSet, object) {
                for (var k in object) {
                  if (hasOwn.call(object, k)) {
                    resultSet[k] = !!object[k];
                  }
                }
              }
              var SPACE = /\s+/;
              function _parseString(resultSet, str) {
                var array = str.split(SPACE);
                var length = array.length;
                for (var i = 0; i < length; ++i) {
                  resultSet[array[i]] = true;
                }
              }
              function _parse(resultSet, arg) {
                if (!arg)
                  return;
                var argType = typeof arg;
                if (argType === "string") {
                  _parseString(resultSet, arg);
                } else if (Array.isArray(arg)) {
                  _parseArray(resultSet, arg);
                } else if (argType === "object") {
                  _parseObject(resultSet, arg);
                } else if (argType === "number") {
                  _parseNumber(resultSet, arg);
                }
              }
              function _classNames() {
                var len = arguments.length;
                var args = Array(len);
                for (var i = 0; i < len; i++) {
                  args[i] = arguments[i];
                }
                var classSet = new StorageObject();
                _parseArray(classSet, args);
                var list = [];
                for (var k in classSet) {
                  if (classSet[k]) {
                    list.push(k);
                  }
                }
                return list.join(" ");
              }
              return _classNames;
            }();
            if (typeof module3 !== "undefined" && module3.exports) {
              module3.exports = classNames;
            } else if (true) {
              !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return classNames;
              }.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module3.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else {
            }
          })();
        },
        "./node_modules/core-js/es/array/from.js": function(module3, exports2, __webpack_require__) {
          __webpack_require__("./node_modules/core-js/modules/es.string.iterator.js");
          __webpack_require__("./node_modules/core-js/modules/es.array.from.js");
          var path = __webpack_require__("./node_modules/core-js/internals/path.js");
          module3.exports = path.Array.from;
        },
        "./node_modules/core-js/internals/a-function.js": function(module3, exports2) {
          module3.exports = function(it) {
            if (typeof it != "function") {
              throw TypeError(String(it) + " is not a function");
            }
            return it;
          };
        },
        "./node_modules/core-js/internals/an-object.js": function(module3, exports2, __webpack_require__) {
          var isObject2 = __webpack_require__("./node_modules/core-js/internals/is-object.js");
          module3.exports = function(it) {
            if (!isObject2(it)) {
              throw TypeError(String(it) + " is not an object");
            }
            return it;
          };
        },
        "./node_modules/core-js/internals/array-from.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          var bind2 = __webpack_require__("./node_modules/core-js/internals/bind-context.js");
          var toObject = __webpack_require__("./node_modules/core-js/internals/to-object.js");
          var callWithSafeIterationClosing = __webpack_require__("./node_modules/core-js/internals/call-with-safe-iteration-closing.js");
          var isArrayIteratorMethod = __webpack_require__("./node_modules/core-js/internals/is-array-iterator-method.js");
          var toLength = __webpack_require__("./node_modules/core-js/internals/to-length.js");
          var createProperty = __webpack_require__("./node_modules/core-js/internals/create-property.js");
          var getIteratorMethod = __webpack_require__("./node_modules/core-js/internals/get-iterator-method.js");
          module3.exports = function from(arrayLike) {
            var O = toObject(arrayLike);
            var C = typeof this == "function" ? this : Array;
            var argumentsLength = arguments.length;
            var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
            var mapping = mapfn !== void 0;
            var index = 0;
            var iteratorMethod = getIteratorMethod(O);
            var length, result, step, iterator;
            if (mapping)
              mapfn = bind2(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2);
            if (iteratorMethod != void 0 && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
              iterator = iteratorMethod.call(O);
              result = new C();
              for (; !(step = iterator.next()).done; index++) {
                createProperty(result, index, mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value);
              }
            } else {
              length = toLength(O.length);
              result = new C(length);
              for (; length > index; index++) {
                createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
              }
            }
            result.length = index;
            return result;
          };
        },
        "./node_modules/core-js/internals/array-includes.js": function(module3, exports2, __webpack_require__) {
          var toIndexedObject = __webpack_require__("./node_modules/core-js/internals/to-indexed-object.js");
          var toLength = __webpack_require__("./node_modules/core-js/internals/to-length.js");
          var toAbsoluteIndex = __webpack_require__("./node_modules/core-js/internals/to-absolute-index.js");
          module3.exports = function(IS_INCLUDES) {
            return function($this, el, fromIndex) {
              var O = toIndexedObject($this);
              var length = toLength(O.length);
              var index = toAbsoluteIndex(fromIndex, length);
              var value;
              if (IS_INCLUDES && el != el)
                while (length > index) {
                  value = O[index++];
                  if (value != value)
                    return true;
                }
              else
                for (; length > index; index++)
                  if (IS_INCLUDES || index in O) {
                    if (O[index] === el)
                      return IS_INCLUDES || index || 0;
                  }
              return !IS_INCLUDES && -1;
            };
          };
        },
        "./node_modules/core-js/internals/bind-context.js": function(module3, exports2, __webpack_require__) {
          var aFunction = __webpack_require__("./node_modules/core-js/internals/a-function.js");
          module3.exports = function(fn, that, length) {
            aFunction(fn);
            if (that === void 0)
              return fn;
            switch (length) {
              case 0:
                return function() {
                  return fn.call(that);
                };
              case 1:
                return function(a) {
                  return fn.call(that, a);
                };
              case 2:
                return function(a, b) {
                  return fn.call(that, a, b);
                };
              case 3:
                return function(a, b, c) {
                  return fn.call(that, a, b, c);
                };
            }
            return function() {
              return fn.apply(that, arguments);
            };
          };
        },
        "./node_modules/core-js/internals/call-with-safe-iteration-closing.js": function(module3, exports2, __webpack_require__) {
          var anObject = __webpack_require__("./node_modules/core-js/internals/an-object.js");
          module3.exports = function(iterator, fn, value, ENTRIES) {
            try {
              return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
            } catch (error) {
              var returnMethod = iterator["return"];
              if (returnMethod !== void 0)
                anObject(returnMethod.call(iterator));
              throw error;
            }
          };
        },
        "./node_modules/core-js/internals/check-correctness-of-iteration.js": function(module3, exports2, __webpack_require__) {
          var wellKnownSymbol = __webpack_require__("./node_modules/core-js/internals/well-known-symbol.js");
          var ITERATOR = wellKnownSymbol("iterator");
          var SAFE_CLOSING = false;
          try {
            var called = 0;
            var iteratorWithReturn = {
              next: function() {
                return { done: !!called++ };
              },
              "return": function() {
                SAFE_CLOSING = true;
              }
            };
            iteratorWithReturn[ITERATOR] = function() {
              return this;
            };
            Array.from(iteratorWithReturn, function() {
              throw 2;
            });
          } catch (error) {
          }
          module3.exports = function(exec, SKIP_CLOSING) {
            if (!SKIP_CLOSING && !SAFE_CLOSING)
              return false;
            var ITERATION_SUPPORT = false;
            try {
              var object = {};
              object[ITERATOR] = function() {
                return {
                  next: function() {
                    return { done: ITERATION_SUPPORT = true };
                  }
                };
              };
              exec(object);
            } catch (error) {
            }
            return ITERATION_SUPPORT;
          };
        },
        "./node_modules/core-js/internals/classof-raw.js": function(module3, exports2) {
          var toString = {}.toString;
          module3.exports = function(it) {
            return toString.call(it).slice(8, -1);
          };
        },
        "./node_modules/core-js/internals/classof.js": function(module3, exports2, __webpack_require__) {
          var classofRaw = __webpack_require__("./node_modules/core-js/internals/classof-raw.js");
          var wellKnownSymbol = __webpack_require__("./node_modules/core-js/internals/well-known-symbol.js");
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          var CORRECT_ARGUMENTS = classofRaw(function() {
            return arguments;
          }()) == "Arguments";
          var tryGet = function(it, key) {
            try {
              return it[key];
            } catch (error) {
            }
          };
          module3.exports = function(it) {
            var O, tag, result;
            return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
          };
        },
        "./node_modules/core-js/internals/copy-constructor-properties.js": function(module3, exports2, __webpack_require__) {
          var has = __webpack_require__("./node_modules/core-js/internals/has.js");
          var ownKeys = __webpack_require__("./node_modules/core-js/internals/own-keys.js");
          var getOwnPropertyDescriptorModule = __webpack_require__("./node_modules/core-js/internals/object-get-own-property-descriptor.js");
          var definePropertyModule = __webpack_require__("./node_modules/core-js/internals/object-define-property.js");
          module3.exports = function(target, source) {
            var keys = ownKeys(source);
            var defineProperty = definePropertyModule.f;
            var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (!has(target, key))
                defineProperty(target, key, getOwnPropertyDescriptor(source, key));
            }
          };
        },
        "./node_modules/core-js/internals/correct-prototype-getter.js": function(module3, exports2, __webpack_require__) {
          var fails = __webpack_require__("./node_modules/core-js/internals/fails.js");
          module3.exports = !fails(function() {
            function F() {
            }
            F.prototype.constructor = null;
            return Object.getPrototypeOf(new F()) !== F.prototype;
          });
        },
        "./node_modules/core-js/internals/create-iterator-constructor.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          var IteratorPrototype = __webpack_require__("./node_modules/core-js/internals/iterators-core.js").IteratorPrototype;
          var create = __webpack_require__("./node_modules/core-js/internals/object-create.js");
          var createPropertyDescriptor = __webpack_require__("./node_modules/core-js/internals/create-property-descriptor.js");
          var setToStringTag = __webpack_require__("./node_modules/core-js/internals/set-to-string-tag.js");
          var Iterators = __webpack_require__("./node_modules/core-js/internals/iterators.js");
          var returnThis = function() {
            return this;
          };
          module3.exports = function(IteratorConstructor, NAME, next) {
            var TO_STRING_TAG = NAME + " Iterator";
            IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
            setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
            Iterators[TO_STRING_TAG] = returnThis;
            return IteratorConstructor;
          };
        },
        "./node_modules/core-js/internals/create-property-descriptor.js": function(module3, exports2) {
          module3.exports = function(bitmap, value) {
            return {
              enumerable: !(bitmap & 1),
              configurable: !(bitmap & 2),
              writable: !(bitmap & 4),
              value
            };
          };
        },
        "./node_modules/core-js/internals/create-property.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          var toPrimitive = __webpack_require__("./node_modules/core-js/internals/to-primitive.js");
          var definePropertyModule = __webpack_require__("./node_modules/core-js/internals/object-define-property.js");
          var createPropertyDescriptor = __webpack_require__("./node_modules/core-js/internals/create-property-descriptor.js");
          module3.exports = function(object, key, value) {
            var propertyKey = toPrimitive(key);
            if (propertyKey in object)
              definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
            else
              object[propertyKey] = value;
          };
        },
        "./node_modules/core-js/internals/define-iterator.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          var $ = __webpack_require__("./node_modules/core-js/internals/export.js");
          var createIteratorConstructor = __webpack_require__("./node_modules/core-js/internals/create-iterator-constructor.js");
          var getPrototypeOf = __webpack_require__("./node_modules/core-js/internals/object-get-prototype-of.js");
          var setPrototypeOf = __webpack_require__("./node_modules/core-js/internals/object-set-prototype-of.js");
          var setToStringTag = __webpack_require__("./node_modules/core-js/internals/set-to-string-tag.js");
          var hide = __webpack_require__("./node_modules/core-js/internals/hide.js");
          var redefine = __webpack_require__("./node_modules/core-js/internals/redefine.js");
          var wellKnownSymbol = __webpack_require__("./node_modules/core-js/internals/well-known-symbol.js");
          var IS_PURE = __webpack_require__("./node_modules/core-js/internals/is-pure.js");
          var Iterators = __webpack_require__("./node_modules/core-js/internals/iterators.js");
          var IteratorsCore = __webpack_require__("./node_modules/core-js/internals/iterators-core.js");
          var IteratorPrototype = IteratorsCore.IteratorPrototype;
          var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
          var ITERATOR = wellKnownSymbol("iterator");
          var KEYS = "keys";
          var VALUES = "values";
          var ENTRIES = "entries";
          var returnThis = function() {
            return this;
          };
          module3.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
            createIteratorConstructor(IteratorConstructor, NAME, next);
            var getIterationMethod = function(KIND) {
              if (KIND === DEFAULT && defaultIterator)
                return defaultIterator;
              if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                return IterablePrototype[KIND];
              switch (KIND) {
                case KEYS:
                  return function keys() {
                    return new IteratorConstructor(this, KIND);
                  };
                case VALUES:
                  return function values() {
                    return new IteratorConstructor(this, KIND);
                  };
                case ENTRIES:
                  return function entries() {
                    return new IteratorConstructor(this, KIND);
                  };
              }
              return function() {
                return new IteratorConstructor(this);
              };
            };
            var TO_STRING_TAG = NAME + " Iterator";
            var INCORRECT_VALUES_NAME = false;
            var IterablePrototype = Iterable.prototype;
            var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
            var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
            var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
            var CurrentIteratorPrototype, methods, KEY;
            if (anyNativeIterator) {
              CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
              if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                  if (setPrototypeOf) {
                    setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                  } else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") {
                    hide(CurrentIteratorPrototype, ITERATOR, returnThis);
                  }
                }
                setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                if (IS_PURE)
                  Iterators[TO_STRING_TAG] = returnThis;
              }
            }
            if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
              INCORRECT_VALUES_NAME = true;
              defaultIterator = function values() {
                return nativeIterator.call(this);
              };
            }
            if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
              hide(IterablePrototype, ITERATOR, defaultIterator);
            }
            Iterators[NAME] = defaultIterator;
            if (DEFAULT) {
              methods = {
                values: getIterationMethod(VALUES),
                keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                entries: getIterationMethod(ENTRIES)
              };
              if (FORCED)
                for (KEY in methods) {
                  if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                    redefine(IterablePrototype, KEY, methods[KEY]);
                  }
                }
              else
                $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
            }
            return methods;
          };
        },
        "./node_modules/core-js/internals/descriptors.js": function(module3, exports2, __webpack_require__) {
          var fails = __webpack_require__("./node_modules/core-js/internals/fails.js");
          module3.exports = !fails(function() {
            return Object.defineProperty({}, "a", { get: function() {
              return 7;
            } }).a != 7;
          });
        },
        "./node_modules/core-js/internals/document-create-element.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var isObject2 = __webpack_require__("./node_modules/core-js/internals/is-object.js");
          var document2 = global2.document;
          var exist = isObject2(document2) && isObject2(document2.createElement);
          module3.exports = function(it) {
            return exist ? document2.createElement(it) : {};
          };
        },
        "./node_modules/core-js/internals/enum-bug-keys.js": function(module3, exports2) {
          module3.exports = [
            "constructor",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "toLocaleString",
            "toString",
            "valueOf"
          ];
        },
        "./node_modules/core-js/internals/export.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var getOwnPropertyDescriptor = __webpack_require__("./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
          var hide = __webpack_require__("./node_modules/core-js/internals/hide.js");
          var redefine = __webpack_require__("./node_modules/core-js/internals/redefine.js");
          var setGlobal = __webpack_require__("./node_modules/core-js/internals/set-global.js");
          var copyConstructorProperties = __webpack_require__("./node_modules/core-js/internals/copy-constructor-properties.js");
          var isForced = __webpack_require__("./node_modules/core-js/internals/is-forced.js");
          module3.exports = function(options, source) {
            var TARGET = options.target;
            var GLOBAL = options.global;
            var STATIC = options.stat;
            var FORCED, target, key, targetProperty, sourceProperty, descriptor;
            if (GLOBAL) {
              target = global2;
            } else if (STATIC) {
              target = global2[TARGET] || setGlobal(TARGET, {});
            } else {
              target = (global2[TARGET] || {}).prototype;
            }
            if (target)
              for (key in source) {
                sourceProperty = source[key];
                if (options.noTargetGet) {
                  descriptor = getOwnPropertyDescriptor(target, key);
                  targetProperty = descriptor && descriptor.value;
                } else
                  targetProperty = target[key];
                FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
                if (!FORCED && targetProperty !== void 0) {
                  if (typeof sourceProperty === typeof targetProperty)
                    continue;
                  copyConstructorProperties(sourceProperty, targetProperty);
                }
                if (options.sham || targetProperty && targetProperty.sham) {
                  hide(sourceProperty, "sham", true);
                }
                redefine(target, key, sourceProperty, options);
              }
          };
        },
        "./node_modules/core-js/internals/fails.js": function(module3, exports2) {
          module3.exports = function(exec) {
            try {
              return !!exec();
            } catch (error) {
              return true;
            }
          };
        },
        "./node_modules/core-js/internals/function-to-string.js": function(module3, exports2, __webpack_require__) {
          var shared = __webpack_require__("./node_modules/core-js/internals/shared.js");
          module3.exports = shared("native-function-to-string", Function.toString);
        },
        "./node_modules/core-js/internals/get-iterator-method.js": function(module3, exports2, __webpack_require__) {
          var classof = __webpack_require__("./node_modules/core-js/internals/classof.js");
          var Iterators = __webpack_require__("./node_modules/core-js/internals/iterators.js");
          var wellKnownSymbol = __webpack_require__("./node_modules/core-js/internals/well-known-symbol.js");
          var ITERATOR = wellKnownSymbol("iterator");
          module3.exports = function(it) {
            if (it != void 0)
              return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
          };
        },
        "./node_modules/core-js/internals/global.js": function(module3, exports2, __webpack_require__) {
          (function(global2) {
            var O = "object";
            var check = function(it) {
              return it && it.Math == Math && it;
            };
            module3.exports = check(typeof globalThis == O && globalThis) || check(typeof window == O && window) || check(typeof self == O && self) || check(typeof global2 == O && global2) || Function("return this")();
          }).call(this, __webpack_require__("./node_modules/webpack/buildin/global.js"));
        },
        "./node_modules/core-js/internals/has.js": function(module3, exports2) {
          var hasOwnProperty = {}.hasOwnProperty;
          module3.exports = function(it, key) {
            return hasOwnProperty.call(it, key);
          };
        },
        "./node_modules/core-js/internals/hidden-keys.js": function(module3, exports2) {
          module3.exports = {};
        },
        "./node_modules/core-js/internals/hide.js": function(module3, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("./node_modules/core-js/internals/descriptors.js");
          var definePropertyModule = __webpack_require__("./node_modules/core-js/internals/object-define-property.js");
          var createPropertyDescriptor = __webpack_require__("./node_modules/core-js/internals/create-property-descriptor.js");
          module3.exports = DESCRIPTORS ? function(object, key, value) {
            return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
          } : function(object, key, value) {
            object[key] = value;
            return object;
          };
        },
        "./node_modules/core-js/internals/html.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var document2 = global2.document;
          module3.exports = document2 && document2.documentElement;
        },
        "./node_modules/core-js/internals/ie8-dom-define.js": function(module3, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("./node_modules/core-js/internals/descriptors.js");
          var fails = __webpack_require__("./node_modules/core-js/internals/fails.js");
          var createElement = __webpack_require__("./node_modules/core-js/internals/document-create-element.js");
          module3.exports = !DESCRIPTORS && !fails(function() {
            return Object.defineProperty(createElement("div"), "a", {
              get: function() {
                return 7;
              }
            }).a != 7;
          });
        },
        "./node_modules/core-js/internals/indexed-object.js": function(module3, exports2, __webpack_require__) {
          var fails = __webpack_require__("./node_modules/core-js/internals/fails.js");
          var classof = __webpack_require__("./node_modules/core-js/internals/classof-raw.js");
          var split = "".split;
          module3.exports = fails(function() {
            return !Object("z").propertyIsEnumerable(0);
          }) ? function(it) {
            return classof(it) == "String" ? split.call(it, "") : Object(it);
          } : Object;
        },
        "./node_modules/core-js/internals/internal-state.js": function(module3, exports2, __webpack_require__) {
          var NATIVE_WEAK_MAP = __webpack_require__("./node_modules/core-js/internals/native-weak-map.js");
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var isObject2 = __webpack_require__("./node_modules/core-js/internals/is-object.js");
          var hide = __webpack_require__("./node_modules/core-js/internals/hide.js");
          var objectHas = __webpack_require__("./node_modules/core-js/internals/has.js");
          var sharedKey = __webpack_require__("./node_modules/core-js/internals/shared-key.js");
          var hiddenKeys = __webpack_require__("./node_modules/core-js/internals/hidden-keys.js");
          var WeakMap2 = global2.WeakMap;
          var set2, get, has;
          var enforce = function(it) {
            return has(it) ? get(it) : set2(it, {});
          };
          var getterFor = function(TYPE) {
            return function(it) {
              var state;
              if (!isObject2(it) || (state = get(it)).type !== TYPE) {
                throw TypeError("Incompatible receiver, " + TYPE + " required");
              }
              return state;
            };
          };
          if (NATIVE_WEAK_MAP) {
            var store = new WeakMap2();
            var wmget = store.get;
            var wmhas = store.has;
            var wmset = store.set;
            set2 = function(it, metadata) {
              wmset.call(store, it, metadata);
              return metadata;
            };
            get = function(it) {
              return wmget.call(store, it) || {};
            };
            has = function(it) {
              return wmhas.call(store, it);
            };
          } else {
            var STATE = sharedKey("state");
            hiddenKeys[STATE] = true;
            set2 = function(it, metadata) {
              hide(it, STATE, metadata);
              return metadata;
            };
            get = function(it) {
              return objectHas(it, STATE) ? it[STATE] : {};
            };
            has = function(it) {
              return objectHas(it, STATE);
            };
          }
          module3.exports = {
            set: set2,
            get,
            has,
            enforce,
            getterFor
          };
        },
        "./node_modules/core-js/internals/is-array-iterator-method.js": function(module3, exports2, __webpack_require__) {
          var wellKnownSymbol = __webpack_require__("./node_modules/core-js/internals/well-known-symbol.js");
          var Iterators = __webpack_require__("./node_modules/core-js/internals/iterators.js");
          var ITERATOR = wellKnownSymbol("iterator");
          var ArrayPrototype = Array.prototype;
          module3.exports = function(it) {
            return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
          };
        },
        "./node_modules/core-js/internals/is-forced.js": function(module3, exports2, __webpack_require__) {
          var fails = __webpack_require__("./node_modules/core-js/internals/fails.js");
          var replacement = /#|\.prototype\./;
          var isForced = function(feature, detection) {
            var value = data[normalize(feature)];
            return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
          };
          var normalize = isForced.normalize = function(string) {
            return String(string).replace(replacement, ".").toLowerCase();
          };
          var data = isForced.data = {};
          var NATIVE = isForced.NATIVE = "N";
          var POLYFILL = isForced.POLYFILL = "P";
          module3.exports = isForced;
        },
        "./node_modules/core-js/internals/is-object.js": function(module3, exports2) {
          module3.exports = function(it) {
            return typeof it === "object" ? it !== null : typeof it === "function";
          };
        },
        "./node_modules/core-js/internals/is-pure.js": function(module3, exports2) {
          module3.exports = false;
        },
        "./node_modules/core-js/internals/iterators-core.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          var getPrototypeOf = __webpack_require__("./node_modules/core-js/internals/object-get-prototype-of.js");
          var hide = __webpack_require__("./node_modules/core-js/internals/hide.js");
          var has = __webpack_require__("./node_modules/core-js/internals/has.js");
          var wellKnownSymbol = __webpack_require__("./node_modules/core-js/internals/well-known-symbol.js");
          var IS_PURE = __webpack_require__("./node_modules/core-js/internals/is-pure.js");
          var ITERATOR = wellKnownSymbol("iterator");
          var BUGGY_SAFARI_ITERATORS = false;
          var returnThis = function() {
            return this;
          };
          var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
          if ([].keys) {
            arrayIterator = [].keys();
            if (!("next" in arrayIterator))
              BUGGY_SAFARI_ITERATORS = true;
            else {
              PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
              if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                IteratorPrototype = PrototypeOfArrayIteratorPrototype;
            }
          }
          if (IteratorPrototype == void 0)
            IteratorPrototype = {};
          if (!IS_PURE && !has(IteratorPrototype, ITERATOR))
            hide(IteratorPrototype, ITERATOR, returnThis);
          module3.exports = {
            IteratorPrototype,
            BUGGY_SAFARI_ITERATORS
          };
        },
        "./node_modules/core-js/internals/iterators.js": function(module3, exports2) {
          module3.exports = {};
        },
        "./node_modules/core-js/internals/native-symbol.js": function(module3, exports2, __webpack_require__) {
          var fails = __webpack_require__("./node_modules/core-js/internals/fails.js");
          module3.exports = !!Object.getOwnPropertySymbols && !fails(function() {
            return !String(Symbol());
          });
        },
        "./node_modules/core-js/internals/native-weak-map.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var nativeFunctionToString = __webpack_require__("./node_modules/core-js/internals/function-to-string.js");
          var WeakMap2 = global2.WeakMap;
          module3.exports = typeof WeakMap2 === "function" && /native code/.test(nativeFunctionToString.call(WeakMap2));
        },
        "./node_modules/core-js/internals/object-create.js": function(module3, exports2, __webpack_require__) {
          var anObject = __webpack_require__("./node_modules/core-js/internals/an-object.js");
          var defineProperties = __webpack_require__("./node_modules/core-js/internals/object-define-properties.js");
          var enumBugKeys = __webpack_require__("./node_modules/core-js/internals/enum-bug-keys.js");
          var hiddenKeys = __webpack_require__("./node_modules/core-js/internals/hidden-keys.js");
          var html = __webpack_require__("./node_modules/core-js/internals/html.js");
          var documentCreateElement = __webpack_require__("./node_modules/core-js/internals/document-create-element.js");
          var sharedKey = __webpack_require__("./node_modules/core-js/internals/shared-key.js");
          var IE_PROTO = sharedKey("IE_PROTO");
          var PROTOTYPE = "prototype";
          var Empty = function() {
          };
          var createDict = function() {
            var iframe = documentCreateElement("iframe");
            var length = enumBugKeys.length;
            var lt = "<";
            var script = "script";
            var gt = ">";
            var js = "java" + script + ":";
            var iframeDocument;
            iframe.style.display = "none";
            html.appendChild(iframe);
            iframe.src = String(js);
            iframeDocument = iframe.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write(lt + script + gt + "document.F=Object" + lt + "/" + script + gt);
            iframeDocument.close();
            createDict = iframeDocument.F;
            while (length--)
              delete createDict[PROTOTYPE][enumBugKeys[length]];
            return createDict();
          };
          module3.exports = Object.create || function create(O, Properties) {
            var result;
            if (O !== null) {
              Empty[PROTOTYPE] = anObject(O);
              result = new Empty();
              Empty[PROTOTYPE] = null;
              result[IE_PROTO] = O;
            } else
              result = createDict();
            return Properties === void 0 ? result : defineProperties(result, Properties);
          };
          hiddenKeys[IE_PROTO] = true;
        },
        "./node_modules/core-js/internals/object-define-properties.js": function(module3, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("./node_modules/core-js/internals/descriptors.js");
          var definePropertyModule = __webpack_require__("./node_modules/core-js/internals/object-define-property.js");
          var anObject = __webpack_require__("./node_modules/core-js/internals/an-object.js");
          var objectKeys = __webpack_require__("./node_modules/core-js/internals/object-keys.js");
          module3.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
            anObject(O);
            var keys = objectKeys(Properties);
            var length = keys.length;
            var i = 0;
            var key;
            while (length > i)
              definePropertyModule.f(O, key = keys[i++], Properties[key]);
            return O;
          };
        },
        "./node_modules/core-js/internals/object-define-property.js": function(module3, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("./node_modules/core-js/internals/descriptors.js");
          var IE8_DOM_DEFINE = __webpack_require__("./node_modules/core-js/internals/ie8-dom-define.js");
          var anObject = __webpack_require__("./node_modules/core-js/internals/an-object.js");
          var toPrimitive = __webpack_require__("./node_modules/core-js/internals/to-primitive.js");
          var nativeDefineProperty = Object.defineProperty;
          exports2.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
            anObject(O);
            P = toPrimitive(P, true);
            anObject(Attributes);
            if (IE8_DOM_DEFINE)
              try {
                return nativeDefineProperty(O, P, Attributes);
              } catch (error) {
              }
            if ("get" in Attributes || "set" in Attributes)
              throw TypeError("Accessors not supported");
            if ("value" in Attributes)
              O[P] = Attributes.value;
            return O;
          };
        },
        "./node_modules/core-js/internals/object-get-own-property-descriptor.js": function(module3, exports2, __webpack_require__) {
          var DESCRIPTORS = __webpack_require__("./node_modules/core-js/internals/descriptors.js");
          var propertyIsEnumerableModule = __webpack_require__("./node_modules/core-js/internals/object-property-is-enumerable.js");
          var createPropertyDescriptor = __webpack_require__("./node_modules/core-js/internals/create-property-descriptor.js");
          var toIndexedObject = __webpack_require__("./node_modules/core-js/internals/to-indexed-object.js");
          var toPrimitive = __webpack_require__("./node_modules/core-js/internals/to-primitive.js");
          var has = __webpack_require__("./node_modules/core-js/internals/has.js");
          var IE8_DOM_DEFINE = __webpack_require__("./node_modules/core-js/internals/ie8-dom-define.js");
          var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          exports2.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
            O = toIndexedObject(O);
            P = toPrimitive(P, true);
            if (IE8_DOM_DEFINE)
              try {
                return nativeGetOwnPropertyDescriptor(O, P);
              } catch (error) {
              }
            if (has(O, P))
              return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
          };
        },
        "./node_modules/core-js/internals/object-get-own-property-names.js": function(module3, exports2, __webpack_require__) {
          var internalObjectKeys = __webpack_require__("./node_modules/core-js/internals/object-keys-internal.js");
          var enumBugKeys = __webpack_require__("./node_modules/core-js/internals/enum-bug-keys.js");
          var hiddenKeys = enumBugKeys.concat("length", "prototype");
          exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
            return internalObjectKeys(O, hiddenKeys);
          };
        },
        "./node_modules/core-js/internals/object-get-own-property-symbols.js": function(module3, exports2) {
          exports2.f = Object.getOwnPropertySymbols;
        },
        "./node_modules/core-js/internals/object-get-prototype-of.js": function(module3, exports2, __webpack_require__) {
          var has = __webpack_require__("./node_modules/core-js/internals/has.js");
          var toObject = __webpack_require__("./node_modules/core-js/internals/to-object.js");
          var sharedKey = __webpack_require__("./node_modules/core-js/internals/shared-key.js");
          var CORRECT_PROTOTYPE_GETTER = __webpack_require__("./node_modules/core-js/internals/correct-prototype-getter.js");
          var IE_PROTO = sharedKey("IE_PROTO");
          var ObjectPrototype = Object.prototype;
          module3.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
            O = toObject(O);
            if (has(O, IE_PROTO))
              return O[IE_PROTO];
            if (typeof O.constructor == "function" && O instanceof O.constructor) {
              return O.constructor.prototype;
            }
            return O instanceof Object ? ObjectPrototype : null;
          };
        },
        "./node_modules/core-js/internals/object-keys-internal.js": function(module3, exports2, __webpack_require__) {
          var has = __webpack_require__("./node_modules/core-js/internals/has.js");
          var toIndexedObject = __webpack_require__("./node_modules/core-js/internals/to-indexed-object.js");
          var arrayIncludes = __webpack_require__("./node_modules/core-js/internals/array-includes.js");
          var hiddenKeys = __webpack_require__("./node_modules/core-js/internals/hidden-keys.js");
          var arrayIndexOf = arrayIncludes(false);
          module3.exports = function(object, names2) {
            var O = toIndexedObject(object);
            var i = 0;
            var result = [];
            var key;
            for (key in O)
              !has(hiddenKeys, key) && has(O, key) && result.push(key);
            while (names2.length > i)
              if (has(O, key = names2[i++])) {
                ~arrayIndexOf(result, key) || result.push(key);
              }
            return result;
          };
        },
        "./node_modules/core-js/internals/object-keys.js": function(module3, exports2, __webpack_require__) {
          var internalObjectKeys = __webpack_require__("./node_modules/core-js/internals/object-keys-internal.js");
          var enumBugKeys = __webpack_require__("./node_modules/core-js/internals/enum-bug-keys.js");
          module3.exports = Object.keys || function keys(O) {
            return internalObjectKeys(O, enumBugKeys);
          };
        },
        "./node_modules/core-js/internals/object-property-is-enumerable.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
          var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
          exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
            var descriptor = getOwnPropertyDescriptor(this, V);
            return !!descriptor && descriptor.enumerable;
          } : nativePropertyIsEnumerable;
        },
        "./node_modules/core-js/internals/object-set-prototype-of.js": function(module3, exports2, __webpack_require__) {
          var validateSetPrototypeOfArguments = __webpack_require__("./node_modules/core-js/internals/validate-set-prototype-of-arguments.js");
          module3.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
            var correctSetter = false;
            var test = {};
            var setter;
            try {
              setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
              setter.call(test, []);
              correctSetter = test instanceof Array;
            } catch (error) {
            }
            return function setPrototypeOf(O, proto) {
              validateSetPrototypeOfArguments(O, proto);
              if (correctSetter)
                setter.call(O, proto);
              else
                O.__proto__ = proto;
              return O;
            };
          }() : void 0);
        },
        "./node_modules/core-js/internals/own-keys.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var getOwnPropertyNamesModule = __webpack_require__("./node_modules/core-js/internals/object-get-own-property-names.js");
          var getOwnPropertySymbolsModule = __webpack_require__("./node_modules/core-js/internals/object-get-own-property-symbols.js");
          var anObject = __webpack_require__("./node_modules/core-js/internals/an-object.js");
          var Reflect2 = global2.Reflect;
          module3.exports = Reflect2 && Reflect2.ownKeys || function ownKeys(it) {
            var keys = getOwnPropertyNamesModule.f(anObject(it));
            var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
            return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
          };
        },
        "./node_modules/core-js/internals/path.js": function(module3, exports2, __webpack_require__) {
          module3.exports = __webpack_require__("./node_modules/core-js/internals/global.js");
        },
        "./node_modules/core-js/internals/redefine.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var shared = __webpack_require__("./node_modules/core-js/internals/shared.js");
          var hide = __webpack_require__("./node_modules/core-js/internals/hide.js");
          var has = __webpack_require__("./node_modules/core-js/internals/has.js");
          var setGlobal = __webpack_require__("./node_modules/core-js/internals/set-global.js");
          var nativeFunctionToString = __webpack_require__("./node_modules/core-js/internals/function-to-string.js");
          var InternalStateModule = __webpack_require__("./node_modules/core-js/internals/internal-state.js");
          var getInternalState = InternalStateModule.get;
          var enforceInternalState = InternalStateModule.enforce;
          var TEMPLATE = String(nativeFunctionToString).split("toString");
          shared("inspectSource", function(it) {
            return nativeFunctionToString.call(it);
          });
          (module3.exports = function(O, key, value, options) {
            var unsafe = options ? !!options.unsafe : false;
            var simple = options ? !!options.enumerable : false;
            var noTargetGet = options ? !!options.noTargetGet : false;
            if (typeof value == "function") {
              if (typeof key == "string" && !has(value, "name"))
                hide(value, "name", key);
              enforceInternalState(value).source = TEMPLATE.join(typeof key == "string" ? key : "");
            }
            if (O === global2) {
              if (simple)
                O[key] = value;
              else
                setGlobal(key, value);
              return;
            } else if (!unsafe) {
              delete O[key];
            } else if (!noTargetGet && O[key]) {
              simple = true;
            }
            if (simple)
              O[key] = value;
            else
              hide(O, key, value);
          })(Function.prototype, "toString", function toString() {
            return typeof this == "function" && getInternalState(this).source || nativeFunctionToString.call(this);
          });
        },
        "./node_modules/core-js/internals/require-object-coercible.js": function(module3, exports2) {
          module3.exports = function(it) {
            if (it == void 0)
              throw TypeError("Can't call method on " + it);
            return it;
          };
        },
        "./node_modules/core-js/internals/set-global.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var hide = __webpack_require__("./node_modules/core-js/internals/hide.js");
          module3.exports = function(key, value) {
            try {
              hide(global2, key, value);
            } catch (error) {
              global2[key] = value;
            }
            return value;
          };
        },
        "./node_modules/core-js/internals/set-to-string-tag.js": function(module3, exports2, __webpack_require__) {
          var defineProperty = __webpack_require__("./node_modules/core-js/internals/object-define-property.js").f;
          var has = __webpack_require__("./node_modules/core-js/internals/has.js");
          var wellKnownSymbol = __webpack_require__("./node_modules/core-js/internals/well-known-symbol.js");
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          module3.exports = function(it, TAG, STATIC) {
            if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
              defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
            }
          };
        },
        "./node_modules/core-js/internals/shared-key.js": function(module3, exports2, __webpack_require__) {
          var shared = __webpack_require__("./node_modules/core-js/internals/shared.js");
          var uid2 = __webpack_require__("./node_modules/core-js/internals/uid.js");
          var keys = shared("keys");
          module3.exports = function(key) {
            return keys[key] || (keys[key] = uid2(key));
          };
        },
        "./node_modules/core-js/internals/shared.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var setGlobal = __webpack_require__("./node_modules/core-js/internals/set-global.js");
          var IS_PURE = __webpack_require__("./node_modules/core-js/internals/is-pure.js");
          var SHARED = "__core-js_shared__";
          var store = global2[SHARED] || setGlobal(SHARED, {});
          (module3.exports = function(key, value) {
            return store[key] || (store[key] = value !== void 0 ? value : {});
          })("versions", []).push({
            version: "3.1.3",
            mode: IS_PURE ? "pure" : "global",
            copyright: "\xA9 2019 Denis Pushkarev (zloirock.ru)"
          });
        },
        "./node_modules/core-js/internals/string-at.js": function(module3, exports2, __webpack_require__) {
          var toInteger = __webpack_require__("./node_modules/core-js/internals/to-integer.js");
          var requireObjectCoercible = __webpack_require__("./node_modules/core-js/internals/require-object-coercible.js");
          module3.exports = function(that, pos, CONVERT_TO_STRING) {
            var S = String(requireObjectCoercible(that));
            var position = toInteger(pos);
            var size = S.length;
            var first, second;
            if (position < 0 || position >= size)
              return CONVERT_TO_STRING ? "" : void 0;
            first = S.charCodeAt(position);
            return first < 55296 || first > 56319 || position + 1 === size || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
          };
        },
        "./node_modules/core-js/internals/to-absolute-index.js": function(module3, exports2, __webpack_require__) {
          var toInteger = __webpack_require__("./node_modules/core-js/internals/to-integer.js");
          var max = Math.max;
          var min = Math.min;
          module3.exports = function(index, length) {
            var integer = toInteger(index);
            return integer < 0 ? max(integer + length, 0) : min(integer, length);
          };
        },
        "./node_modules/core-js/internals/to-indexed-object.js": function(module3, exports2, __webpack_require__) {
          var IndexedObject = __webpack_require__("./node_modules/core-js/internals/indexed-object.js");
          var requireObjectCoercible = __webpack_require__("./node_modules/core-js/internals/require-object-coercible.js");
          module3.exports = function(it) {
            return IndexedObject(requireObjectCoercible(it));
          };
        },
        "./node_modules/core-js/internals/to-integer.js": function(module3, exports2) {
          var ceil = Math.ceil;
          var floor = Math.floor;
          module3.exports = function(argument) {
            return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
          };
        },
        "./node_modules/core-js/internals/to-length.js": function(module3, exports2, __webpack_require__) {
          var toInteger = __webpack_require__("./node_modules/core-js/internals/to-integer.js");
          var min = Math.min;
          module3.exports = function(argument) {
            return argument > 0 ? min(toInteger(argument), 9007199254740991) : 0;
          };
        },
        "./node_modules/core-js/internals/to-object.js": function(module3, exports2, __webpack_require__) {
          var requireObjectCoercible = __webpack_require__("./node_modules/core-js/internals/require-object-coercible.js");
          module3.exports = function(argument) {
            return Object(requireObjectCoercible(argument));
          };
        },
        "./node_modules/core-js/internals/to-primitive.js": function(module3, exports2, __webpack_require__) {
          var isObject2 = __webpack_require__("./node_modules/core-js/internals/is-object.js");
          module3.exports = function(it, S) {
            if (!isObject2(it))
              return it;
            var fn, val;
            if (S && typeof (fn = it.toString) == "function" && !isObject2(val = fn.call(it)))
              return val;
            if (typeof (fn = it.valueOf) == "function" && !isObject2(val = fn.call(it)))
              return val;
            if (!S && typeof (fn = it.toString) == "function" && !isObject2(val = fn.call(it)))
              return val;
            throw TypeError("Can't convert object to primitive value");
          };
        },
        "./node_modules/core-js/internals/uid.js": function(module3, exports2) {
          var id = 0;
          var postfix = Math.random();
          module3.exports = function(key) {
            return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + postfix).toString(36));
          };
        },
        "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js": function(module3, exports2, __webpack_require__) {
          var isObject2 = __webpack_require__("./node_modules/core-js/internals/is-object.js");
          var anObject = __webpack_require__("./node_modules/core-js/internals/an-object.js");
          module3.exports = function(O, proto) {
            anObject(O);
            if (!isObject2(proto) && proto !== null) {
              throw TypeError("Can't set " + String(proto) + " as a prototype");
            }
          };
        },
        "./node_modules/core-js/internals/well-known-symbol.js": function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__("./node_modules/core-js/internals/global.js");
          var shared = __webpack_require__("./node_modules/core-js/internals/shared.js");
          var uid2 = __webpack_require__("./node_modules/core-js/internals/uid.js");
          var NATIVE_SYMBOL = __webpack_require__("./node_modules/core-js/internals/native-symbol.js");
          var Symbol2 = global2.Symbol;
          var store = shared("wks");
          module3.exports = function(name) {
            return store[name] || (store[name] = NATIVE_SYMBOL && Symbol2[name] || (NATIVE_SYMBOL ? Symbol2 : uid2)("Symbol." + name));
          };
        },
        "./node_modules/core-js/modules/es.array.from.js": function(module3, exports2, __webpack_require__) {
          var $ = __webpack_require__("./node_modules/core-js/internals/export.js");
          var from = __webpack_require__("./node_modules/core-js/internals/array-from.js");
          var checkCorrectnessOfIteration = __webpack_require__("./node_modules/core-js/internals/check-correctness-of-iteration.js");
          var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
            Array.from(iterable);
          });
          $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
            from
          });
        },
        "./node_modules/core-js/modules/es.string.iterator.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          var codePointAt = __webpack_require__("./node_modules/core-js/internals/string-at.js");
          var InternalStateModule = __webpack_require__("./node_modules/core-js/internals/internal-state.js");
          var defineIterator = __webpack_require__("./node_modules/core-js/internals/define-iterator.js");
          var STRING_ITERATOR = "String Iterator";
          var setInternalState = InternalStateModule.set;
          var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
          defineIterator(String, "String", function(iterated) {
            setInternalState(this, {
              type: STRING_ITERATOR,
              string: String(iterated),
              index: 0
            });
          }, function next() {
            var state = getInternalState(this);
            var string = state.string;
            var index = state.index;
            var point;
            if (index >= string.length)
              return { value: void 0, done: true };
            point = codePointAt(string, index, true);
            state.index += point.length;
            return { value: point, done: false };
          });
        },
        "./node_modules/webpack/buildin/global.js": function(module3, exports2) {
          var g;
          g = function() {
            return this;
          }();
          try {
            g = g || Function("return this")() || (1, eval)("this");
          } catch (e) {
            if (typeof window === "object")
              g = window;
          }
          module3.exports = g;
        },
        "./src/default-attrs.json": function(module3) {
          module3.exports = { "xmlns": "http://www.w3.org/2000/svg", "width": 24, "height": 24, "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "stroke-width": 2, "stroke-linecap": "round", "stroke-linejoin": "round" };
        },
        "./src/icon.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _createClass = function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _dedupe = __webpack_require__("./node_modules/classnames/dedupe.js");
          var _dedupe2 = _interopRequireDefault(_dedupe);
          var _defaultAttrs = __webpack_require__("./src/default-attrs.json");
          var _defaultAttrs2 = _interopRequireDefault(_defaultAttrs);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance10, Constructor) {
            if (!(instance10 instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var Icon = function() {
            function Icon2(name, contents) {
              var tags = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
              _classCallCheck(this, Icon2);
              this.name = name;
              this.contents = contents;
              this.tags = tags;
              this.attrs = _extends({}, _defaultAttrs2.default, { class: "feather feather-" + name });
            }
            _createClass(Icon2, [{
              key: "toSvg",
              value: function toSvg() {
                var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                var combinedAttrs = _extends({}, this.attrs, attrs, { class: (0, _dedupe2.default)(this.attrs.class, attrs.class) });
                return "<svg " + attrsToString(combinedAttrs) + ">" + this.contents + "</svg>";
              }
            }, {
              key: "toString",
              value: function toString() {
                return this.contents;
              }
            }]);
            return Icon2;
          }();
          function attrsToString(attrs) {
            return Object.keys(attrs).map(function(key) {
              return key + '="' + attrs[key] + '"';
            }).join(" ");
          }
          exports2.default = Icon;
        },
        "./src/icons.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _icon = __webpack_require__("./src/icon.js");
          var _icon2 = _interopRequireDefault(_icon);
          var _icons = __webpack_require__("./dist/icons.json");
          var _icons2 = _interopRequireDefault(_icons);
          var _tags = __webpack_require__("./src/tags.json");
          var _tags2 = _interopRequireDefault(_tags);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = Object.keys(_icons2.default).map(function(key) {
            return new _icon2.default(key, _icons2.default[key], _tags2.default[key]);
          }).reduce(function(object, icon) {
            object[icon.name] = icon;
            return object;
          }, {});
        },
        "./src/index.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          var _icons = __webpack_require__("./src/icons.js");
          var _icons2 = _interopRequireDefault(_icons);
          var _toSvg = __webpack_require__("./src/to-svg.js");
          var _toSvg2 = _interopRequireDefault(_toSvg);
          var _replace = __webpack_require__("./src/replace.js");
          var _replace2 = _interopRequireDefault(_replace);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          module3.exports = { icons: _icons2.default, toSvg: _toSvg2.default, replace: _replace2.default };
        },
        "./src/replace.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _dedupe = __webpack_require__("./node_modules/classnames/dedupe.js");
          var _dedupe2 = _interopRequireDefault(_dedupe);
          var _icons = __webpack_require__("./src/icons.js");
          var _icons2 = _interopRequireDefault(_icons);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function replace() {
            var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            if (typeof document === "undefined") {
              throw new Error("`feather.replace()` only works in a browser environment.");
            }
            var elementsToReplace = document.querySelectorAll("[data-feather]");
            Array.from(elementsToReplace).forEach(function(element2) {
              return replaceElement(element2, attrs);
            });
          }
          function replaceElement(element2) {
            var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var elementAttrs = getAttrs(element2);
            var name = elementAttrs["data-feather"];
            delete elementAttrs["data-feather"];
            var svgString = _icons2.default[name].toSvg(_extends({}, attrs, elementAttrs, { class: (0, _dedupe2.default)(attrs.class, elementAttrs.class) }));
            var svgDocument = new DOMParser().parseFromString(svgString, "image/svg+xml");
            var svgElement = svgDocument.querySelector("svg");
            element2.parentNode.replaceChild(svgElement, element2);
          }
          function getAttrs(element2) {
            return Array.from(element2.attributes).reduce(function(attrs, attr2) {
              attrs[attr2.name] = attr2.value;
              return attrs;
            }, {});
          }
          exports2.default = replace;
        },
        "./src/tags.json": function(module3) {
          module3.exports = { "activity": ["pulse", "health", "action", "motion"], "airplay": ["stream", "cast", "mirroring"], "alert-circle": ["warning", "alert", "danger"], "alert-octagon": ["warning", "alert", "danger"], "alert-triangle": ["warning", "alert", "danger"], "align-center": ["text alignment", "center"], "align-justify": ["text alignment", "justified"], "align-left": ["text alignment", "left"], "align-right": ["text alignment", "right"], "anchor": [], "archive": ["index", "box"], "at-sign": ["mention", "at", "email", "message"], "award": ["achievement", "badge"], "aperture": ["camera", "photo"], "bar-chart": ["statistics", "diagram", "graph"], "bar-chart-2": ["statistics", "diagram", "graph"], "battery": ["power", "electricity"], "battery-charging": ["power", "electricity"], "bell": ["alarm", "notification", "sound"], "bell-off": ["alarm", "notification", "silent"], "bluetooth": ["wireless"], "book-open": ["read", "library"], "book": ["read", "dictionary", "booklet", "magazine", "library"], "bookmark": ["read", "clip", "marker", "tag"], "box": ["cube"], "briefcase": ["work", "bag", "baggage", "folder"], "calendar": ["date"], "camera": ["photo"], "cast": ["chromecast", "airplay"], "circle": ["off", "zero", "record"], "clipboard": ["copy"], "clock": ["time", "watch", "alarm"], "cloud-drizzle": ["weather", "shower"], "cloud-lightning": ["weather", "bolt"], "cloud-rain": ["weather"], "cloud-snow": ["weather", "blizzard"], "cloud": ["weather"], "codepen": ["logo"], "codesandbox": ["logo"], "code": ["source", "programming"], "coffee": ["drink", "cup", "mug", "tea", "cafe", "hot", "beverage"], "columns": ["layout"], "command": ["keyboard", "cmd", "terminal", "prompt"], "compass": ["navigation", "safari", "travel", "direction"], "copy": ["clone", "duplicate"], "corner-down-left": ["arrow", "return"], "corner-down-right": ["arrow"], "corner-left-down": ["arrow"], "corner-left-up": ["arrow"], "corner-right-down": ["arrow"], "corner-right-up": ["arrow"], "corner-up-left": ["arrow"], "corner-up-right": ["arrow"], "cpu": ["processor", "technology"], "credit-card": ["purchase", "payment", "cc"], "crop": ["photo", "image"], "crosshair": ["aim", "target"], "database": ["storage", "memory"], "delete": ["remove"], "disc": ["album", "cd", "dvd", "music"], "dollar-sign": ["currency", "money", "payment"], "droplet": ["water"], "edit": ["pencil", "change"], "edit-2": ["pencil", "change"], "edit-3": ["pencil", "change"], "eye": ["view", "watch"], "eye-off": ["view", "watch", "hide", "hidden"], "external-link": ["outbound"], "facebook": ["logo", "social"], "fast-forward": ["music"], "figma": ["logo", "design", "tool"], "file-minus": ["delete", "remove", "erase"], "file-plus": ["add", "create", "new"], "file-text": ["data", "txt", "pdf"], "film": ["movie", "video"], "filter": ["funnel", "hopper"], "flag": ["report"], "folder-minus": ["directory"], "folder-plus": ["directory"], "folder": ["directory"], "framer": ["logo", "design", "tool"], "frown": ["emoji", "face", "bad", "sad", "emotion"], "gift": ["present", "box", "birthday", "party"], "git-branch": ["code", "version control"], "git-commit": ["code", "version control"], "git-merge": ["code", "version control"], "git-pull-request": ["code", "version control"], "github": ["logo", "version control"], "gitlab": ["logo", "version control"], "globe": ["world", "browser", "language", "translate"], "hard-drive": ["computer", "server", "memory", "data"], "hash": ["hashtag", "number", "pound"], "headphones": ["music", "audio", "sound"], "heart": ["like", "love", "emotion"], "help-circle": ["question mark"], "hexagon": ["shape", "node.js", "logo"], "home": ["house", "living"], "image": ["picture"], "inbox": ["email"], "instagram": ["logo", "camera"], "key": ["password", "login", "authentication", "secure"], "layers": ["stack"], "layout": ["window", "webpage"], "life-bouy": ["help", "life ring", "support"], "link": ["chain", "url"], "link-2": ["chain", "url"], "linkedin": ["logo", "social media"], "list": ["options"], "lock": ["security", "password", "secure"], "log-in": ["sign in", "arrow", "enter"], "log-out": ["sign out", "arrow", "exit"], "mail": ["email", "message"], "map-pin": ["location", "navigation", "travel", "marker"], "map": ["location", "navigation", "travel"], "maximize": ["fullscreen"], "maximize-2": ["fullscreen", "arrows", "expand"], "meh": ["emoji", "face", "neutral", "emotion"], "menu": ["bars", "navigation", "hamburger"], "message-circle": ["comment", "chat"], "message-square": ["comment", "chat"], "mic-off": ["record", "sound", "mute"], "mic": ["record", "sound", "listen"], "minimize": ["exit fullscreen", "close"], "minimize-2": ["exit fullscreen", "arrows", "close"], "minus": ["subtract"], "monitor": ["tv", "screen", "display"], "moon": ["dark", "night"], "more-horizontal": ["ellipsis"], "more-vertical": ["ellipsis"], "mouse-pointer": ["arrow", "cursor"], "move": ["arrows"], "music": ["note"], "navigation": ["location", "travel"], "navigation-2": ["location", "travel"], "octagon": ["stop"], "package": ["box", "container"], "paperclip": ["attachment"], "pause": ["music", "stop"], "pause-circle": ["music", "audio", "stop"], "pen-tool": ["vector", "drawing"], "percent": ["discount"], "phone-call": ["ring"], "phone-forwarded": ["call"], "phone-incoming": ["call"], "phone-missed": ["call"], "phone-off": ["call", "mute"], "phone-outgoing": ["call"], "phone": ["call"], "play": ["music", "start"], "pie-chart": ["statistics", "diagram"], "play-circle": ["music", "start"], "plus": ["add", "new"], "plus-circle": ["add", "new"], "plus-square": ["add", "new"], "pocket": ["logo", "save"], "power": ["on", "off"], "printer": ["fax", "office", "device"], "radio": ["signal"], "refresh-cw": ["synchronise", "arrows"], "refresh-ccw": ["arrows"], "repeat": ["loop", "arrows"], "rewind": ["music"], "rotate-ccw": ["arrow"], "rotate-cw": ["arrow"], "rss": ["feed", "subscribe"], "save": ["floppy disk"], "scissors": ["cut"], "search": ["find", "magnifier", "magnifying glass"], "send": ["message", "mail", "email", "paper airplane", "paper aeroplane"], "settings": ["cog", "edit", "gear", "preferences"], "share-2": ["network", "connections"], "shield": ["security", "secure"], "shield-off": ["security", "insecure"], "shopping-bag": ["ecommerce", "cart", "purchase", "store"], "shopping-cart": ["ecommerce", "cart", "purchase", "store"], "shuffle": ["music"], "skip-back": ["music"], "skip-forward": ["music"], "slack": ["logo"], "slash": ["ban", "no"], "sliders": ["settings", "controls"], "smartphone": ["cellphone", "device"], "smile": ["emoji", "face", "happy", "good", "emotion"], "speaker": ["audio", "music"], "star": ["bookmark", "favorite", "like"], "stop-circle": ["media", "music"], "sun": ["brightness", "weather", "light"], "sunrise": ["weather", "time", "morning", "day"], "sunset": ["weather", "time", "evening", "night"], "tablet": ["device"], "tag": ["label"], "target": ["logo", "bullseye"], "terminal": ["code", "command line", "prompt"], "thermometer": ["temperature", "celsius", "fahrenheit", "weather"], "thumbs-down": ["dislike", "bad", "emotion"], "thumbs-up": ["like", "good", "emotion"], "toggle-left": ["on", "off", "switch"], "toggle-right": ["on", "off", "switch"], "tool": ["settings", "spanner"], "trash": ["garbage", "delete", "remove", "bin"], "trash-2": ["garbage", "delete", "remove", "bin"], "triangle": ["delta"], "truck": ["delivery", "van", "shipping", "transport", "lorry"], "tv": ["television", "stream"], "twitch": ["logo"], "twitter": ["logo", "social"], "type": ["text"], "umbrella": ["rain", "weather"], "unlock": ["security"], "user-check": ["followed", "subscribed"], "user-minus": ["delete", "remove", "unfollow", "unsubscribe"], "user-plus": ["new", "add", "create", "follow", "subscribe"], "user-x": ["delete", "remove", "unfollow", "unsubscribe", "unavailable"], "user": ["person", "account"], "users": ["group"], "video-off": ["camera", "movie", "film"], "video": ["camera", "movie", "film"], "voicemail": ["phone"], "volume": ["music", "sound", "mute"], "volume-1": ["music", "sound"], "volume-2": ["music", "sound"], "volume-x": ["music", "sound", "mute"], "watch": ["clock", "time"], "wifi-off": ["disabled"], "wifi": ["connection", "signal", "wireless"], "wind": ["weather", "air"], "x-circle": ["cancel", "close", "delete", "remove", "times", "clear"], "x-octagon": ["delete", "stop", "alert", "warning", "times", "clear"], "x-square": ["cancel", "close", "delete", "remove", "times", "clear"], "x": ["cancel", "close", "delete", "remove", "times", "clear"], "youtube": ["logo", "video", "play"], "zap-off": ["flash", "camera", "lightning"], "zap": ["flash", "camera", "lightning"], "zoom-in": ["magnifying glass"], "zoom-out": ["magnifying glass"] };
        },
        "./src/to-svg.js": function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _icons = __webpack_require__("./src/icons.js");
          var _icons2 = _interopRequireDefault(_icons);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function toSvg(name) {
            var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            console.warn("feather.toSvg() is deprecated. Please use feather.icons[name].toSvg() instead.");
            if (!name) {
              throw new Error("The required `key` (icon name) parameter is missing.");
            }
            if (!_icons2.default[name]) {
              throw new Error("No icon matching '" + name + "'. See the complete list of icons at https://feathericons.com");
            }
            return _icons2.default[name].toSvg(attrs);
          }
          exports2.default = toSvg;
        },
        0: function(module3, exports2, __webpack_require__) {
          __webpack_require__("./node_modules/core-js/es/array/from.js");
          module3.exports = __webpack_require__("./src/index.js");
        }
      });
    });
  }
});

// node_modules/obsidian-dataview/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-dataview/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DATAVIEW_PLACEHOLDER_VALUE = null;
    exports.DATAVIEW_PLACEHOLDER_VALUE = DATAVIEW_PLACEHOLDER_VALUE;
  }
});

// node_modules/nouislider/dist/nouislider.js
var require_nouislider = __commonJS({
  "node_modules/nouislider/dist/nouislider.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.noUiSlider = {}));
    })(exports, function(exports2) {
      "use strict";
      exports2.PipsMode = void 0;
      (function(PipsMode) {
        PipsMode["Range"] = "range";
        PipsMode["Steps"] = "steps";
        PipsMode["Positions"] = "positions";
        PipsMode["Count"] = "count";
        PipsMode["Values"] = "values";
      })(exports2.PipsMode || (exports2.PipsMode = {}));
      exports2.PipsType = void 0;
      (function(PipsType) {
        PipsType[PipsType["None"] = -1] = "None";
        PipsType[PipsType["NoValue"] = 0] = "NoValue";
        PipsType[PipsType["LargeValue"] = 1] = "LargeValue";
        PipsType[PipsType["SmallValue"] = 2] = "SmallValue";
      })(exports2.PipsType || (exports2.PipsType = {}));
      function isValidFormatter(entry) {
        return isValidPartialFormatter(entry) && typeof entry.from === "function";
      }
      function isValidPartialFormatter(entry) {
        return typeof entry === "object" && typeof entry.to === "function";
      }
      function removeElement(el) {
        el.parentElement.removeChild(el);
      }
      function isSet(value) {
        return value !== null && value !== void 0;
      }
      function preventDefault(e) {
        e.preventDefault();
      }
      function unique(array) {
        return array.filter(function(a) {
          return !this[a] ? this[a] = true : false;
        }, {});
      }
      function closest(value, to) {
        return Math.round(value / to) * to;
      }
      function offset(elem, orientation) {
        var rect = elem.getBoundingClientRect();
        var doc = elem.ownerDocument;
        var docElem = doc.documentElement;
        var pageOffset = getPageOffset(doc);
        if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {
          pageOffset.x = 0;
        }
        return orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft;
      }
      function isNumeric(a) {
        return typeof a === "number" && !isNaN(a) && isFinite(a);
      }
      function addClassFor(element2, className, duration) {
        if (duration > 0) {
          addClass(element2, className);
          setTimeout(function() {
            removeClass(element2, className);
          }, duration);
        }
      }
      function limit(a) {
        return Math.max(Math.min(a, 100), 0);
      }
      function asArray(a) {
        return Array.isArray(a) ? a : [a];
      }
      function countDecimals(numStr) {
        numStr = String(numStr);
        var pieces = numStr.split(".");
        return pieces.length > 1 ? pieces[1].length : 0;
      }
      function addClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
          el.classList.add(className);
        } else {
          el.className += " " + className;
        }
      }
      function removeClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
          el.classList.remove(className);
        } else {
          el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
        }
      }
      function hasClass(el, className) {
        return el.classList ? el.classList.contains(className) : new RegExp("\\b" + className + "\\b").test(el.className);
      }
      function getPageOffset(doc) {
        var supportPageOffset = window.pageXOffset !== void 0;
        var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";
        var x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft;
        var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop;
        return {
          x,
          y
        };
      }
      function getActions() {
        return window.navigator.pointerEnabled ? {
          start: "pointerdown",
          move: "pointermove",
          end: "pointerup"
        } : window.navigator.msPointerEnabled ? {
          start: "MSPointerDown",
          move: "MSPointerMove",
          end: "MSPointerUp"
        } : {
          start: "mousedown touchstart",
          move: "mousemove touchmove",
          end: "mouseup touchend"
        };
      }
      function getSupportsPassive() {
        var supportsPassive = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supportsPassive = true;
            }
          });
          window.addEventListener("test", null, opts);
        } catch (e) {
        }
        return supportsPassive;
      }
      function getSupportsTouchActionNone() {
        return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
      }
      function subRangeRatio(pa, pb) {
        return 100 / (pb - pa);
      }
      function fromPercentage(range, value, startRange) {
        return value * 100 / (range[startRange + 1] - range[startRange]);
      }
      function toPercentage2(range, value) {
        return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0], 0);
      }
      function isPercentage(range, value) {
        return value * (range[1] - range[0]) / 100 + range[0];
      }
      function getJ(value, arr) {
        var j = 1;
        while (value >= arr[j]) {
          j += 1;
        }
        return j;
      }
      function toStepping(xVal, xPct, value) {
        if (value >= xVal.slice(-1)[0]) {
          return 100;
        }
        var j = getJ(value, xVal);
        var va = xVal[j - 1];
        var vb = xVal[j];
        var pa = xPct[j - 1];
        var pb = xPct[j];
        return pa + toPercentage2([va, vb], value) / subRangeRatio(pa, pb);
      }
      function fromStepping(xVal, xPct, value) {
        if (value >= 100) {
          return xVal.slice(-1)[0];
        }
        var j = getJ(value, xPct);
        var va = xVal[j - 1];
        var vb = xVal[j];
        var pa = xPct[j - 1];
        var pb = xPct[j];
        return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));
      }
      function getStep(xPct, xSteps, snap, value) {
        if (value === 100) {
          return value;
        }
        var j = getJ(value, xPct);
        var a = xPct[j - 1];
        var b = xPct[j];
        if (snap) {
          if (value - a > (b - a) / 2) {
            return b;
          }
          return a;
        }
        if (!xSteps[j - 1]) {
          return value;
        }
        return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);
      }
      var Spectrum = function() {
        function Spectrum2(entry, snap, singleStep) {
          this.xPct = [];
          this.xVal = [];
          this.xSteps = [];
          this.xNumSteps = [];
          this.xHighestCompleteStep = [];
          this.xSteps = [singleStep || false];
          this.xNumSteps = [false];
          this.snap = snap;
          var index;
          var ordered = [];
          Object.keys(entry).forEach(function(index2) {
            ordered.push([asArray(entry[index2]), index2]);
          });
          ordered.sort(function(a, b) {
            return a[0][0] - b[0][0];
          });
          for (index = 0; index < ordered.length; index++) {
            this.handleEntryPoint(ordered[index][1], ordered[index][0]);
          }
          this.xNumSteps = this.xSteps.slice(0);
          for (index = 0; index < this.xNumSteps.length; index++) {
            this.handleStepPoint(index, this.xNumSteps[index]);
          }
        }
        Spectrum2.prototype.getDistance = function(value) {
          var distances = [];
          for (var index = 0; index < this.xNumSteps.length - 1; index++) {
            distances[index] = fromPercentage(this.xVal, value, index);
          }
          return distances;
        };
        Spectrum2.prototype.getAbsoluteDistance = function(value, distances, direction) {
          var xPct_index = 0;
          if (value < this.xPct[this.xPct.length - 1]) {
            while (value > this.xPct[xPct_index + 1]) {
              xPct_index++;
            }
          } else if (value === this.xPct[this.xPct.length - 1]) {
            xPct_index = this.xPct.length - 2;
          }
          if (!direction && value === this.xPct[xPct_index + 1]) {
            xPct_index++;
          }
          if (distances === null) {
            distances = [];
          }
          var start_factor;
          var rest_factor = 1;
          var rest_rel_distance = distances[xPct_index];
          var range_pct = 0;
          var rel_range_distance = 0;
          var abs_distance_counter = 0;
          var range_counter = 0;
          if (direction) {
            start_factor = (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
          } else {
            start_factor = (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
          }
          while (rest_rel_distance > 0) {
            range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter];
            if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {
              rel_range_distance = range_pct * start_factor;
              rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter];
              start_factor = 1;
            } else {
              rel_range_distance = distances[xPct_index + range_counter] * range_pct / 100 * rest_factor;
              rest_factor = 0;
            }
            if (direction) {
              abs_distance_counter = abs_distance_counter - rel_range_distance;
              if (this.xPct.length + range_counter >= 1) {
                range_counter--;
              }
            } else {
              abs_distance_counter = abs_distance_counter + rel_range_distance;
              if (this.xPct.length - range_counter >= 1) {
                range_counter++;
              }
            }
            rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;
          }
          return value + abs_distance_counter;
        };
        Spectrum2.prototype.toStepping = function(value) {
          value = toStepping(this.xVal, this.xPct, value);
          return value;
        };
        Spectrum2.prototype.fromStepping = function(value) {
          return fromStepping(this.xVal, this.xPct, value);
        };
        Spectrum2.prototype.getStep = function(value) {
          value = getStep(this.xPct, this.xSteps, this.snap, value);
          return value;
        };
        Spectrum2.prototype.getDefaultStep = function(value, isDown, size) {
          var j = getJ(value, this.xPct);
          if (value === 100 || isDown && value === this.xPct[j - 1]) {
            j = Math.max(j - 1, 1);
          }
          return (this.xVal[j] - this.xVal[j - 1]) / size;
        };
        Spectrum2.prototype.getNearbySteps = function(value) {
          var j = getJ(value, this.xPct);
          return {
            stepBefore: {
              startValue: this.xVal[j - 2],
              step: this.xNumSteps[j - 2],
              highestStep: this.xHighestCompleteStep[j - 2]
            },
            thisStep: {
              startValue: this.xVal[j - 1],
              step: this.xNumSteps[j - 1],
              highestStep: this.xHighestCompleteStep[j - 1]
            },
            stepAfter: {
              startValue: this.xVal[j],
              step: this.xNumSteps[j],
              highestStep: this.xHighestCompleteStep[j]
            }
          };
        };
        Spectrum2.prototype.countStepDecimals = function() {
          var stepDecimals = this.xNumSteps.map(countDecimals);
          return Math.max.apply(null, stepDecimals);
        };
        Spectrum2.prototype.hasNoSize = function() {
          return this.xVal[0] === this.xVal[this.xVal.length - 1];
        };
        Spectrum2.prototype.convert = function(value) {
          return this.getStep(this.toStepping(value));
        };
        Spectrum2.prototype.handleEntryPoint = function(index, value) {
          var percentage;
          if (index === "min") {
            percentage = 0;
          } else if (index === "max") {
            percentage = 100;
          } else {
            percentage = parseFloat(index);
          }
          if (!isNumeric(percentage) || !isNumeric(value[0])) {
            throw new Error("noUiSlider: 'range' value isn't numeric.");
          }
          this.xPct.push(percentage);
          this.xVal.push(value[0]);
          var value1 = Number(value[1]);
          if (!percentage) {
            if (!isNaN(value1)) {
              this.xSteps[0] = value1;
            }
          } else {
            this.xSteps.push(isNaN(value1) ? false : value1);
          }
          this.xHighestCompleteStep.push(0);
        };
        Spectrum2.prototype.handleStepPoint = function(i, n) {
          if (!n) {
            return;
          }
          if (this.xVal[i] === this.xVal[i + 1]) {
            this.xSteps[i] = this.xHighestCompleteStep[i] = this.xVal[i];
            return;
          }
          this.xSteps[i] = fromPercentage([this.xVal[i], this.xVal[i + 1]], n, 0) / subRangeRatio(this.xPct[i], this.xPct[i + 1]);
          var totalSteps = (this.xVal[i + 1] - this.xVal[i]) / this.xNumSteps[i];
          var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
          var step = this.xVal[i] + this.xNumSteps[i] * highestStep;
          this.xHighestCompleteStep[i] = step;
        };
        return Spectrum2;
      }();
      var defaultFormatter = {
        to: function(value) {
          return value === void 0 ? "" : value.toFixed(2);
        },
        from: Number
      };
      var cssClasses = {
        target: "target",
        base: "base",
        origin: "origin",
        handle: "handle",
        handleLower: "handle-lower",
        handleUpper: "handle-upper",
        touchArea: "touch-area",
        horizontal: "horizontal",
        vertical: "vertical",
        background: "background",
        connect: "connect",
        connects: "connects",
        ltr: "ltr",
        rtl: "rtl",
        textDirectionLtr: "txt-dir-ltr",
        textDirectionRtl: "txt-dir-rtl",
        draggable: "draggable",
        drag: "state-drag",
        tap: "state-tap",
        active: "active",
        tooltip: "tooltip",
        pips: "pips",
        pipsHorizontal: "pips-horizontal",
        pipsVertical: "pips-vertical",
        marker: "marker",
        markerHorizontal: "marker-horizontal",
        markerVertical: "marker-vertical",
        markerNormal: "marker-normal",
        markerLarge: "marker-large",
        markerSub: "marker-sub",
        value: "value",
        valueHorizontal: "value-horizontal",
        valueVertical: "value-vertical",
        valueNormal: "value-normal",
        valueLarge: "value-large",
        valueSub: "value-sub"
      };
      var INTERNAL_EVENT_NS = {
        tooltips: ".__tooltips",
        aria: ".__aria"
      };
      function testStep(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'step' is not numeric.");
        }
        parsed.singleStep = entry;
      }
      function testKeyboardPageMultiplier(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric.");
        }
        parsed.keyboardPageMultiplier = entry;
      }
      function testKeyboardMultiplier(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric.");
        }
        parsed.keyboardMultiplier = entry;
      }
      function testKeyboardDefaultStep(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric.");
        }
        parsed.keyboardDefaultStep = entry;
      }
      function testRange(parsed, entry) {
        if (typeof entry !== "object" || Array.isArray(entry)) {
          throw new Error("noUiSlider: 'range' is not an object.");
        }
        if (entry.min === void 0 || entry.max === void 0) {
          throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
        }
        parsed.spectrum = new Spectrum(entry, parsed.snap || false, parsed.singleStep);
      }
      function testStart(parsed, entry) {
        entry = asArray(entry);
        if (!Array.isArray(entry) || !entry.length) {
          throw new Error("noUiSlider: 'start' option is incorrect.");
        }
        parsed.handles = entry.length;
        parsed.start = entry;
      }
      function testSnap(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'snap' option must be a boolean.");
        }
        parsed.snap = entry;
      }
      function testAnimate(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'animate' option must be a boolean.");
        }
        parsed.animate = entry;
      }
      function testAnimationDuration(parsed, entry) {
        if (typeof entry !== "number") {
          throw new Error("noUiSlider: 'animationDuration' option must be a number.");
        }
        parsed.animationDuration = entry;
      }
      function testConnect(parsed, entry) {
        var connect = [false];
        var i;
        if (entry === "lower") {
          entry = [true, false];
        } else if (entry === "upper") {
          entry = [false, true];
        }
        if (entry === true || entry === false) {
          for (i = 1; i < parsed.handles; i++) {
            connect.push(entry);
          }
          connect.push(false);
        } else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {
          throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
        } else {
          connect = entry;
        }
        parsed.connect = connect;
      }
      function testOrientation(parsed, entry) {
        switch (entry) {
          case "horizontal":
            parsed.ort = 0;
            break;
          case "vertical":
            parsed.ort = 1;
            break;
          default:
            throw new Error("noUiSlider: 'orientation' option is invalid.");
        }
      }
      function testMargin(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'margin' option must be numeric.");
        }
        if (entry === 0) {
          return;
        }
        parsed.margin = parsed.spectrum.getDistance(entry);
      }
      function testLimit(parsed, entry) {
        if (!isNumeric(entry)) {
          throw new Error("noUiSlider: 'limit' option must be numeric.");
        }
        parsed.limit = parsed.spectrum.getDistance(entry);
        if (!parsed.limit || parsed.handles < 2) {
          throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.");
        }
      }
      function testPadding(parsed, entry) {
        var index;
        if (!isNumeric(entry) && !Array.isArray(entry)) {
          throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
        }
        if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {
          throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
        }
        if (entry === 0) {
          return;
        }
        if (!Array.isArray(entry)) {
          entry = [entry, entry];
        }
        parsed.padding = [parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1])];
        for (index = 0; index < parsed.spectrum.xNumSteps.length - 1; index++) {
          if (parsed.padding[0][index] < 0 || parsed.padding[1][index] < 0) {
            throw new Error("noUiSlider: 'padding' option must be a positive number(s).");
          }
        }
        var totalPadding = entry[0] + entry[1];
        var firstValue = parsed.spectrum.xVal[0];
        var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];
        if (totalPadding / (lastValue - firstValue) > 1) {
          throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.");
        }
      }
      function testDirection(parsed, entry) {
        switch (entry) {
          case "ltr":
            parsed.dir = 0;
            break;
          case "rtl":
            parsed.dir = 1;
            break;
          default:
            throw new Error("noUiSlider: 'direction' option was not recognized.");
        }
      }
      function testBehaviour(parsed, entry) {
        if (typeof entry !== "string") {
          throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
        }
        var tap = entry.indexOf("tap") >= 0;
        var drag = entry.indexOf("drag") >= 0;
        var fixed = entry.indexOf("fixed") >= 0;
        var snap = entry.indexOf("snap") >= 0;
        var hover = entry.indexOf("hover") >= 0;
        var unconstrained = entry.indexOf("unconstrained") >= 0;
        var dragAll = entry.indexOf("drag-all") >= 0;
        if (fixed) {
          if (parsed.handles !== 2) {
            throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles");
          }
          testMargin(parsed, parsed.start[1] - parsed.start[0]);
        }
        if (unconstrained && (parsed.margin || parsed.limit)) {
          throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit");
        }
        parsed.events = {
          tap: tap || snap,
          drag,
          dragAll,
          fixed,
          snap,
          hover,
          unconstrained
        };
      }
      function testTooltips(parsed, entry) {
        if (entry === false) {
          return;
        }
        if (entry === true || isValidPartialFormatter(entry)) {
          parsed.tooltips = [];
          for (var i = 0; i < parsed.handles; i++) {
            parsed.tooltips.push(entry);
          }
        } else {
          entry = asArray(entry);
          if (entry.length !== parsed.handles) {
            throw new Error("noUiSlider: must pass a formatter for all handles.");
          }
          entry.forEach(function(formatter) {
            if (typeof formatter !== "boolean" && !isValidPartialFormatter(formatter)) {
              throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.");
            }
          });
          parsed.tooltips = entry;
        }
      }
      function testHandleAttributes(parsed, entry) {
        if (entry.length !== parsed.handles) {
          throw new Error("noUiSlider: must pass a attributes for all handles.");
        }
        parsed.handleAttributes = entry;
      }
      function testAriaFormat(parsed, entry) {
        if (!isValidPartialFormatter(entry)) {
          throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
        }
        parsed.ariaFormat = entry;
      }
      function testFormat(parsed, entry) {
        if (!isValidFormatter(entry)) {
          throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
        }
        parsed.format = entry;
      }
      function testKeyboardSupport(parsed, entry) {
        if (typeof entry !== "boolean") {
          throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean.");
        }
        parsed.keyboardSupport = entry;
      }
      function testDocumentElement(parsed, entry) {
        parsed.documentElement = entry;
      }
      function testCssPrefix(parsed, entry) {
        if (typeof entry !== "string" && entry !== false) {
          throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`.");
        }
        parsed.cssPrefix = entry;
      }
      function testCssClasses(parsed, entry) {
        if (typeof entry !== "object") {
          throw new Error("noUiSlider: 'cssClasses' must be an object.");
        }
        if (typeof parsed.cssPrefix === "string") {
          parsed.cssClasses = {};
          Object.keys(entry).forEach(function(key) {
            parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
          });
        } else {
          parsed.cssClasses = entry;
        }
      }
      function testOptions(options) {
        var parsed = {
          margin: null,
          limit: null,
          padding: null,
          animate: true,
          animationDuration: 300,
          ariaFormat: defaultFormatter,
          format: defaultFormatter
        };
        var tests = {
          step: { r: false, t: testStep },
          keyboardPageMultiplier: { r: false, t: testKeyboardPageMultiplier },
          keyboardMultiplier: { r: false, t: testKeyboardMultiplier },
          keyboardDefaultStep: { r: false, t: testKeyboardDefaultStep },
          start: { r: true, t: testStart },
          connect: { r: true, t: testConnect },
          direction: { r: true, t: testDirection },
          snap: { r: false, t: testSnap },
          animate: { r: false, t: testAnimate },
          animationDuration: { r: false, t: testAnimationDuration },
          range: { r: true, t: testRange },
          orientation: { r: false, t: testOrientation },
          margin: { r: false, t: testMargin },
          limit: { r: false, t: testLimit },
          padding: { r: false, t: testPadding },
          behaviour: { r: true, t: testBehaviour },
          ariaFormat: { r: false, t: testAriaFormat },
          format: { r: false, t: testFormat },
          tooltips: { r: false, t: testTooltips },
          keyboardSupport: { r: true, t: testKeyboardSupport },
          documentElement: { r: false, t: testDocumentElement },
          cssPrefix: { r: true, t: testCssPrefix },
          cssClasses: { r: true, t: testCssClasses },
          handleAttributes: { r: false, t: testHandleAttributes }
        };
        var defaults2 = {
          connect: false,
          direction: "ltr",
          behaviour: "tap",
          orientation: "horizontal",
          keyboardSupport: true,
          cssPrefix: "noUi-",
          cssClasses,
          keyboardPageMultiplier: 5,
          keyboardMultiplier: 1,
          keyboardDefaultStep: 10
        };
        if (options.format && !options.ariaFormat) {
          options.ariaFormat = options.format;
        }
        Object.keys(tests).forEach(function(name) {
          if (!isSet(options[name]) && defaults2[name] === void 0) {
            if (tests[name].r) {
              throw new Error("noUiSlider: '" + name + "' is required.");
            }
            return;
          }
          tests[name].t(parsed, !isSet(options[name]) ? defaults2[name] : options[name]);
        });
        parsed.pips = options.pips;
        var d = document.createElement("div");
        var msPrefix = d.style.msTransform !== void 0;
        var noPrefix = d.style.transform !== void 0;
        parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform";
        var styles = [
          ["left", "top"],
          ["right", "bottom"]
        ];
        parsed.style = styles[parsed.dir][parsed.ort];
        return parsed;
      }
      function scope(target, options, originalOptions) {
        var actions = getActions();
        var supportsTouchActionNone = getSupportsTouchActionNone();
        var supportsPassive = supportsTouchActionNone && getSupportsPassive();
        var scope_Target = target;
        var scope_Base;
        var scope_Handles;
        var scope_Connects;
        var scope_Pips;
        var scope_Tooltips;
        var scope_Spectrum = options.spectrum;
        var scope_Values = [];
        var scope_Locations = [];
        var scope_HandleNumbers = [];
        var scope_ActiveHandlesCount = 0;
        var scope_Events = {};
        var scope_Document = target.ownerDocument;
        var scope_DocumentElement = options.documentElement || scope_Document.documentElement;
        var scope_Body = scope_Document.body;
        var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100;
        function addNodeTo(addTarget, className) {
          var div = scope_Document.createElement("div");
          if (className) {
            addClass(div, className);
          }
          addTarget.appendChild(div);
          return div;
        }
        function addOrigin(base, handleNumber) {
          var origin = addNodeTo(base, options.cssClasses.origin);
          var handle = addNodeTo(origin, options.cssClasses.handle);
          addNodeTo(handle, options.cssClasses.touchArea);
          handle.setAttribute("data-handle", String(handleNumber));
          if (options.keyboardSupport) {
            handle.setAttribute("tabindex", "0");
            handle.addEventListener("keydown", function(event) {
              return eventKeydown(event, handleNumber);
            });
          }
          if (options.handleAttributes !== void 0) {
            var attributes_1 = options.handleAttributes[handleNumber];
            Object.keys(attributes_1).forEach(function(attribute) {
              handle.setAttribute(attribute, attributes_1[attribute]);
            });
          }
          handle.setAttribute("role", "slider");
          handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");
          if (handleNumber === 0) {
            addClass(handle, options.cssClasses.handleLower);
          } else if (handleNumber === options.handles - 1) {
            addClass(handle, options.cssClasses.handleUpper);
          }
          return origin;
        }
        function addConnect(base, add) {
          if (!add) {
            return false;
          }
          return addNodeTo(base, options.cssClasses.connect);
        }
        function addElements(connectOptions, base) {
          var connectBase = addNodeTo(base, options.cssClasses.connects);
          scope_Handles = [];
          scope_Connects = [];
          scope_Connects.push(addConnect(connectBase, connectOptions[0]));
          for (var i = 0; i < options.handles; i++) {
            scope_Handles.push(addOrigin(base, i));
            scope_HandleNumbers[i] = i;
            scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));
          }
        }
        function addSlider(addTarget) {
          addClass(addTarget, options.cssClasses.target);
          if (options.dir === 0) {
            addClass(addTarget, options.cssClasses.ltr);
          } else {
            addClass(addTarget, options.cssClasses.rtl);
          }
          if (options.ort === 0) {
            addClass(addTarget, options.cssClasses.horizontal);
          } else {
            addClass(addTarget, options.cssClasses.vertical);
          }
          var textDirection = getComputedStyle(addTarget).direction;
          if (textDirection === "rtl") {
            addClass(addTarget, options.cssClasses.textDirectionRtl);
          } else {
            addClass(addTarget, options.cssClasses.textDirectionLtr);
          }
          return addNodeTo(addTarget, options.cssClasses.base);
        }
        function addTooltip(handle, handleNumber) {
          if (!options.tooltips || !options.tooltips[handleNumber]) {
            return false;
          }
          return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
        }
        function isSliderDisabled() {
          return scope_Target.hasAttribute("disabled");
        }
        function isHandleDisabled(handleNumber) {
          var handleOrigin = scope_Handles[handleNumber];
          return handleOrigin.hasAttribute("disabled");
        }
        function removeTooltips() {
          if (scope_Tooltips) {
            removeEvent("update" + INTERNAL_EVENT_NS.tooltips);
            scope_Tooltips.forEach(function(tooltip) {
              if (tooltip) {
                removeElement(tooltip);
              }
            });
            scope_Tooltips = null;
          }
        }
        function tooltips() {
          removeTooltips();
          scope_Tooltips = scope_Handles.map(addTooltip);
          bindEvent("update" + INTERNAL_EVENT_NS.tooltips, function(values, handleNumber, unencoded) {
            if (!scope_Tooltips || !options.tooltips) {
              return;
            }
            if (scope_Tooltips[handleNumber] === false) {
              return;
            }
            var formattedValue = values[handleNumber];
            if (options.tooltips[handleNumber] !== true) {
              formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);
            }
            scope_Tooltips[handleNumber].innerHTML = formattedValue;
          });
        }
        function aria() {
          removeEvent("update" + INTERNAL_EVENT_NS.aria);
          bindEvent("update" + INTERNAL_EVENT_NS.aria, function(values, handleNumber, unencoded, tap, positions2) {
            scope_HandleNumbers.forEach(function(index) {
              var handle = scope_Handles[index];
              var min = checkHandlePosition(scope_Locations, index, 0, true, true, true);
              var max = checkHandlePosition(scope_Locations, index, 100, true, true, true);
              var now = positions2[index];
              var text2 = String(options.ariaFormat.to(unencoded[index]));
              min = scope_Spectrum.fromStepping(min).toFixed(1);
              max = scope_Spectrum.fromStepping(max).toFixed(1);
              now = scope_Spectrum.fromStepping(now).toFixed(1);
              handle.children[0].setAttribute("aria-valuemin", min);
              handle.children[0].setAttribute("aria-valuemax", max);
              handle.children[0].setAttribute("aria-valuenow", now);
              handle.children[0].setAttribute("aria-valuetext", text2);
            });
          });
        }
        function getGroup(pips2) {
          if (pips2.mode === exports2.PipsMode.Range || pips2.mode === exports2.PipsMode.Steps) {
            return scope_Spectrum.xVal;
          }
          if (pips2.mode === exports2.PipsMode.Count) {
            if (pips2.values < 2) {
              throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'.");
            }
            var interval = pips2.values - 1;
            var spread = 100 / interval;
            var values = [];
            while (interval--) {
              values[interval] = interval * spread;
            }
            values.push(100);
            return mapToRange(values, pips2.stepped);
          }
          if (pips2.mode === exports2.PipsMode.Positions) {
            return mapToRange(pips2.values, pips2.stepped);
          }
          if (pips2.mode === exports2.PipsMode.Values) {
            if (pips2.stepped) {
              return pips2.values.map(function(value) {
                return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
              });
            }
            return pips2.values;
          }
          return [];
        }
        function mapToRange(values, stepped) {
          return values.map(function(value) {
            return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);
          });
        }
        function generateSpread(pips2) {
          function safeIncrement(value, increment) {
            return Number((value + increment).toFixed(7));
          }
          var group = getGroup(pips2);
          var indexes = {};
          var firstInRange = scope_Spectrum.xVal[0];
          var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
          var ignoreFirst = false;
          var ignoreLast = false;
          var prevPct = 0;
          group = unique(group.slice().sort(function(a, b) {
            return a - b;
          }));
          if (group[0] !== firstInRange) {
            group.unshift(firstInRange);
            ignoreFirst = true;
          }
          if (group[group.length - 1] !== lastInRange) {
            group.push(lastInRange);
            ignoreLast = true;
          }
          group.forEach(function(current, index) {
            var step;
            var i;
            var q;
            var low = current;
            var high = group[index + 1];
            var newPct;
            var pctDifference;
            var pctPos;
            var type;
            var steps;
            var realSteps;
            var stepSize;
            var isSteps = pips2.mode === exports2.PipsMode.Steps;
            if (isSteps) {
              step = scope_Spectrum.xNumSteps[index];
            }
            if (!step) {
              step = high - low;
            }
            if (high === void 0) {
              high = low;
            }
            step = Math.max(step, 1e-7);
            for (i = low; i <= high; i = safeIncrement(i, step)) {
              newPct = scope_Spectrum.toStepping(i);
              pctDifference = newPct - prevPct;
              steps = pctDifference / (pips2.density || 1);
              realSteps = Math.round(steps);
              stepSize = pctDifference / realSteps;
              for (q = 1; q <= realSteps; q += 1) {
                pctPos = prevPct + q * stepSize;
                indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];
              }
              type = group.indexOf(i) > -1 ? exports2.PipsType.LargeValue : isSteps ? exports2.PipsType.SmallValue : exports2.PipsType.NoValue;
              if (!index && ignoreFirst && i !== high) {
                type = 0;
              }
              if (!(i === high && ignoreLast)) {
                indexes[newPct.toFixed(5)] = [i, type];
              }
              prevPct = newPct;
            }
          });
          return indexes;
        }
        function addMarking(spread, filterFunc, formatter) {
          var _a, _b;
          var element2 = scope_Document.createElement("div");
          var valueSizeClasses = (_a = {}, _a[exports2.PipsType.None] = "", _a[exports2.PipsType.NoValue] = options.cssClasses.valueNormal, _a[exports2.PipsType.LargeValue] = options.cssClasses.valueLarge, _a[exports2.PipsType.SmallValue] = options.cssClasses.valueSub, _a);
          var markerSizeClasses = (_b = {}, _b[exports2.PipsType.None] = "", _b[exports2.PipsType.NoValue] = options.cssClasses.markerNormal, _b[exports2.PipsType.LargeValue] = options.cssClasses.markerLarge, _b[exports2.PipsType.SmallValue] = options.cssClasses.markerSub, _b);
          var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];
          var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];
          addClass(element2, options.cssClasses.pips);
          addClass(element2, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);
          function getClasses(type, source) {
            var a = source === options.cssClasses.value;
            var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;
            var sizeClasses = a ? valueSizeClasses : markerSizeClasses;
            return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type];
          }
          function addSpread(offset2, value, type) {
            type = filterFunc ? filterFunc(value, type) : type;
            if (type === exports2.PipsType.None) {
              return;
            }
            var node = addNodeTo(element2, false);
            node.className = getClasses(type, options.cssClasses.marker);
            node.style[options.style] = offset2 + "%";
            if (type > exports2.PipsType.NoValue) {
              node = addNodeTo(element2, false);
              node.className = getClasses(type, options.cssClasses.value);
              node.setAttribute("data-value", String(value));
              node.style[options.style] = offset2 + "%";
              node.innerHTML = String(formatter.to(value));
            }
          }
          Object.keys(spread).forEach(function(offset2) {
            addSpread(offset2, spread[offset2][0], spread[offset2][1]);
          });
          return element2;
        }
        function removePips() {
          if (scope_Pips) {
            removeElement(scope_Pips);
            scope_Pips = null;
          }
        }
        function pips(pips2) {
          removePips();
          var spread = generateSpread(pips2);
          var filter = pips2.filter;
          var format = pips2.format || {
            to: function(value) {
              return String(Math.round(value));
            }
          };
          scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format));
          return scope_Pips;
        }
        function baseSize() {
          var rect = scope_Base.getBoundingClientRect();
          var alt = "offset" + ["Width", "Height"][options.ort];
          return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
        }
        function attachEvent(events, element2, callback2, data) {
          var method = function(event) {
            var e = fixEvent(event, data.pageOffset, data.target || element2);
            if (!e) {
              return false;
            }
            if (isSliderDisabled() && !data.doNotReject) {
              return false;
            }
            if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {
              return false;
            }
            if (events === actions.start && e.buttons !== void 0 && e.buttons > 1) {
              return false;
            }
            if (data.hover && e.buttons) {
              return false;
            }
            if (!supportsPassive) {
              e.preventDefault();
            }
            e.calcPoint = e.points[options.ort];
            callback2(e, data);
            return;
          };
          var methods = [];
          events.split(" ").forEach(function(eventName) {
            element2.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);
            methods.push([eventName, method]);
          });
          return methods;
        }
        function fixEvent(e, pageOffset, eventTarget) {
          var touch = e.type.indexOf("touch") === 0;
          var mouse = e.type.indexOf("mouse") === 0;
          var pointer = e.type.indexOf("pointer") === 0;
          var x = 0;
          var y = 0;
          if (e.type.indexOf("MSPointer") === 0) {
            pointer = true;
          }
          if (e.type === "mousedown" && !e.buttons && !e.touches) {
            return false;
          }
          if (touch) {
            var isTouchOnTarget = function(checkTouch) {
              var target2 = checkTouch.target;
              return target2 === eventTarget || eventTarget.contains(target2) || e.composed && e.composedPath().shift() === eventTarget;
            };
            if (e.type === "touchstart") {
              var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);
              if (targetTouches.length > 1) {
                return false;
              }
              x = targetTouches[0].pageX;
              y = targetTouches[0].pageY;
            } else {
              var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);
              if (!targetTouch) {
                return false;
              }
              x = targetTouch.pageX;
              y = targetTouch.pageY;
            }
          }
          pageOffset = pageOffset || getPageOffset(scope_Document);
          if (mouse || pointer) {
            x = e.clientX + pageOffset.x;
            y = e.clientY + pageOffset.y;
          }
          e.pageOffset = pageOffset;
          e.points = [x, y];
          e.cursor = mouse || pointer;
          return e;
        }
        function calcPointToPercentage(calcPoint) {
          var location = calcPoint - offset(scope_Base, options.ort);
          var proposal = location * 100 / baseSize();
          proposal = limit(proposal);
          return options.dir ? 100 - proposal : proposal;
        }
        function getClosestHandle(clickedPosition) {
          var smallestDifference = 100;
          var handleNumber = false;
          scope_Handles.forEach(function(handle, index) {
            if (isHandleDisabled(index)) {
              return;
            }
            var handlePosition = scope_Locations[index];
            var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition);
            var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100;
            var isCloser = differenceWithThisHandle < smallestDifference;
            var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;
            if (isCloser || isCloserAfter || clickAtEdge) {
              handleNumber = index;
              smallestDifference = differenceWithThisHandle;
            }
          });
          return handleNumber;
        }
        function documentLeave(event, data) {
          if (event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null) {
            eventEnd(event, data);
          }
        }
        function eventMove(event, data) {
          if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {
            return eventEnd(event, data);
          }
          var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);
          var proposal = movement * 100 / data.baseSize;
          moveHandles(movement > 0, proposal, data.locations, data.handleNumbers, data.connect);
        }
        function eventEnd(event, data) {
          if (data.handle) {
            removeClass(data.handle, options.cssClasses.active);
            scope_ActiveHandlesCount -= 1;
          }
          data.listeners.forEach(function(c) {
            scope_DocumentElement.removeEventListener(c[0], c[1]);
          });
          if (scope_ActiveHandlesCount === 0) {
            removeClass(scope_Target, options.cssClasses.drag);
            setZindex();
            if (event.cursor) {
              scope_Body.style.cursor = "";
              scope_Body.removeEventListener("selectstart", preventDefault);
            }
          }
          data.handleNumbers.forEach(function(handleNumber) {
            fireEvent("change", handleNumber);
            fireEvent("set", handleNumber);
            fireEvent("end", handleNumber);
          });
        }
        function eventStart(event, data) {
          if (data.handleNumbers.some(isHandleDisabled)) {
            return;
          }
          var handle;
          if (data.handleNumbers.length === 1) {
            var handleOrigin = scope_Handles[data.handleNumbers[0]];
            handle = handleOrigin.children[0];
            scope_ActiveHandlesCount += 1;
            addClass(handle, options.cssClasses.active);
          }
          event.stopPropagation();
          var listeners = [];
          var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
            target: event.target,
            handle,
            connect: data.connect,
            listeners,
            startCalcPoint: event.calcPoint,
            baseSize: baseSize(),
            pageOffset: event.pageOffset,
            handleNumbers: data.handleNumbers,
            buttonsProperty: event.buttons,
            locations: scope_Locations.slice()
          });
          var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
            target: event.target,
            handle,
            listeners,
            doNotReject: true,
            handleNumbers: data.handleNumbers
          });
          var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
            target: event.target,
            handle,
            listeners,
            doNotReject: true,
            handleNumbers: data.handleNumbers
          });
          listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));
          if (event.cursor) {
            scope_Body.style.cursor = getComputedStyle(event.target).cursor;
            if (scope_Handles.length > 1) {
              addClass(scope_Target, options.cssClasses.drag);
            }
            scope_Body.addEventListener("selectstart", preventDefault, false);
          }
          data.handleNumbers.forEach(function(handleNumber) {
            fireEvent("start", handleNumber);
          });
        }
        function eventTap(event) {
          event.stopPropagation();
          var proposal = calcPointToPercentage(event.calcPoint);
          var handleNumber = getClosestHandle(proposal);
          if (handleNumber === false) {
            return;
          }
          if (!options.events.snap) {
            addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
          }
          setHandle(handleNumber, proposal, true, true);
          setZindex();
          fireEvent("slide", handleNumber, true);
          fireEvent("update", handleNumber, true);
          if (!options.events.snap) {
            fireEvent("change", handleNumber, true);
            fireEvent("set", handleNumber, true);
          } else {
            eventStart(event, { handleNumbers: [handleNumber] });
          }
        }
        function eventHover(event) {
          var proposal = calcPointToPercentage(event.calcPoint);
          var to = scope_Spectrum.getStep(proposal);
          var value = scope_Spectrum.fromStepping(to);
          Object.keys(scope_Events).forEach(function(targetEvent) {
            if (targetEvent.split(".")[0] === "hover") {
              scope_Events[targetEvent].forEach(function(callback2) {
                callback2.call(scope_Self, value);
              });
            }
          });
        }
        function eventKeydown(event, handleNumber) {
          if (isSliderDisabled() || isHandleDisabled(handleNumber)) {
            return false;
          }
          var horizontalKeys = ["Left", "Right"];
          var verticalKeys = ["Down", "Up"];
          var largeStepKeys = ["PageDown", "PageUp"];
          var edgeKeys = ["Home", "End"];
          if (options.dir && !options.ort) {
            horizontalKeys.reverse();
          } else if (options.ort && !options.dir) {
            verticalKeys.reverse();
            largeStepKeys.reverse();
          }
          var key = event.key.replace("Arrow", "");
          var isLargeDown = key === largeStepKeys[0];
          var isLargeUp = key === largeStepKeys[1];
          var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;
          var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;
          var isMin = key === edgeKeys[0];
          var isMax = key === edgeKeys[1];
          if (!isDown && !isUp && !isMin && !isMax) {
            return true;
          }
          event.preventDefault();
          var to;
          if (isUp || isDown) {
            var direction = isDown ? 0 : 1;
            var steps = getNextStepsForHandle(handleNumber);
            var step = steps[direction];
            if (step === null) {
              return false;
            }
            if (step === false) {
              step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options.keyboardDefaultStep);
            }
            if (isLargeUp || isLargeDown) {
              step *= options.keyboardPageMultiplier;
            } else {
              step *= options.keyboardMultiplier;
            }
            step = Math.max(step, 1e-7);
            step = (isDown ? -1 : 1) * step;
            to = scope_Values[handleNumber] + step;
          } else if (isMax) {
            to = options.spectrum.xVal[options.spectrum.xVal.length - 1];
          } else {
            to = options.spectrum.xVal[0];
          }
          setHandle(handleNumber, scope_Spectrum.toStepping(to), true, true);
          fireEvent("slide", handleNumber);
          fireEvent("update", handleNumber);
          fireEvent("change", handleNumber);
          fireEvent("set", handleNumber);
          return false;
        }
        function bindSliderEvents(behaviour) {
          if (!behaviour.fixed) {
            scope_Handles.forEach(function(handle, index) {
              attachEvent(actions.start, handle.children[0], eventStart, {
                handleNumbers: [index]
              });
            });
          }
          if (behaviour.tap) {
            attachEvent(actions.start, scope_Base, eventTap, {});
          }
          if (behaviour.hover) {
            attachEvent(actions.move, scope_Base, eventHover, {
              hover: true
            });
          }
          if (behaviour.drag) {
            scope_Connects.forEach(function(connect, index) {
              if (connect === false || index === 0 || index === scope_Connects.length - 1) {
                return;
              }
              var handleBefore = scope_Handles[index - 1];
              var handleAfter = scope_Handles[index];
              var eventHolders = [connect];
              var handlesToDrag = [handleBefore, handleAfter];
              var handleNumbersToDrag = [index - 1, index];
              addClass(connect, options.cssClasses.draggable);
              if (behaviour.fixed) {
                eventHolders.push(handleBefore.children[0]);
                eventHolders.push(handleAfter.children[0]);
              }
              if (behaviour.dragAll) {
                handlesToDrag = scope_Handles;
                handleNumbersToDrag = scope_HandleNumbers;
              }
              eventHolders.forEach(function(eventHolder) {
                attachEvent(actions.start, eventHolder, eventStart, {
                  handles: handlesToDrag,
                  handleNumbers: handleNumbersToDrag,
                  connect
                });
              });
            });
          }
        }
        function bindEvent(namespacedEvent, callback2) {
          scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
          scope_Events[namespacedEvent].push(callback2);
          if (namespacedEvent.split(".")[0] === "update") {
            scope_Handles.forEach(function(a, index) {
              fireEvent("update", index);
            });
          }
        }
        function isInternalNamespace(namespace) {
          return namespace === INTERNAL_EVENT_NS.aria || namespace === INTERNAL_EVENT_NS.tooltips;
        }
        function removeEvent(namespacedEvent) {
          var event = namespacedEvent && namespacedEvent.split(".")[0];
          var namespace = event ? namespacedEvent.substring(event.length) : namespacedEvent;
          Object.keys(scope_Events).forEach(function(bind2) {
            var tEvent = bind2.split(".")[0];
            var tNamespace = bind2.substring(tEvent.length);
            if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {
              if (!isInternalNamespace(tNamespace) || namespace === tNamespace) {
                delete scope_Events[bind2];
              }
            }
          });
        }
        function fireEvent(eventName, handleNumber, tap) {
          Object.keys(scope_Events).forEach(function(targetEvent) {
            var eventType = targetEvent.split(".")[0];
            if (eventName === eventType) {
              scope_Events[targetEvent].forEach(function(callback2) {
                callback2.call(scope_Self, scope_Values.map(options.format.to), handleNumber, scope_Values.slice(), tap || false, scope_Locations.slice(), scope_Self);
              });
            }
          });
        }
        function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue) {
          var distance;
          if (scope_Handles.length > 1 && !options.events.unconstrained) {
            if (lookBackward && handleNumber > 0) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, false);
              to = Math.max(to, distance);
            }
            if (lookForward && handleNumber < scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, true);
              to = Math.min(to, distance);
            }
          }
          if (scope_Handles.length > 1 && options.limit) {
            if (lookBackward && handleNumber > 0) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, false);
              to = Math.min(to, distance);
            }
            if (lookForward && handleNumber < scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, true);
              to = Math.max(to, distance);
            }
          }
          if (options.padding) {
            if (handleNumber === 0) {
              distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], false);
              to = Math.max(to, distance);
            }
            if (handleNumber === scope_Handles.length - 1) {
              distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], true);
              to = Math.min(to, distance);
            }
          }
          to = scope_Spectrum.getStep(to);
          to = limit(to);
          if (to === reference[handleNumber] && !getValue) {
            return false;
          }
          return to;
        }
        function inRuleOrder(v, a) {
          var o = options.ort;
          return (o ? a : v) + ", " + (o ? v : a);
        }
        function moveHandles(upward, proposal, locations, handleNumbers, connect) {
          var proposals = locations.slice();
          var firstHandle = handleNumbers[0];
          var b = [!upward, upward];
          var f = [upward, !upward];
          handleNumbers = handleNumbers.slice();
          if (upward) {
            handleNumbers.reverse();
          }
          if (handleNumbers.length > 1) {
            handleNumbers.forEach(function(handleNumber, o) {
              var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], false);
              if (to === false) {
                proposal = 0;
              } else {
                proposal = to - proposals[handleNumber];
                proposals[handleNumber] = to;
              }
            });
          } else {
            b = f = [true];
          }
          var state = false;
          handleNumbers.forEach(function(handleNumber, o) {
            state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state;
          });
          if (state) {
            handleNumbers.forEach(function(handleNumber) {
              fireEvent("update", handleNumber);
              fireEvent("slide", handleNumber);
            });
            if (connect != void 0) {
              fireEvent("drag", firstHandle);
            }
          }
        }
        function transformDirection(a, b) {
          return options.dir ? 100 - a - b : a;
        }
        function updateHandlePosition(handleNumber, to) {
          scope_Locations[handleNumber] = to;
          scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);
          var translation = transformDirection(to, 0) - scope_DirOffset;
          var translateRule = "translate(" + inRuleOrder(translation + "%", "0") + ")";
          scope_Handles[handleNumber].style[options.transformRule] = translateRule;
          updateConnect(handleNumber);
          updateConnect(handleNumber + 1);
        }
        function setZindex() {
          scope_HandleNumbers.forEach(function(handleNumber) {
            var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;
            var zIndex = 3 + (scope_Handles.length + dir * handleNumber);
            scope_Handles[handleNumber].style.zIndex = String(zIndex);
          });
        }
        function setHandle(handleNumber, to, lookBackward, lookForward, exactInput) {
          if (!exactInput) {
            to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false);
          }
          if (to === false) {
            return false;
          }
          updateHandlePosition(handleNumber, to);
          return true;
        }
        function updateConnect(index) {
          if (!scope_Connects[index]) {
            return;
          }
          var l = 0;
          var h = 100;
          if (index !== 0) {
            l = scope_Locations[index - 1];
          }
          if (index !== scope_Connects.length - 1) {
            h = scope_Locations[index];
          }
          var connectWidth = h - l;
          var translateRule = "translate(" + inRuleOrder(transformDirection(l, connectWidth) + "%", "0") + ")";
          var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";
          scope_Connects[index].style[options.transformRule] = translateRule + " " + scaleRule;
        }
        function resolveToValue(to, handleNumber) {
          if (to === null || to === false || to === void 0) {
            return scope_Locations[handleNumber];
          }
          if (typeof to === "number") {
            to = String(to);
          }
          to = options.format.from(to);
          if (to !== false) {
            to = scope_Spectrum.toStepping(to);
          }
          if (to === false || isNaN(to)) {
            return scope_Locations[handleNumber];
          }
          return to;
        }
        function valueSet(input, fireSetEvent, exactInput) {
          var values = asArray(input);
          var isInit = scope_Locations[0] === void 0;
          fireSetEvent = fireSetEvent === void 0 ? true : fireSetEvent;
          if (options.animate && !isInit) {
            addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
          }
          scope_HandleNumbers.forEach(function(handleNumber) {
            setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), true, false, exactInput);
          });
          var i = scope_HandleNumbers.length === 1 ? 0 : 1;
          if (isInit && scope_Spectrum.hasNoSize()) {
            exactInput = true;
            scope_Locations[0] = 0;
            if (scope_HandleNumbers.length > 1) {
              var space_1 = 100 / (scope_HandleNumbers.length - 1);
              scope_HandleNumbers.forEach(function(handleNumber) {
                scope_Locations[handleNumber] = handleNumber * space_1;
              });
            }
          }
          for (; i < scope_HandleNumbers.length; ++i) {
            scope_HandleNumbers.forEach(function(handleNumber) {
              setHandle(handleNumber, scope_Locations[handleNumber], true, true, exactInput);
            });
          }
          setZindex();
          scope_HandleNumbers.forEach(function(handleNumber) {
            fireEvent("update", handleNumber);
            if (values[handleNumber] !== null && fireSetEvent) {
              fireEvent("set", handleNumber);
            }
          });
        }
        function valueReset(fireSetEvent) {
          valueSet(options.start, fireSetEvent);
        }
        function valueSetHandle(handleNumber, value, fireSetEvent, exactInput) {
          handleNumber = Number(handleNumber);
          if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {
            throw new Error("noUiSlider: invalid handle number, got: " + handleNumber);
          }
          setHandle(handleNumber, resolveToValue(value, handleNumber), true, true, exactInput);
          fireEvent("update", handleNumber);
          if (fireSetEvent) {
            fireEvent("set", handleNumber);
          }
        }
        function valueGet(unencoded) {
          if (unencoded === void 0) {
            unencoded = false;
          }
          if (unencoded) {
            return scope_Values.length === 1 ? scope_Values[0] : scope_Values.slice(0);
          }
          var values = scope_Values.map(options.format.to);
          if (values.length === 1) {
            return values[0];
          }
          return values;
        }
        function destroy() {
          removeEvent(INTERNAL_EVENT_NS.aria);
          removeEvent(INTERNAL_EVENT_NS.tooltips);
          Object.keys(options.cssClasses).forEach(function(key) {
            removeClass(scope_Target, options.cssClasses[key]);
          });
          while (scope_Target.firstChild) {
            scope_Target.removeChild(scope_Target.firstChild);
          }
          delete scope_Target.noUiSlider;
        }
        function getNextStepsForHandle(handleNumber) {
          var location = scope_Locations[handleNumber];
          var nearbySteps = scope_Spectrum.getNearbySteps(location);
          var value = scope_Values[handleNumber];
          var increment = nearbySteps.thisStep.step;
          var decrement = null;
          if (options.snap) {
            return [
              value - nearbySteps.stepBefore.startValue || null,
              nearbySteps.stepAfter.startValue - value || null
            ];
          }
          if (increment !== false) {
            if (value + increment > nearbySteps.stepAfter.startValue) {
              increment = nearbySteps.stepAfter.startValue - value;
            }
          }
          if (value > nearbySteps.thisStep.startValue) {
            decrement = nearbySteps.thisStep.step;
          } else if (nearbySteps.stepBefore.step === false) {
            decrement = false;
          } else {
            decrement = value - nearbySteps.stepBefore.highestStep;
          }
          if (location === 100) {
            increment = null;
          } else if (location === 0) {
            decrement = null;
          }
          var stepDecimals = scope_Spectrum.countStepDecimals();
          if (increment !== null && increment !== false) {
            increment = Number(increment.toFixed(stepDecimals));
          }
          if (decrement !== null && decrement !== false) {
            decrement = Number(decrement.toFixed(stepDecimals));
          }
          return [decrement, increment];
        }
        function getNextSteps() {
          return scope_HandleNumbers.map(getNextStepsForHandle);
        }
        function updateOptions(optionsToUpdate, fireSetEvent) {
          var v = valueGet();
          var updateAble = [
            "margin",
            "limit",
            "padding",
            "range",
            "animate",
            "snap",
            "step",
            "format",
            "pips",
            "tooltips"
          ];
          updateAble.forEach(function(name) {
            if (optionsToUpdate[name] !== void 0) {
              originalOptions[name] = optionsToUpdate[name];
            }
          });
          var newOptions = testOptions(originalOptions);
          updateAble.forEach(function(name) {
            if (optionsToUpdate[name] !== void 0) {
              options[name] = newOptions[name];
            }
          });
          scope_Spectrum = newOptions.spectrum;
          options.margin = newOptions.margin;
          options.limit = newOptions.limit;
          options.padding = newOptions.padding;
          if (options.pips) {
            pips(options.pips);
          } else {
            removePips();
          }
          if (options.tooltips) {
            tooltips();
          } else {
            removeTooltips();
          }
          scope_Locations = [];
          valueSet(isSet(optionsToUpdate.start) ? optionsToUpdate.start : v, fireSetEvent);
        }
        function setupSlider() {
          scope_Base = addSlider(scope_Target);
          addElements(options.connect, scope_Base);
          bindSliderEvents(options.events);
          valueSet(options.start);
          if (options.pips) {
            pips(options.pips);
          }
          if (options.tooltips) {
            tooltips();
          }
          aria();
        }
        setupSlider();
        var scope_Self = {
          destroy,
          steps: getNextSteps,
          on: bindEvent,
          off: removeEvent,
          get: valueGet,
          set: valueSet,
          setHandle: valueSetHandle,
          reset: valueReset,
          __moveHandles: function(upward, proposal, handleNumbers) {
            moveHandles(upward, proposal, scope_Locations, handleNumbers);
          },
          options: originalOptions,
          updateOptions,
          target: scope_Target,
          removePips,
          removeTooltips,
          getPositions: function() {
            return scope_Locations.slice();
          },
          getTooltips: function() {
            return scope_Tooltips;
          },
          getOrigins: function() {
            return scope_Handles;
          },
          pips
        };
        return scope_Self;
      }
      function initialize(target, originalOptions) {
        if (!target || !target.nodeName) {
          throw new Error("noUiSlider: create requires a single element, got: " + target);
        }
        if (target.noUiSlider) {
          throw new Error("noUiSlider: Slider was already initialized.");
        }
        var options = testOptions(originalOptions);
        var api = scope(target, options, originalOptions);
        target.noUiSlider = api;
        return api;
      }
      var nouislider = {
        __spectrum: Spectrum,
        cssClasses,
        create: initialize
      };
      exports2.create = initialize;
      exports2.cssClasses = cssClasses;
      exports2["default"] = nouislider;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// src/main.ts
__export(exports, {
  default: () => DataAnalysisPlugin
});
var import_json2csv = __toModule(require_json2csv_umd());
var import_luxon3 = __toModule(require_luxon());
var import_obsidian9 = __toModule(require("obsidian"));

// node_modules/obsidian-community-lib/dist/utils.js
var feather = __toModule(require_feather());
var import_obsidian = __toModule(require("obsidian"));
function addFeatherIcon(name, attr2 = { viewBox: "0 0 24 24", width: "100", height: "100" }) {
  if (feather.icons[name]) {
    const iconName = `feather-${name}`;
    (0, import_obsidian.addIcon)(iconName, feather.icons[name].toSvg(attr2));
    return iconName;
  } else {
    throw Error(`This Icon (${name}) doesn't exist in the Feather Library.`);
  }
}
async function openView(app, viewType, viewClass, side = "right") {
  let leaf = null;
  for (leaf of app.workspace.getLeavesOfType(viewType)) {
    if (leaf.view instanceof viewClass) {
      return leaf.view;
    }
    await leaf.setViewState({ type: "empty" });
    break;
  }
  leaf = (leaf !== null && leaf !== void 0 ? leaf : side === "right") ? app.workspace.getRightLeaf(false) : app.workspace.getLeftLeaf(false);
  await leaf.setViewState({
    type: viewType,
    active: true
  });
  return leaf.view;
}

// src/ChartModal.ts
var import_obsidian2 = __toModule(require("obsidian"));

// node_modules/svelte/internal/index.mjs
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
var tasks = new Set();
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_attributes(node, attributes) {
  const descriptors2 = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors2[key] && descriptors2[key].set) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function select_option(select, value) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  select.selectedIndex = -1;
}
function select_value(select) {
  const selected_option = select.querySelector(":checked") || select.options[0];
  return selected_option && selected_option.__value;
}
var active_docs = new Set();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback2 = render_callbacks[i];
      if (!seen_callbacks.has(callback2)) {
        seen_callbacks.add(callback2);
        callback2();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback2) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback2) {
        if (detach2)
          block.d(1);
        callback2();
      }
    });
    block.o(local);
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
function bind(component, name, callback2) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback2;
    callback2(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance10, create_fragment11, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance10 ? instance10(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment11 ? create_fragment11($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback2) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback2);
      return () => {
        const index = callbacks.indexOf(callback2);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback2) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback2);
    return () => {
      const index = callbacks.indexOf(callback2);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// src/Components/Chart.svelte
var import_obsidian_dataview = __toModule(require_lib());

// src/analyses.ts
function getPearsonCorrelation(xs, ys, skipQuantCheck = false) {
  if (xs.length <= 1 || ys.length <= 1)
    return null;
  if (!skipQuantCheck && (!isQuant(xs) || !isQuant(ys)))
    return null;
  const n = xs.length;
  if (n !== ys.length)
    throw new Error("Arrays must be the same length");
  let sum_x = 0;
  let sum_y = 0;
  let sum_xy = 0;
  let sum_xx = 0;
  let sum_yy = 0;
  for (let i = 0; i < n; i++) {
    const x = xs[i];
    const y = ys[i];
    sum_x += x;
    sum_y += y;
    sum_xx += x * x;
    sum_yy += y * y;
    sum_xy += x * y;
  }
  const corr = (n * sum_xy - sum_x * sum_y) / Math.sqrt((n * sum_xx - sum_x * sum_x) * (n * sum_yy - sum_y * sum_y));
  return corr;
}
function getPointBiserialCorrelation(xs, ys) {
  if (xs.length <= 1 || ys.length <= 1 || !isBinary(xs) || !isQuant(ys))
    return null;
  const m0 = [], m1 = [];
  xs.forEach((x, i) => {
    const y = ys[i];
    if (!x)
      m0.push(y);
    else
      m1.push(y);
  });
  return (m1.length - m0.length) / getStdDev(ys) * Math.sqrt(m1.length * m0.length / xs.length);
}
function isQuant(xs) {
  return xs.length && xs.every((x) => typeof x === "number");
}
function isBinary(xs) {
  return xs.length && xs.every((x) => x === 0 || x === 1 || x === false || x === true);
}
function getMean(xs) {
  if (!isQuant(xs))
    return null;
  return xs.reduce((a, b) => a + b) / xs.length;
}
function getMedian(xs) {
  if (!isQuant(xs))
    return null;
  const sorted = xs.slice().sort((a, b) => a - b);
  return sorted[Math.floor(sorted.length / 2)];
}
function getMode(xs) {
  const flattened = xs.flat();
  const counts = {};
  flattened.forEach((x) => {
    if (counts[x])
      counts[x] = counts[x] + 1;
    else
      counts[x] = 1;
  });
  const max = Math.max(...Object.values(counts));
  return Object.keys(counts).filter((x) => counts[x] === max);
}
function getVariance(xs) {
  if (!isQuant(xs))
    return null;
  const mean = getMean(xs);
  return xs.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / xs.length;
}
function getStdDev(xs) {
  if (!isQuant(xs))
    return null;
  return Math.sqrt(getVariance(xs));
}

// node_modules/svelte-chartjs/src/utils.js
function clean($$props, extra_keys) {
  let keys = ["children", "$$scope", "$$slots"].concat(extra_keys);
  const rest = {};
  for (const key of Object.keys($$props)) {
    if (!keys.includes(key)) {
      rest[key] = $$props[key];
    }
  }
  return rest;
}

// node_modules/chart.js/dist/chunks/helpers.segment.js
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg, updateFn) {
  const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
  let ticking = false;
  let args = [];
  return function(...rest) {
    args = updateArgs(rest);
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, args);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function noop2() {
}
var uid = function() {
  let id = 0;
  return function() {
    return id++;
  };
}();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.substr(0, 7) === "[object" && type.substr(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
var isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone$1(source) {
  if (isArray(source)) {
    return source.map(clone$1);
  }
  if (isObject(source)) {
    const target = Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone$1(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone$1(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [source];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  for (let i = 0; i < ilen; ++i) {
    source = sources[i];
    if (!isObject(source)) {
      continue;
    }
    const keys = Object.keys(source);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, source, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, { merger: _mergerIf });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone$1(sval);
  }
}
var emptyString = "";
var dot = ".";
function indexOfDotOrLength(key, start) {
  const idx = key.indexOf(dot, start);
  return idx === -1 ? key.length : idx;
}
function resolveObjectKey(obj, key) {
  if (key === emptyString) {
    return obj;
  }
  let pos = 0;
  let idx = indexOfDotOrLength(key, pos);
  while (obj && idx > pos) {
    obj = obj[key.substr(pos, idx - pos)];
    pos = idx + 1;
    idx = indexOfDotOrLength(key, pos);
  }
  return obj;
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
var atEdge = (t) => t === 0 || t === 1;
var elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
var elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
var effects = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: (t) => Math.sin(t * HALF_PI),
  easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
  },
  easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < 1 / d) {
      return m * t * t;
    }
    if (t < 2 / d) {
      return m * (t -= 1.5 / d) * t + 0.75;
    }
    if (t < 2.5 / d) {
      return m * (t -= 2.25 / d) * t + 0.9375;
    }
    return m * (t -= 2.625 / d) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
var map = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = "0123456789ABCDEF";
var h1 = (b) => hex[b & 15];
var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
var eq = (b) => (b & 240) >> 4 === (b & 15);
function isShort(v) {
  return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
}
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map[str[1]] * 17,
        g: 255 & map[str[2]] * 17,
        b: 255 & map[str[3]] * 17,
        a: len === 5 ? map[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map[str[1]] << 4 | map[str[2]],
        g: map[str[3]] << 4 | map[str[4]],
        b: map[str[5]] << 4 | map[str[6]],
        a: len === 9 ? map[str[7]] << 4 | map[str[8]] : 255
      };
    }
  }
  return ret;
}
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : "") : v;
}
function round(v) {
  return v + 0.5 | 0;
}
var lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = 255 & (m[8] ? p2b(v) : v * 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : r);
  g = 255 & (m[4] ? p2b(g) : g);
  b = 255 & (m[6] ? p2b(b) : b);
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
    h = h * 60 + 0.5;
  }
  return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h, s, l) {
  return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
  return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
}
var map$1 = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names);
  const tkeys = Object.keys(map$1);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map$1[k]);
    }
    k = parseInt(names[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
var names$1;
function nameParse(str) {
  if (!names$1) {
    names$1 = unpack();
    names$1.transparent = [0, 0, 0, 0];
  }
  const a = names$1[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : this._rgb;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : this._rgb;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : this._rgb;
  }
  mix(color2, weight) {
    const me = this;
    if (color2) {
      const c1 = me.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      me.rgb = c1;
    }
    return me;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};
function index_esm(input) {
  return new Color(input);
}
var isPatternOrGradient = (value) => value instanceof CanvasGradient || value instanceof CanvasPattern;
function color(value) {
  return isPatternOrGradient(value) ? value : index_esm(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
}
var overrides = Object.create(null);
var descriptors = Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
};
var defaults = new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
});
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  let type, xOffset, yOffset, size, cornerRadius;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      ctx.arc(x, y, radius, 0, TAU);
      ctx.closePath();
      break;
    case "triangle":
      ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        ctx.rect(x - size, y - size, 2 * size, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + yOffset, y - xOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      break;
    case "star":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      rad += QUARTER_PI;
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      break;
    case "line":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function renderText(ctx, text2, x, y, font, opts = {}) {
  const lines = isArray(text2) ? text2 : [text2];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += font.lineHeight;
  }
  ctx.restore();
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
var LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
var FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
var numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, { top: "y", right: "x", bottom: "y", left: "x" });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = "";
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index !== void 0 && isArray(value)) {
      value = value[index % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index) => table[index] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return { lo, hi };
}
var _lookupByKey = (table, key, value) => _lookup(table, value, (index) => table[index][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index) => table[index][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [listener]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index = listeners.indexOf(listener);
  if (index !== -1) {
    listeners.splice(index, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = new Set();
  let i, ilen;
  for (i = 0, ilen = items.length; i < ilen; ++i) {
    set2.add(items[i]);
  }
  if (set2.size === ilen) {
    return items;
  }
  return Array.from(set2);
}
function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget2 = () => scopes[0]) {
  if (!defined(fallback)) {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: rootScopes,
    _fallback: fallback,
    _getTarget: getTarget2,
    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget2());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = { scriptable: true, indexable: true }) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, value, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  value = value(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (defined(_context.index) && isIndexable(prop)) {
    value = value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s) => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [...parentScopes, ...rootScopes];
  const set2 = new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (defined(fallback) && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [""], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target;
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (defined(value)) {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (defined(value)) {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
var EPSILON = Number.EPSILON || 1e-14;
var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle2 = (element2) => window.getComputedStyle(element2, null);
function getStyle(el, property) {
  return getComputedStyle2(el).getPropertyValue(property);
}
var positions = ["top", "right", "bottom", "left"];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(evt, canvas) {
  const e = evt.native || evt;
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return { x, y, box };
}
function getRelativePosition(evt, chart) {
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle2(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(evt, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle2(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle2(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = deviceHeight / pixelRatio;
  chart.width = deviceWidth / pixelRatio;
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener("test", null, options);
    window.removeEventListener("test", null, options);
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element2, property) {
  const value = getStyle(element2, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = { x: p1.cp2x, y: p1.cp2y };
  const cp2 = { x: p2.cp1x, y: p2.cp1y };
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}
var intlCache = new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: (x) => x
  };
}
function normalizeSegment({ start, end, count, loop, style }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property);
  const count = points.length;
  let { start, end, loop } = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return { start, end, loop, style: segment.style };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [segment];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({ start: subStart, end: i, loop, count, style }));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({ start: subStart, end, loop, count, style }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return { start, end };
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({ start: start % count, end: (end - 1) % count, loop });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({ start: start % count, end: last % count, loop });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [{ start, end, loop }], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({ start: s % count, end: e % count, loop: l, style: st });
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
}

// node_modules/chart.js/dist/chart.esm.js
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw2 = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw2 = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from, to, factor) {
    return factor > 0.5 ? to : from;
  },
  color(from, to, factor) {
    const c0 = color(from || transparent);
    const c1 = c0.valid && color(to || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
  },
  number(from, to, factor) {
    return from + (to - from) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to) {
    const currentValue = target[prop];
    to = resolve([cfg.to, to, currentValue, cfg.from]);
    const from = resolve([cfg.from, currentValue, to]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from;
    this._to = to;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([cfg.to, to, currentValue, cfg.from]);
      this._from = resolve([cfg.from, currentValue, to]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from = this._from;
    const loop = this._loop;
    const to = this._to;
    let factor;
    this._active = from !== to && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from, to, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({ res, rej });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
};
var numbers = ["x", "y", "borderWidth", "radius", "tension"];
var colors = ["color", "borderColor", "backgroundColor"];
defaults.set("animation", {
  delay: void 0,
  duration: 1e3,
  easing: "easeOutQuart",
  fn: void 0,
  from: void 0,
  loop: void 0,
  to: void 0,
  type: void 0
});
var animationOptions = Object.keys(defaults.animation);
defaults.describe("animation", {
  _fallback: false,
  _indexable: false,
  _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
});
defaults.set("animations", {
  colors: {
    type: "color",
    properties: colors
  },
  numbers: {
    type: "number",
    properties: numbers
  }
});
defaults.describe("animations", {
  _fallback: "animation"
});
defaults.set("transitions", {
  active: {
    animation: {
      duration: 400
    }
  },
  resize: {
    animation: {
      duration: 0
    }
  },
  show: {
    animations: {
      colors: {
        from: "transparent"
      },
      visible: {
        type: "boolean",
        duration: 0
      }
    }
  },
  hide: {
    animations: {
      colors: {
        to: "transparent"
      },
      visible: {
        type: "boolean",
        easing: "linear",
        fn: (v) => v | 0
      }
    }
  }
});
var Animations = class {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, { $shared: false, $animations: {} });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l;
  if (isObject(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
  }
}
function getFirstScaleId(chart, axis) {
  const scales2 = chart.scales;
  return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
}
function createDatasetContext(parent, index) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index,
    index,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index, element2) {
  return createContext(parent, {
    active: false,
    dataIndex: index,
    parsed: void 0,
    raw: void 0,
    element: element2,
    index,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && { keys: getSortedDatasetIndices(chart, true), values: null };
var DatasetController = class {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.$context = void 0;
    this._syncList = [];
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index], index),
        [vAxis]: vScale.parse(data[index], index)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(item[0], index),
        y: yScale.parse(item[1], index)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
      };
    }
    return parsed;
  }
  getParsed(index) {
    return this._cachedMeta._parsed[index];
  }
  getDataElement(index) {
    return this._cachedMeta.data[index];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]
    };
    return applyStack(stack, value, meta.index, { mode });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements2 = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element2 = elements2[i];
      if (element2.hidden) {
        continue;
      }
      if (element2.active && drawActiveElementsOnTop) {
        active.push(element2);
      } else {
        element2.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index, active) {
    const mode = active ? "active" : "default";
    return index === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
  }
  getContext(index, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index >= 0 && index < this._cachedMeta.data.length) {
      const element2 = this._cachedMeta.data[index];
      context = element2.$context || (element2.$context = createDataContext(this.getContext(), index, element2));
      context.parsed = this.getParsed(index);
      context.raw = dataset.data[index];
      context.index = context.dataIndex = index;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index);
  }
  _resolveElementOptions(elementType, mode = "default", index) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index, active);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  updateElement(element2, index, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element2, properties);
    } else {
      this._resolveAnimations(index, mode).update(element2, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element2, index, mode, active) {
    element2.active = active;
    const options = this.getStyle(index, active);
    this._resolveAnimations(index, mode, active).update(element2, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element2, datasetIndex, index) {
    this._setStyle(element2, index, "active", false);
  }
  setHoverStyle(element2, datasetIndex, index) {
    this._setStyle(element2, index, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element2 = this._cachedMeta.dataset;
    if (element2) {
      this._setStyle(element2, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element2 = this._cachedMeta.dataset;
    if (element2) {
      this._setStyle(element2, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element2, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([this.index, ...args]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync(["_insertElements", this.getDataset().data.length - count, count]);
  }
  _onDataPop() {
    this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
  }
  _onDataShift() {
    this._sync(["_removeElements", 0, 1]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync(["_removeElements", start, count]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync(["_insertElements", start, newCount]);
    }
  }
  _onDataUnshift() {
    this._sync(["_insertElements", 0, arguments.length]);
  }
};
DatasetController.defaults = {};
DatasetController.prototype.datasetElementType = null;
DatasetController.prototype.dataElementType = null;
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index] - size / 2
  };
}
function computeFlexCategoryTraits(index, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index];
  let prev = index > 0 ? pixels[index - 1] : null;
  let next = index < pixels.length - 1 ? pixels[index + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return { start, end, reverse, top, bottom };
}
function setBorderSkipped(properties, options, stack, index) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index) {
      edge = top;
    } else if ((stack._bottom || 0) === index) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = class extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === "reset";
    const { index, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? { base, head: base } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const metasets = iScale.getMatchingVisibleMetas(this._type);
    const stacked = iScale.options.stacked;
    const ilen = metasets.length;
    const stacks = [];
    let i, item;
    for (i = 0; i < ilen; ++i) {
      item = metasets[i];
      if (!item.controller.options.grouped) {
        continue;
      }
      if (typeof dataIndex !== "undefined") {
        const val = item.controller.getParsed(dataIndex)[item.controller._cachedMeta.vScale.axis];
        if (isNullOrUndef(val) || isNaN(val)) {
          continue;
        }
      }
      if (stacked === false || stacks.indexOf(item.stack) === -1 || stacked === void 0 && item.stack === void 0) {
        stacks.push(item.stack);
      }
      if (item.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index) {
    return this._getStacks(void 0, index).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index = name !== void 0 ? stacks.indexOf(name) : -1;
    return index === -1 ? stacks.length - 1 : index;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index) {
    const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      head = base + size;
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
      const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : void 0);
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }
};
BarController.id = "bar";
BarController.defaults = {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "base", "width", "height"]
    }
  }
};
BarController.overrides = {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
};
var BubbleController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: meta.label,
      value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  resolveDataElementOptions(index, mode) {
    const parsed = this.getParsed(index);
    let values = super.resolveDataElementOptions(index, mode);
    if (values.$shared) {
      values = Object.assign({}, values, { $shared: false });
    }
    const radius = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
};
BubbleController.id = "bubble";
BubbleController.defaults = {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "borderWidth", "radius"]
    }
  }
};
BubbleController.overrides = {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        }
      }
    }
  }
};
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return { ratioX, ratioY, offsetX, offsetY };
}
var DoughnutController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i2) => +data[i2];
      if (isObject(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data[i2], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index], chart.options.locale);
    return {
      label: labels[index] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
DoughnutController.id = "doughnut";
DoughnutController.defaults = {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
};
DoughnutController.descriptors = {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing"
};
DoughnutController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(tooltipItem) {
          let dataLabel = tooltipItem.label;
          const value = ": " + tooltipItem.formattedValue;
          if (isArray(dataLabel)) {
            dataLabel = dataLabel.slice();
            dataLabel[0] += value;
          } else {
            dataLabel += value;
          }
          return dataLabel;
        }
      }
    }
  }
};
var LineController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && parsed[iAxis] - prevParsed[iAxis] > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
};
LineController.id = "line";
LineController.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
};
LineController.overrides = {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
};
function getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, _parsed } = meta;
    const axis = iScale.axis;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1), start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return { start, count };
}
function scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
var PolarAreaController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index].r, chart.options.locale);
    return {
      label: labels[index] || "",
      value
    };
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const dataset = this.getDataset();
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const dataset = this.getDataset();
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element2, index) => {
      if (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index, mode, defaultAngle) {
    return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
  }
};
PolarAreaController.id = "polarArea";
PolarAreaController.defaults = {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
    }
  },
  indexAxis: "r",
  startAngle: 0
};
PolarAreaController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(context) {
          return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
        }
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
};
var PieController = class extends DoughnutController {
};
PieController.id = "pie";
PieController.defaults = {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
};
var RadarController = class extends DatasetController {
  getLabelAndValue(index) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: vScale.getLabels()[index],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const dataset = this.getDataset();
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
};
RadarController.id = "radar";
RadarController.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
};
RadarController.overrides = {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
};
var ScatterController = class extends LineController {
};
ScatterController.id = "scatter";
ScatterController.defaults = {
  showLine: false,
  fill: false
};
ScatterController.overrides = {
  interaction: {
    mode: "point"
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(item) {
          return "(" + item.label + ", " + item.formattedValue + ")";
        }
      }
    }
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
};
var controllers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PolarAreaController,
  PieController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapter = class {
  constructor(options) {
    this.options = options || {};
  }
  formats() {
    return abstract();
  }
  parse(value, format) {
    return abstract();
  }
  format(timestamp, format) {
    return abstract();
  }
  add(timestamp, amount, unit) {
    return abstract();
  }
  diff(a, b, unit) {
    return abstract();
  }
  startOf(timestamp, unit, weekday) {
    return abstract();
  }
  endOf(timestamp, unit) {
    return abstract();
  }
};
DateAdapter.override = function(members) {
  Object.assign(DateAdapter.prototype, members);
};
var adapters = {
  _date: DateAdapter
};
function getRelativePosition2(e, chart) {
  if ("native" in e) {
    return {
      x: e.x,
      y: e.y
    };
  }
  return getRelativePosition(e, chart);
}
function evaluateAllVisibleItems(chart, handler) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  let index, data, element2;
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    ({ index, data } = metasets[i]);
    for (let j = 0, jlen = data.length; j < jlen; ++j) {
      element2 = data[j];
      if (!element2.skip) {
        handler(element2, index, j);
      }
    }
  }
}
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return { lo: start.lo, hi: end.hi };
      }
    }
  }
  return { lo: 0, hi: data.length - 1 };
}
function optimizedEvaluateItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index, data } = metasets[i];
    const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element2 = data[j];
      if (!element2.skip) {
        handler(element2, index, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition) {
  const items = [];
  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
    return items;
  }
  const evaluationFunc = function(element2, datasetIndex, index) {
    if (element2.inRange(position.x, position.y, useFinalPosition)) {
      items.push({ element: element2, datasetIndex, index });
    }
  };
  optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element2, datasetIndex, index) {
    const { startAngle, endAngle } = element2.getProps(["startAngle", "endAngle"], useFinalPosition);
    const { angle } = getAngleFromPoint(element2, { x: position.x, y: position.y });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({ element: element2, datasetIndex, index });
    }
  }
  optimizedEvaluateItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element2, datasetIndex, index) {
    const inRange2 = element2.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element2.getCenterPoint(useFinalPosition);
    const pointInArea = _isPointInArea(center, chart.chartArea, chart._minPadding);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [{ element: element2, datasetIndex, index }];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({ element: element2, datasetIndex, index });
    }
  }
  optimizedEvaluateItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition) {
  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition);
}
function getAxisItems(chart, e, options, useFinalPosition) {
  const position = getRelativePosition2(e, chart);
  const items = [];
  const axis = options.axis;
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateAllVisibleItems(chart, (element2, datasetIndex, index) => {
    if (element2[rangeMethod](position[axis], useFinalPosition)) {
      items.push({ element: element2, datasetIndex, index });
    }
    if (element2.inRange(position.x, position.y, useFinalPosition)) {
      intersectsItem = true;
    }
  });
  if (options.intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition2(e, chart);
      const axis = options.axis || "x";
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index = items[0].index;
        const element2 = meta.data[index];
        if (element2 && !element2.skip) {
          elements2.push({ element: element2, datasetIndex: meta.index, index });
        }
      });
      return elements2;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition2(e, chart);
      const axis = options.axis || "xy";
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({ element: data[i], datasetIndex, index: i });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition2(e, chart);
      const axis = options.axis || "xy";
      return getIntersectItems(chart, position, axis, useFinalPosition);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition2(e, chart);
      const axis = options.axis || "xy";
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition);
    },
    x(chart, e, options, useFinalPosition) {
      return getAxisItems(chart, e, { axis: "x", intersect: options.intersect }, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      return getAxisItems(chart, e, { axis: "y", intersect: options.intersect }, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = ["left", "top", "right", "bottom"];
function filterByPosition(array, position) {
  return array.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || { size: 0, count: 1 };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = { left: 0, top: 0, right: 0, bottom: 0 };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
defaults.set("layout", {
  autoPadding: true,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
});
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [{
        z: 0,
        draw(chartArea) {
          item.draw(chartArea);
        }
      }];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index !== -1) {
      chart.boxes.splice(index, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, { left: 0, top: 0, right: 0, bottom: 0 });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element2, width, height, aspectRatio) {
    width = Math.max(0, width || element2.width);
    height = height || element2.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, { childList: true, subtree: true });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, { childList: true, subtree: true });
  return observer;
}
var drpListeningCharts = new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart, (args) => {
    const event = args[0];
    return [event, event.offsetX, event.offsetY];
  });
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    ["height", "width"].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var Element = class {
  constructor() {
    this.x = void 0;
    this.y = void 0;
    this.active = false;
    this.options = void 0;
    this.$animations = void 0;
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return { x, y };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
Element.defaults = {};
Element.defaultRoutes = void 0;
var formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if (remain === 1 || remain === 2 || remain === 5) {
      return formatters.numeric.call(this, tickValue, index, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = { formatters };
defaults.set("scale", {
  display: true,
  offset: false,
  reverse: false,
  beginAtZero: false,
  bounds: "ticks",
  grace: 0,
  grid: {
    display: true,
    lineWidth: 1,
    drawBorder: true,
    drawOnChartArea: true,
    drawTicks: true,
    tickLength: 8,
    tickWidth: (_ctx, options) => options.lineWidth,
    tickColor: (_ctx, options) => options.color,
    offset: false,
    borderDash: [],
    borderDashOffset: 0,
    borderWidth: 1
  },
  title: {
    display: false,
    text: "",
    padding: {
      top: 4,
      bottom: 4
    }
  },
  ticks: {
    minRotation: 0,
    maxRotation: 50,
    mirror: false,
    textStrokeWidth: 0,
    textStrokeColor: "",
    padding: 3,
    display: true,
    autoSkip: true,
    autoSkipPadding: 3,
    labelOffset: 0,
    callback: Ticks.formatters.values,
    minor: {},
    major: {},
    align: "center",
    crossAlign: "near",
    showLabelBackdrop: false,
    backdropColor: "rgba(255, 255, 255, 0.75)",
    backdropPadding: 2
  }
});
defaults.route("scale.ticks", "color", "", "color");
defaults.route("scale.grid", "color", "", "borderColor");
defaults.route("scale.grid", "borderColor", "", "borderColor");
defaults.route("scale.title", "color", "", "color");
defaults.describe("scale", {
  _fallback: false,
  _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
  _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash"
});
defaults.describe("scales", {
  _fallback: "scale"
});
defaults.describe("scale.ticks", {
  _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
  _indexable: (name) => name !== "backdropPadding"
});
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index, tick2) {
  return createContext(parent, {
    tick: tick2,
    index,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales: scales2 } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return { titleX, titleY, maxWidth, rotation };
}
var Scale = class extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return { min, max };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [this]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [this]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [this]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [this]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [this]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [this]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick2;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick2 = ticks[i];
      tick2.label = callback(tickOpts.callback, [tick2.value, i, ticks], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [this]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [this]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = this.ticks.length;
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [this]);
  }
  beforeFit() {
    callback(this.options.beforeFit, [this]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [this]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; ++i) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || { data: {}, gc: [] };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index) {
    const ticks = this.ticks || [];
    if (index >= 0 && index < ticks.length) {
      const tick2 = ticks[index];
      return tick2.$context || (tick2.$context = createTickContext(this.getContext(), index, tick2));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const optsAtIndex = grid.setContext(this.getContext(i));
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = grid.borderDash || [];
      const borderDashOffset = optsAtIndex.borderDashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick2, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick2 = ticks[i];
      label = tick2.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      if (isHorizontal) {
        x = pixel;
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = y + textOffset - labelPadding.top;
        let left = x - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        rotation,
        label,
        font,
        color: color2,
        strokeColor,
        strokeWidth,
        textOffset,
        textAlign,
        textBaseline,
        translation: [x, y],
        backdrop
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return { textAlign, x };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return { top: 0, left: this.left, bottom: chart.height, right: this.right };
    }
    if (position === "top" || position === "bottom") {
      return { top: this.top, left: 0, bottom: this.bottom, right: chart.width };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index = ticks.findIndex((t) => t.value === value);
    if (index >= 0) {
      const opts = grid.setContext(this.getContext(index));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine({ x: item.x1, y: item.y1 }, { x: item.x2, y: item.y2 }, item);
        }
        if (grid.drawTicks) {
          drawLine({ x: item.tx1, y: item.ty1 }, { x: item.tx2, y: item.ty2 }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { grid } } = this;
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.borderWidth;
    ctx.strokeStyle = borderOpts.borderColor;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    let i, ilen;
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      const item = items[i];
      const tickFont = item.font;
      const label = item.label;
      if (item.backdrop) {
        ctx.fillStyle = item.backdrop.color;
        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
      }
      let y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, item);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [titleX, titleY]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [{
        z: tz,
        draw: (chartArea) => {
          this.draw(chartArea);
        }
      }];
    }
    return [{
      z: gz,
      draw: (chartArea) => {
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawTitle();
      }
    }, {
      z: gz + 1,
      draw: () => {
        this.drawBorder();
      }
    }, {
      z: tz,
      draw: (chartArea) => {
        this.drawLabels(chartArea);
      }
    }];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index) {
    const opts = this.options.ticks.setContext(this.getContext(index));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [scope].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [this.controllers, this.scales, this.elements];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [...args].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = new Registry();
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [chart, args, descriptor.options];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins2 = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
};
function allPlugins(config) {
  const plugins2 = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins2.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins2.indexOf(plugin) === -1) {
      plugins2.push(plugin);
    }
  }
  return plugins2;
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, plugins2, options, all) {
  const result = [];
  const context = chart.getContext();
  for (let i = 0; i < plugins2.length; i++) {
    const plugin = plugins2[i];
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, plugin, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, plugin, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  return config.createResolver(scopes, context, [""], { scriptable: false, indexable: false, allKeys: true });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, scaleOptions) {
  if (id === "x" || id === "y") {
    return id;
  }
  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || { scales: {} };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const firstIDs = Object.create(null);
  const scales2 = Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    firstIDs[axis] = firstIDs[axis] || id;
    scales2[id] = mergeIf(Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
      scales2[id] = scales2[id] || Object.create(null);
      mergeIf(scales2[id], [{ axis }, configScales[id], defaultScaleOptions[defaultID]]);
    });
  });
  Object.keys(scales2).forEach((key) => {
    const scale = scales2[key];
    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
  });
  return scales2;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = new Map();
var keysCached = new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
var addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = new Map();
    this._resolverCache = new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [[
      `datasets.${datasetType}`,
      ""
    ]]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [[
      `datasets.${datasetType}.elements.${elementType}`,
      `datasets.${datasetType}`,
      `elements.${elementType}`,
      ""
    ]]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [[
      `plugins.${id}`,
      ...plugin.additionalOptionScopes || []
    ]]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      { type },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
    const result = { $shared: true };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "3.7.0";
var KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions2 = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions2 && animationOptions2.onComplete, [context], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions2 = chart.options.animation;
  callback(animationOptions2 && animationOptions2.onProgress, [context], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
var Chart = class {
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = { width, height };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", { size: newSize });
    callback(options.onResize, [this, newSize], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales2 && scales2[id].type === scaleType) {
        scale = scales2[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales2[id];
      }
    });
    each(scales2, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index) => {
      if (datasets.filter((x) => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass.prototype, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", { mode });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({ method: a[1], start: +a[2], count: +a[3] }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index) => {
      item._idx = index;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction(mode) ? mode({ datasetIndex: i }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", { mode });
  }
  _updateDataset(index, mode) {
    const meta = this.getDatasetMeta(index);
    const args = { meta, index, mode, cancelable: true };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({ chart: this });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = this.chartArea;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, { chart: this, type: "chart" }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index) {
    this._hiddenIndices[index] = !this._hiddenIndices[index];
  }
  getDataVisibility(index) {
    return !this._hiddenIndices[index];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, { visible });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    this.notifyPlugins("destroy");
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: _isPointInArea(e, this.chartArea, this._minPadding)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [e, active, this], this);
      if (isClick) {
        callback(options.onClick, [e, active, this], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
var invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());
var enumerable = true;
Object.defineProperties(Chart, {
  defaults: {
    enumerable,
    value: defaults
  },
  instances: {
    enumerable,
    value: instances
  },
  overrides: {
    enumerable,
    value: overrides
  },
  registry: {
    enumerable,
    value: registry
  },
  version: {
    enumerable,
    value: version
  },
  getChart: {
    enumerable,
    value: getChart
  },
  register: {
    enumerable,
    value: (...items) => {
      registry.add(...items);
      invalidatePlugins();
    }
  },
  unregister: {
    enumerable,
    value: (...items) => {
      registry.remove(...items);
      invalidatePlugins();
    }
  }
});
function clipArc(ctx, element2, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element2;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx, element2, offset, spacing, end) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element2;
  const outerRadius = Math.max(element2.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
    spacingOffset = (alpha - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element2, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
  if (outerEnd > 0) {
    const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
  }
  const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
  ctx.lineTo(p4.x, p4.y);
  if (innerEnd > 0) {
    const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
  }
  ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
  if (innerStart > 0) {
    const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
  }
  const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
  ctx.lineTo(p8.x, p8.y);
  if (outerStart > 0) {
    const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
  }
  ctx.closePath();
}
function drawArc(ctx, element2, offset, spacing) {
  const { fullCircles, startAngle, circumference } = element2;
  let endAngle = element2.endAngle;
  if (fullCircles) {
    pathArc(ctx, element2, offset, spacing, startAngle + TAU);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + circumference % TAU;
      if (circumference % TAU === 0) {
        endAngle += TAU;
      }
    }
  }
  pathArc(ctx, element2, offset, spacing, endAngle);
  ctx.fill();
  return endAngle;
}
function drawFullCircleBorders(ctx, element2, inner) {
  const { x, y, startAngle, pixelMargin, fullCircles } = element2;
  const outerRadius = Math.max(element2.outerRadius - pixelMargin, 0);
  const innerRadius = element2.innerRadius + pixelMargin;
  let i;
  if (inner) {
    clipArc(ctx, element2, startAngle + TAU);
  }
  ctx.beginPath();
  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
}
function drawBorder(ctx, element2, offset, spacing, endAngle) {
  const { options } = element2;
  const { borderWidth, borderJoinStyle } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  if (element2.fullCircles) {
    drawFullCircleBorders(ctx, element2, inner);
  }
  if (inner) {
    clipArc(ctx, element2, endAngle);
  }
  pathArc(ctx, element2, offset, spacing, endAngle);
  ctx.stroke();
}
var ArcElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps(["x", "y"], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, { x: chartX, y: chartY });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = this.options.spacing / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 2;
    const spacing = (options.spacing || 0) / 2;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    let radiusOffset = 0;
    if (offset) {
      radiusOffset = offset / 2;
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
      if (this.circumference >= PI) {
        radiusOffset = offset;
      }
    }
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    const endAngle = drawArc(ctx, this, radiusOffset, spacing);
    drawBorder(ctx, this, radiusOffset, spacing, endAngle);
    ctx.restore();
  }
};
ArcElement.id = "arc";
ArcElement.defaults = {
  borderAlign: "center",
  borderColor: "#fff",
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0
};
ArcElement.defaultRoutes = {
  backgroundColor: "backgroundColor"
};
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, { start, end: start + count - 1 })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
var usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
var LineElement = class extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, { property, start: value, end: value });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const { start, end } = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, { start, end: start + count - 1 });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
};
LineElement.id = "line";
LineElement.defaults = {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
};
LineElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
LineElement.descriptors = {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
};
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([axis], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
var PointElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return { x, y };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
};
PointElement.id = "point";
PointElement.defaults = {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
};
PointElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return { left, top, right, bottom };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
var BarElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
BarElement.id = "bar";
BarElement.defaults = {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
};
BarElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
var elements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement,
  LineElement,
  PointElement,
  BarElement
});
function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const { x: pointAx, y: pointAy } = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i = start; i < start + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", { value: data });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const { iScale } = meta;
  const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return { start, count };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([indexAxis, chart.options.indexAxis]) === "y") {
        return;
      }
      if (meta.type !== "line") {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data, start, count, availableWidth, options);
          break;
        case "min-max":
          decimated = minMaxDecimation(data, start, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
function getLineByIndex(chart, index) {
  const meta = chart.getDatasetMeta(index);
  const visible = meta && chart.isDatasetVisible(index);
  return visible ? meta.dataset : null;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill === void 0) {
    fill = !!options.backgroundColor;
  }
  if (fill === false || fill === null) {
    return false;
  }
  if (fill === true) {
    return "origin";
  }
  return fill;
}
function decodeFill(line, index, count) {
  const fill = parseFillOption(line);
  if (isObject(fill)) {
    return isNaN(fill.value) ? false : fill;
  }
  let target = parseFloat(fill);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    if (fill[0] === "-" || fill[0] === "+") {
      target = index + target;
    }
    if (target === index || target < 0 || target >= count) {
      return false;
    }
    return target;
  }
  return ["origin", "start", "end", "stack", "shape"].indexOf(fill) >= 0 && fill;
}
function computeLinearBoundary(source) {
  const { scale = {}, fill } = source;
  let target = null;
  let horizontal;
  if (fill === "start") {
    target = scale.bottom;
  } else if (fill === "end") {
    target = scale.top;
  } else if (isObject(fill)) {
    target = scale.getPixelForValue(fill.value);
  } else if (scale.getBasePixel) {
    target = scale.getBasePixel();
  }
  if (isNumberFinite(target)) {
    horizontal = scale.isHorizontal();
    return {
      x: horizontal ? target : null,
      y: horizontal ? null : target
    };
  }
  return null;
}
var simpleArc = class {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const { x, y, radius } = this;
    bounds = bounds || { start: 0, end: TAU };
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x, y, radius } = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
};
function computeCircularBoundary(source) {
  const { scale, fill } = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const target = [];
  const start = options.reverse ? scale.max : scale.min;
  const end = options.reverse ? scale.min : scale.max;
  let i, center, value;
  if (fill === "start") {
    value = start;
  } else if (fill === "end") {
    value = end;
  } else if (isObject(fill)) {
    value = fill.value;
  } else {
    value = scale.getBaseValue();
  }
  if (options.grid.circular) {
    center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value));
  }
  return target;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function pointsFromSegments(boundary, line) {
  const { x = null, y = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start, end }) => {
    end = findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({ x: first.x, y });
      points.push({ x: last.x, y });
    } else if (x !== null) {
      points.push({ x, y: first.y });
      points.push({ x, y: last.y });
    }
  });
  return points;
}
function buildStackLine(source) {
  const { scale, index, line } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index);
  linesBelow.push(createBoundaryLine({ x: null, y: scale.bottom }, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({ points, options: {} });
}
function getLinesBelow(scale, index) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas("line");
  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];
    if (meta.index === index) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return { first, last, point };
}
function getTarget(source) {
  const { chart, fill, line } = source;
  if (isNumberFinite(fill)) {
    return getLineByIndex(chart, fill);
  }
  if (fill === "stack") {
    return buildStackLine(source);
  }
  if (fill === "shape") {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return createBoundaryLine(boundary, line);
}
function createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: { tension: 0 },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function resolveTarget(sources, index, propagate) {
  const source = sources[index];
  let fill = source.fill;
  const visited = [index];
  let target;
  if (!propagate) {
    return fill;
  }
  while (fill !== false && visited.indexOf(fill) === -1) {
    if (!isNumberFinite(fill)) {
      return fill;
    }
    target = sources[fill];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill;
    }
    visited.push(fill);
    fill = target.fill;
  }
  return false;
}
function _clip(ctx, target, clipY) {
  ctx.beginPath();
  target.path(ctx);
  ctx.lineTo(target.last().x, clipY);
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === "angle") {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return { property, start, end };
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start, end } = segment;
    end = findSegmentEnd(start, end, points);
    const bounds = getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function clipBounds(ctx, scale, bounds) {
  const { top, bottom } = scale.chart.chartArea;
  const { property, start, end } = bounds || {};
  if (property === "x") {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
function _fill(ctx, cfg) {
  const { line, target, property, color: color2, scale } = cfg;
  const segments = _segments(line, target, property);
  for (const { source: src, target: tgt, start, end } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, { move: lineLoop, reverse: true });
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? "evenodd" : "nonzero");
    ctx.restore();
  }
}
function doFill(ctx, cfg) {
  const { line, target, above, below, area, scale } = cfg;
  const property = line._loop ? "angle" : cfg.axis;
  ctx.save();
  if (property === "x" && below !== above) {
    _clip(ctx, target, area.top);
    _fill(ctx, { line, target, color: above, scale, property });
    ctx.restore();
    ctx.save();
    _clip(ctx, target, area.bottom);
  }
  _fill(ctx, { line, target, color: below, scale, property });
  ctx.restore();
}
function drawfill(ctx, source, area) {
  const target = getTarget(source);
  const { line, scale, axis } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, { line, target, above, below, area, scale, axis });
    unclipArea(ctx);
  }
}
var plugin_filler = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source;
    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: decodeFill(line, i, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i = 0; i < count; ++i) {
      source = sources[i];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw2 = options.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw2) {
        drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (source) {
        drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!source || source.fill === false || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
var Legend = class extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [0];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = { left: 0, top, row, width: itemWidth, height: itemHeight };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({ width: currentColWidth, height: currentColHeight });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = { left, top: currentColHeight, col, width: itemWidth, height: itemHeight };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({ width: currentColWidth, height: currentColHeight });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { color: fontColor, padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxWidth * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor || fontColor;
      ctx.fillStyle = legendItem.fontColor || fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [e, previous, this], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [e, hoveredItem, this], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [e, hoveredItem, this], this);
    }
  }
};
function isListened(type, opts) {
  if (type === "mousemove" && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({ ctx: chart.ctx, options, chart });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index)) {
        ci.hide(index);
        legendItem.hidden = true;
      } else {
        ci.show(index);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2 } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: 0,
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => !["generateLabels", "filter", "sort"].includes(name)
    }
  }
};
var Title = class extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return { titleX, titleY, maxWidth, rotation };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [titleX, titleY]
    });
  }
};
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var map2 = new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map2.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map2.get(chart));
    map2.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map2.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let x = 0;
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }
    return {
      x: x / count,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element: element2, datasetIndex, index } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index);
  return {
    chart,
    label,
    parsed: controller.getParsed(index),
    raw: chart.data.datasets[datasetIndex].data[index],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index,
    datasetIndex,
    element: element2
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return { width, height };
}
function determineYAlign(chart, size) {
  const { y, height } = size;
  if (y < height / 2) {
    return "top";
  } else if (y > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width } = size;
  if (xAlign === "right") {
    x -= width;
  } else if (xAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var Tooltip = class extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart || config._chart;
    this._chart = this.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
    const title = callbacks.title.apply(this, [context]);
    const afterTitle = callbacks.afterTitle.apply(this, [context]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
    const footer = callbacks.footer.apply(this, [tooltipItems]);
    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element2, index, array) => options.filter(element2, index, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(scoped.labelColor.call(this, context));
      labelPointStyles.push(scoped.labelPointStyle.call(this, context));
      labelTextColors.push(scoped.labelTextColor.call(this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, { chart: this.chart, tooltip: this, replay });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return { x1, x2, x3, y1, y2, y3 };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColors = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColors.borderColor;
      ctx.fillStyle = labelColors.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = labelColors.borderWidth || 1;
      ctx.strokeStyle = labelColors.borderColor;
      ctx.setLineDash(labelColors.borderDash || []);
      ctx.lineDashOffset = labelColors.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
      const borderRadius = toTRBLCorners(labelColors.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
Tooltip.positioners = positioners;
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({ chart, options });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    const args = {
      tooltip
    };
    if (chart.notifyPlugins("beforeTooltipDraw", args) === false) {
      return;
    }
    if (tooltip) {
      tooltip.draw(chart.ctx);
    }
    chart.notifyPlugins("afterTooltipDraw", args);
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "width", "height", "caretX", "caretY"]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: {
      beforeTitle: noop2,
      title(tooltipItems) {
        if (tooltipItems.length > 0) {
          const item = tooltipItems[0];
          const labels = item.chart.data.labels;
          const labelCount = labels ? labels.length : 0;
          if (this && this.options && this.options.mode === "dataset") {
            return item.dataset.label || "";
          } else if (item.label) {
            return item.label;
          } else if (labelCount > 0 && item.dataIndex < labelCount) {
            return labels[item.dataIndex];
          }
        }
        return "";
      },
      afterTitle: noop2,
      beforeBody: noop2,
      beforeLabel: noop2,
      label(tooltipItem) {
        if (this && this.options && this.options.mode === "dataset") {
          return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
        }
        let label = tooltipItem.dataset.label || "";
        if (label) {
          label += ": ";
        }
        const value = tooltipItem.formattedValue;
        if (!isNullOrUndef(value)) {
          label += value;
        }
        return label;
      },
      labelColor(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          borderColor: options.borderColor,
          backgroundColor: options.backgroundColor,
          borderWidth: options.borderWidth,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderRadius: 0
        };
      },
      labelTextColor() {
        return this.options.bodyColor;
      },
      labelPointStyle(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          pointStyle: options.pointStyle,
          rotation: options.rotation
        };
      },
      afterLabel: noop2,
      afterBody: noop2,
      beforeFooter: noop2,
      footer: noop2,
      afterFooter: noop2
    }
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: ["interaction"]
};
var plugins = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Decimation: plugin_decimation,
  Filler: plugin_filler,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
var addIfString = (labels, raw, index, addedLabels) => {
  if (typeof raw === "string") {
    index = labels.push(raw) - 1;
    addedLabels.unshift({ index, label: raw });
  } else if (isNaN(raw)) {
    index = null;
  }
  return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index : first;
}
var validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);
var CategoryScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index, label } of added) {
        if (labels[index] === label) {
          labels.splice(index, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
    return validIndex(index, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({ value });
    }
    return ticks;
  }
  getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
CategoryScale.id = "category";
CategoryScale.defaults = {
  ticks: {
    callback: CategoryScale.prototype.getLabelForValue
  }
};
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [{ value: rmin }, { value: rmax }];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({ value: min });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    ticks.push({ value: Math.round((niceMin + j * spacing) * factor) / factor });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({ value: max });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({ value: niceMax });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = 1;
      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
        offset = Math.abs(max * 0.05);
      }
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
LinearScale.id = "linear";
LinearScale.defaults = {
  ticks: {
    callback: Ticks.formatters.numeric
  }
};
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
  return remain === 1;
}
function generateTicks(generationOptions, dataRange) {
  const endExp = Math.floor(log10(dataRange.max));
  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
  const ticks = [];
  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
  let exp = Math.floor(log10(tickVal));
  let significand = Math.floor(tickVal / Math.pow(10, exp));
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  do {
    ticks.push({ value: tickVal, major: isMajor(tickVal) });
    ++significand;
    if (significand === 10) {
      significand = 1;
      ++exp;
      precision = exp >= 0 ? 1 : precision;
    }
    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
  } while (exp < endExp || exp === endExp && significand < endSignificand);
  const lastTick = finiteOrDefault(generationOptions.max, tickVal);
  ticks.push({ value: lastTick, major: isMajor(tickVal) });
  return ticks;
}
var LogarithmicScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(exp(min, -1));
        setMax(exp(max, 1));
      }
    }
    if (min <= 0) {
      setMin(exp(max, -1));
    }
    if (max <= 0) {
      setMax(exp(min, 1));
    }
    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
      setMin(exp(min, -1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
LogarithmicScale.id = "logarithmic";
LogarithmicScale.defaults = {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
};
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [label];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const extra = getTickBackdropHeight(opts) / 2;
  const outerDistance = scale.drawingArea;
  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const size = labelSizes[i];
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    items.push({
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    });
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= h / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];
    const { backdropColor } = optsAtIndex;
    if (!isNullOrUndef(backdropColor)) {
      const padding = toPadding(optsAtIndex.backdropPadding);
      ctx.fillStyle = backdropColor;
      ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);
    }
    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(gridLineOpts.borderDash);
  ctx.lineDashOffset = gridLineOpts.borderDashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index, label) {
  return createContext(parent, {
    label,
    index,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index) => {
      const label = callback(this.options.pointLabels.callback, [value, index], this);
      return label || label === 0 ? label : "";
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index) {
    const pointLabels = this._pointLabels || [];
    if (index >= 0 && index < pointLabels.length) {
      const pointLabel = pointLabels[index];
      return createPointLabelContext(this.getContext(), index, pointLabel);
    }
  }
  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index, value) {
    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index) {
    return this.getPointPositionForValue(index || 0, this.getBaseValue());
  }
  getPointLabelPosition(index) {
    const { left, top, right, bottom } = this._pointLabelItems[index];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick2, index) => {
        if (index !== 0) {
          offset = this.getDistanceFromCenterForValue(tick2.value);
          const optsAtIndex = grid.setContext(this.getContext(index - 1));
          drawRadiusLine(this, optsAtIndex, offset, labelCount);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick2, index) => {
      if (index === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick2.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick2.label, 0, -offset, tickFont, {
        color: optsAtIndex.color
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
RadialLinearScale.id = "radialLinear";
RadialLinearScale.defaults = {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
};
RadialLinearScale.defaultRoutes = {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
};
RadialLinearScale.descriptors = {
  angleLines: {
    _fallback: "grid"
  }
};
var INTERVALS = {
  millisecond: { common: true, size: 1, steps: 1e3 },
  second: { common: true, size: 1e3, steps: 60 },
  minute: { common: true, size: 6e4, steps: 60 },
  hour: { common: true, size: 36e5, steps: 24 },
  day: { common: true, size: 864e5, steps: 30 },
  week: { common: false, size: 6048e5, steps: 4 },
  month: { common: true, size: 2628e6, steps: 12 },
  quarter: { common: false, size: 7884e6, steps: 4 },
  year: { common: true, size: 3154e7 }
};
var UNITS = Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map3, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index = map3[major];
    if (index >= 0) {
      ticks[index].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map3 = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map3[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return { min, max };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  initOffsets(timestamps) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = { start, end, factor: 1 / (start + 1 + end) };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(timeOpts.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  _tickFormatFunction(time, index, ticks, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick2 = ticks[index];
    const major = majorUnit && majorFormat && tick2 && tick2.major;
    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    const formatter = options.ticks.callback;
    return formatter ? callback(formatter, [label, index, ticks], this) : label;
  }
  generateTickLabels(ticks) {
    let i, ilen, tick2;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick2 = ticks[i];
      tick2.label = this._tickFormatFunction(tick2.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
TimeScale.id = "time";
TimeScale.defaults = {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    major: {
      enabled: false
    }
  }
};
function interpolate(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate(table, this.min);
    this._tableRange = interpolate(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        { time: min, pos: 0 },
        { time: max, pos: 1 }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({ time: curr, pos: i / (ilen - 1) });
      }
    }
    return table;
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
TimeSeriesScale.id = "timeseries";
TimeSeriesScale.defaults = TimeScale.defaults;
var scales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
var registerables = [
  controllers,
  elements,
  plugins,
  scales
];

// node_modules/svelte-chartjs/src/Base.svelte
function create_fragment(ctx) {
  let canvas;
  let canvas_levels = [ctx[1]];
  let canvas_data = {};
  for (let i = 0; i < canvas_levels.length; i += 1) {
    canvas_data = assign(canvas_data, canvas_levels[i]);
  }
  return {
    c() {
      canvas = element("canvas");
      set_attributes(canvas, canvas_data);
    },
    m(target, anchor) {
      insert(target, canvas, anchor);
      ctx[6](canvas);
    },
    p(ctx2, [dirty]) {
      set_attributes(canvas, canvas_data = get_spread_update(canvas_levels, [ctx2[1]]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(canvas);
      ctx[6](null);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  Chart.register(...registerables);
  let { data = {
    labels: [],
    datasets: [{ data: [] }],
    yMarkers: {},
    yRegions: []
  } } = $$props;
  let { type = "line" } = $$props;
  let { options = {} } = $$props;
  let { plugins: plugins2 = [] } = $$props;
  let chart = null;
  let chartRef;
  let props = clean($$props, ["data", "type", "options", "plugins"]);
  onMount(() => {
    chart = new Chart(chartRef, { type, data, options, plugins: plugins2 });
  });
  afterUpdate(() => {
    if (!chart)
      return;
    chart.data = data;
    chart.type = type;
    chart.options = options;
    chart.plugins = plugins2;
    chart.update();
  });
  onDestroy(() => {
    chart = null;
  });
  function canvas_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      chartRef = $$value;
      $$invalidate(0, chartRef);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("data" in $$new_props)
      $$invalidate(2, data = $$new_props.data);
    if ("type" in $$new_props)
      $$invalidate(3, type = $$new_props.type);
    if ("options" in $$new_props)
      $$invalidate(4, options = $$new_props.options);
    if ("plugins" in $$new_props)
      $$invalidate(5, plugins2 = $$new_props.plugins);
  };
  $$props = exclude_internal_props($$props);
  return [chartRef, props, data, type, options, plugins2, canvas_binding];
}
var Base = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { data: 2, type: 3, options: 4, plugins: 5 });
  }
};
var Base_default = Base;

// node_modules/svelte-chartjs/src/Scatter.svelte
function create_fragment2(ctx) {
  let base;
  let current;
  const base_spread_levels = [ctx[0], { type: "scatter" }];
  let base_props = {};
  for (let i = 0; i < base_spread_levels.length; i += 1) {
    base_props = assign(base_props, base_spread_levels[i]);
  }
  base = new Base_default({ props: base_props });
  return {
    c() {
      create_component(base.$$.fragment);
    },
    m(target, anchor) {
      mount_component(base, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const base_changes = dirty & 1 ? get_spread_update(base_spread_levels, [get_spread_object(ctx2[0]), base_spread_levels[1]]) : {};
      base.$set(base_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(base.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(base.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(base, detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var Scatter = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
  }
};
var Scatter_default = Scatter;

// src/Components/ChartOptions.svelte
var import_luxon = __toModule(require_luxon());
function create_if_block(ctx) {
  let label0;
  let t0;
  let input0;
  let t1;
  let label1;
  let t2;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      label0 = element("label");
      t0 = text("Start\r\n		");
      input0 = element("input");
      t1 = space();
      label1 = element("label");
      t2 = text("End\r\n		");
      input1 = element("input");
      attr(input0, "type", "date");
      input0.value = ctx[4];
      attr(input0, "min", ctx[4]);
      attr(input0, "max", ctx[5]);
      attr(input1, "type", "date");
      input1.value = ctx[5];
      attr(input1, "min", ctx[4]);
      attr(input1, "max", ctx[5]);
    },
    m(target, anchor) {
      insert(target, label0, anchor);
      append(label0, t0);
      append(label0, input0);
      insert(target, t1, anchor);
      insert(target, label1, anchor);
      append(label1, t2);
      append(label1, input1);
      if (!mounted) {
        dispose = [
          listen(input0, "change", ctx[8]),
          listen(input1, "change", ctx[9])
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(label0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(label1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment3(ctx) {
  let input0;
  let t0;
  let label;
  let t1;
  let input1;
  let t2;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = ctx[3] && create_if_block(ctx);
  return {
    c() {
      input0 = element("input");
      t0 = space();
      label = element("label");
      t1 = text("Date Range");
      input1 = element("input");
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input0, "type", "color");
      attr(input1, "type", "checkbox");
      input1.checked = ctx[3];
    },
    m(target, anchor) {
      insert(target, input0, anchor);
      set_input_value(input0, ctx[0]);
      insert(target, t0, anchor);
      insert(target, label, anchor);
      append(label, t1);
      append(label, input1);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[6]),
          listen(input1, "change", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        set_input_value(input0, ctx2[0]);
      }
      if (dirty & 8) {
        input1.checked = ctx2[3];
      }
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(label);
      if (detaching)
        detach(t2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { colour } = $$props;
  let { startDate } = $$props;
  let { endDate } = $$props;
  let { dnOnly } = $$props;
  const minDateStr = startDate.toISODate();
  const maxDateStr = endDate.toISODate();
  function input0_input_handler() {
    colour = this.value;
    $$invalidate(0, colour);
  }
  const change_handler = () => $$invalidate(3, dnOnly = !dnOnly);
  const change_handler_1 = (e) => $$invalidate(1, startDate = import_luxon.DateTime.fromISO(e.target.value));
  const change_handler_2 = (e) => $$invalidate(2, endDate = import_luxon.DateTime.fromISO(e.target.value));
  $$self.$$set = ($$props2) => {
    if ("colour" in $$props2)
      $$invalidate(0, colour = $$props2.colour);
    if ("startDate" in $$props2)
      $$invalidate(1, startDate = $$props2.startDate);
    if ("endDate" in $$props2)
      $$invalidate(2, endDate = $$props2.endDate);
    if ("dnOnly" in $$props2)
      $$invalidate(3, dnOnly = $$props2.dnOnly);
  };
  return [
    colour,
    startDate,
    endDate,
    dnOnly,
    minDateStr,
    maxDateStr,
    input0_input_handler,
    change_handler,
    change_handler_1,
    change_handler_2
  ];
}
var ChartOptions = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      colour: 0,
      startDate: 1,
      endDate: 2,
      dnOnly: 3
    });
  }
};
var ChartOptions_default = ChartOptions;

// src/Components/Chart.svelte
function add_css(target) {
  append_styles(target, "svelte-t771rz", "div.checkboxes.svelte-t771rz{border-radius:5px;border:1px solid var(--background-modifier-border);padding:3px}div.measures.svelte-t771rz{display:flex;justify-content:space-between}span.measure-name.svelte-t771rz{background-color:var(--background-secondary-alt);padding:2px 4px;border-radius:3px;font-size:12px;line-height:12px}span.measure-name.svelte-t771rz:hover{background-color:var(--interactive-accent)}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let option;
  let option_value_value;
  return {
    c() {
      option = element("option");
      option.__value = option_value_value = ctx[29];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_else_block(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Select 2 fields";
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_1(ctx) {
  let span2;
  let span0;
  let t1;
  let span1;
  let t2_value = ctx[6].length + "";
  let t2;
  let t3;
  let span5;
  let span3;
  let t5;
  let span4;
  let t6_value = ctx[10]?.toFixed(4) + "";
  let t6;
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      span0.textContent = "n:";
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      t3 = space();
      span5 = element("span");
      span3 = element("span");
      span3.textContent = "Correlation:";
      t5 = space();
      span4 = element("span");
      t6 = text(t6_value);
      attr(span0, "class", "measure-name svelte-t771rz");
      attr(span1, "class", "measure-value");
      attr(span3, "class", "measure-name svelte-t771rz");
      attr(span4, "class", "measure-value");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      append(span2, t1);
      append(span2, span1);
      append(span1, t2);
      insert(target, t3, anchor);
      insert(target, span5, anchor);
      append(span5, span3);
      append(span5, t5);
      append(span5, span4);
      append(span4, t6);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 64 && t2_value !== (t2_value = ctx2[6].length + ""))
        set_data(t2, t2_value);
      if (dirty[0] & 1024 && t6_value !== (t6_value = ctx2[10]?.toFixed(4) + ""))
        set_data(t6, t6_value);
    },
    d(detaching) {
      if (detaching)
        detach(span2);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(span5);
    }
  };
}
function create_if_block2(ctx) {
  let span;
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text("Error: ");
      t1 = text(ctx[7]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 128)
        set_data(t1, ctx2[7]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment4(ctx) {
  let div0;
  let datalist;
  let t0;
  let label0;
  let t1;
  let input0;
  let t2;
  let label1;
  let t3;
  let input1;
  let t4;
  let chartoptions;
  let updating_colour;
  let updating_startDate;
  let updating_endDate;
  let updating_dnOnly;
  let t5;
  let scatter;
  let t6;
  let div1;
  let show_if;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[11];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  function chartoptions_colour_binding(value) {
    ctx[15](value);
  }
  function chartoptions_startDate_binding(value) {
    ctx[16](value);
  }
  function chartoptions_endDate_binding(value) {
    ctx[17](value);
  }
  function chartoptions_dnOnly_binding(value) {
    ctx[18](value);
  }
  let chartoptions_props = {};
  if (ctx[2] !== void 0) {
    chartoptions_props.colour = ctx[2];
  }
  if (ctx[3] !== void 0) {
    chartoptions_props.startDate = ctx[3];
  }
  if (ctx[4] !== void 0) {
    chartoptions_props.endDate = ctx[4];
  }
  if (ctx[5] !== void 0) {
    chartoptions_props.dnOnly = ctx[5];
  }
  chartoptions = new ChartOptions_default({ props: chartoptions_props });
  binding_callbacks.push(() => bind(chartoptions, "colour", chartoptions_colour_binding));
  binding_callbacks.push(() => bind(chartoptions, "startDate", chartoptions_startDate_binding));
  binding_callbacks.push(() => bind(chartoptions, "endDate", chartoptions_endDate_binding));
  binding_callbacks.push(() => bind(chartoptions, "dnOnly", chartoptions_dnOnly_binding));
  scatter = new Scatter_default({
    props: {
      data: ctx[9],
      options: ctx[8]
    }
  });
  function select_block_type(ctx2, dirty) {
    if (dirty[0] & 3)
      show_if = null;
    if (ctx2[7] != "")
      return create_if_block2;
    if (show_if == null)
      show_if = !!isValidSelection(ctx2[0], ctx2[1]);
    if (show_if)
      return create_if_block_1;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div0 = element("div");
      datalist = element("datalist");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      label0 = element("label");
      t1 = text("Field 1:\r\n		");
      input0 = element("input");
      t2 = space();
      label1 = element("label");
      t3 = text("Field 2:\r\n		");
      input1 = element("input");
      t4 = space();
      create_component(chartoptions.$$.fragment);
      t5 = space();
      create_component(scatter.$$.fragment);
      t6 = space();
      div1 = element("div");
      if_block.c();
      attr(datalist, "id", "fields");
      attr(input0, "list", "fields");
      attr(input1, "list", "fields");
      attr(div0, "class", "checkboxes svelte-t771rz");
      attr(div1, "class", "measures svelte-t771rz");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, datalist);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(datalist, null);
      }
      append(div0, t0);
      append(div0, label0);
      append(label0, t1);
      append(label0, input0);
      set_input_value(input0, ctx[0]);
      append(div0, t2);
      append(div0, label1);
      append(label1, t3);
      append(label1, input1);
      set_input_value(input1, ctx[1]);
      insert(target, t4, anchor);
      mount_component(chartoptions, target, anchor);
      insert(target, t5, anchor);
      mount_component(scatter, target, anchor);
      insert(target, t6, anchor);
      insert(target, div1, anchor);
      if_block.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[13]),
          listen(input1, "input", ctx[14])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2048) {
        each_value = ctx2[11];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(datalist, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty[0] & 1 && input0.value !== ctx2[0]) {
        set_input_value(input0, ctx2[0]);
      }
      if (dirty[0] & 2 && input1.value !== ctx2[1]) {
        set_input_value(input1, ctx2[1]);
      }
      const chartoptions_changes = {};
      if (!updating_colour && dirty[0] & 4) {
        updating_colour = true;
        chartoptions_changes.colour = ctx2[2];
        add_flush_callback(() => updating_colour = false);
      }
      if (!updating_startDate && dirty[0] & 8) {
        updating_startDate = true;
        chartoptions_changes.startDate = ctx2[3];
        add_flush_callback(() => updating_startDate = false);
      }
      if (!updating_endDate && dirty[0] & 16) {
        updating_endDate = true;
        chartoptions_changes.endDate = ctx2[4];
        add_flush_callback(() => updating_endDate = false);
      }
      if (!updating_dnOnly && dirty[0] & 32) {
        updating_dnOnly = true;
        chartoptions_changes.dnOnly = ctx2[5];
        add_flush_callback(() => updating_dnOnly = false);
      }
      chartoptions.$set(chartoptions_changes);
      const scatter_changes = {};
      if (dirty[0] & 512)
        scatter_changes.data = ctx2[9];
      if (dirty[0] & 256)
        scatter_changes.options = ctx2[8];
      scatter.$set(scatter_changes);
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(chartoptions.$$.fragment, local);
      transition_in(scatter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chartoptions.$$.fragment, local);
      transition_out(scatter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t4);
      destroy_component(chartoptions, detaching);
      if (detaching)
        detach(t5);
      destroy_component(scatter, detaching);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(div1);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function isValidSelection(f1, f2) {
  return f1 && f2;
}
function refreshChartOptions(f1, f2) {
  return {
    title: {
      display: true,
      text: "Scatter Chart - Logarithmic X-Axis"
    },
    scales: {
      xAxes: {
        title: {
          display: isValidSelection(f1, f2),
          text: f1 ?? ""
        },
        type: "linear",
        position: "bottom",
        scaleLabel: { labelString: "Frequency", display: true }
      },
      yAxes: {
        type: "linear",
        scaleLabel: { labelString: "Voltage", display: true },
        title: {
          display: isValidSelection(f1, f2),
          text: f2 ?? ""
        }
      }
    },
    plugins: {
      tooltip: {
        callbacks: {
          label(tooltipItem) {
            const { raw } = tooltipItem;
            return `${raw.name}:
(${raw.x}, ${raw.y})`;
          }
        }
      }
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let innerData;
  let correlation;
  let data;
  let chartOptions;
  let { modal } = $$props;
  let { f1, f2 } = modal;
  const { app, plugin } = modal;
  const { index, settings } = plugin;
  const { fieldsToCheck } = settings;
  let allFields = fieldsToCheck;
  let [n1, n2] = [0, 0];
  let colour = "#15a252";
  let startDate = index.minDate;
  let endDate = index.maxDate;
  let dnOnly = false;
  let errorMessage = "";
  function refreshInnerData(f12, f22, dnOnly2, startDate2, endDate2) {
    const fileRange = dnOnly2 ? index.data.filter((item) => {
      const { day } = item.file;
      return day && startDate2.ts <= day.ts && day.ts <= endDate2.ts;
    }) : index.data;
    const innerData2 = fileRange.map((page) => {
      return {
        x: page[f12],
        y: page[f22],
        name: page.file.name
      };
    }).filter((point) => {
      return point.x !== void 0 && point.y !== void 0;
    });
    return innerData2;
  }
  function refreshCorrelation(f12, f22, innerData2) {
    const xs = innerData2.map((p) => p.x);
    const ys = innerData2.map((p) => p.y);
    if (isValidSelection(f12, f22)) {
      const xValid = isQuant(xs);
      const yValid = isQuant(ys);
      if (!xValid && !yValid) {
        $$invalidate(7, errorMessage = "Both fields have non-numeric values.");
        return null;
      } else if (!xValid) {
        $$invalidate(7, errorMessage = "First field has non-numeric values.");
        return null;
      } else if (!yValid) {
        $$invalidate(7, errorMessage = "Second field has non-numeric values.");
        return null;
      }
      $$invalidate(7, errorMessage = "");
      return getPearsonCorrelation(xs, ys, true);
    }
    return null;
  }
  function refreshChartData(colour2, innerData2) {
    return {
      labels: ["Scatter"],
      datasets: [
        {
          borderColor: colour2,
          backgroundColor: colour2,
          label: "Data",
          data: innerData2
        }
      ]
    };
  }
  function input0_input_handler() {
    f1 = this.value;
    $$invalidate(0, f1);
  }
  function input1_input_handler() {
    f2 = this.value;
    $$invalidate(1, f2);
  }
  function chartoptions_colour_binding(value) {
    colour = value;
    $$invalidate(2, colour);
  }
  function chartoptions_startDate_binding(value) {
    startDate = value;
    $$invalidate(3, startDate);
  }
  function chartoptions_endDate_binding(value) {
    endDate = value;
    $$invalidate(4, endDate);
  }
  function chartoptions_dnOnly_binding(value) {
    dnOnly = value;
    $$invalidate(5, dnOnly);
  }
  $$self.$$set = ($$props2) => {
    if ("modal" in $$props2)
      $$invalidate(12, modal = $$props2.modal);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 59) {
      $:
        $$invalidate(6, innerData = refreshInnerData(f1, f2, dnOnly, startDate, endDate));
    }
    if ($$self.$$.dirty[0] & 67) {
      $:
        $$invalidate(10, correlation = refreshCorrelation(f1, f2, innerData));
    }
    if ($$self.$$.dirty[0] & 68) {
      $:
        $$invalidate(9, data = refreshChartData(colour, innerData));
    }
    if ($$self.$$.dirty[0] & 3) {
      $:
        $$invalidate(8, chartOptions = refreshChartOptions(f1, f2));
    }
  };
  return [
    f1,
    f2,
    colour,
    startDate,
    endDate,
    dnOnly,
    innerData,
    errorMessage,
    chartOptions,
    data,
    correlation,
    allFields,
    modal,
    input0_input_handler,
    input1_input_handler,
    chartoptions_colour_binding,
    chartoptions_startDate_binding,
    chartoptions_endDate_binding,
    chartoptions_dnOnly_binding
  ];
}
var Chart2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { modal: 12 }, add_css, [-1, -1]);
  }
};
var Chart_default = Chart2;

// src/ChartModal.ts
var ChartModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, f1 = "", f2 = "") {
    super(app);
    this.plugin = plugin;
    this.modal = this;
    this.f1 = f1;
    this.f2 = f2;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    new Chart_default({
      target: contentEl,
      props: {
        modal: this
      }
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/const.ts
var CORRELATION_VIEW = "correlation-view";
var CORRELATION_REPORT_VIEW = "correlation-report-view";
var DECIMALS = 4;
var DEFAULT_SETTINGS = {
  fieldsToCheck: [],
  fieldsToIgnoreForCorrs: [],
  fieldLists: [],
  dateFormat: "YYYY-MM-DD",
  defaultSavePath: "/",
  nullValue: "null",
  undefinedValue: "undefined",
  addFileData: false,
  addNoteContent: false
};
var splitLinksRegex = new RegExp(/\[\[(.*?)\]\]/g);
var dropHeaderOrAlias = new RegExp(/\[\[([^#|]*)\]\]/);

// src/CorrelationsReportView.ts
var import_obsidian5 = __toModule(require("obsidian"));

// src/utils.ts
var import_obsidian4 = __toModule(require("obsidian"));

// src/StatsModal.ts
var import_obsidian3 = __toModule(require("obsidian"));

// src/Components/Stats.svelte
function add_css2(target) {
  append_styles(target, "svelte-l76002", "table.svelte-l76002{margin-top:5px;border-collapse:collapse}th.svelte-l76002,td.svelte-l76002{border:1px solid var(--background-modifier-border)}td.svelte-l76002{padding:0.2rem 0.5rem}td.svelte-l76002:first-child{text-align:right}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let option;
  let option_value_value;
  return {
    c() {
      option = element("option");
      option.__value = option_value_value = ctx[19];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block3(ctx) {
  let tr;
  let td0;
  let t0_value = ctx[16][0] + "";
  let t0;
  let t1;
  let td1;
  let t2_value = ctx[16][1] + "";
  let t2;
  let t3;
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      attr(td0, "class", "svelte-l76002");
      attr(td1, "class", "svelte-l76002");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[16][0] + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && t2_value !== (t2_value = ctx2[16][1] + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_each_block2(ctx) {
  let if_block_anchor;
  let if_block = ctx[16] && create_if_block3(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[16]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment5(ctx) {
  let datalist;
  let t0;
  let label;
  let t1;
  let input;
  let t2;
  let table;
  let thead;
  let t6;
  let mounted;
  let dispose;
  let each_value_1 = ctx[2];
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  return {
    c() {
      datalist = element("datalist");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t0 = space();
      label = element("label");
      t1 = text("Field:\r\n	");
      input = element("input");
      t2 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th class="svelte-l76002">Stat</th> 
			<th class="svelte-l76002">Value</th></tr>`;
      t6 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(datalist, "id", "fields");
      attr(input, "list", "fields");
      attr(label, "for", "fields");
      attr(table, "class", "svelte-l76002");
    },
    m(target, anchor) {
      insert(target, datalist, anchor);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(datalist, null);
      }
      insert(target, t0, anchor);
      insert(target, label, anchor);
      append(label, t1);
      append(label, input);
      set_input_value(input, ctx[0]);
      insert(target, t2, anchor);
      insert(target, table, anchor);
      append(table, thead);
      append(table, t6);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(table, null);
      }
      if (!mounted) {
        dispose = listen(input, "input", ctx[10]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4) {
        each_value_1 = ctx2[2];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(datalist, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (dirty & 2) {
        each_value = ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(table, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(datalist);
      destroy_each(each_blocks_1, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(label);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(table);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let data;
  let n;
  let mean;
  let median;
  let mode;
  let std;
  let stats;
  let { modal } = $$props;
  const { app, plugin } = modal;
  const { index, settings } = plugin;
  const { fieldsToCheck } = settings;
  let { f1 } = modal;
  const updateData = (field) => index.data.map((d) => d[field]).filter((d) => d !== void 0 && d !== null);
  function input_input_handler() {
    f1 = this.value;
    $$invalidate(0, f1);
  }
  $$self.$$set = ($$props2) => {
    if ("modal" in $$props2)
      $$invalidate(3, modal = $$props2.modal);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(9, data = updateData(f1));
    }
    if ($$self.$$.dirty & 512) {
      $:
        $$invalidate(8, n = data.length);
    }
    if ($$self.$$.dirty & 512) {
      $:
        $$invalidate(7, mean = getMean(data));
    }
    if ($$self.$$.dirty & 512) {
      $:
        $$invalidate(6, median = getMedian(data));
    }
    if ($$self.$$.dirty & 512) {
      $:
        $$invalidate(5, mode = getMode(data));
    }
    if ($$self.$$.dirty & 512) {
      $:
        $$invalidate(4, std = getStdDev(data));
    }
    if ($$self.$$.dirty & 496) {
      $:
        $$invalidate(1, stats = [
          n ? ["n", n] : null,
          mean ? ["Mean", roundNumber(mean)] : null,
          median ? ["Median", roundNumber(median)] : null,
          ["Mode", mode],
          std ? ["Std Dev.", roundNumber(std)] : null
        ]);
    }
  };
  return [
    f1,
    stats,
    fieldsToCheck,
    modal,
    std,
    mode,
    median,
    mean,
    n,
    data,
    input_input_handler
  ];
}
var Stats = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { modal: 3 }, add_css2);
  }
};
var Stats_default = Stats;

// src/StatsModal.ts
var StatsModal = class extends import_obsidian3.Modal {
  constructor(app, plugin, f1 = "") {
    super(app);
    this.plugin = plugin;
    this.modal = this;
    this.f1 = f1;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    new Stats_default({
      target: contentEl,
      props: {
        modal: this
      }
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/utils.ts
var splitAndTrim = (fields, split = ",") => {
  if (fields === "")
    return [];
  else
    return fields.split(split).map((str) => str.trim());
};
var makeArr = (input) => [input].flat();
var makeSub = (field, sub, connector = ".") => field + connector + sub;
function stringToNullOrUndefined(str) {
  if (str === "undefined")
    return void 0;
  else if (str === "null")
    return null;
  else
    return str;
}
var toKebabCase = (input) => input.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var roundNumber = (num, dec = DECIMALS) => Math.round(num * Math.pow(10, dec)) / Math.pow(10, dec);
var tryParseNumber = (input) => {
  const num = Number.parseFloat(input);
  return isNaN(num) ? input : num;
};
function menuForChartNStatsModal(event, plugin) {
  const { app } = plugin;
  const menu = new import_obsidian4.Menu(app);
  const target = event.target;
  const parentElement = target.parentElement;
  const clickedCell = tryParseNumber(target.innerText);
  const row = Array.from(parentElement.cells).map((el) => tryParseNumber(el.textContent));
  menu.addItem((item) => item.setTitle("Open Chart Modal").setIcon(addFeatherIcon("bar-chart-2")).onClick(() => {
    new ChartModal(app, plugin, row[0], row[1]).open();
  }));
  if (typeof clickedCell === "string") {
    menu.addItem((item) => item.setTitle("Open Stats Modal").setIcon(addFeatherIcon("grid")).onClick(() => {
      new StatsModal(app, plugin, clickedCell).open();
    }));
  }
  menu.showAtMouseEvent(event);
}
var dropWiki = (str) => str.startsWith("[[") && str.endsWith("]]") ? str.slice(2, -2) : str;

// src/reportViewUtils.ts
var ALL_FIELDS = "All Fields";
var buildPrintableCorrs = (corrs) => {
  if (corrs === void 0)
    return [];
  const fields = Object.keys(corrs);
  return fields.map((fieldA) => {
    const correlatedFields = Object.keys(corrs[fieldA]);
    return correlatedFields.map((fieldB) => {
      return { fieldA, fieldB, info: corrs[fieldA][fieldB] };
    });
  }).flat();
};
var getReportCorrs = (printableCorrs, selectedField, max, min) => {
  const corrsToShow = printableCorrs.filter((item) => {
    const { info, fieldA, fieldB } = item;
    const fieldSelected = selectedField == ALL_FIELDS || fieldA == selectedField || fieldB == selectedField;
    return info && fieldSelected && info.corr !== NaN && info.corr <= max && info.corr >= min;
  }).sort((a, b) => b.info.corr - a.info.corr);
  return corrsToShow;
};
var buildDropdownOptionsFromCorrs = (printableCorrs) => {
  const fieldOptions = new Set();
  printableCorrs.forEach((corr) => {
    fieldOptions.add(corr.fieldA);
    fieldOptions.add(corr.fieldB);
  });
  const results = Array.from(fieldOptions);
  return results.sort((a, b) => a.localeCompare(b));
};
var top3PositiveCorrs = (correlations, sorted = true) => {
  if (!sorted)
    correlations.sort((a, b) => b.info.corr - a.info.corr);
  return correlations.slice(0, 3);
};
var top3NegativeCorrs = (correlations, sorted = true) => {
  if (!sorted)
    correlations.sort((a, b) => b.info.corr - a.info.corr);
  return correlations.slice(-3);
};
var ariaN = (n) => n ? "n: " + n.toFixed() : "";

// src/Components/CorrTableBody.svelte
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i].fieldA;
  child_ctx[5] = list[i].fieldB;
  child_ctx[6] = list[i].info.corr;
  child_ctx[7] = list[i].info.n;
  return child_ctx;
}
function create_if_block4(ctx) {
  let tr;
  let td0;
  let t0_value = ctx[4] + "";
  let t0;
  let t1;
  let td1;
  let t2_value = ctx[5] + "";
  let t2;
  let t3;
  let td2;
  let t4_value = roundNumber(ctx[6]) + "";
  let t4;
  let t5;
  let tr_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      t4 = text(t4_value);
      t5 = space();
      attr(tr, "aria-label", tr_aria_label_value = ariaN(ctx[7]));
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      append(td2, t4);
      append(tr, t5);
      if (!mounted) {
        dispose = listen(tr, "contextmenu", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = ctx2[4] + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && t2_value !== (t2_value = ctx2[5] + ""))
        set_data(t2, t2_value);
      if (dirty & 1 && t4_value !== (t4_value = roundNumber(ctx2[6]) + ""))
        set_data(t4, t4_value);
      if (dirty & 1 && tr_aria_label_value !== (tr_aria_label_value = ariaN(ctx2[7]))) {
        attr(tr, "aria-label", tr_aria_label_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block3(ctx) {
  let show_if = ctx[1](ctx[6]) && ctx[7] >= ctx[0].minN;
  let if_block_anchor;
  let if_block = show_if && create_if_block4(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 3)
        show_if = ctx2[1](ctx2[6]) && ctx2[7] >= ctx2[0].minN;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment6(ctx) {
  let tbody;
  let each_value = ctx[0].corrsToShow;
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  return {
    c() {
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
    },
    m(target, anchor) {
      insert(target, tbody, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tbody, null);
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 7) {
        each_value = ctx2[0].corrsToShow;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tbody, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(tbody);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { view } = $$props;
  let { criteria } = $$props;
  const { plugin } = view;
  const contextmenu_handler = (e) => menuForChartNStatsModal(e, plugin);
  $$self.$$set = ($$props2) => {
    if ("view" in $$props2)
      $$invalidate(0, view = $$props2.view);
    if ("criteria" in $$props2)
      $$invalidate(1, criteria = $$props2.criteria);
  };
  return [view, criteria, plugin, contextmenu_handler];
}
var CorrTableBody = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, { view: 0, criteria: 1 });
  }
};
var CorrTableBody_default = CorrTableBody;

// src/Components/CorrTableHeader.svelte
function create_fragment7(ctx) {
  let thead;
  return {
    c() {
      thead = element("thead");
      thead.innerHTML = `<tr><th>Field 1</th> 
		<th>Field 2</th> 
		<th>Correlation</th></tr>`;
    },
    m(target, anchor) {
      insert(target, thead, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(thead);
    }
  };
}
var CorrTableHeader = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment7, safe_not_equal, {});
  }
};
var CorrTableHeader_default = CorrTableHeader;

// src/Components/CorrTableTop3.svelte
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i].fieldA;
  child_ctx[5] = list[i].fieldB;
  child_ctx[6] = list[i].info.corr;
  child_ctx[7] = list[i].info.n;
  return child_ctx;
}
function create_each_block4(ctx) {
  let tr;
  let td0;
  let t0_value = ctx[4] + "";
  let t0;
  let t1;
  let td1;
  let t2_value = ctx[5] + "";
  let t2;
  let t3;
  let td2;
  let t4_value = ctx[6].toFixed(4) + "";
  let t4;
  let t5;
  let tr_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      t4 = text(t4_value);
      t5 = space();
      attr(tr, "aria-label", tr_aria_label_value = ariaN(ctx[7]));
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      append(td2, t4);
      append(tr, t5);
      if (!mounted) {
        dispose = listen(tr, "contextmenu", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = ctx2[4] + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && t2_value !== (t2_value = ctx2[5] + ""))
        set_data(t2, t2_value);
      if (dirty & 1 && t4_value !== (t4_value = ctx2[6].toFixed(4) + ""))
        set_data(t4, t4_value);
      if (dirty & 1 && tr_aria_label_value !== (tr_aria_label_value = ariaN(ctx2[7]))) {
        attr(tr, "aria-label", tr_aria_label_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment8(ctx) {
  let each_1_anchor;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { view } = $$props;
  let { top3 } = $$props;
  const { plugin } = view;
  const contextmenu_handler = (e) => menuForChartNStatsModal(e, plugin);
  $$self.$$set = ($$props2) => {
    if ("view" in $$props2)
      $$invalidate(2, view = $$props2.view);
    if ("top3" in $$props2)
      $$invalidate(0, top3 = $$props2.top3);
  };
  return [top3, plugin, view, contextmenu_handler];
}
var CorrTableTop3 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment8, safe_not_equal, { view: 2, top3: 0 });
  }
};
var CorrTableTop3_default = CorrTableTop3;

// src/Components/CorrelationsReport.svelte
function add_css3(target) {
  append_styles(target, "svelte-16114ox", "div.component.svelte-16114ox{padding:5px}div.standard.svelte-16114ox{padding:3px}table.svelte-16114ox{border-collapse:collapse;overflow:auto}table.svelte-16114ox{border:1px solid var(--background-modifier-border)}");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function create_each_block5(ctx) {
  let option;
  let t0_value = ctx[3](ctx[19]) + "";
  let t0;
  let t1;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      option.__value = option_value_value = ctx[19];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = ctx2[3](ctx2[19]) + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && option_value_value !== (option_value_value = ctx2[19])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_key_block_4(ctx) {
  let select;
  let mounted;
  let dispose;
  let each_value = ctx[0].fieldOptions;
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  return {
    c() {
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(select, "class", "dropdown");
      if (ctx[0].selectedField === void 0)
        add_render_callback(() => ctx[4].call(select));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(select, ctx[0].selectedField);
      if (!mounted) {
        dispose = [
          listen(select, "change", ctx[4]),
          listen(select, "change", function() {
            if (is_function(ctx[0].calculateReport))
              ctx[0].calculateReport.apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 9) {
        each_value = ctx[0].fieldOptions;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 1) {
        select_option(select, ctx[0].selectedField);
      }
    },
    d(detaching) {
      if (detaching)
        detach(select);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_5(ctx) {
  let div0;
  let strong0;
  let t1;
  let input0;
  let input0_value_value;
  let t2;
  let div1;
  let strong1;
  let t4;
  let input1;
  let input1_value_value;
  let t5;
  let div2;
  let strong2;
  let t7_value = "|r| >= ";
  let t7;
  let input2;
  let input2_value_value;
  let t8;
  let div3;
  let strong3;
  let t10;
  let t11_value = ctx[0].lower + " < |r| < " + ctx[0].medium + "";
  let t11;
  let t12;
  let div4;
  let strong4;
  let t14_value = "|r| =< ";
  let t14;
  let input3;
  let input3_value_value;
  let t15;
  let div5;
  let strong5;
  let t17;
  let t18_value = "n >= ";
  let t18;
  let input4;
  let input4_value_value;
  let mounted;
  let dispose;
  return {
    c() {
      div0 = element("div");
      strong0 = element("strong");
      strong0.textContent = "Max:";
      t1 = space();
      input0 = element("input");
      t2 = space();
      div1 = element("div");
      strong1 = element("strong");
      strong1.textContent = "Min:";
      t4 = space();
      input1 = element("input");
      t5 = space();
      div2 = element("div");
      strong2 = element("strong");
      strong2.textContent = "Strong: ";
      t7 = text(t7_value);
      input2 = element("input");
      t8 = space();
      div3 = element("div");
      strong3 = element("strong");
      strong3.textContent = "Medium:";
      t10 = space();
      t11 = text(t11_value);
      t12 = space();
      div4 = element("div");
      strong4 = element("strong");
      strong4.textContent = "Weak/No: ";
      t14 = text(t14_value);
      input3 = element("input");
      t15 = space();
      div5 = element("div");
      strong5 = element("strong");
      strong5.textContent = "Min sample size:";
      t17 = space();
      t18 = text(t18_value);
      input4 = element("input");
      attr(input0, "type", "number");
      input0.value = input0_value_value = ctx[0].max;
      attr(div0, "class", "standard svelte-16114ox");
      attr(input1, "type", "number");
      input1.value = input1_value_value = ctx[0].min;
      attr(div1, "class", "standard svelte-16114ox");
      attr(input2, "type", "number");
      input2.value = input2_value_value = ctx[0].medium;
      attr(div2, "class", "standard svelte-16114ox");
      attr(div3, "class", "standard svelte-16114ox");
      attr(input3, "type", "number");
      input3.value = input3_value_value = ctx[0].lower;
      attr(div4, "class", "standard svelte-16114ox");
      attr(input4, "type", "number");
      input4.value = input4_value_value = ctx[0].minN;
      attr(div5, "class", "standard svelte-16114ox");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, strong0);
      append(div0, t1);
      append(div0, input0);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      append(div1, strong1);
      append(div1, t4);
      append(div1, input1);
      insert(target, t5, anchor);
      insert(target, div2, anchor);
      append(div2, strong2);
      append(div2, t7);
      append(div2, input2);
      insert(target, t8, anchor);
      insert(target, div3, anchor);
      append(div3, strong3);
      append(div3, t10);
      append(div3, t11);
      insert(target, t12, anchor);
      insert(target, div4, anchor);
      append(div4, strong4);
      append(div4, t14);
      append(div4, input3);
      insert(target, t15, anchor);
      insert(target, div5, anchor);
      append(div5, strong5);
      append(div5, t17);
      append(div5, t18);
      append(div5, input4);
      if (!mounted) {
        dispose = [
          listen(input0, "change", ctx[6]),
          listen(input1, "change", ctx[7]),
          listen(input2, "change", ctx[8]),
          listen(input3, "change", ctx[9]),
          listen(input4, "change", ctx[10])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input0_value_value !== (input0_value_value = ctx2[0].max) && input0.value !== input0_value_value) {
        input0.value = input0_value_value;
      }
      if (dirty & 1 && input1_value_value !== (input1_value_value = ctx2[0].min) && input1.value !== input1_value_value) {
        input1.value = input1_value_value;
      }
      if (dirty & 1 && input2_value_value !== (input2_value_value = ctx2[0].medium) && input2.value !== input2_value_value) {
        input2.value = input2_value_value;
      }
      if (dirty & 1 && t11_value !== (t11_value = ctx2[0].lower + " < |r| < " + ctx2[0].medium + ""))
        set_data(t11, t11_value);
      if (dirty & 1 && input3_value_value !== (input3_value_value = ctx2[0].lower) && input3.value !== input3_value_value) {
        input3.value = input3_value_value;
      }
      if (dirty & 1 && input4_value_value !== (input4_value_value = ctx2[0].minN) && input4.value !== input4_value_value) {
        input4.value = input4_value_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(div2);
      if (detaching)
        detach(t8);
      if (detaching)
        detach(div3);
      if (detaching)
        detach(t12);
      if (detaching)
        detach(div4);
      if (detaching)
        detach(t15);
      if (detaching)
        detach(div5);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_4(ctx) {
  let table;
  let header;
  let t;
  let top3;
  let current;
  header = new CorrTableHeader_default({});
  top3 = new CorrTableTop3_default({
    props: {
      view: ctx[0],
      top3: ctx[0].topPos3
    }
  });
  return {
    c() {
      table = element("table");
      create_component(header.$$.fragment);
      t = space();
      create_component(top3.$$.fragment);
      attr(table, "class", "markdown-preview-view svelte-16114ox");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      mount_component(header, table, null);
      append(table, t);
      mount_component(top3, table, null);
      current = true;
    },
    p(ctx2, dirty) {
      const top3_changes = {};
      if (dirty & 1)
        top3_changes.view = ctx2[0];
      if (dirty & 1)
        top3_changes.top3 = ctx2[0].topPos3;
      top3.$set(top3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(top3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(top3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(header);
      destroy_component(top3);
    }
  };
}
function create_if_block_3(ctx) {
  let table;
  let header;
  let t;
  let top3;
  let current;
  header = new CorrTableHeader_default({});
  top3 = new CorrTableTop3_default({
    props: {
      view: ctx[0],
      top3: ctx[0].topNeg3
    }
  });
  return {
    c() {
      table = element("table");
      create_component(header.$$.fragment);
      t = space();
      create_component(top3.$$.fragment);
      attr(table, "class", "markdown-preview-view svelte-16114ox");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      mount_component(header, table, null);
      append(table, t);
      mount_component(top3, table, null);
      current = true;
    },
    p(ctx2, dirty) {
      const top3_changes = {};
      if (dirty & 1)
        top3_changes.view = ctx2[0];
      if (dirty & 1)
        top3_changes.top3 = ctx2[0].topNeg3;
      top3.$set(top3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(top3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(top3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(header);
      destroy_component(top3);
    }
  };
}
function create_if_block_2(ctx) {
  let table;
  let header;
  let t;
  let body;
  let current;
  header = new CorrTableHeader_default({});
  body = new CorrTableBody_default({
    props: {
      view: ctx[0],
      criteria: ctx[14]
    }
  });
  return {
    c() {
      table = element("table");
      create_component(header.$$.fragment);
      t = space();
      create_component(body.$$.fragment);
      attr(table, "class", "markdown-preview-view svelte-16114ox");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      mount_component(header, table, null);
      append(table, t);
      mount_component(body, table, null);
      current = true;
    },
    p(ctx2, dirty) {
      const body_changes = {};
      if (dirty & 1)
        body_changes.view = ctx2[0];
      if (dirty & 1)
        body_changes.criteria = ctx2[14];
      body.$set(body_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(body.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(body.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(header);
      destroy_component(body);
    }
  };
}
function create_if_block_12(ctx) {
  let table;
  let header;
  let t;
  let body;
  let current;
  header = new CorrTableHeader_default({});
  body = new CorrTableBody_default({
    props: {
      view: ctx[0],
      criteria: ctx[16]
    }
  });
  return {
    c() {
      table = element("table");
      create_component(header.$$.fragment);
      t = space();
      create_component(body.$$.fragment);
      attr(table, "class", "markdown-preview-view svelte-16114ox");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      mount_component(header, table, null);
      append(table, t);
      mount_component(body, table, null);
      current = true;
    },
    p(ctx2, dirty) {
      const body_changes = {};
      if (dirty & 1)
        body_changes.view = ctx2[0];
      if (dirty & 1)
        body_changes.criteria = ctx2[16];
      body.$set(body_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(body.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(body.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(header);
      destroy_component(body);
    }
  };
}
function create_if_block5(ctx) {
  let table;
  let header;
  let t;
  let body;
  let current;
  header = new CorrTableHeader_default({});
  body = new CorrTableBody_default({
    props: {
      view: ctx[0],
      criteria: ctx[18]
    }
  });
  return {
    c() {
      table = element("table");
      create_component(header.$$.fragment);
      t = space();
      create_component(body.$$.fragment);
      attr(table, "class", "markdown-preview-view svelte-16114ox");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      mount_component(header, table, null);
      append(table, t);
      mount_component(body, table, null);
      current = true;
    },
    p(ctx2, dirty) {
      const body_changes = {};
      if (dirty & 1)
        body_changes.view = ctx2[0];
      if (dirty & 1)
        body_changes.criteria = ctx2[18];
      body.$set(body_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(body.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(body.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(header);
      destroy_component(body);
    }
  };
}
function create_key_block_3(ctx) {
  let h30;
  let t0;
  let button0;
  let t1_value = ctx[1](ctx[0].showStrong) + "";
  let t1;
  let button0_aria_label_value;
  let t2;
  let t3;
  let h31;
  let t4;
  let button1;
  let t5_value = ctx[1](ctx[0].showMedium) + "";
  let t5;
  let button1_aria_label_value;
  let t6;
  let t7;
  let h32;
  let t8;
  let button2;
  let t9_value = ctx[1](ctx[0].showWeak) + "";
  let t9;
  let button2_aria_label_value;
  let t10;
  let if_block2_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[0].showStrong && create_if_block_2(ctx);
  let if_block1 = ctx[0].showMedium && create_if_block_12(ctx);
  let if_block2 = ctx[0].showWeak && create_if_block5(ctx);
  return {
    c() {
      h30 = element("h3");
      t0 = text("Strongly Correlated\r\n						");
      button0 = element("button");
      t1 = text(t1_value);
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      h31 = element("h3");
      t4 = text("Somewhat Correlated\r\n						");
      button1 = element("button");
      t5 = text(t5_value);
      t6 = space();
      if (if_block1)
        if_block1.c();
      t7 = space();
      h32 = element("h3");
      t8 = text("Weakly/Not Correlated\r\n						");
      button2 = element("button");
      t9 = text(t9_value);
      t10 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      attr(button0, "aria-label", button0_aria_label_value = ctx[2](ctx[0].showStrong));
      attr(button1, "aria-label", button1_aria_label_value = ctx[2](ctx[0].showMedium));
      attr(button2, "aria-label", button2_aria_label_value = ctx[2](ctx[0].showWeak));
    },
    m(target, anchor) {
      insert(target, h30, anchor);
      append(h30, t0);
      append(h30, button0);
      append(button0, t1);
      insert(target, t2, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t3, anchor);
      insert(target, h31, anchor);
      append(h31, t4);
      append(h31, button1);
      append(button1, t5);
      insert(target, t6, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t7, anchor);
      insert(target, h32, anchor);
      append(h32, t8);
      append(h32, button2);
      append(button2, t9);
      insert(target, t10, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[13]),
          listen(button1, "click", ctx[15]),
          listen(button2, "click", ctx[17])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx2[1](ctx2[0].showStrong) + ""))
        set_data(t1, t1_value);
      if (!current || dirty & 1 && button0_aria_label_value !== (button0_aria_label_value = ctx2[2](ctx2[0].showStrong))) {
        attr(button0, "aria-label", button0_aria_label_value);
      }
      if (ctx2[0].showStrong) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t3.parentNode, t3);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty & 1) && t5_value !== (t5_value = ctx2[1](ctx2[0].showMedium) + ""))
        set_data(t5, t5_value);
      if (!current || dirty & 1 && button1_aria_label_value !== (button1_aria_label_value = ctx2[2](ctx2[0].showMedium))) {
        attr(button1, "aria-label", button1_aria_label_value);
      }
      if (ctx2[0].showMedium) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_12(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t7.parentNode, t7);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if ((!current || dirty & 1) && t9_value !== (t9_value = ctx2[1](ctx2[0].showWeak) + ""))
        set_data(t9, t9_value);
      if (!current || dirty & 1 && button2_aria_label_value !== (button2_aria_label_value = ctx2[2](ctx2[0].showWeak))) {
        attr(button2, "aria-label", button2_aria_label_value);
      }
      if (ctx2[0].showWeak) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block5(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h30);
      if (detaching)
        detach(t2);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(h31);
      if (detaching)
        detach(t6);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t7);
      if (detaching)
        detach(h32);
      if (detaching)
        detach(t10);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_key_block_2(ctx) {
  let h3;
  let t0;
  let button;
  let t1_value = ctx[1](ctx[0].showTopNeg) + "";
  let t1;
  let button_aria_label_value;
  let t2;
  let t3;
  let previous_key = [ctx[0].lower, ctx[0].medium];
  let key_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[0].showTopNeg && create_if_block_3(ctx);
  let key_block = create_key_block_3(ctx);
  return {
    c() {
      h3 = element("h3");
      t0 = text("Top 3 Negative Correlations\r\n					");
      button = element("button");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      key_block.c();
      key_block_anchor = empty();
      attr(button, "aria-label", button_aria_label_value = ctx[2](ctx[0].showTopNeg));
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t0);
      append(h3, button);
      append(button, t1);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t3, anchor);
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[12]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx2[1](ctx2[0].showTopNeg) + ""))
        set_data(t1, t1_value);
      if (!current || dirty & 1 && button_aria_label_value !== (button_aria_label_value = ctx2[2](ctx2[0].showTopNeg))) {
        attr(button, "aria-label", button_aria_label_value);
      }
      if (ctx2[0].showTopNeg) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t3.parentNode, t3);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 1 && safe_not_equal(previous_key, previous_key = [ctx2[0].lower, ctx2[0].medium])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block_3(ctx2);
        key_block.c();
        transition_in(key_block);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_key_block_1(ctx) {
  let h3;
  let t0;
  let button;
  let t1_value = ctx[1](ctx[0].showTopPos) + "";
  let t1;
  let button_aria_label_value;
  let t2;
  let t3;
  let previous_key = ctx[0].min;
  let key_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[0].showTopPos && create_if_block_4(ctx);
  let key_block = create_key_block_2(ctx);
  return {
    c() {
      h3 = element("h3");
      t0 = text("Top 3 Positive Correlations\r\n				");
      button = element("button");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      key_block.c();
      key_block_anchor = empty();
      attr(button, "aria-label", button_aria_label_value = ctx[2](ctx[0].showTopPos));
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t0);
      append(h3, button);
      append(button, t1);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t3, anchor);
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[11]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx2[1](ctx2[0].showTopPos) + ""))
        set_data(t1, t1_value);
      if (!current || dirty & 1 && button_aria_label_value !== (button_aria_label_value = ctx2[2](ctx2[0].showTopPos))) {
        attr(button, "aria-label", button_aria_label_value);
      }
      if (ctx2[0].showTopPos) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t3.parentNode, t3);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 1 && safe_not_equal(previous_key, previous_key = ctx2[0].min)) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block_2(ctx2);
        key_block.c();
        transition_in(key_block);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_key_block(ctx) {
  let h3;
  let t0;
  let button;
  let t1_value = ctx[1](ctx[0].showStandards) + "";
  let t1;
  let button_aria_label_value;
  let t2;
  let t3;
  let previous_key = ctx[0].max;
  let key_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[0].showStandards && create_if_block_5(ctx);
  let key_block = create_key_block_1(ctx);
  return {
    c() {
      h3 = element("h3");
      t0 = text("Standards:\r\n			");
      button = element("button");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      key_block.c();
      key_block_anchor = empty();
      attr(button, "aria-label", button_aria_label_value = ctx[2](ctx[0].showStandards));
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t0);
      append(h3, button);
      append(button, t1);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t3, anchor);
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx2[1](ctx2[0].showStandards) + ""))
        set_data(t1, t1_value);
      if (!current || dirty & 1 && button_aria_label_value !== (button_aria_label_value = ctx2[2](ctx2[0].showStandards))) {
        attr(button, "aria-label", button_aria_label_value);
      }
      if (ctx2[0].showStandards) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_5(ctx2);
          if_block.c();
          if_block.m(t3.parentNode, t3);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 1 && safe_not_equal(previous_key, previous_key = ctx2[0].max)) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block_1(ctx2);
        key_block.c();
        transition_in(key_block);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment9(ctx) {
  let div;
  let h12;
  let t1;
  let previous_key = ctx[0].fieldOptions;
  let t2;
  let previous_key_1 = ctx[0].selectedField;
  let current;
  let key_block0 = create_key_block_4(ctx);
  let key_block1 = create_key_block(ctx);
  return {
    c() {
      div = element("div");
      h12 = element("h1");
      h12.textContent = "Correlations Report";
      t1 = space();
      key_block0.c();
      t2 = space();
      key_block1.c();
      attr(div, "class", "component svelte-16114ox");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, h12);
      append(div, t1);
      key_block0.m(div, null);
      append(div, t2);
      key_block1.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && safe_not_equal(previous_key, previous_key = ctx2[0].fieldOptions)) {
        key_block0.d(1);
        key_block0 = create_key_block_4(ctx2);
        key_block0.c();
        key_block0.m(div, t2);
      } else {
        key_block0.p(ctx2, dirty);
      }
      if (dirty & 1 && safe_not_equal(previous_key_1, previous_key_1 = ctx2[0].selectedField)) {
        group_outros();
        transition_out(key_block1, 1, 1, noop);
        check_outros();
        key_block1 = create_key_block(ctx2);
        key_block1.c();
        transition_in(key_block1);
        key_block1.m(div, null);
      } else {
        key_block1.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block1);
      current = true;
    },
    o(local) {
      transition_out(key_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      key_block0.d(detaching);
      key_block1.d(detaching);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { view } = $$props;
  const getButtonText = (show) => show ? "\u2193" : "\u2191";
  const ariaShowText = (show) => show ? "Hide section" : "Show section";
  const displaySubfield = (field) => field.split(".").last();
  function select_change_handler() {
    view.selectedField = select_value(this);
    $$invalidate(0, view);
  }
  const click_handler = () => $$invalidate(0, view.showStandards = !view.showStandards, view);
  const change_handler = (e) => {
    $$invalidate(0, view.max = parseFloat(e.target.value), view);
    view.calculateReport();
  };
  const change_handler_1 = (e) => {
    $$invalidate(0, view.min = parseFloat(e.target.value), view);
    view.calculateReport();
  };
  const change_handler_2 = (e) => {
    $$invalidate(0, view.medium = parseFloat(e.target.value), view);
    view.calculateReport();
  };
  const change_handler_3 = (e) => {
    $$invalidate(0, view.lower = parseFloat(e.target.value), view);
    view.calculateReport();
  };
  const change_handler_4 = (e) => {
    $$invalidate(0, view.minN = parseFloat(e.target.value), view);
    view.calculateReport();
  };
  const click_handler_1 = () => $$invalidate(0, view.showTopPos = !view.showTopPos, view);
  const click_handler_2 = () => $$invalidate(0, view.showTopNeg = !view.showTopNeg, view);
  const click_handler_3 = () => $$invalidate(0, view.showStrong = !view.showStrong, view);
  const func = (corr) => Math.abs(corr) >= view.medium;
  const click_handler_4 = () => $$invalidate(0, view.showMedium = !view.showMedium, view);
  const func_1 = (corr) => Math.abs(corr) < view.medium && Math.abs(corr) > view.lower;
  const click_handler_5 = () => $$invalidate(0, view.showWeak = !view.showWeak, view);
  const func_2 = (corr) => Math.abs(corr) < view.lower;
  $$self.$$set = ($$props2) => {
    if ("view" in $$props2)
      $$invalidate(0, view = $$props2.view);
  };
  return [
    view,
    getButtonText,
    ariaShowText,
    displaySubfield,
    select_change_handler,
    click_handler,
    change_handler,
    change_handler_1,
    change_handler_2,
    change_handler_3,
    change_handler_4,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    func,
    click_handler_4,
    func_1,
    click_handler_5,
    func_2
  ];
}
var CorrelationsReport = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment9, safe_not_equal, { view: 0 }, add_css3);
  }
};
var CorrelationsReport_default = CorrelationsReport;

// src/correlationUtils.ts
var import_luxon2 = __toModule(require_luxon());
function arrayOverlap(A, B) {
  const iA = [];
  A.forEach((a, i) => {
    if (a !== void 0)
      iA.push(i);
  });
  const iB = [];
  B.forEach((b, i) => {
    if (b !== void 0)
      iB.push(i);
  });
  const aOverlap = A.filter((a, i) => iA.includes(i) && iB.includes(i));
  const bOverlap = B.filter((b, i) => iA.includes(i) && iB.includes(i));
  if (!aOverlap.length || !bOverlap.length)
    return [[], []];
  return [aOverlap, bOverlap];
}
var inferType = (xs) => {
  const defineds = xs.filter((x) => x);
  const types = defineds.map((x) => typeof x);
  if (!defineds.length)
    return "undefined";
  const thresh = defineds.length / 2;
  if (types.filter((x) => x === "number").length >= thresh)
    return "number";
  else if (types.filter((x) => x === "string").length >= thresh)
    return "string";
  else
    return "object";
};
var splitAndTrim2 = (fields) => {
  if (fields === "")
    return [];
  else
    return fields.split(",").map((str) => str.trim());
};
var getInnerValue = (value) => {
  const unproxied = unproxy(value);
  if (unproxied.length === 1) {
    if (typeof unproxied[0] === "string") {
      let list = unproxied[0];
      if (list.startsWith("[") && list.endsWith("]")) {
        list = list.slice(1, -1);
      }
      const splits = splitAndTrim2(list).map((item) => {
        if (item.startsWith(`"`) && item.endsWith(`"`)) {
          return item.slice(1, -1);
        } else
          return item;
      });
      if (splits.length === 1)
        return splits[0];
      else
        return splits;
    } else {
      if (unproxied[0].type === "file") {
        return unproxied[0].path;
      } else
        return unproxied[0];
    }
  } else {
    if (unproxied[0].type === "file") {
      return unproxied.map((link) => link.path);
    } else
      return unproxied;
  }
};
var unproxy = (item) => {
  const unproxied = [];
  const queue = [item];
  while (queue.length) {
    const currItem = queue.shift();
    if (typeof currItem.defaultComparator === "function") {
      const possibleUnproxied = Object.assign({}, currItem);
      const { values } = possibleUnproxied;
      if (values)
        queue.push(...values);
      else
        unproxied.push(possibleUnproxied);
    } else
      unproxied.push(currItem);
  }
  return unproxied;
};
var processPages = (pages, fieldsToCheck) => {
  const dates = [];
  pages.forEach((page) => {
    const potentialDate = import_luxon2.DateTime.fromISO(page.file.name);
    if (potentialDate.isValid)
      dates.push(potentialDate);
    fieldsToCheck.forEach((field) => {
      const value = page[field];
      if (value) {
        page["hasFieldsOfInterest"] = true;
        page[field] = getInnerValue(value);
      }
    });
  });
  return {
    pages: pages.filter((page) => page.hasFieldsOfInterest),
    dates
  };
};
var buildAllPairs = (items, sortedSkipPairs, sorted = false) => {
  if (!sorted)
    items.sort((a, b) => a.localeCompare(b));
  const stringifiedSortedSkipPairs = sortedSkipPairs.map((value) => value.toString());
  let results = [];
  for (let outerIndex = 0; outerIndex < items.length; outerIndex++) {
    let first = items[outerIndex];
    for (let innerIndex = outerIndex + 1; innerIndex < items.length; innerIndex++) {
      const pair = [first, items[innerIndex]];
      if (!stringifiedSortedSkipPairs.includes(pair.toString())) {
        results.push([first, items[innerIndex]]);
      }
    }
  }
  return results;
};
var buildAllDataByFieldsToCheck = (data, fieldsToCheck) => {
  const dataByField = {};
  for (const field of fieldsToCheck) {
    dataByField[field] = data.map((page) => page[field]);
  }
  return dataByField;
};
var buildAllCorrelations = (data, fieldsToCheck, pairsToSkip, debugMode = false) => {
  fieldsToCheck.sort((a, b) => a.localeCompare(b));
  const alphabetizedSkipPairs = [];
  for (const skipPair of pairsToSkip) {
    skipPair.sort((a, b) => a.localeCompare(b));
    alphabetizedSkipPairs.push(skipPair);
  }
  const corrs = {};
  const dataByField = buildAllDataByFieldsToCheck(data, fieldsToCheck);
  let pairs = buildAllPairs(fieldsToCheck, alphabetizedSkipPairs, true);
  for (const pair of pairs) {
    const [fieldA, fieldB] = pair;
    const fieldAData = dataByField[fieldA];
    const fieldBData = dataByField[fieldB];
    buildCorrelation(fieldA, fieldB, fieldAData, fieldBData, corrs);
  }
  if (debugMode)
    console.log({ corrs });
  return corrs;
};
var buildCorrelationNumberAndObject = (numberField, numberFieldData, objectField, objectFieldData, corrs) => {
  if (!corrs[numberField]) {
    corrs[numberField] = {};
  }
  const oA = numberFieldData.filter((a) => a);
  const oB = objectFieldData.filter((b, i) => numberFieldData[i] !== void 0);
  const uniqueStrs = [...new Set(oB.flat())].filter((str) => typeof str === "string");
  uniqueStrs.forEach((subF) => {
    const subA = oA;
    const subB = oB.map((b) => b && b.includes(subF) ? 1 : 0);
    const corr = getPointBiserialCorrelation(subB, subA);
    corrs[numberField][objectField + "." + subF] = corr ? { corr, n: subA.length } : null;
  });
  return corrs;
};
var buildCorrelationNumberAndString = (stringField, stringFieldData, numberField, numberFieldData, corrs) => {
  if (!corrs[numberField]) {
    corrs[numberField] = {};
  }
  const oA = numberFieldData.filter((a) => a);
  const oB = stringFieldData.filter((b, i) => numberFieldData[i] !== void 0).map((b) => b ?? 0);
  const uniqueStrs = [...new Set(oB)].filter((str) => typeof str === "string");
  uniqueStrs.forEach((subF) => {
    const subA = oA;
    const subB = oB.map((b) => b === subF ? 1 : 0);
    const corr = getPointBiserialCorrelation(subB, subA);
    corrs[numberField][stringField + "." + subF] = corr ? { corr, n: subA.length } : null;
  });
  return corrs;
};
var buildCorrelation = (fieldA, fieldB, fieldAData, fieldBData, corrs) => {
  if (fieldA == fieldB) {
    return;
  }
  if (!corrs[fieldA])
    corrs[fieldA] = {};
  const fieldAType = inferType(fieldAData);
  const fieldBType = inferType(fieldBData);
  if (fieldAType === "number" && fieldBType === "number") {
    const [oA, oB] = arrayOverlap(fieldAData, fieldBData);
    const corr = getPearsonCorrelation(oA, oB);
    corrs[fieldA][fieldB] = corr ? { corr, n: oA.length } : null;
  } else if (fieldAType === "number" && fieldBType === "string") {
    corrs = buildCorrelationNumberAndString(fieldB, fieldBData, fieldA, fieldAData, corrs);
  } else if (fieldAType === "number" && fieldBType === "object") {
    corrs = buildCorrelationNumberAndObject(fieldA, fieldAData, fieldB, fieldBData, corrs);
  } else if (fieldAType === "string" && fieldBType === "string") {
    corrs[fieldA][fieldB] = null;
  } else if (fieldAType === "string" && fieldBType === "number") {
    corrs = buildCorrelationNumberAndString(fieldA, fieldAData, fieldB, fieldBData, corrs);
  } else if (fieldAType === "string" && fieldBType === "object") {
    corrs[fieldA][fieldB] = null;
  } else if (fieldAType === "object" && fieldBType === "object") {
    corrs[fieldA][fieldB] = null;
  } else if (fieldAType === "object" && fieldBType === "number") {
    corrs = buildCorrelationNumberAndObject(fieldB, fieldBData, fieldA, fieldAData, corrs);
  } else if (fieldAType === "object" && fieldBType === "string") {
    corrs[fieldA][fieldB] = null;
  }
  return corrs;
};

// src/CorrelationsReportView.ts
var CorrelationView = class extends import_obsidian5.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.icon = addFeatherIcon("trending-up");
    this.calculateReport = () => {
      var dropdownCorrs = buildPrintableCorrs(this.plugin.index.corrs);
      this.corrsToShow = getReportCorrs(dropdownCorrs, this.selectedField, this.max, this.min);
      this.topPos3 = top3PositiveCorrs(this.corrsToShow);
      this.topNeg3 = top3NegativeCorrs(this.corrsToShow);
      this.fieldOptions = [ALL_FIELDS, ...buildDropdownOptionsFromCorrs(dropdownCorrs)];
    };
    this.plugin = plugin;
    this.lower = 0.5;
    this.medium = 0.75;
    this.max = 9999;
    this.min = -9999;
    this.showStandards = true;
    this.showTopPos = true;
    this.showTopNeg = true;
    this.showStrong = true;
    this.showMedium = true;
    this.showWeak = false;
    this.minN = 1;
    this.corrsToShow = [];
    this.topPos3 = [];
    this.topNeg3 = [];
    this.selectedField = ALL_FIELDS;
    this.fieldOptions = [ALL_FIELDS];
    this.calculateReport();
  }
  async onload() {
    super.onload();
  }
  getViewType() {
    return CORRELATION_REPORT_VIEW;
  }
  getDisplayText() {
    return "Correlations View";
  }
  async onOpen() {
    await this.draw();
  }
  onClose() {
    this.view?.$destroy();
    return Promise.resolve();
  }
  async draw() {
    const { contentEl, plugin } = this;
    contentEl.empty();
    contentEl.addClass("DA-corr-view");
    contentEl.createEl("button", { text: "\u21BB", attr: { "aria-label": "Refresh Index & Redraw" } }, (but) => {
      but.onclick = async () => {
        await plugin.refreshIndex();
        plugin.index.corrs = buildAllCorrelations(plugin.index.data, plugin.settings.fieldsToCheck, plugin.settings.fieldsToIgnoreForCorrs);
        this.calculateReport();
        await this.draw();
      };
    });
    new CorrelationsReport_default({ target: contentEl, props: { view: this } });
  }
};

// src/CorrelationView.ts
var import_obsidian7 = __toModule(require("obsidian"));

// src/Components/Correlations.svelte
var import_nouislider = __toModule(require_nouislider());
var import_obsidian6 = __toModule(require("obsidian"));
function add_css4(target) {
  append_styles(target, "svelte-1xw1t7u", "div.component.svelte-1xw1t7u.svelte-1xw1t7u{padding:5px}div.slider.svelte-1xw1t7u.svelte-1xw1t7u{width:150px;height:10px;display:inline-block}table.svelte-1xw1t7u.svelte-1xw1t7u{border-collapse:collapse;overflow:auto}table.svelte-1xw1t7u.svelte-1xw1t7u,table.svelte-1xw1t7u tr.svelte-1xw1t7u,table.svelte-1xw1t7u td.svelte-1xw1t7u{border:1px solid var(--background-modifier-border)}");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i].fA;
  child_ctx[18] = list[i].fB;
  child_ctx[19] = list[i].info.corr;
  child_ctx[20] = list[i].info.n;
  return child_ctx;
}
function create_else_block2(ctx) {
  let table;
  let thead;
  let t5;
  let tbody;
  let previous_key = ctx[2];
  let key_block = create_key_block2(ctx);
  return {
    c() {
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr class="svelte-1xw1t7u"><th>Field 1</th> 
					<th>Field 2</th> 
					<th>Correlation</th></tr>`;
      t5 = space();
      tbody = element("tbody");
      key_block.c();
      attr(table, "class", "markdown-preview-view svelte-1xw1t7u");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      append(table, thead);
      append(table, t5);
      append(table, tbody);
      key_block.m(tbody, null);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && safe_not_equal(previous_key, previous_key = ctx2[2])) {
        key_block.d(1);
        key_block = create_key_block2(ctx2);
        key_block.c();
        key_block.m(tbody, null);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    d(detaching) {
      if (detaching)
        detach(table);
      key_block.d(detaching);
    }
  };
}
function create_if_block6(ctx) {
  let t;
  return {
    c() {
      t = text("No relevant fields in current file. Select a different file.");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_13(ctx) {
  let tr;
  let td0;
  let t0_value = ctx[17] + "";
  let t0;
  let t1;
  let td1;
  let t2_value = ctx[18] + "";
  let t2;
  let t3;
  let td2;
  let t4_value = ctx[19].toFixed(4) + "";
  let t4;
  let t5;
  let tr_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      t4 = text(t4_value);
      t5 = space();
      attr(td0, "class", "svelte-1xw1t7u");
      attr(td1, "class", "svelte-1xw1t7u");
      attr(td2, "class", "svelte-1xw1t7u");
      attr(tr, "aria-label", tr_aria_label_value = ctx[20] ? "n: " + ctx[20].toFixed() : "");
      attr(tr, "aria-label-position", "left");
      attr(tr, "class", "svelte-1xw1t7u");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      append(td2, t4);
      append(tr, t5);
      if (!mounted) {
        dispose = listen(tr, "contextmenu", ctx[9]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(tr);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block6(ctx) {
  let show_if = (ctx[3].includes(ctx[17]) || ctx[18].includes(".") && ctx[3].includes(ctx[18])) && ctx[0] <= ctx[19] && ctx[19] <= ctx[1];
  let if_block_anchor;
  let if_block = show_if && create_if_block_13(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 11)
        show_if = (ctx2[3].includes(ctx2[17]) || ctx2[18].includes(".") && ctx2[3].includes(ctx2[18])) && ctx2[0] <= ctx2[19] && ctx2[19] <= ctx2[1];
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_13(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_key_block2(ctx) {
  let each_1_anchor;
  let each_value = ctx[6];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 91) {
        each_value = ctx2[6];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment10(ctx) {
  let div2;
  let div1;
  let label0;
  let div0;
  let createSlider_action;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let label1;
  let input;
  let t6;
  let t7;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[6].length == 0)
      return create_if_block6;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      label0 = element("label");
      div0 = element("div");
      t0 = text("\r\n			(");
      t1 = text(ctx[0]);
      t2 = text(") \u2194 (");
      t3 = text(ctx[1]);
      t4 = text(")");
      t5 = space();
      label1 = element("label");
      input = element("input");
      t6 = text("\r\n			|Abs|");
      t7 = space();
      if_block.c();
      attr(div0, "class", "slider svelte-1xw1t7u");
      attr(input, "type", "checkbox");
      attr(div2, "class", "component svelte-1xw1t7u");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, label0);
      append(label0, div0);
      append(label0, t0);
      append(label0, t1);
      append(label0, t2);
      append(label0, t3);
      append(label0, t4);
      append(div1, t5);
      append(div1, label1);
      append(label1, input);
      input.checked = ctx[2];
      append(label1, t6);
      append(div2, t7);
      if_block.m(div2, null);
      if (!mounted) {
        dispose = [
          action_destroyer(createSlider_action = ctx[5].call(null, div0)),
          listen(input, "change", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        set_data(t1, ctx2[0]);
      if (dirty & 2)
        set_data(t3, ctx2[1]);
      if (dirty & 4) {
        input.checked = ctx2[2];
      }
      if_block.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { view } = $$props;
  const { plugin, app } = view;
  const { index } = plugin;
  const { corrs } = index;
  let [lower, upper] = [-1, 0.5];
  let absQ = false;
  let slider;
  function createSlider(node) {
    slider = import_nouislider.default.create(node, {
      start: [lower, upper],
      connect: true,
      range: { min: -1, max: 1 }
    });
    slider.on("update", (e) => {
      $$invalidate(0, lower = Number.parseFloat(e[0]));
      $$invalidate(1, upper = Number.parseFloat(e[1]));
    });
  }
  function updateFieldsInFile(currFile2) {
    const currPage = index.data.find((d) => d.file.name === currFile2.basename);
    if (!currPage) {
      return [];
    }
    const fieldsInFile2 = Object.keys(currPage);
    const { unwrappedFields } = plugin;
    Object.keys(unwrappedFields).forEach((field) => {
      if (fieldsInFile2.includes(field)) {
        unwrappedFields[field].forEach((subF) => {
          if (currPage[field].includes && currPage[field]?.includes(subF)) {
            fieldsInFile2.push(field + "." + subF);
          }
        });
      }
    });
    console.log({ fieldsInFile: fieldsInFile2 });
    return fieldsInFile2;
  }
  let currFile = app.workspace.getActiveFile();
  let fieldsInFile = updateFieldsInFile(currFile);
  plugin.registerEvent(app.workspace.on("active-leaf-change", () => {
    currFile = app.workspace.getActiveFile();
    $$invalidate(3, fieldsInFile = updateFieldsInFile(currFile));
  }));
  const fields = Object.keys(corrs);
  const corrsToShow = fields.map((fA) => fieldsInFile.map((fB) => {
    return { fA, fB, info: corrs[fA][fB] };
  })).flat().filter((item) => {
    const { info } = item;
    return info && info.corr !== NaN;
  }).sort((a, b) => b.info.corr - a.info.corr);
  console.log({ corrsToShow });
  function input_change_handler() {
    absQ = this.checked;
    $$invalidate(2, absQ);
  }
  const contextmenu_handler = (e) => menuForChartNStatsModal(e, plugin);
  $$self.$$set = ($$props2) => {
    if ("view" in $$props2)
      $$invalidate(7, view = $$props2.view);
  };
  return [
    lower,
    upper,
    absQ,
    fieldsInFile,
    plugin,
    createSlider,
    corrsToShow,
    view,
    input_change_handler,
    contextmenu_handler
  ];
}
var Correlations = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment10, safe_not_equal, { view: 7 }, add_css4);
  }
};
var Correlations_default = Correlations;

// src/CorrelationView.ts
var CorrelationView2 = class extends import_obsidian7.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.icon = addFeatherIcon("trending-up");
    this.plugin = plugin;
  }
  async onload() {
    super.onload();
  }
  getViewType() {
    return CORRELATION_VIEW;
  }
  getDisplayText() {
    return "Correlations View";
  }
  async onOpen() {
    await this.draw();
  }
  onClose() {
    this.view?.$destroy();
    return Promise.resolve();
  }
  async draw() {
    const { contentEl, plugin } = this;
    contentEl.empty();
    contentEl.addClass("DA-corr-view");
    contentEl.createEl("button", { text: "\u21BB", attr: { "aria-label": "Refresh Index & Redraw" } }, (but) => {
      but.onclick = async () => {
        await plugin.refreshIndex();
        plugin.index.corrs = buildAllCorrelations(plugin.index.data, plugin.settings.fieldsToCheck, plugin.settings.fieldsToIgnoreForCorrs);
        await this.draw();
      };
    });
    new Correlations_default({ target: contentEl, props: { view: this } });
  }
};

// src/SettingTab.ts
var import_obsidian8 = __toModule(require("obsidian"));
var fragWithHTML = (html) => createFragment((frag) => frag.createDiv().innerHTML = html);
var SettingTab = class extends import_obsidian8.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl, plugin } = this;
    const { settings } = plugin;
    containerEl.empty();
    new import_obsidian8.Setting(containerEl).setClass("fields-to-check").setName("Fields to Check").setDesc("A comma-separated list of fields to look for data in.").addTextArea((text2) => {
      text2.setValue(settings.fieldsToCheck.join(", "));
      text2.inputEl.onblur = async () => {
        const splits = splitAndTrim2(text2.getValue());
        const noDups = [...new Set(splits)];
        if (splits.length !== noDups.length) {
          new import_obsidian8.Notice("Duplicates found and removed");
          settings.fieldsToCheck = noDups;
          await plugin.saveSettings();
          this.display();
        } else {
          settings.fieldsToCheck = splits;
          await plugin.saveSettings();
        }
        await plugin.refreshIndex();
      };
    });
    new import_obsidian8.Setting(containerEl).setName("Add All Numeric Fields").setDesc("Add all fields with numeric values to the list of fields to check").addButton((but) => {
      but.setButtonText("Add").onClick(async () => {
        const { data } = plugin.index;
        for (const page of data) {
          for (const field in page) {
            if (typeof page[field] === "number" && !settings.fieldsToCheck.includes(field) && !settings.fieldsToCheck.map((field2) => toKebabCase(field2)).includes(field)) {
              settings.fieldsToCheck.push(field);
              settings.fieldsToCheck = settings.fieldsToCheck.sort((a, b) => a.localeCompare(b));
              await plugin.saveSettings();
            }
          }
        }
        this.display();
        new import_obsidian8.Notice("Numeric fields added");
      });
    });
    new import_obsidian8.Setting(containerEl).setName("Field Lists").setDesc("A comma-separated list of files that you keep fields in. Each field must be on a new line. It can be a wikilink, or not.").addText((text2) => {
      text2.setValue(settings.fieldLists.join(", "));
      text2.inputEl.onblur = async () => {
        const splits = splitAndTrim2(text2.getValue());
        settings.fieldLists = splits;
        await plugin.saveSettings();
        await plugin.refreshIndex();
      };
    });
    new import_obsidian8.Setting(containerEl).setClass("fields-to-skip").setName("Fields to Check Skip in Correlations").setDesc(fragWithHTML(`A list of pairs of fields to NOT show in the Correlations View. Enter each pair on a new line, with each pair separated by a comma.</br>
					For example:
					<pre><code>
					a, b
					c, d
					</code></pre>`)).addTextArea((text2) => {
      text2.setValue(settings.fieldsToIgnoreForCorrs.map((pair) => pair.join(", ")).join("\n"));
      text2.inputEl.onblur = async () => {
        const value = text2.getValue();
        const splits = value.split("\n").map(splitAndTrim2);
        settings.fieldsToIgnoreForCorrs = splits;
        await plugin.saveSettings();
        await plugin.refreshIndex();
      };
    });
    new import_obsidian8.Setting(containerEl).setName("Date Format").setDesc("The date format you use in your vault.").addMomentFormat((format) => {
      format.setDefaultFormat(DEFAULT_SETTINGS.dateFormat).setValue(settings.dateFormat).onChange(async (value) => {
        settings.dateFormat = value;
        await plugin.saveSettings();
      });
    });
    containerEl.createEl("h2", { text: "Exporting Data" });
    new import_obsidian8.Setting(containerEl).setName("Default save path").setDesc(`The full file path to save the metadataframe to. Don't include the file extension. For example, this is a correct file path: SubFolder/metadataframe. Use "/" to save to the root of your vault.`).addText((text2) => text2.setValue(settings.defaultSavePath).onChange(async (value) => {
      settings.defaultSavePath = value;
      await plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Null value").setDesc("What should the default value be for missing field values? Default is 'null'. Don't use quotes, just enter the value.").addText((text2) => text2.setValue(settings.nullValue).onChange(async (value) => {
      settings.nullValue = value;
      await plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Add inherent file metadata").setDesc("Each file has alot of inherent metadata to it (besides the fields you add). Should metadataframe add these fields too? It can be alot, so there is the option to disable this behaviour.").addToggle((toggle) => toggle.setValue(settings.addFileData).onChange(async (value) => {
      settings.addFileData = value;
      await plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Add content of each note").setDesc("Add a column for the content of each note. This will add alot of size to the CSV file, so it is off by default.").addToggle((toggle) => toggle.setValue(settings.addNoteContent).onChange(async (value) => {
      settings.addNoteContent = value;
      await plugin.saveSettings();
    }));
  }
};

// src/main.ts
var DataAnalysisPlugin = class extends import_obsidian9.Plugin {
  constructor() {
    super(...arguments);
    this.index = {
      data: void 0,
      dataMap: void 0,
      corrs: void 0,
      minDate: void 0,
      maxDate: void 0
    };
    this.unwrappedFields = {};
    this.getDVAPI = () => this.app.plugins.plugins.dataview?.api;
  }
  async onload() {
    console.log("Loading data-analysis plugin");
    await this.loadSettings();
    this.addSettingTab(new SettingTab(this.app, this));
    const onAPIReady = async () => {
      this.app.workspace.onLayoutReady(async () => {
        await this.refreshIndex();
        this.index.corrs = buildAllCorrelations(this.index.data, this.settings.fieldsToCheck, this.settings.fieldsToIgnoreForCorrs, true);
      });
    };
    if (this.app.plugins.enabledPlugins.has("dataview")) {
      const api = this.app.plugins.plugins.dataview?.api;
      if (api)
        await onAPIReady();
      else {
        this.registerEvent(this.app.metadataCache.on("dataview:api-ready", async (api2) => {
          await onAPIReady();
        }));
      }
    } else {
      new import_obsidian9.Notice("Dataview must be enabled for the Data Analysis plugin to work");
    }
    this.addCommand({
      id: "refresh-index",
      name: "Refresh Index",
      callback: async () => await this.refreshIndex()
    });
    this.addCommand({
      id: "chart-view",
      name: "Open Chart Modal",
      callback: async () => new ChartModal(this.app, this).open()
    });
    this.addCommand({
      id: "stats-view",
      name: "Open Stats Modal",
      callback: async () => new StatsModal(this.app, this).open()
    });
    this.addCommand({
      id: "builds-corrs",
      name: "Build Correlations",
      callback: async () => {
        const corrs = buildAllCorrelations(this.index.data, this.settings.fieldsToCheck, this.settings.fieldsToIgnoreForCorrs, true);
        console.log(corrs);
      }
    });
    this.addCommand({
      id: "export-data",
      name: "Export Data",
      callback: async () => {
        try {
          const jsDF = await this.createJSDF();
          console.log(jsDF);
          await this.writeMetadataframe(jsDF);
        } catch (error) {
          new import_obsidian9.Notice("An error occured. Please check the console.");
          console.log(error);
        }
      }
    });
    this.addCommand({
      id: "open-correlation-view",
      name: "Open File Correlations View",
      callback: async () => await openView(this.app, CORRELATION_VIEW, CorrelationView2)
    });
    this.addCommand({
      id: "open-correlation-report",
      name: "Open Correlations Summary Report",
      callback: async () => await openView(this.app, CORRELATION_REPORT_VIEW, CorrelationView)
    });
    this.registerView(CORRELATION_VIEW, (leaf) => new CorrelationView2(leaf, this));
    this.registerView(CORRELATION_REPORT_VIEW, (leaf) => new CorrelationView(leaf, this));
  }
  onunload() {
    this.app.workspace.getLeavesOfType(CORRELATION_VIEW).forEach((leaf) => leaf.detach());
  }
  unproxy(item) {
    const unproxied = [];
    const queue = [item];
    while (queue.length) {
      const currItem = queue.shift();
      if (typeof currItem.defaultComparator === "function") {
        const possibleUnproxied = Object.assign({}, currItem);
        const { values } = possibleUnproxied;
        if (values)
          queue.push(...values);
        else
          unproxied.push(possibleUnproxied);
      } else
        unproxied.push(currItem);
    }
    return unproxied;
  }
  getInnerValue(value) {
    const unproxied = this.unproxy(value);
    if (unproxied.length === 1) {
      if (typeof unproxied[0] === "string") {
        let list = unproxied[0];
        if (list.startsWith("[") && list.endsWith("]")) {
          list = list.slice(1, -1);
        }
        const splits = splitAndTrim(list).map((item) => {
          if (item.startsWith(`"`) && item.endsWith(`"`)) {
            return item.slice(1, -1);
          } else
            return item;
        });
        if (splits.length === 1)
          return splits[0];
        else
          return splits;
      } else {
        if (unproxied[0].type === "file") {
          return unproxied[0].path;
        } else
          return unproxied[0];
      }
    } else {
      if (unproxied[0].type === "file") {
        return unproxied.map((link) => link.path);
      } else
        return unproxied;
    }
  }
  async getSuperchargedFields() {
    const { app, settings } = this;
    const presetFields = app.plugins.plugins["supercharged-links-obsidian"]?.settings.presetFields;
    if (!presetFields)
      return null;
    return Promise.all(presetFields.map(async (field) => {
      const { valuesListNotePath, values, name } = field;
      const newValues = Object.values(values);
      if (valuesListNotePath) {
        const file = this.app.metadataCache.getFirstLinkpathDest(valuesListNotePath, "");
        if (!file)
          return;
        const content = await this.app.vault.cachedRead(file);
        const lines = content.split("\n");
        lines.forEach((line) => newValues.push(line));
      }
      return { name, values: newValues };
    }));
  }
  async unwrapStrLists(data) {
    const { unwrappedFields } = this;
    const { fieldsToCheck } = this.settings;
    const scFields = await this.getSuperchargedFields();
    if (scFields) {
      for (const scField of scFields) {
        const { name, values } = scField;
        unwrappedFields[name] = [];
        for (const value of values) {
          if (value.trim() === "")
            continue;
          unwrappedFields[name].push(dropWiki(value));
        }
      }
    } else {
      for (const field of fieldsToCheck) {
        unwrappedFields[field] = [];
        data.forEach((d) => {
          const cell = d[field];
          if (typeof cell === "string") {
            d[cell] = true;
            if (!unwrappedFields[field].includes(cell))
              unwrappedFields[field].push(cell);
          } else if (cell?.every && cell.every((x) => typeof x === "string")) {
            cell.forEach((str) => {
              d[str] = true;
              if (!unwrappedFields[field].includes(str))
                unwrappedFields[field].push(str);
            });
          }
        });
      }
    }
  }
  async refreshIndex() {
    const notice = new import_obsidian9.Notice("Index refreshing...");
    const dvApi = this.getDVAPI();
    if (!dvApi) {
      notice.setMessage("Dataview must be enabled");
      return;
    }
    const { app, settings } = this;
    const { fieldsToCheck, fieldLists } = settings;
    for (const path of fieldLists) {
      const file = app.metadataCache.getFirstLinkpathDest(path, "");
      if (!file)
        continue;
      const content = await app.vault.cachedRead(file);
      content.split("\n").forEach((line) => {
        const field = dropWiki(line);
        if (!fieldsToCheck.includes(field))
          fieldsToCheck.push(field);
      });
      settings.fieldsToCheck = fieldsToCheck;
      await this.saveSettings();
    }
    let pages = dvApi.pages().values;
    const result = processPages(pages, fieldsToCheck);
    await this.unwrapStrLists(result.pages);
    this.index.data = result.pages;
    this.index.minDate = import_luxon3.DateTime.min(...result.dates);
    this.index.maxDate = import_luxon3.DateTime.max(...result.dates);
    console.log(this.index);
    notice.setMessage("Index refreshed \u2705");
  }
  allUniqueValuesForField(field) {
    const values = [];
    this.index.data.forEach((page) => {
      if (page[field]) {
        const value = unproxy(page[field]);
        makeArr(value).forEach((v) => {
          if (typeof value === "string")
            values.push(v);
          else if (v.path)
            values.push(v.path);
        });
      }
    });
    return [...new Set([...values])];
  }
  inferType(xs) {
    const defineds = xs.filter((x) => x);
    const types = defineds.map((x) => typeof x);
    if (!defineds.length)
      return "undefined";
    const thresh = defineds.length / 2;
    if (types.filter((x) => x === "number").length >= thresh)
      return "number";
    else if (types.filter((x) => x === "string").length >= thresh)
      return "string";
    else
      return "object";
  }
  replaceMissing(xs) {
    const type = this.inferType(xs);
    return xs.map((x) => x ?? (type === "number" ? 0 : "N/A"));
  }
  async createJSDF() {
    const { settings } = this;
    const {
      addNoteContent,
      addFileData,
      nullValue,
      undefinedValue,
      fieldsToCheck
    } = settings;
    const table = [];
    const uniqueKeys = [];
    let actualNullValue = stringToNullOrUndefined(nullValue);
    for (const page of this.index.data) {
      let updateCell = function(col, currRow2) {
        if (col !== "position" && (col !== "file" || addFileData)) {
          const value = page[col];
          const arrValues = [value].flat(4);
          if (!uniqueKeys.includes(col))
            uniqueKeys.push(col);
          if (value === null || value == void 0) {
            currRow2[col] = actualNullValue;
          } else if (typeof value === "string") {
            const splits = value.match(splitLinksRegex);
            if (splits !== null) {
              const links = splits.map((link) => {
                const dropped = link.match(dropHeaderOrAlias)?.[1];
                return dropped ? `[[${dropped}]]` : link;
              }).join(", ");
              currRow2[col] = links;
            } else {
              currRow2[col] = value;
            }
          } else if (arrValues?.[0]?.ts) {
            currRow2[col] = arrValues.map((val) => val?.ts).join(", ");
          } else if (arrValues?.[0]?.path) {
            currRow2[col] = arrValues.map((val) => `[[${val?.path}]]`).join(", ");
          } else if (Object.prototype.toString.call(value) === "[object Object]") {
            currRow2[col] = value;
          } else {
            currRow2[col] = arrValues.join(", ");
          }
        }
      };
      const { file } = page;
      const currRow = { file: { path: file.path }, content: "" };
      if (addNoteContent) {
        const content = await this.app.vault.cachedRead(file);
        currRow["content"] = content;
      }
      for (const key of fieldsToCheck)
        updateCell(key, currRow);
      const { unwrappedFields } = this;
      for (const field in unwrappedFields) {
        const allVals = this.allUniqueValuesForField(field);
        const cell = page[field];
        if (cell !== null && cell !== void 0) {
          const unproxieds = unproxy(cell);
          allVals.forEach((sub) => {
            currRow[makeSub(field, sub)] = 0;
            [unproxieds].flat().forEach((unproxied) => {
              if (typeof unproxied === "string") {
                splitAndTrim(unproxied).forEach((split) => currRow[makeSub(field, split)] = 1);
              } else if (typeof unproxied.path === "string") {
                currRow[makeSub(field, unproxied.path)] = 1;
              }
            });
          });
        }
      }
      table.push(currRow);
    }
    for (let i = 0; i < Object.keys(table).length; i++) {
      uniqueKeys.forEach((key) => {
        if (table[i][key] === void 0) {
          table[i][key] = stringToNullOrUndefined(undefinedValue);
        }
      });
    }
    return table;
  }
  async writeMetadataframe(jsDF) {
    const { nullValue, defaultSavePath } = this.settings;
    const defaultValue = nullValue;
    const opts = { defaultValue, transforms: [import_json2csv.transforms.flatten()] };
    let csv = "";
    try {
      const parser = new import_json2csv.Parser(opts);
      csv = parser.parse(jsDF);
      if (defaultSavePath === "" && csv !== "") {
        new import_obsidian9.Notice("Please choose a path to save to in settings");
      } else {
        try {
          const savePath = (0, import_obsidian9.normalizePath)(defaultSavePath);
          const now = window.moment().format("YYYY-MM-DD HHmmss");
          await this.app.vault.create(`${savePath} ${now}.csv`, csv);
          new import_obsidian9.Notice("Write Metadataframe complete");
        } catch (error) {
          new import_obsidian9.Notice("File already exists");
        }
      }
    } catch (err) {
      console.error(err);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/*!
 * @kurkle/color v0.1.9
 * https://github.com/kurkle/color#readme
 * (c) 2020 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v3.7.0
 * https://www.chartjs.org
 * (c) 2021 Chart.js Contributors
 * Released under the MIT License
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2pzb24yY3N2L2Rpc3QvanNvbjJjc3YudW1kLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZXJyb3JzLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9mb3JtYXRzLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC91dGlsLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9lbmdsaXNoLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9mb3JtYXR0ZXIuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2ludmFsaWQuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvc3lzdGVtWm9uZS5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL0lBTkFab25lLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvZml4ZWRPZmZzZXRab25lLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvaW52YWxpZFpvbmUuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3pvbmVVdGlsLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvc2V0dGluZ3MuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2xvY2FsZS5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvcmVnZXhQYXJzZXIuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9kdXJhdGlvbi5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2ludGVydmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW5mby5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlmZi5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlnaXRzLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC90b2tlblBhcnNlci5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvY29udmVyc2lvbnMuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9kYXRldGltZS5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2x1eG9uLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL3dlYnBhY2svYm9vdHN0cmFwIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9kZWR1cGUuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL2FycmF5L2Zyb20uanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWZ1bmN0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktZnJvbS5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYmluZC1jb250ZXh0LmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24uanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXIuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3IuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvci5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi10by1zdHJpbmcuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRlLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZC5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMtY29yZS5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZi5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3duLWtleXMuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXRoLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtZ2xvYmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLWF0LmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXIuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcmltaXRpdmUuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy92YWxpZGF0ZS1zZXQtcHJvdG90eXBlLW9mLWFyZ3VtZW50cy5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL3NyYy9pY29uLmpzIiwgIm5vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3Qvd2VicGFjazovZmVhdGhlci9zcmMvaWNvbnMuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL3NyYy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L3dlYnBhY2s6L2ZlYXRoZXIvc3JjL3JlcGxhY2UuanMiLCAibm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC93ZWJwYWNrOi9mZWF0aGVyL3NyYy90by1zdmcuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L2xpYi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbm91aXNsaWRlci9kaXN0L25vdWlzbGlkZXIuanMiLCAic3JjL21haW4udHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWNvbW11bml0eS1saWIvZGlzdC91dGlscy5qcyIsICJzcmMvQ2hhcnRNb2RhbC50cyIsICJub2RlX21vZHVsZXMvc3ZlbHRlL2ludGVybmFsL2luZGV4Lm1qcyIsICJzcmMvQ29tcG9uZW50cy9DaGFydC5zdmVsdGUiLCAic3JjL2FuYWx5c2VzLnRzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUtY2hhcnRqcy9zcmMvdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvY2h1bmtzL2hlbHBlcnMuc2VnbWVudC5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9jaGFydC5lc20uanMiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS1jaGFydGpzL3NyYy9CYXNlLnN2ZWx0ZSIsICJub2RlX21vZHVsZXMvc3ZlbHRlLWNoYXJ0anMvc3JjL1NjYXR0ZXIuc3ZlbHRlIiwgInNyYy9Db21wb25lbnRzL0NoYXJ0T3B0aW9ucy5zdmVsdGUiLCAic3JjL2NvbnN0LnRzIiwgInNyYy9Db3JyZWxhdGlvbnNSZXBvcnRWaWV3LnRzIiwgInNyYy91dGlscy50cyIsICJzcmMvU3RhdHNNb2RhbC50cyIsICJzcmMvQ29tcG9uZW50cy9TdGF0cy5zdmVsdGUiLCAic3JjL3JlcG9ydFZpZXdVdGlscy50cyIsICJzcmMvQ29tcG9uZW50cy9Db3JyVGFibGVCb2R5LnN2ZWx0ZSIsICJzcmMvQ29tcG9uZW50cy9Db3JyVGFibGVIZWFkZXIuc3ZlbHRlIiwgInNyYy9Db21wb25lbnRzL0NvcnJUYWJsZVRvcDMuc3ZlbHRlIiwgInNyYy9Db21wb25lbnRzL0NvcnJlbGF0aW9uc1JlcG9ydC5zdmVsdGUiLCAic3JjL2NvcnJlbGF0aW9uVXRpbHMudHMiLCAic3JjL0NvcnJlbGF0aW9uVmlldy50cyIsICJzcmMvQ29tcG9uZW50cy9Db3JyZWxhdGlvbnMuc3ZlbHRlIiwgInNyYy9TZXR0aW5nVGFiLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuanNvbjJjc3YgPSB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGRvbWFpbjtcblxuICAvLyBUaGlzIGNvbnN0cnVjdG9yIGlzIHVzZWQgdG8gc3RvcmUgZXZlbnQgaGFuZGxlcnMuIEluc3RhbnRpYXRpbmcgdGhpcyBpc1xuICAvLyBmYXN0ZXIgdGhhbiBleHBsaWNpdGx5IGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIHRvIGdldCBhIFwiY2xlYW5cIiBlbXB0eVxuICAvLyBvYmplY3QgKHRlc3RlZCB3aXRoIHY4IHY0LjkpLlxuICBmdW5jdGlvbiBFdmVudEhhbmRsZXJzKCkge31cbiAgRXZlbnRIYW5kbGVycy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLy8gbm9kZWpzIG9kZGl0eVxuICAvLyByZXF1aXJlKCdldmVudHMnKSA9PT0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIEV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbiAgRXZlbnRFbWl0dGVyLnVzaW5nRG9tYWlucyA9IGZhbHNlO1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZG9tYWluID0gdW5kZWZpbmVkO1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuICAvLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbiAgLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbiAgRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuICBFdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZG9tYWluID0gbnVsbDtcbiAgICBpZiAoRXZlbnRFbWl0dGVyLnVzaW5nRG9tYWlucykge1xuICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gYWN0aXZlIGRvbWFpbiwgdGhlbiBhdHRhY2ggdG8gaXQuXG4gICAgICBpZiAoZG9tYWluLmFjdGl2ZSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBkb21haW4uRG9tYWluKSkgO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZXZlbnRzIHx8IHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3NcbiAgLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJuXCIgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gICAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG4gIH1cblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbiAgfTtcblxuICAvLyBUaGVzZSBzdGFuZGFsb25lIGVtaXQqIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byBvcHRpbWl6ZSBjYWxsaW5nIG9mIGV2ZW50XG4gIC8vIGhhbmRsZXJzIGZvciBmYXN0IGNhc2VzIGJlY2F1c2UgZW1pdCgpIGl0c2VsZiBvZnRlbiBoYXMgYSB2YXJpYWJsZSBudW1iZXIgb2ZcbiAgLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcbiAgLy8gdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgdGh1cyBkbyBub3QgZ2V0IGRlb3B0aW1pemVkLCBzbyB0aGUgY29kZVxuICAvLyBpbnNpZGUgdGhlbSBjYW4gZXhlY3V0ZSBmYXN0ZXIuXG4gIGZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHtcbiAgICBpZiAoaXNGbilcbiAgICAgIGhhbmRsZXIuY2FsbChzZWxmKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxKSB7XG4gICAgaWYgKGlzRm4pXG4gICAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMikge1xuICAgIGlmIChpc0ZuKVxuICAgICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmIChpc0ZuKVxuICAgICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZ3MpIHtcbiAgICBpZiAoaXNGbilcbiAgICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICAgIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBldmVudHMsIGRvbWFpbjtcbiAgICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICBpZiAoZXZlbnRzKVxuICAgICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PSBudWxsKTtcbiAgICBlbHNlIGlmICghZG9FcnJvcilcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGRvbWFpbiA9IHRoaXMuZG9tYWluO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICAgIGlmIChkb0Vycm9yKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgaWYgKCFlcilcbiAgICAgICAgICBlciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudCcpO1xuICAgICAgICBlci5kb21haW5FbWl0dGVyID0gdGhpcztcbiAgICAgICAgZXIuZG9tYWluID0gZG9tYWluO1xuICAgICAgICBlci5kb21haW5UaHJvd24gPSBmYWxzZTtcbiAgICAgICAgZG9tYWluLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgfSBlbHNlIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAoIWhhbmRsZXIpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgaXNGbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nO1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJncyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgICB2YXIgbTtcbiAgICB2YXIgZXZlbnRzO1xuICAgIHZhciBleGlzdGluZztcblxuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICBpZiAoIWV2ZW50cykge1xuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7XG4gICAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gICAgfVxuXG4gICAgaWYgKCFleGlzdGluZykge1xuICAgICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgICBpZiAoIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgICAgICBpZiAobSAmJiBtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtKSB7XG4gICAgICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIHR5cGUgKyAnIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgICAgIGVtaXRXYXJuaW5nKHcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBmdW5jdGlvbiBlbWl0V2FybmluZyhlKSB7XG4gICAgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gJ2Z1bmN0aW9uJyA/IGNvbnNvbGUud2FybihlKSA6IGNvbnNvbGUubG9nKGUpO1xuICB9XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgICB9O1xuXG4gIGZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGZpcmVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gZygpIHtcbiAgICAgIHRhcmdldC5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcbiAgICAgIGlmICghZmlyZWQpIHtcbiAgICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgICBsaXN0ZW5lci5hcHBseSh0YXJnZXQsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuICAgIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICByZXR1cm4gZztcbiAgfVxuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICAgIGlmICghbGlzdClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgKGxpc3QubGlzdGVuZXIgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBsaXN0WzBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzO1xuXG4gICAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgICBpZiAoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGtleTsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgIH0gd2hpbGUgKGxpc3RlbmVyc1swXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICAgIHZhciBldmxpc3RlbmVyO1xuICAgIHZhciByZXQ7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICAgIGlmICghZXZlbnRzKVxuICAgICAgcmV0ID0gW107XG4gICAgZWxzZSB7XG4gICAgICBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKCFldmxpc3RlbmVyKVxuICAgICAgICByZXQgPSBbXTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXQgPSBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0ID0gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gICAgfVxuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG4gIGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChldmxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG4gIH07XG5cbiAgLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpLlxuICBmdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpXG4gICAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgICBsaXN0LnBvcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIGkpIHtcbiAgICB2YXIgY29weSA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgY29weVtpXSA9IGFycltpXTtcbiAgICByZXR1cm4gY29weTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgdmFyIGdsb2JhbCQxID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOlxuICAgICAgICAgICAgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOlxuICAgICAgICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pO1xuXG4gIHZhciBsb29rdXAgPSBbXTtcbiAgdmFyIHJldkxvb2t1cCA9IFtdO1xuICB2YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5O1xuICB2YXIgaW5pdGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGluaXQgKCkge1xuICAgIGluaXRlZCA9IHRydWU7XG4gICAgdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGxvb2t1cFtpXSA9IGNvZGVbaV07XG4gICAgICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gICAgfVxuXG4gICAgcmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyO1xuICAgIHJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2MztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgICBpZiAoIWluaXRlZCkge1xuICAgICAgaW5pdCgpO1xuICAgIH1cbiAgICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFycjtcbiAgICB2YXIgbGVuID0gYjY0Lmxlbmd0aDtcblxuICAgIGlmIChsZW4gJSA0ID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgICB9XG5cbiAgICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAgIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gICAgcGxhY2VIb2xkZXJzID0gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMDtcblxuICAgIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICAgIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICAgIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlbjtcblxuICAgIHZhciBMID0gMDtcblxuICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXTtcbiAgICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGO1xuICAgICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRjtcbiAgICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgICB9XG5cbiAgICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KTtcbiAgICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpO1xuICAgICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRjtcbiAgICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyXG4gIH1cblxuICBmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICAgIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHRtcDtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSk7XG4gICAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gICAgaWYgKCFpbml0ZWQpIHtcbiAgICAgIGluaXQoKTtcbiAgICB9XG4gICAgdmFyIHRtcDtcbiAgICB2YXIgbGVuID0gdWludDgubGVuZ3RoO1xuICAgIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMzsgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODM7IC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gICAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpO1xuICAgIH1cblxuICAgIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgICAgdG1wID0gdWludDhbbGVuIC0gMV07XG4gICAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXTtcbiAgICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdO1xuICAgICAgb3V0cHV0ICs9ICc9PSc7XG4gICAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pO1xuICAgICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdO1xuICAgICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl07XG4gICAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXTtcbiAgICAgIG91dHB1dCArPSAnPSc7XG4gICAgfVxuXG4gICAgcGFydHMucHVzaChvdXRwdXQpO1xuXG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gICAgdmFyIGUsIG07XG4gICAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gICAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gICAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICAgIHZhciBuQml0cyA9IC03O1xuICAgIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDA7XG4gICAgdmFyIGQgPSBpc0xFID8gLTEgOiAxO1xuICAgIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gICAgaSArPSBkO1xuXG4gICAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gICAgcyA+Pj0gKC1uQml0cyk7XG4gICAgbkJpdHMgKz0gZUxlbjtcbiAgICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gICAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gICAgZSA+Pj0gKC1uQml0cyk7XG4gICAgbkJpdHMgKz0gbUxlbjtcbiAgICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gICAgaWYgKGUgPT09IDApIHtcbiAgICAgIGUgPSAxIC0gZUJpYXM7XG4gICAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlIC0gZUJpYXM7XG4gICAgfVxuICAgIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZSAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgICB2YXIgZSwgbSwgYztcbiAgICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gICAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKTtcbiAgICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpO1xuICAgIHZhciBkID0gaXNMRSA/IDEgOiAtMTtcbiAgICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICAgIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gICAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICAgIGUtLTtcbiAgICAgICAgYyAqPSAyO1xuICAgICAgfVxuICAgICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgICBlKys7XG4gICAgICAgIGMgLz0gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICAgIG0gPSAwO1xuICAgICAgICBlID0gZU1heDtcbiAgICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgICBlID0gZSArIGVCaWFzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgICBlID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gICAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgICBlTGVuICs9IG1MZW47XG4gICAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gICAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xuICB9XG5cbiAgdmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgdmFyIElOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cbiAgLyoqXG4gICAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gICAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gICAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAgICpcbiAgICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICAgKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gICAqXG4gICAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAgICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gICAqXG4gICAqIE5vdGU6XG4gICAqXG4gICAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gICAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAgICpcbiAgICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gICAqXG4gICAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gICAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICAgKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICAgKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAgICovXG4gIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsJDEuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gICAgPyBnbG9iYWwkMS5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgOiB0cnVlO1xuXG4gIGZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICAgIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgICAgPyAweDdmZmZmZmZmXG4gICAgICA6IDB4M2ZmZmZmZmZcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gICAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgICB9XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuICAgICAgfVxuICAgICAgdGhhdC5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAgICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICAgKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gICAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gICAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gICAqXG4gICAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAgICovXG5cbiAgZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAgIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gICAgfVxuXG4gICAgLy8gQ29tbW9uIGNhc2UuXG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gICAgfVxuICAgIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgQnVmZmVyLnBvb2xTaXplID0gODE5MjsgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4gIC8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuICBCdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gICAgcmV0dXJuIGFyclxuICB9O1xuXG4gIGZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICAgIH1cblxuICAgIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gICAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICAgKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gICAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICAgKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gICAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICAgKiovXG4gIEJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9O1xuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGU7XG4gICAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXk7XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gICAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgICBhc3NlcnRTaXplKHNpemUpO1xuICAgIGlmIChzaXplIDw9IDApIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgICB9XG4gICAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAgICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICAgKiovXG4gIEJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICAgIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbiAgfTtcblxuICBmdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICAgIGFzc2VydFNpemUoc2l6ZSk7XG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMCk7XG4gICAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgICAgdGhhdFtpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICAvKipcbiAgICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAgICogKi9cbiAgQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbiAgfTtcbiAgLyoqXG4gICAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICAgKi9cbiAgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG4gIH07XG5cbiAgZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgfVxuXG4gICAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgICB9XG5cbiAgICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDA7XG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuXG4gICAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7XG5cbiAgICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwO1xuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTU7XG4gICAgfVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBhcnJheS5ieXRlTGVuZ3RoOyAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gICAgfVxuXG4gICAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgICB9XG5cbiAgICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KTtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgICAgdGhhdCA9IGFycmF5O1xuICAgICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihvYmopKSB7XG4gICAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDA7XG4gICAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbik7XG5cbiAgICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhhdFxuICAgICAgfVxuXG4gICAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pO1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBpZiAob2JqKSB7XG4gICAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICAgIH1cblxuICAgICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAgIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAgIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICAgIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gICAgfVxuICAgIHJldHVybiBsZW5ndGggfCAwXG4gIH1cbiAgQnVmZmVyLmlzQnVmZmVyID0gaXNCdWZmZXI7XG4gIGZ1bmN0aW9uIGludGVybmFsSXNCdWZmZXIgKGIpIHtcbiAgICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxuICB9XG5cbiAgQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gICAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGEpIHx8ICFpbnRlcm5hbElzQnVmZmVyKGIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICAgIHZhciB4ID0gYS5sZW5ndGg7XG4gICAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICB4ID0gYVtpXTtcbiAgICAgICAgeSA9IGJbaV07XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgICBpZiAoeSA8IHgpIHJldHVybiAxXG4gICAgcmV0dXJuIDBcbiAgfTtcblxuICBCdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gICAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gICAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgICAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGJ1ZikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICAgIH1cbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyXG4gIH07XG5cbiAgZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICAgIGlmIChpbnRlcm5hbElzQnVmZmVyKHN0cmluZykpIHtcbiAgICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gICAgfVxuICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAgIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICAgIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICAgIGZvciAoOzspIHtcbiAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICAgIHJldHVybiBsZW5cbiAgICAgICAgY2FzZSAndXRmOCc6XG4gICAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgICBjYXNlICd1Y3MtMic6XG4gICAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBCdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG5cbiAgZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICAgIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuXG4gICAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gICAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAgIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAgIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAgIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAgIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gICAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKGVuZCA8PSAwKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICAgIGVuZCA+Pj49IDA7XG4gICAgc3RhcnQgPj4+PSAwO1xuXG4gICAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICBjYXNlICdoZXgnOlxuICAgICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgICBjYXNlICd1Y3MyJzpcbiAgICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4gIC8vIEJ1ZmZlciBpbnN0YW5jZXMuXG4gIEJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZTtcblxuICBmdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gICAgdmFyIGkgPSBiW25dO1xuICAgIGJbbl0gPSBiW21dO1xuICAgIGJbbV0gPSBpO1xuICB9XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgc3dhcCh0aGlzLCBpLCBpICsgMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgc3dhcCh0aGlzLCBpLCBpICsgMyk7XG4gICAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgICAgc3dhcCh0aGlzLCBpLCBpICsgNyk7XG4gICAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNik7XG4gICAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSk7XG4gICAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwO1xuICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gICAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gICAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIHZhciBtYXggPSBJTlNQRUNUX01BWF9CWVRFUztcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICc7XG4gICAgfVxuICAgIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgICBpZiAoIWludGVybmFsSXNCdWZmZXIodGFyZ2V0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzU3RhcnQgPSAwO1xuICAgIH1cbiAgICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgICB9XG5cbiAgICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHN0YXJ0ID4+Pj0gMDtcbiAgICBlbmQgPj4+PSAwO1xuICAgIHRoaXNTdGFydCA+Pj49IDA7XG4gICAgdGhpc0VuZCA+Pj49IDA7XG5cbiAgICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gICAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0O1xuICAgIHZhciB5ID0gZW5kIC0gc3RhcnQ7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpO1xuXG4gICAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpO1xuICAgIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICAgIHggPSB0aGlzQ29weVtpXTtcbiAgICAgICAgeSA9IHRhcmdldENvcHlbaV07XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgICBpZiAoeSA8IHgpIHJldHVybiAxXG4gICAgcmV0dXJuIDBcbiAgfTtcblxuICAvLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4gIC8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4gIC8vXG4gIC8vIEFyZ3VtZW50czpcbiAgLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbiAgLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbiAgLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4gIC8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4gIC8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG4gIGZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAgIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAgIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gICAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0O1xuICAgICAgYnl0ZU9mZnNldCA9IDA7XG4gICAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmY7XG4gICAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMDtcbiAgICB9XG4gICAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0OyAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gICAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXQ7XG4gICAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMTtcbiAgICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMDtcbiAgICAgIGVsc2UgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgLy8gTm9ybWFsaXplIHZhbFxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZyk7XG4gICAgfVxuXG4gICAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgICBpZiAoaW50ZXJuYWxJc0J1ZmZlcih2YWwpKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsID0gdmFsICYgMHhGRjsgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKGRpcikge1xuICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gICAgdmFyIGluZGV4U2l6ZSA9IDE7XG4gICAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGg7XG5cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaW5kZXhTaXplID0gMjtcbiAgICAgICAgYXJyTGVuZ3RoIC89IDI7XG4gICAgICAgIHZhbExlbmd0aCAvPSAyO1xuICAgICAgICBieXRlT2Zmc2V0IC89IDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICAgIHJldHVybiBidWZbaV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgaWYgKGRpcikge1xuICAgICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4O1xuICAgICAgICAgIGZvdW5kSW5kZXggPSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aDtcbiAgICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBmb3VuZCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxuICB9O1xuXG4gIGZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwO1xuICAgIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0O1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpO1xuICAgICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICAgIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgICBsZW5ndGggPSBzdHJMZW4gLyAyO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KTtcbiAgICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkO1xuICAgIH1cbiAgICByZXR1cm4gaVxuICB9XG5cbiAgZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBmdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gICAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgICBsZW5ndGggPSBsZW5ndGggfCAwO1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgICApXG4gICAgfVxuXG4gICAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZztcblxuICAgIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICAgIH1cblxuICAgIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gICAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG4gICAgZm9yICg7Oykge1xuICAgICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICBjYXNlICdoZXgnOlxuICAgICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgICBjYXNlICd1Y3MtMic6XG4gICAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICAgIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmcm9tQnl0ZUFycmF5KGJ1ZilcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gICAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcbiAgICB2YXIgcmVzID0gW107XG5cbiAgICB2YXIgaSA9IHN0YXJ0O1xuICAgIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldO1xuICAgICAgdmFyIGNvZGVQb2ludCA9IG51bGw7XG4gICAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICA6IDE7XG5cbiAgICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludDtcblxuICAgICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRik7XG4gICAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdO1xuICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgICAgY29kZVBvaW50ID0gMHhGRkZEO1xuICAgICAgICBieXRlc1BlclNlcXVlbmNlID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuICAgICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRjtcbiAgICAgIH1cblxuICAgICAgcmVzLnB1c2goY29kZVBvaW50KTtcbiAgICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbiAgfVxuXG4gIC8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuICAvLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4gIC8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbiAgdmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwO1xuXG4gIGZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICAgIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aDtcbiAgICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgICB9XG5cbiAgICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICAgIFN0cmluZyxcbiAgICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHJldCA9ICcnO1xuICAgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3Rik7XG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIGZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgcmV0ID0gJyc7XG4gICAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcblxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBmdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7XG5cbiAgICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICAgIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG5cbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIG91dCArPSB0b0hleChidWZbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICBmdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKTtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBCdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgc3RhcnQgPSB+fnN0YXJ0O1xuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmQ7XG5cbiAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICBzdGFydCArPSBsZW47XG4gICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gICAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgICAgc3RhcnQgPSBsZW47XG4gICAgfVxuXG4gICAgaWYgKGVuZCA8IDApIHtcbiAgICAgIGVuZCArPSBsZW47XG4gICAgICBpZiAoZW5kIDwgMCkgZW5kID0gMDtcbiAgICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgICAgZW5kID0gbGVuO1xuICAgIH1cblxuICAgIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7XG5cbiAgICB2YXIgbmV3QnVmO1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTtcbiAgICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydDtcbiAgICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdCdWZcbiAgfTtcblxuICAvKlxuICAgKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAgICovXG4gIGZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gICAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdO1xuICAgIHZhciBtdWwgPSAxO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbFxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdO1xuICAgIHZhciBtdWwgPSAxO1xuICAgIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpc1tvZmZzZXRdXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICAgIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICAgIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgIHRoaXNbb2Zmc2V0ICsgM10pXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuICAgIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG4gICAgdmFyIG11bCA9IDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgICB9XG4gICAgbXVsICo9IDB4ODA7XG5cbiAgICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcblxuICAgIHJldHVybiB2YWxcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gICAgdmFyIGkgPSBieXRlTGVuZ3RoO1xuICAgIHZhciBtdWwgPSAxO1xuICAgIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV07XG4gICAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsO1xuICAgIH1cbiAgICBtdWwgKj0gMHg4MDtcblxuICAgIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpO1xuXG4gICAgcmV0dXJuIHZhbFxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICAgIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCk7XG4gICAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KTtcbiAgICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gICAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSlcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcbiAgICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICAgIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICAgIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gICAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICB9XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIHtcbiAgICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCk7XG4gICAgfVxuXG4gICAgdmFyIG11bCA9IDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRjtcbiAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGO1xuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIHtcbiAgICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCk7XG4gICAgfVxuXG4gICAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMTtcbiAgICB2YXIgbXVsID0gMTtcbiAgICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICAgIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGO1xuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApO1xuICAgIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgcmV0dXJuIG9mZnNldCArIDFcbiAgfTtcblxuICBmdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMTtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDg7XG4gICAgfVxuICB9XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldCArIDJcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldCArIDJcbiAgfTtcblxuICBmdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDE7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZjtcbiAgICB9XG4gIH1cblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNik7XG4gICAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldCArIDRcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KTtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KTtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgKyA0XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIHtcbiAgICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSk7XG5cbiAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIG11bCA9IDE7XG4gICAgdmFyIHN1YiA9IDA7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGO1xuICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgICBzdWIgPSAxO1xuICAgICAgfVxuICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRjtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gICAgdmFsdWUgPSArdmFsdWU7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuXG4gICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCk7XG4gICAgfVxuXG4gICAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMTtcbiAgICB2YXIgbXVsID0gMTtcbiAgICB2YXIgc3ViID0gMDtcbiAgICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuICAgIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgICAgc3ViID0gMTtcbiAgICAgIH1cbiAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKTtcbiAgICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMTtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgMVxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0ICsgMlxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldCArIDJcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNik7XG4gICAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0ICsgNFxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuICAgIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMTtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldCArIDRcbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICAgIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0KTtcbiAgICB9XG4gICAgd3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgNFxuICB9XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxuICB9O1xuXG4gIGZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4KTtcbiAgICB9XG4gICAgd3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgOFxuICB9XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxuICB9O1xuXG4gIC8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbiAgQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICAgIGlmICghc3RhcnQpIHN0YXJ0ID0gMDtcbiAgICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7XG4gICAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwO1xuICAgIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydDtcblxuICAgIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICAgIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICAgIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gICAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICAgIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgICB9XG4gICAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICAgIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gICAgLy8gQXJlIHdlIG9vYj9cbiAgICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQ7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICAgIHZhciBpO1xuXG4gICAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgICB0YXJnZXRTdGFydFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVuXG4gIH07XG5cbiAgLy8gVXNhZ2U6XG4gIC8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuICAvLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbiAgLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG4gIEJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZW5jb2RpbmcgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZW5jb2RpbmcgPSBlbmQ7XG4gICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgICB2YWwgPSBjb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsID0gdmFsICYgMjU1O1xuICAgIH1cblxuICAgIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICAgIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gICAgfVxuXG4gICAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzdGFydCA9IHN0YXJ0ID4+PiAwO1xuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDA7XG5cbiAgICBpZiAoIXZhbCkgdmFsID0gMDtcblxuICAgIHZhciBpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICB0aGlzW2ldID0gdmFsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnl0ZXMgPSBpbnRlcm5hbElzQnVmZmVyKHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpO1xuICAgICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH07XG5cbiAgLy8gSEVMUEVSIEZVTkNUSU9OU1xuICAvLyA9PT09PT09PT09PT09PT09XG5cbiAgdmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nO1xuXG4gIGZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpO1xuICAgIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAgIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICAgIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgc3RyID0gc3RyICsgJz0nO1xuICAgIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gICAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gICAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG4gIH1cblxuICBmdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICAgIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHk7XG4gICAgdmFyIGNvZGVQb2ludDtcbiAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG4gICAgdmFyIGJ5dGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgIH1cblxuICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG5cbiAgICAgIC8vIGVuY29kZSB1dGY4XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgICBieXRlcy5wdXNoKFxuICAgICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBieXRlc1xuICB9XG5cbiAgZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgICB2YXIgYnl0ZUFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVBcnJheVxuICB9XG5cbiAgZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgICB2YXIgYywgaGksIGxvO1xuICAgIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIGhpID0gYyA+PiA4O1xuICAgICAgbG8gPSBjICUgMjU2O1xuICAgICAgYnl0ZUFycmF5LnB1c2gobG8pO1xuICAgICAgYnl0ZUFycmF5LnB1c2goaGkpO1xuICAgIH1cblxuICAgIHJldHVybiBieXRlQXJyYXlcbiAgfVxuXG5cbiAgZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gICAgcmV0dXJuIHRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG4gIH1cblxuICBmdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gICAgfVxuICAgIHJldHVybiBpXG4gIH1cblxuICBmdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIH1cblxuXG4gIC8vIHRoZSBmb2xsb3dpbmcgaXMgZnJvbSBpcy1idWZmZXIsIGFsc28gYnkgRmVyb3NzIEFib3VraGFkaWplaCBhbmQgd2l0aCBzYW1lIGxpc2VuY2VcbiAgLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuICAvLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG4gIGZ1bmN0aW9uIGlzQnVmZmVyKG9iaikge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiAoISFvYmouX2lzQnVmZmVyIHx8IGlzRmFzdEJ1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopKVxuICB9XG5cbiAgZnVuY3Rpb24gaXNGYXN0QnVmZmVyIChvYmopIHtcbiAgICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxuICB9XG5cbiAgLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbiAgZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzRmFzdEJ1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG4gIH1cblxuICAvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbiAgLy8gYmFzZWQgb2ZmIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWZ1bmN0em9tYmllL25vZGUtcHJvY2Vzcy9ibG9iL21hc3Rlci9icm93c2VyLmpzXG5cbiAgZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xuICB9XG4gIGZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbiAgfVxuICB2YXIgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gIHZhciBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICBpZiAodHlwZW9mIGdsb2JhbCQxLnNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsJDEuY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgICAgfVxuICAgICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cblxuICB9XG4gIGZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cblxuXG4gIH1cbiAgdmFyIHF1ZXVlID0gW107XG4gIHZhciBkcmFpbmluZyA9IGZhbHNlO1xuICB2YXIgY3VycmVudFF1ZXVlO1xuICB2YXIgcXVldWVJbmRleCA9IC0xO1xuXG4gIGZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgfVxuICBmdW5jdGlvbiBuZXh0VGljayhmdW4pIHtcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgICB9XG4gIH1cbiAgLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuICBmdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICAgIHRoaXMuZnVuID0gZnVuO1xuICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG4gIEl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xuICB9O1xuXG4gIC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2t1bWF2aXMvYnJvd3Nlci1wcm9jZXNzLWhydGltZS9ibG9iL21hc3Rlci9pbmRleC5qc1xuICB2YXIgcGVyZm9ybWFuY2UgPSBnbG9iYWwkMS5wZXJmb3JtYW5jZSB8fCB7fTtcbiAgdmFyIHBlcmZvcm1hbmNlTm93ID1cbiAgICBwZXJmb3JtYW5jZS5ub3cgICAgICAgIHx8XG4gICAgcGVyZm9ybWFuY2UubW96Tm93ICAgICB8fFxuICAgIHBlcmZvcm1hbmNlLm1zTm93ICAgICAgfHxcbiAgICBwZXJmb3JtYW5jZS5vTm93ICAgICAgIHx8XG4gICAgcGVyZm9ybWFuY2Uud2Via2l0Tm93ICB8fFxuICAgIGZ1bmN0aW9uKCl7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIH07XG5cbiAgdmFyIGluaGVyaXRzO1xuICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpe1xuICAgIGluaGVyaXRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGluaGVyaXRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gICAgfTtcbiAgfVxuICB2YXIgaW5oZXJpdHMkMSA9IGluaGVyaXRzO1xuXG4gIHZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuICBmdW5jdGlvbiBmb3JtYXQoZikge1xuICAgIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICAgIHZhciBvYmplY3RzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICAgIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICAgIHN3aXRjaCAoeCkge1xuICAgICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICAvLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAvLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICAvLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICBmdW5jdGlvbiBkZXByZWNhdGUoZm4sIG1zZykge1xuICAgIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gICAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbCQxLnByb2Nlc3MpKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgICB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVwcmVjYXRlZDtcbiAgfVxuXG4gIHZhciBkZWJ1Z3MgPSB7fTtcbiAgdmFyIGRlYnVnRW52aXJvbjtcbiAgZnVuY3Rpb24gZGVidWdsb2coc2V0KSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgICBkZWJ1Z0Vudmlyb24gPSAgJyc7XG4gICAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICAgIHZhciBwaWQgPSAwO1xuICAgICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBtc2cgPSBmb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlYnVnc1tzZXRdO1xuICB9XG5cbiAgLyoqXG4gICAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAgICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gICAqL1xuICAvKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG4gIGZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgdmFyIGN0eCA9IHtcbiAgICAgIHNlZW46IFtdLFxuICAgICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgICB9O1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICAgIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAgIC8vIGxlZ2FjeS4uLlxuICAgICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICAgIH0gZWxzZSBpZiAob3B0cykge1xuICAgICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgICAgX2V4dGVuZChjdHgsIG9wdHMpO1xuICAgIH1cbiAgICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gICAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG4gIH1cblxuICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3NcbiAgaW5zcGVjdC5jb2xvcnMgPSB7XG4gICAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgICAnaXRhbGljJyA6IFszLCAyM10sXG4gICAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAgICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICAgJ3doaXRlJyA6IFszNywgMzldLFxuICAgICdncmV5JyA6IFs5MCwgMzldLFxuICAgICdibGFjaycgOiBbMzAsIDM5XSxcbiAgICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgICAneWVsbG93JyA6IFszMywgMzldXG4gIH07XG5cbiAgLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG4gIGluc3BlY3Quc3R5bGVzID0ge1xuICAgICdzcGVjaWFsJzogJ2N5YW4nLFxuICAgICdudW1iZXInOiAneWVsbG93JyxcbiAgICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAgICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICAgJ251bGwnOiAnYm9sZCcsXG4gICAgJ3N0cmluZyc6ICdncmVlbicsXG4gICAgJ2RhdGUnOiAnbWFnZW50YScsXG4gICAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgICAncmVnZXhwJzogJ3JlZCdcbiAgfTtcblxuXG4gIGZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgICB2YXIgaGFzaCA9IHt9O1xuXG4gICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHJldHVybiBoYXNoO1xuICB9XG5cblxuICBmdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gICAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gICAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICAgIHZhbHVlICYmXG4gICAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICAgIHZhbHVlLmluc3BlY3QgIT09IGluc3BlY3QgJiZcbiAgICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICAgIGlmIChwcmltaXRpdmUpIHtcbiAgICAgIHJldHVybiBwcmltaXRpdmU7XG4gICAgfVxuXG4gICAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gICAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICAgIH1cblxuICAgIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICAgIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gICAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICAgIGlmIChpc0FycmF5JDEodmFsdWUpKSB7XG4gICAgICBhcnJheSA9IHRydWU7XG4gICAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICAgIH1cblxuICAgIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICAgIH1cblxuICAgIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gICAgfVxuXG4gICAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gICAgdmFyIG91dHB1dDtcbiAgICBpZiAoYXJyYXkpIHtcbiAgICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xuICB9XG5cblxuICBmdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICAgIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gICAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICAgIGlmIChpc051bGwodmFsdWUpKVxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xuICB9XG5cblxuICBmdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgICAgfVxuICAgIH1cbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICAgIH1cbiAgICBpZiAoIXN0cikge1xuICAgICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gICAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIDtcbiAgICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgICB9LCAwKTtcblxuICAgIGlmIChsZW5ndGggPiA2MCkge1xuICAgICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgYnJhY2VzWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG4gIH1cblxuXG4gIC8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuICAvLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbiAgZnVuY3Rpb24gaXNBcnJheSQxKGFyKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG4gIH1cblxuICBmdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG4gIH1cblxuICBmdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG4gIH1cblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG4gIH1cblxuICBmdW5jdGlvbiBfZXh0ZW5kKG9yaWdpbiwgYWRkKSB7XG4gICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICAgIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICAgIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ2luO1xuICB9XG4gIGZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgcC5kYXRhLmNvcHkocmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4gIHZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICAgIH1cbiAgICAgICB9O1xuXG5cbiAgZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gICAgfVxuICB9XG5cbiAgLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuICAvLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbiAgLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4gIC8vXG4gIC8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuICAvLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbiAgLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuICAvLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG4gIGZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICAgIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAgIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gICAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAgIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgICB0aGlzLmNoYXJMZW5ndGggPSAwO1xuICB9XG5cbiAgLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuICAvLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuICAvLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuICAvL1xuICAvLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuICAvLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuICAvLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuICAvLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuICBTdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgIHZhciBjaGFyU3RyID0gJyc7XG4gICAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICAgIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICAgIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB9XG5cbiAgICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gICAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgICB9XG5cbiAgICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgICByZXR1cm4gY2hhclN0cjtcbiAgfTtcblxuICAvLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4gIC8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4gIC8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuICAvLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuICBTdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gICAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICAgIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAgIC8vIDExMFhYWFhYXG4gICAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyAxMTEwWFhYWFxuICAgICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gMTExMTBYWFhcbiAgICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbiAgfTtcblxuICBTdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBmdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG4gIH1cblxuICBmdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gICAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gICAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbiAgfVxuXG4gIFJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4gIHZhciBkZWJ1ZyA9IGRlYnVnbG9nKCdzdHJlYW0nKTtcbiAgaW5oZXJpdHMkMShSZWFkYWJsZSwgRXZlbnRFbWl0dGVyKTtcblxuICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gICAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAgICAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gICAgICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gICAgICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gICAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSlcbiAgICAgICAgZW1pdHRlci5vbihldmVudCwgZm4pO1xuICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSlcbiAgICAgICAgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtcbiAgICAgIGVsc2VcbiAgICAgICAgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQkMSAoZW1pdHRlciwgdHlwZSkge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG4gIH1cbiAgZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICAgIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gICAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAgIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICAgIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgICAvLyBjYXN0IHRvIGludHMuXG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfiB+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gICAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAgIC8vIGFycmF5LnNoaWZ0KClcbiAgICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucGlwZXMgPSBudWxsO1xuICAgIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gICAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAgIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gICAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICAgIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gICAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAgIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICAgIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICAgIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gICAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAgIC8vIGxlZ2FjeVxuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4gIC8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuICAvLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4gIC8vIHdyaXRlKCkgc29tZSBtb3JlLlxuICBSZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gICAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG4gIFJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbiAgfTtcblxuICBSZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgICAgdmFyIF9lID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBfZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2tpcEFkZDtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBza2lwQWRkID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgY2h1bmsubGVuZ3RoID09PSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhZGRUb0Zyb250KSBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gRG9uJ3QgYWRkIHRvIHRoZSBidWZmZXIgaWYgd2UndmUgZGVjb2RlZCB0byBhbiBlbXB0eSBzdHJpbmcgY2h1bmsgYW5kXG4gICAgICAgIC8vIHdlJ3JlIG5vdCBpbiBvYmplY3QgbW9kZVxuICAgICAgICBpZiAoIXNraXBBZGQpIHtcbiAgICAgICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xuICB9XG5cbiAgLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbiAgLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4gIC8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4gIC8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuICAvLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuICAvLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuICBmdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xuICB9XG5cbiAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIFJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxuICB2YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuICBmdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gICAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgICAgbiA9IE1BWF9IV007XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgICAgLy8gdGlueSBhbW91bnRzXG4gICAgICBuLS07XG4gICAgICBuIHw9IG4gPj4+IDE7XG4gICAgICBuIHw9IG4gPj4+IDI7XG4gICAgICBuIHw9IG4gPj4+IDQ7XG4gICAgICBuIHw9IG4gPj4+IDg7XG4gICAgICBuIHw9IG4gPj4+IDE2O1xuICAgICAgbisrO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4gIC8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG4gIGZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICAgIGlmIChuICE9PSBuKSB7XG4gICAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gICAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gICAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIC8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG4gIFJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1ZygncmVhZCcsIG4pO1xuICAgIG4gPSBwYXJzZUludChuLCAxMCk7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICB2YXIgbk9yaWcgPSBuO1xuXG4gICAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gICAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAgIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gICAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAgIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAgIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gICAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgICAvL1xuICAgIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAgIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAgIC8vXG4gICAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gICAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gICAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gICAgLy9cbiAgICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gICAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgICBkb1JlYWQgPSB0cnVlO1xuICAgICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgICB9XG5cbiAgICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAgIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgICAgZG9SZWFkID0gZmFsc2U7XG4gICAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gICAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0O1xuICAgIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICAgIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBuID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUubGVuZ3RoIC09IG47XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIH1cblxuICAgIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgICB2YXIgZXIgPSBudWxsO1xuICAgIGlmICghaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gICAgfVxuICAgIHJldHVybiBlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gICAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cblxuICAvLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbiAgLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4gIC8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbiAgZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICAgIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChzdGF0ZS5zeW5jKSBuZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gICAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgICBmbG93KHN0cmVhbSk7XG4gIH1cblxuICAvLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuICAvLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4gIC8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4gIC8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4gIC8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4gIC8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG4gIGZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICAgIH1cbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuICB9XG5cbiAgLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuICAvLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuICAvLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuICAvLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG4gIFJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xuICB9O1xuXG4gIFJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gICAgdmFyIHNyYyA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAgIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gICAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKTtcblxuICAgIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBuZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gICAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICAgIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgICAgZGVzdC5lbmQoKTtcbiAgICB9XG5cbiAgICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gICAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gICAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgICAvLyB0b28gc2xvdy5cbiAgICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gICAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAgIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gICAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gICAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgICAgZGVidWcoJ29uZGF0YScpO1xuICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHNyYy5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAgIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICAgIHVucGlwZSgpO1xuICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICAgIGlmIChsaXN0ZW5lckNvdW50JDEoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICAgIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAgIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gICAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICAgIHVucGlwZSgpO1xuICAgIH1cbiAgICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgICB1bnBpcGUoKTtcbiAgICB9XG4gICAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgICBzcmMudW5waXBlKGRlc3QpO1xuICAgIH1cblxuICAgIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gICAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAgIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgICAgc3JjLnJlc3VtZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXN0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBzcmMubGlzdGVuZXJzKCdkYXRhJykubGVuZ3RoKSB7XG4gICAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgICBmbG93KHNyYyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIFJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gICAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gICAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICAgIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgICBpZiAoIWRlc3QpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZW47IF9pKyspIHtcbiAgICAgICAgZGVzdHNbX2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgICAgfXJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gICAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgICBpZiAoaSA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gICAgc3RhdGUucGlwZXMuc3BsaWNlKGksIDEpO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICAgIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4gIC8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG4gIFJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgICB2YXIgcmVzID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgICBuZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICBSZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbiAgZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gICAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICAgIHNlbGYucmVhZCgwKTtcbiAgfVxuXG4gIC8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbiAgLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuICBSZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICBuZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gICAgZmxvdyhzdHJlYW0pO1xuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIFJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxuICB9XG5cbiAgLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbiAgLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuICAvLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cbiAgUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnB1c2gobnVsbCk7XG4gICAgfSk7XG5cbiAgICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgICBpZiAoIXJldCkge1xuICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfShpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gICAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gICAgfSk7XG5cbiAgICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gICAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gICAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgICAgaWYgKHBhdXNlZCkge1xuICAgICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG4gIFJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4gIC8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbiAgLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbiAgLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbiAgZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgcmV0O1xuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4gIC8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG4gIGZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gICAgdmFyIHJldDtcbiAgICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4gIC8vIGNodW5rcy5cbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbiAgLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbiAgZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICAgIHZhciBwID0gbGlzdC5oZWFkO1xuICAgIHZhciBjID0gMTtcbiAgICB2YXIgcmV0ID0gcC5kYXRhO1xuICAgIG4gLT0gcmV0Lmxlbmd0aDtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgICAgbiAtPSBuYjtcbiAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICsrYztcbiAgICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgICsrYztcbiAgICB9XG4gICAgbGlzdC5sZW5ndGggLT0gYztcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuICAvLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuICBmdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgICB2YXIgYyA9IDE7XG4gICAgcC5kYXRhLmNvcHkocmV0KTtcbiAgICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgICAgbiAtPSBuYjtcbiAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICAgICsrYztcbiAgICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgICsrYztcbiAgICB9XG4gICAgbGlzdC5sZW5ndGggLT0gYztcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gICAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gICAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAgIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgICBuZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZih4c1tpXSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbiAgV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG4gIGluaGVyaXRzJDEoV3JpdGFibGUsIEV2ZW50RW1pdHRlcik7XG5cbiAgZnVuY3Rpb24gbm9wKCkge31cblxuICBmdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgdGhpcy5jaHVuayA9IGNodW5rO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nKVxuICAgIH0pO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gICAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICAgIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gICAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gICAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gICAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICAgIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gICAgLy8gY2FzdCB0byBpbnRzLlxuICAgIHRoaXMuaGlnaFdhdGVyTWFyayA9IH4gfnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICAgIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gICAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAgIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gICAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gICAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gICAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gICAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICAgIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAgIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gICAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICAgIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gICAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gICAgLy8gc29ja2V0IG9yIGZpbGUuXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAgIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAgIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gICAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAgIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gICAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gICAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gICAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICAgIH07XG5cbiAgICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gICAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICAgIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gICAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAgIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICAgIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAgIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICAgIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAgIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gICAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAgIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gICAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gICAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICAgIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG4gIH1cblxuICBXcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiB3cml0YWJsZVN0YXRlR2V0QnVmZmVyKCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG4gIGZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcblxuICAgIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gICAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAgIC8vIGxlZ2FjeS5cbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgfVxuXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIH1cblxuICAvLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG4gIFdyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gICAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBuZXh0VGljayhjYiwgZXIpO1xuICB9XG5cbiAgLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4gIC8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4gIC8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuICAvLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbiAgLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbiAgZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgICB2YXIgdmFsaWQgPSB0cnVlO1xuICAgIHZhciBlciA9IGZhbHNlO1xuICAgIC8vIEFsd2F5cyB0aHJvdyBlcnJvciBpZiBhIG51bGwgaXMgd3JpdHRlblxuICAgIC8vIGlmIHdlIGFyZSBub3QgaW4gb2JqZWN0IG1vZGUgdGhlbiB0aHJvd1xuICAgIC8vIGlmIGl0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBvciB1bmRlZmluZWQuXG4gICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gICAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICAgIH1cbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgIG5leHRUaWNrKGNiLCBlcik7XG4gICAgICB2YWxpZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWQ7XG4gIH1cblxuICBXcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gICAgdmFyIHJldCA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBlbmNvZGluZztcbiAgICAgIGVuY29kaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBXcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gICAgc3RhdGUuY29ya2VkKys7XG4gIH07XG5cbiAgV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gICAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgICB9XG4gIH07XG5cbiAgV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAgIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2h1bms7XG4gIH1cblxuICAvLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbiAgLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbiAgLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbiAgZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICAgIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgICAgfVxuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICAgIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAgIC0tc3RhdGUucGVuZGluZ2NiO1xuICAgIGlmIChzeW5jKSBuZXh0VGljayhjYiwgZXIpO2Vsc2UgY2IoZXIpO1xuXG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICAgIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICAgIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgICBzdGF0ZS53cml0ZWxlbiA9IDA7XG4gIH1cblxuICBmdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gICAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICAgIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gICAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgICAgICBuZXh0VGljayhhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIC8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbiAgLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbiAgZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuICBmdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gICAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gICAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgICBjb3VudCArPSAxO1xuICAgICAgfVxuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gICAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG5cbiAgV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG4gIH07XG5cbiAgV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG4gIFdyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGNodW5rO1xuICAgICAgY2h1bmsgPSBudWxsO1xuICAgICAgZW5jb2RpbmcgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGVuY29kaW5nO1xuICAgICAgZW5jb2RpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICAgIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgICB0aGlzLnVuY29yaygpO1xuICAgIH1cblxuICAgIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG4gIH07XG5cbiAgZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgICBpZiAobmVlZCkge1xuICAgICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmVlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gICAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgbmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgICB9XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4gIC8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuICBmdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHZhciBlbnRyeSA9IF90aGlzLmVudHJ5O1xuICAgICAgX3RoaXMuZW50cnkgPSBudWxsO1xuICAgICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IF90aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gX3RoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGluaGVyaXRzJDEoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbiAgZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbiAgfVxuXG4gIC8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgICAvLyB0aGVuIHdlJ3JlIG9rLlxuICAgIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gICAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAgIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICAgIG5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gICAgc2VsZi5lbmQoKTtcbiAgfVxuXG4gIC8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbiAgaW5oZXJpdHMkMShUcmFuc2Zvcm0sIER1cGxleCk7XG5cbiAgZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUoc3RyZWFtKSB7XG4gICAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICAgIH07XG5cbiAgICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICAgIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gICAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbiAgICB0aGlzLndyaXRlZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICAgIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gICAgaWYgKCFjYikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgICB0cy53cml0ZWNiID0gbnVsbDtcblxuICAgIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgICBjYihlcik7XG5cbiAgICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gICAgcnMucmVhZGluZyA9IGZhbHNlO1xuICAgIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICAgIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XG5cbiAgICAvLyB3aGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gICAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gICAgLy8gc3luYyBndWFyZCBmbGFnLlxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgICB9XG5cbiAgICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlcikge1xuICAgICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7XG4gICAgfSk7XG4gIH1cblxuICBUcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gICAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICAgIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuICAvLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4gIC8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4gIC8vXG4gIC8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuICAvLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuICAvL1xuICAvLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuICAvLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4gIC8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgfTtcblxuICBUcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gICAgdHMud3JpdGVjYiA9IGNiO1xuICAgIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbiAgLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbiAgLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gICAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gICAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICAgIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gICAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG4gIH1cblxuICBpbmhlcml0cyQxKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuICBmdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICAgIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGNiKG51bGwsIGNodW5rKTtcbiAgfTtcblxuICBpbmhlcml0cyQxKFN0cmVhbSwgRXZlbnRFbWl0dGVyKTtcbiAgU3RyZWFtLlJlYWRhYmxlID0gUmVhZGFibGU7XG4gIFN0cmVhbS5Xcml0YWJsZSA9IFdyaXRhYmxlO1xuICBTdHJlYW0uRHVwbGV4ID0gRHVwbGV4O1xuICBTdHJlYW0uVHJhbnNmb3JtID0gVHJhbnNmb3JtO1xuICBTdHJlYW0uUGFzc1Rocm91Z2ggPSBQYXNzVGhyb3VnaDtcblxuICAvLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuICBTdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG4gIC8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbiAgLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuICBmdW5jdGlvbiBTdHJlYW0oKSB7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIH1cblxuICBTdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIH1cblxuICAgIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICAgIGRlc3QuZW5kKCk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gICAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgaWYgKEV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgICB9XG4gICAgfVxuXG4gICAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gICAgfVxuXG4gICAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAgIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gICAgcmV0dXJuIGRlc3Q7XG4gIH07XG5cbiAgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfdHlwZW9mKG9iaik7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cblxuICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RvQXJyYXkoYXJyKSB7XG4gICAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gICAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgICAgcmV0dXJuIGFycjI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gIH1cblxuICAvKlxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMTYgQ29kZXJQdXBweVxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG5cbiAgKi9cbiAgdmFyIF9lbmRpYW5uZXNzO1xuICBmdW5jdGlvbiBlbmRpYW5uZXNzKCkge1xuICAgIGlmICh0eXBlb2YgX2VuZGlhbm5lc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgYSA9IG5ldyBBcnJheUJ1ZmZlcigyKTtcbiAgICAgIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkoYSk7XG4gICAgICB2YXIgYyA9IG5ldyBVaW50MTZBcnJheShhKTtcbiAgICAgIGJbMF0gPSAxO1xuICAgICAgYlsxXSA9IDI7XG4gICAgICBpZiAoY1swXSA9PT0gMjU4KSB7XG4gICAgICAgIF9lbmRpYW5uZXNzID0gJ0JFJztcbiAgICAgIH0gZWxzZSBpZiAoY1swXSA9PT0gNTEzKXtcbiAgICAgICAgX2VuZGlhbm5lc3MgPSAnTEUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gZmlndXJlIG91dCBlbmRpYW5lc3MnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9lbmRpYW5uZXNzO1xuICB9XG5cbiAgZnVuY3Rpb24gaG9zdG5hbWUoKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwkMS5sb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBnbG9iYWwkMS5sb2NhdGlvbi5ob3N0bmFtZVxuICAgIH0gZWxzZSByZXR1cm4gJyc7XG4gIH1cblxuICBmdW5jdGlvbiBsb2FkYXZnKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwdGltZSgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWVtZW0oKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG4gIH1cblxuICBmdW5jdGlvbiB0b3RhbG1lbSgpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNwdXMoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gdHlwZSgpIHtcbiAgICByZXR1cm4gJ0Jyb3dzZXInO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVsZWFzZSAoKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwkMS5uYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsJDEubmF2aWdhdG9yLmFwcFZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIG5ldHdvcmtJbnRlcmZhY2VzKCl7fVxuICBmdW5jdGlvbiBnZXROZXR3b3JrSW50ZXJmYWNlcygpe31cblxuICBmdW5jdGlvbiB0bXBEaXIoKSB7XG4gICAgcmV0dXJuICcvdG1wJztcbiAgfVxuICB2YXIgdG1wZGlyID0gdG1wRGlyO1xuXG4gIHZhciBFT0wgPSAnXFxuJztcbiAgdmFyIG9zID0ge1xuICAgIEVPTDogRU9MLFxuICAgIHRtcGRpcjogdG1wZGlyLFxuICAgIHRtcERpcjogdG1wRGlyLFxuICAgIG5ldHdvcmtJbnRlcmZhY2VzOm5ldHdvcmtJbnRlcmZhY2VzLFxuICAgIGdldE5ldHdvcmtJbnRlcmZhY2VzOiBnZXROZXR3b3JrSW50ZXJmYWNlcyxcbiAgICByZWxlYXNlOiByZWxlYXNlLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY3B1czogY3B1cyxcbiAgICB0b3RhbG1lbTogdG90YWxtZW0sXG4gICAgZnJlZW1lbTogZnJlZW1lbSxcbiAgICB1cHRpbWU6IHVwdGltZSxcbiAgICBsb2FkYXZnOiBsb2FkYXZnLFxuICAgIGhvc3RuYW1lOiBob3N0bmFtZSxcbiAgICBlbmRpYW5uZXNzOiBlbmRpYW5uZXNzLFxuICB9O1xuXG4gIHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG4gIC8qKlxuICAgKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gICAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAgICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICAgKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICAgKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAgICovXG5cbiAgLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbiAgdmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuICAvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG4gIHZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbiAgdmFyIElORklOSVRZID0gMSAvIDA7XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICAgIHJlTGVhZGluZ0RvdCA9IC9eXFwuLyxcbiAgICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAgICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gICAqL1xuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBjb21tb25qc0dsb2JhbDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuICB2YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgICAvLyBNYW55IGhvc3Qgb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2UgdG8gc3RyaW5nc1xuICAgIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbiAgdmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xuICB2YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICAgIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbiAgfSgpKTtcblxuICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG4gIHZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbiAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSQxID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAqIG9mIHZhbHVlcy5cbiAgICovXG4gIHZhciBvYmplY3RUb1N0cmluZyQxID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbiAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSQxKS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4gICk7XG5cbiAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gIHZhciBTeW1ib2wkMSA9IHJvb3QuU3ltYm9sLFxuICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbiAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuICB2YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuICAvKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbiAgdmFyIHN5bWJvbFByb3RvID0gU3ltYm9sJDEgPyBTeW1ib2wkMS5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgKi9cbiAgZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgY2xlYXJcbiAgICogQG1lbWJlck9mIEhhc2hcbiAgICovXG4gIGZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGRlbGV0ZVxuICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGdldFxuICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkkMS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBoYXNcbiAgICogQG1lbWJlck9mIEhhc2hcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgIHJldHVybiBuYXRpdmVDcmVhdGUgPyBkYXRhW2tleV0gIT09IHVuZGVmaW5lZCA6IGhhc093blByb3BlcnR5JDEuY2FsbChkYXRhLCBrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgc2V0XG4gICAqIEBtZW1iZXJPZiBIYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG4gIEhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuICBIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuICBIYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuICBIYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuICBIYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAqL1xuICBmdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGNsZWFyXG4gICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICAgIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgZGVsZXRlXG4gICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgICAgZGF0YS5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgZ2V0XG4gICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBoYXNcbiAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICAgIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgc2V0XG4gICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG4gIExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbiAgTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG4gIExpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuICBMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbiAgTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgKi9cbiAgZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgY2xlYXJcbiAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAqL1xuICBmdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICAgIHRoaXMuX19kYXRhX18gPSB7XG4gICAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGRlbGV0ZVxuICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgZ2V0XG4gICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgaGFzXG4gICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgc2V0XG4gICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLnNldChrZXksIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG4gIE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG4gIE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbiAgTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuICBNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG4gIE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICAgIHBhdGggPSBpc0tleShwYXRoLCBvYmplY3QpID8gW3BhdGhdIDogY2FzdFBhdGgocGF0aCk7XG5cbiAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgICB9XG4gICAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCQxKHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHBhdHRlcm4gPSAoaXNGdW5jdGlvbiQxKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICAgKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSkge1xuICAgIHJldHVybiBpc0FycmF5JDIodmFsdWUpID8gdmFsdWUgOiBzdHJpbmdUb1BhdGgodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgICA6IGRhdGEubWFwO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICAgIGlmIChpc0FycmF5JDIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICAgIDogKHZhbHVlID09PSBudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gICAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAqL1xuICB2YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZShmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBzdHJpbmcgPSB0b1N0cmluZyQxKHN0cmluZyk7XG5cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgaWYgKHJlTGVhZGluZ0RvdC50ZXN0KHN0cmluZykpIHtcbiAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICB9XG4gICAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gICAqL1xuICBmdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICAgKi9cbiAgZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICAgIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICAgKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAgICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAqXG4gICAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gICAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gICAqXG4gICAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICogLy8gPT4gWzEsIDJdXG4gICAqXG4gICAqIHZhbHVlcyhvdGhlcik7XG4gICAqIC8vID0+IFszLCA0XVxuICAgKlxuICAgKiBvYmplY3QuYSA9IDI7XG4gICAqIHZhbHVlcyhvYmplY3QpO1xuICAgKiAvLyA9PiBbMSwgMl1cbiAgICpcbiAgICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gICAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICogdmFsdWVzKG9iamVjdCk7XG4gICAqIC8vID0+IFsnYScsICdiJ11cbiAgICpcbiAgICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAgICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAgICovXG4gIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgfVxuICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gIH1cblxuICAvLyBBc3NpZ24gY2FjaGUgdG8gYF8ubWVtb2l6ZWAuXG4gIG1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuICAvKipcbiAgICogUGVyZm9ybXMgYVxuICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAqXG4gICAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uZXEoJ2EnLCAnYScpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uZXEoTmFOLCBOYU4pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoJ2FiYycpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIHZhciBpc0FycmF5JDIgPSBBcnJheS5pc0FycmF5O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbiQxKHZhbHVlKSB7XG4gICAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gICAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICAgIHZhciB0YWcgPSBpc09iamVjdCQxKHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nJDEuY2FsbCh2YWx1ZSkgOiAnJztcbiAgICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAgICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICAgKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc09iamVjdCh7fSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KG51bGwpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNPYmplY3QkMSh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gICAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZyQxLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAgICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy50b1N0cmluZyhudWxsKTtcbiAgICogLy8gPT4gJydcbiAgICpcbiAgICogXy50b1N0cmluZygtMCk7XG4gICAqIC8vID0+ICctMCdcbiAgICpcbiAgICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICAgKiAvLyA9PiAnMSwyLDMnXG4gICAqL1xuICBmdW5jdGlvbiB0b1N0cmluZyQxKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAgICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDMuNy4wXG4gICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAqXG4gICAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAqIC8vID0+IDNcbiAgICpcbiAgICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAqIC8vID0+IDNcbiAgICpcbiAgICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICovXG4gIGZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG4gIH1cblxuICB2YXIgbG9kYXNoX2dldCA9IGdldDtcblxuICBmdW5jdGlvbiBnZXRQcm9wKG9iaiwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIG9ialtwYXRoXSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogb2JqW3BhdGhdO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJvcChvYmosIHBhdGgsIHZhbHVlKSB7XG4gICAgdmFyIHBhdGhBcnJheSA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuXG4gICAgdmFyIF9wYXRoQXJyYXkgPSBfdG9BcnJheShwYXRoQXJyYXkpLFxuICAgICAgICBrZXkgPSBfcGF0aEFycmF5WzBdLFxuICAgICAgICByZXN0UGF0aCA9IF9wYXRoQXJyYXkuc2xpY2UoMSk7XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBwYXRoQXJyYXkubGVuZ3RoID4gMSA/IHNldFByb3Aob2JqW2tleV0gfHwge30sIHJlc3RQYXRoLCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb2JqLCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgbmV3VmFsdWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuc2V0UHJvcChvYmosIHBhdGgpIHtcbiAgICB2YXIgcGF0aEFycmF5ID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KCcuJyk7XG5cbiAgICB2YXIgX3BhdGhBcnJheTIgPSBfdG9BcnJheShwYXRoQXJyYXkpLFxuICAgICAgICBrZXkgPSBfcGF0aEFycmF5MlswXSxcbiAgICAgICAgcmVzdFBhdGggPSBfcGF0aEFycmF5Mi5zbGljZSgxKTtcblxuICAgIGlmIChfdHlwZW9mKG9ialtrZXldKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCBuZXZlciBiZSBoaXQgaW4gdGhlIGN1cnJlbnQgY29kZSBiZWNhdXNlIHVud2luZCBkb2VzIHRoZSBjaGVjayBiZWZvcmUgY2FsbGluZyB1bnNldFByb3BcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgaWYgKHBhdGhBcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmZpbHRlcihmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICByZXR1cm4gcHJvcCAhPT0ga2V5O1xuICAgICAgfSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjLCBfZGVmaW5lUHJvcGVydHkoe30sIHByb3AsIG9ialtwcm9wXSkpO1xuICAgICAgfSwge30pO1xuICAgIH1cblxuICAgIHJldHVybiB1bnNldFByb3Aob2JqW2tleV0sIHJlc3RQYXRoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsYXR0ZW5SZWR1Y2VyKGFjYywgYXJyKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoaXMgaXMgZmFzdGVyIGJ1dCBzdXNjZXB0aWJsZSB0byBgUmFuZ2VFcnJvcjogTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRgXG4gICAgICBhY2MucHVzaC5hcHBseShhY2MsIF90b0NvbnN1bWFibGVBcnJheShhcnIpKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBhIHNsb3dlciBidXQgc2FmZXIgb3B0aW9uXG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChhcnIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZhc3RKb2luKGFyciwgc2VwYXJhdG9yKSB7XG4gICAgdmFyIGlzRmlyc3QgPSB0cnVlO1xuICAgIHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGVsZW0pIHtcbiAgICAgIGlmIChlbGVtID09PSBudWxsIHx8IGVsZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbGVtID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIGlzRmlyc3QgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGVsZW0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQoYWNjKS5jb25jYXQoc2VwYXJhdG9yKS5jb25jYXQoZWxlbSk7XG4gICAgfSwgJycpO1xuICB9XG5cbiAgdmFyIHV0aWxzID0ge1xuICAgIGdldFByb3A6IGdldFByb3AsXG4gICAgc2V0UHJvcDogc2V0UHJvcCxcbiAgICB1bnNldFByb3A6IHVuc2V0UHJvcCxcbiAgICBmYXN0Sm9pbjogZmFzdEpvaW4sXG4gICAgZmxhdHRlblJlZHVjZXI6IGZsYXR0ZW5SZWR1Y2VyXG4gIH07XG5cbiAgdmFyIGdldFByb3AkMSA9IHV0aWxzLmdldFByb3AsXG4gICAgICBmYXN0Sm9pbiQxID0gdXRpbHMuZmFzdEpvaW4sXG4gICAgICBmbGF0dGVuUmVkdWNlciQxID0gdXRpbHMuZmxhdHRlblJlZHVjZXI7XG5cbiAgdmFyIEpTT04yQ1NWQmFzZSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpTT04yQ1NWQmFzZShvcHRzKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSlNPTjJDU1ZCYXNlKTtcblxuICAgICAgdGhpcy5vcHRzID0gdGhpcy5wcmVwcm9jZXNzT3B0cyhvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgcGFzc2luZyBvcHRzIGFuZCBzZXQgZGVmYXVsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pzb24yQ3N2T3B0aW9uc30gb3B0cyBPcHRpb25zIG9iamVjdCBjb250YWluaW5nIGZpZWxkcyxcbiAgICAgKiBkZWxpbWl0ZXIsIGRlZmF1bHQgdmFsdWUsIHF1b3RlIG1hcmssIGhlYWRlciwgZXRjLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSlNPTjJDU1ZCYXNlLCBbe1xuICAgICAga2V5OiBcInByZXByb2Nlc3NPcHRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcHJvY2Vzc09wdHMob3B0cykge1xuICAgICAgICB2YXIgcHJvY2Vzc2VkT3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpO1xuICAgICAgICBwcm9jZXNzZWRPcHRzLnRyYW5zZm9ybXMgPSAhQXJyYXkuaXNBcnJheShwcm9jZXNzZWRPcHRzLnRyYW5zZm9ybXMpID8gcHJvY2Vzc2VkT3B0cy50cmFuc2Zvcm1zID8gW3Byb2Nlc3NlZE9wdHMudHJhbnNmb3Jtc10gOiBbXSA6IHByb2Nlc3NlZE9wdHMudHJhbnNmb3JtcztcbiAgICAgICAgcHJvY2Vzc2VkT3B0cy5kZWxpbWl0ZXIgPSBwcm9jZXNzZWRPcHRzLmRlbGltaXRlciB8fCAnLCc7XG4gICAgICAgIHByb2Nlc3NlZE9wdHMuZW9sID0gcHJvY2Vzc2VkT3B0cy5lb2wgfHwgb3MuRU9MO1xuICAgICAgICBwcm9jZXNzZWRPcHRzLnF1b3RlID0gdHlwZW9mIHByb2Nlc3NlZE9wdHMucXVvdGUgPT09ICdzdHJpbmcnID8gcHJvY2Vzc2VkT3B0cy5xdW90ZSA6ICdcIic7XG4gICAgICAgIHByb2Nlc3NlZE9wdHMuZXNjYXBlZFF1b3RlID0gdHlwZW9mIHByb2Nlc3NlZE9wdHMuZXNjYXBlZFF1b3RlID09PSAnc3RyaW5nJyA/IHByb2Nlc3NlZE9wdHMuZXNjYXBlZFF1b3RlIDogXCJcIi5jb25jYXQocHJvY2Vzc2VkT3B0cy5xdW90ZSkuY29uY2F0KHByb2Nlc3NlZE9wdHMucXVvdGUpO1xuICAgICAgICBwcm9jZXNzZWRPcHRzLmhlYWRlciA9IHByb2Nlc3NlZE9wdHMuaGVhZGVyICE9PSBmYWxzZTtcbiAgICAgICAgcHJvY2Vzc2VkT3B0cy5pbmNsdWRlRW1wdHlSb3dzID0gcHJvY2Vzc2VkT3B0cy5pbmNsdWRlRW1wdHlSb3dzIHx8IGZhbHNlO1xuICAgICAgICBwcm9jZXNzZWRPcHRzLndpdGhCT00gPSBwcm9jZXNzZWRPcHRzLndpdGhCT00gfHwgZmFsc2U7XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWRPcHRzO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBDaGVjayBhbmQgbm9ybWFsaXplIHRoZSBmaWVsZHMgY29uZmlndXJhdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KVtdfSBmaWVsZHMgRmllbGRzIGNvbmZpZ3VyYXRpb24gcHJvdmlkZWQgYnkgdGhlIHVzZXJcbiAgICAgICAqIG9yIGluZmVycmVkIGZyb20gdGhlIGRhdGFcbiAgICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX0gcHJlcHJvY2Vzc2VkIEZpZWxkc0luZm8gYXJyYXlcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInByZXByb2Nlc3NGaWVsZHNJbmZvXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcHJvY2Vzc0ZpZWxkc0luZm8oZmllbGRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoZnVuY3Rpb24gKGZpZWxkSW5mbykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZmllbGRJbmZvID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbGFiZWw6IGZpZWxkSW5mbyxcbiAgICAgICAgICAgICAgdmFsdWU6IGZpZWxkSW5mby5pbmNsdWRlcygnLicpIHx8IGZpZWxkSW5mby5pbmNsdWRlcygnWycpID8gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2Rhc2hfZ2V0KHJvdywgZmllbGRJbmZvLCBfdGhpcy5vcHRzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3AkMShyb3csIGZpZWxkSW5mbywgX3RoaXMub3B0cy5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfdHlwZW9mKGZpZWxkSW5mbykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gJ2RlZmF1bHQnIGluIGZpZWxkSW5mbyA/IGZpZWxkSW5mby5kZWZhdWx0IDogX3RoaXMub3B0cy5kZWZhdWx0VmFsdWU7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGRJbmZvLnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBmaWVsZEluZm8ubGFiZWwgfHwgZmllbGRJbmZvLnZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmaWVsZEluZm8udmFsdWUuaW5jbHVkZXMoJy4nKSB8fCBmaWVsZEluZm8udmFsdWUuaW5jbHVkZXMoJ1snKSA/IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsb2Rhc2hfZ2V0KHJvdywgZmllbGRJbmZvLnZhbHVlLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvcCQxKHJvdywgZmllbGRJbmZvLnZhbHVlLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZEluZm8udmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdmFyIGxhYmVsID0gZmllbGRJbmZvLmxhYmVsIHx8IGZpZWxkSW5mby52YWx1ZS5uYW1lIHx8ICcnO1xuICAgICAgICAgICAgICB2YXIgZmllbGQgPSB7XG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocm93KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBmaWVsZEluZm8udmFsdWUocm93LCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZmllbGQgaW5mbyBvcHRpb24uICcgKyBKU09OLnN0cmluZ2lmeShmaWVsZEluZm8pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSB0aGUgdGl0bGUgcm93IHdpdGggYWxsIHRoZSBwcm92aWRlZCBmaWVsZHMgYXMgY29sdW1uIGhlYWRpbmdzXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge1N0cmluZ30gdGl0bGVzIGFzIGEgc3RyaW5nXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRIZWFkZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWFkZXIoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBmYXN0Sm9pbiQxKHRoaXMub3B0cy5maWVsZHMubWFwKGZ1bmN0aW9uIChmaWVsZEluZm8pIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLnByb2Nlc3NWYWx1ZShmaWVsZEluZm8ubGFiZWwpO1xuICAgICAgICB9KSwgdGhpcy5vcHRzLmRlbGltaXRlcik7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFByZXByb2Nlc3MgZWFjaCBvYmplY3QgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB0cmFuc2Zvcm1zICh1bndpbmQsIGZsYXR0ZW4sIGV0Yy4pLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJvdyBKU09OIG9iamVjdCB0byBiZSBjb252ZXJ0ZWQgaW4gYSBDU1Ygcm93XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcmVwcm9jZXNzUm93XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcHJvY2Vzc1Jvdyhyb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0cy50cmFuc2Zvcm1zLnJlZHVjZShmdW5jdGlvbiAocm93cywgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgcmV0dXJuIHJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm0ocm93KTtcbiAgICAgICAgICB9KS5yZWR1Y2UoZmxhdHRlblJlZHVjZXIkMSwgW10pO1xuICAgICAgICB9LCBbcm93XSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSB0aGUgY29udGVudCBvZiBhIHNwZWNpZmljIENTViByb3dcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcm93IEpTT04gb2JqZWN0IHRvIGJlIGNvbnZlcnRlZCBpbiBhIENTViByb3dcbiAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IENTViBzdHJpbmcgKHJvdylcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInByb2Nlc3NSb3dcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzUm93KHJvdykge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICBpZiAoIXJvdykge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvY2Vzc2VkUm93ID0gdGhpcy5vcHRzLmZpZWxkcy5tYXAoZnVuY3Rpb24gKGZpZWxkSW5mbykge1xuICAgICAgICAgIHJldHVybiBfdGhpczMucHJvY2Vzc0NlbGwocm93LCBmaWVsZEluZm8pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXRoaXMub3B0cy5pbmNsdWRlRW1wdHlSb3dzICYmIHByb2Nlc3NlZFJvdy5ldmVyeShmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICByZXR1cm4gZmllbGQgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhc3RKb2luJDEocHJvY2Vzc2VkUm93LCB0aGlzLm9wdHMuZGVsaW1pdGVyKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIHRoZSBjb250ZW50IG9mIGEgc3BlY2ZpYyBDU1Ygcm93IGNlbGxcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gcm93IEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgIENTViByb3cgdGhhdCB0aGUgY2VsbCBiZWxvbmdzIHRvXG4gICAgICAgKiBAcGFyYW0ge0ZpZWxkSW5mb30gZmllbGRJbmZvIERldGFpbHMgb2YgdGhlIGZpZWxkIHRvIHByb2Nlc3MgdG8gYmUgYSBDU1YgY2VsbFxuICAgICAgICogQHJldHVybnMge1N0cmluZ30gQ1NWIHN0cmluZyAoY2VsbClcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInByb2Nlc3NDZWxsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0NlbGwocm93LCBmaWVsZEluZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1ZhbHVlKGZpZWxkSW5mby52YWx1ZShyb3cpKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIHRoZSBjb250ZW50IG9mIGEgc3BlY2ZpYyBDU1Ygcm93IGNlbGxcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0FueX0gdmFsdWUgVmFsdWUgdG8gYmUgaW5jbHVkZWQgaW4gYSBDU1YgY2VsbFxuICAgICAgICogQHJldHVybnMge1N0cmluZ30gVmFsdWUgc3RyaW5naWZpZWQgYW5kIHByb2Nlc3NlZFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJvY2Vzc1ZhbHVlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1ZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZVR5cGUgPSBfdHlwZW9mKHZhbHVlKTtcblxuICAgICAgICBpZiAodmFsdWVUeXBlICE9PSAnYm9vbGVhbicgJiYgdmFsdWVUeXBlICE9PSAnbnVtYmVyJyAmJiB2YWx1ZVR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWVbMF0gPT09ICdcIicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXlwiKC4rKVwiJC8sICckMScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0cy5leGNlbFN0cmluZ3MpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyh0aGlzLm9wdHMucXVvdGUpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShuZXcgUmVnRXhwKHRoaXMub3B0cy5xdW90ZSwgJ2cnKSwgXCJcIi5jb25jYXQodGhpcy5vcHRzLmVzY2FwZWRRdW90ZSkuY29uY2F0KHRoaXMub3B0cy5lc2NhcGVkUXVvdGUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSBcIlxcXCI9XFxcIlxcXCJcIi5jb25jYXQodmFsdWUsIFwiXFxcIlxcXCJcXFwiXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXModGhpcy5vcHRzLnF1b3RlKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UobmV3IFJlZ0V4cCh0aGlzLm9wdHMucXVvdGUsICdnJyksIHRoaXMub3B0cy5lc2NhcGVkUXVvdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IFwiXCIuY29uY2F0KHRoaXMub3B0cy5xdW90ZSkuY29uY2F0KHZhbHVlKS5jb25jYXQodGhpcy5vcHRzLnF1b3RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEpTT04yQ1NWQmFzZTtcbiAgfSgpO1xuXG4gIHZhciBKU09OMkNTVkJhc2VfMSA9IEpTT04yQ1NWQmFzZTtcblxuICB2YXIgZmFzdEpvaW4kMiA9IHV0aWxzLmZhc3RKb2luLFxuICAgICAgZmxhdHRlblJlZHVjZXIkMiA9IHV0aWxzLmZsYXR0ZW5SZWR1Y2VyO1xuXG4gIHZhciBKU09OMkNTVlBhcnNlciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9KU09OMkNTVkJhc2UpIHtcbiAgICBfaW5oZXJpdHMoSlNPTjJDU1ZQYXJzZXIsIF9KU09OMkNTVkJhc2UpO1xuXG4gICAgZnVuY3Rpb24gSlNPTjJDU1ZQYXJzZXIob3B0cykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSlNPTjJDU1ZQYXJzZXIpO1xuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihKU09OMkNTVlBhcnNlcikuY2FsbCh0aGlzLCBvcHRzKSk7XG5cbiAgICAgIGlmIChfdGhpcy5vcHRzLmZpZWxkcykge1xuICAgICAgICBfdGhpcy5vcHRzLmZpZWxkcyA9IF90aGlzLnByZXByb2Nlc3NGaWVsZHNJbmZvKF90aGlzLm9wdHMuZmllbGRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWluIGZ1bmN0aW9uIHRoYXQgY29udmVydHMganNvbiB0byBjc3YuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gZGF0YSBBcnJheSBvZiBKU09OIG9iamVjdHMgdG8gYmUgY29udmVydGVkIHRvIENTVlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBDU1YgZm9ybWF0ZWQgZGF0YSBhcyBhIHN0cmluZ1xuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSlNPTjJDU1ZQYXJzZXIsIFt7XG4gICAgICBrZXk6IFwicGFyc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShkYXRhKSB7XG4gICAgICAgIHZhciBwcm9jZXNzZWREYXRhID0gdGhpcy5wcmVwcm9jZXNzRGF0YShkYXRhKTtcblxuICAgICAgICBpZiAoIXRoaXMub3B0cy5maWVsZHMpIHtcbiAgICAgICAgICB0aGlzLm9wdHMuZmllbGRzID0gcHJvY2Vzc2VkRGF0YS5yZWR1Y2UoZnVuY3Rpb24gKGZpZWxkcywgaXRlbSkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoaXRlbSkuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgaWYgKCFmaWVsZHMuaW5jbHVkZXMoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goZmllbGQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgICAgICAgfSwgW10pO1xuICAgICAgICAgIHRoaXMub3B0cy5maWVsZHMgPSB0aGlzLnByZXByb2Nlc3NGaWVsZHNJbmZvKHRoaXMub3B0cy5maWVsZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMub3B0cy5oZWFkZXIgPyB0aGlzLmdldEhlYWRlcigpIDogJyc7XG4gICAgICAgIHZhciByb3dzID0gdGhpcy5wcm9jZXNzRGF0YShwcm9jZXNzZWREYXRhKTtcbiAgICAgICAgdmFyIGNzdiA9ICh0aGlzLm9wdHMud2l0aEJPTSA/IFwiXFx1RkVGRlwiIDogJycpICsgaGVhZGVyICsgKGhlYWRlciAmJiByb3dzID8gdGhpcy5vcHRzLmVvbCA6ICcnKSArIHJvd3M7XG4gICAgICAgIHJldHVybiBjc3Y7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFByZXByb2Nlc3MgdGhlIGRhdGEgYWNjb3JkaW5nIHRvIHRoZSBnaXZlIG9wdHMgKHVud2luZCwgZmxhdHRlbiwgZXRjLilcbiAgICAgICAgYW5kIGNhbGN1bGF0ZSB0aGUgZmllbGRzIGFuZCBmaWVsZCBuYW1lcyBpZiB0aGV5IGFyZSBub3QgcHJvdmlkZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGRhdGEgQXJyYXkgb3Igb2JqZWN0IHRvIGJlIGNvbnZlcnRlZCB0byBDU1ZcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInByZXByb2Nlc3NEYXRhXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcHJvY2Vzc0RhdGEoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhIDogW2RhdGFdO1xuXG4gICAgICAgIGlmICghdGhpcy5vcHRzLmZpZWxkcyAmJiAocHJvY2Vzc2VkRGF0YS5sZW5ndGggPT09IDAgfHwgX3R5cGVvZihwcm9jZXNzZWREYXRhWzBdKSAhPT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIHNob3VsZCBub3QgYmUgZW1wdHkgb3IgdGhlIFwiZmllbGRzXCIgb3B0aW9uIHNob3VsZCBiZSBpbmNsdWRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0cy50cmFuc2Zvcm1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHByb2Nlc3NlZERhdGE7XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWREYXRhLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5wcmVwcm9jZXNzUm93KHJvdyk7XG4gICAgICAgIH0pLnJlZHVjZShmbGF0dGVuUmVkdWNlciQyLCBbXSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSB0aGUgY29udGVudCByb3cgYnkgcm93IGJlbG93IHRoZSBoZWFkZXJcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIEFycmF5IG9mIEpTT04gb2JqZWN0cyB0byBiZSBjb252ZXJ0ZWQgdG8gQ1NWXG4gICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBDU1Ygc3RyaW5nIChib2R5KVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJvY2Vzc0RhdGFcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzRGF0YShkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBmYXN0Sm9pbiQyKGRhdGEubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLnByb2Nlc3NSb3cocm93KTtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9KSwgLy8gRmlsdGVyIGVtcHR5IHJvd3NcbiAgICAgICAgdGhpcy5vcHRzLmVvbCk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEpTT04yQ1NWUGFyc2VyO1xuICB9KEpTT04yQ1NWQmFzZV8xKTtcblxuICB2YXIgSlNPTjJDU1ZQYXJzZXJfMSA9IEpTT04yQ1NWUGFyc2VyO1xuXG4gIC8qZ2xvYmFsIEJ1ZmZlciovXG4gIC8vIE5hbWVkIGNvbnN0YW50cyB3aXRoIHVuaXF1ZSBpbnRlZ2VyIHZhbHVlc1xuICB2YXIgQyA9IHt9O1xuICAvLyBUb2tlbnNcbiAgdmFyIExFRlRfQlJBQ0UgICAgPSBDLkxFRlRfQlJBQ0UgICAgPSAweDE7XG4gIHZhciBSSUdIVF9CUkFDRSAgID0gQy5SSUdIVF9CUkFDRSAgID0gMHgyO1xuICB2YXIgTEVGVF9CUkFDS0VUICA9IEMuTEVGVF9CUkFDS0VUICA9IDB4MztcbiAgdmFyIFJJR0hUX0JSQUNLRVQgPSBDLlJJR0hUX0JSQUNLRVQgPSAweDQ7XG4gIHZhciBDT0xPTiAgICAgICAgID0gQy5DT0xPTiAgICAgICAgID0gMHg1O1xuICB2YXIgQ09NTUEgICAgICAgICA9IEMuQ09NTUEgICAgICAgICA9IDB4NjtcbiAgdmFyIFRSVUUgICAgICAgICAgPSBDLlRSVUUgICAgICAgICAgPSAweDc7XG4gIHZhciBGQUxTRSAgICAgICAgID0gQy5GQUxTRSAgICAgICAgID0gMHg4O1xuICB2YXIgTlVMTCAgICAgICAgICA9IEMuTlVMTCAgICAgICAgICA9IDB4OTtcbiAgdmFyIFNUUklORyAgICAgICAgPSBDLlNUUklORyAgICAgICAgPSAweGE7XG4gIHZhciBOVU1CRVIgICAgICAgID0gQy5OVU1CRVIgICAgICAgID0gMHhiO1xuICAvLyBUb2tlbml6ZXIgU3RhdGVzXG4gIHZhciBTVEFSVCAgID0gQy5TVEFSVCAgID0gMHgxMTtcbiAgdmFyIFNUT1AgICAgPSBDLlNUT1AgICAgPSAweDEyO1xuICB2YXIgVFJVRTEgICA9IEMuVFJVRTEgICA9IDB4MjE7XG4gIHZhciBUUlVFMiAgID0gQy5UUlVFMiAgID0gMHgyMjtcbiAgdmFyIFRSVUUzICAgPSBDLlRSVUUzICAgPSAweDIzO1xuICB2YXIgRkFMU0UxICA9IEMuRkFMU0UxICA9IDB4MzE7XG4gIHZhciBGQUxTRTIgID0gQy5GQUxTRTIgID0gMHgzMjtcbiAgdmFyIEZBTFNFMyAgPSBDLkZBTFNFMyAgPSAweDMzO1xuICB2YXIgRkFMU0U0ICA9IEMuRkFMU0U0ICA9IDB4MzQ7XG4gIHZhciBOVUxMMSAgID0gQy5OVUxMMSAgID0gMHg0MTtcbiAgdmFyIE5VTEwyICAgPSBDLk5VTEwyICAgPSAweDQyO1xuICB2YXIgTlVMTDMgICA9IEMuTlVMTDMgICA9IDB4NDM7XG4gIHZhciBOVU1CRVIxID0gQy5OVU1CRVIxID0gMHg1MTtcbiAgdmFyIE5VTUJFUjMgPSBDLk5VTUJFUjMgPSAweDUzO1xuICB2YXIgU1RSSU5HMSA9IEMuU1RSSU5HMSA9IDB4NjE7XG4gIHZhciBTVFJJTkcyID0gQy5TVFJJTkcyID0gMHg2MjtcbiAgdmFyIFNUUklORzMgPSBDLlNUUklORzMgPSAweDYzO1xuICB2YXIgU1RSSU5HNCA9IEMuU1RSSU5HNCA9IDB4NjQ7XG4gIHZhciBTVFJJTkc1ID0gQy5TVFJJTkc1ID0gMHg2NTtcbiAgdmFyIFNUUklORzYgPSBDLlNUUklORzYgPSAweDY2O1xuICAvLyBQYXJzZXIgU3RhdGVzXG4gIHZhciBWQUxVRSAgID0gQy5WQUxVRSAgID0gMHg3MTtcbiAgdmFyIEtFWSAgICAgPSBDLktFWSAgICAgPSAweDcyO1xuICAvLyBQYXJzZXIgTW9kZXNcbiAgdmFyIE9CSkVDVCAgPSBDLk9CSkVDVCAgPSAweDgxO1xuICB2YXIgQVJSQVkgICA9IEMuQVJSQVkgICA9IDB4ODI7XG4gIC8vIENoYXJhY3RlciBjb25zdGFudHNcbiAgdmFyIEJBQ0tfU0xBU0ggPSAgICAgIFwiXFxcXFwiLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBGT1JXQVJEX1NMQVNIID0gICBcIlxcL1wiLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBCQUNLU1BBQ0UgPSAgICAgICBcIlxcYlwiLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBGT1JNX0ZFRUQgPSAgICAgICBcIlxcZlwiLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBORVdMSU5FID0gICAgICAgICBcIlxcblwiLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBDQVJSSUFHRV9SRVRVUk4gPSBcIlxcclwiLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBUQUIgPSAgICAgICAgICAgICBcIlxcdFwiLmNoYXJDb2RlQXQoMCk7XG5cbiAgdmFyIFNUUklOR19CVUZGRVJfU0laRSA9IDY0ICogMTAyNDtcblxuICBmdW5jdGlvbiBQYXJzZXIoKSB7XG4gICAgdGhpcy50U3RhdGUgPSBTVEFSVDtcbiAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5zdHJpbmcgPSB1bmRlZmluZWQ7IC8vIHN0cmluZyBkYXRhXG4gICAgdGhpcy5zdHJpbmdCdWZmZXIgPSBCdWZmZXIuYWxsb2MgPyBCdWZmZXIuYWxsb2MoU1RSSU5HX0JVRkZFUl9TSVpFKSA6IG5ldyBCdWZmZXIoU1RSSU5HX0JVRkZFUl9TSVpFKTtcbiAgICB0aGlzLnN0cmluZ0J1ZmZlck9mZnNldCA9IDA7XG4gICAgdGhpcy51bmljb2RlID0gdW5kZWZpbmVkOyAvLyB1bmljb2RlIGVzY2FwZXNcbiAgICB0aGlzLmhpZ2hTdXJyb2dhdGUgPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLmtleSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1vZGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMuc3RhdGUgPSBWQUxVRTtcbiAgICB0aGlzLmJ5dGVzX3JlbWFpbmluZyA9IDA7IC8vIG51bWJlciBvZiBieXRlcyByZW1haW5pbmcgaW4gbXVsdGkgYnl0ZSB1dGY4IGNoYXIgdG8gcmVhZCBhZnRlciBzcGxpdCBib3VuZGFyeVxuICAgIHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UgPSAwOyAvLyBieXRlcyBpbiBtdWx0aSBieXRlIHV0ZjggY2hhciB0byByZWFkXG4gICAgdGhpcy50ZW1wX2J1ZmZzID0geyBcIjJcIjogbmV3IEJ1ZmZlcigyKSwgXCIzXCI6IG5ldyBCdWZmZXIoMyksIFwiNFwiOiBuZXcgQnVmZmVyKDQpIH07IC8vIGZvciByZWJ1aWxkaW5nIGNoYXJzIHNwbGl0IGJlZm9yZSBib3VuZGFyeSBpcyByZWFjaGVkXG5cbiAgICAvLyBTdHJlYW0gb2Zmc2V0XG4gICAgdGhpcy5vZmZzZXQgPSAtMTtcbiAgfVxuXG4gIC8vIFNsb3cgY29kZSB0byBzdHJpbmcgY29udmVydGVyIChvbmx5IHVzZWQgd2hlbiB0aHJvd2luZyBzeW50YXggZXJyb3JzKVxuICBQYXJzZXIudG9rbmFtID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKEMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKENba2V5XSA9PT0gY29kZSkgeyByZXR1cm4ga2V5OyB9XG4gICAgfVxuICAgIHJldHVybiBjb2RlICYmIChcIjB4XCIgKyBjb2RlLnRvU3RyaW5nKDE2KSk7XG4gIH07XG5cbiAgdmFyIHByb3RvID0gUGFyc2VyLnByb3RvdHlwZTtcbiAgcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgdGhyb3cgZXJyOyB9O1xuICBwcm90by5jaGFyRXJyb3IgPSBmdW5jdGlvbiAoYnVmZmVyLCBpKSB7XG4gICAgdGhpcy50U3RhdGUgPSBTVE9QO1xuICAgIHRoaXMub25FcnJvcihuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFwiICsgSlNPTi5zdHJpbmdpZnkoU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXJbaV0pKSArIFwiIGF0IHBvc2l0aW9uIFwiICsgaSArIFwiIGluIHN0YXRlIFwiICsgUGFyc2VyLnRva25hbSh0aGlzLnRTdGF0ZSkpKTtcbiAgfTtcbiAgcHJvdG8uYXBwZW5kU3RyaW5nQ2hhciA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgaWYgKHRoaXMuc3RyaW5nQnVmZmVyT2Zmc2V0ID49IFNUUklOR19CVUZGRVJfU0laRSkge1xuICAgICAgdGhpcy5zdHJpbmcgKz0gdGhpcy5zdHJpbmdCdWZmZXIudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgIHRoaXMuc3RyaW5nQnVmZmVyT2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLnN0cmluZ0J1ZmZlclt0aGlzLnN0cmluZ0J1ZmZlck9mZnNldCsrXSA9IGNoYXI7XG4gIH07XG4gIHByb3RvLmFwcGVuZFN0cmluZ0J1ZiA9IGZ1bmN0aW9uIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgc2l6ZSA9IGJ1Zi5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmICh0eXBlb2YgZW5kID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgIC8vIGFkZGluZyBhIG5lZ2F0aXZlIGVuZCBkZWNyZWVzZXMgdGhlIHNpemVcbiAgICAgICAgICBzaXplID0gYnVmLmxlbmd0aCAtIHN0YXJ0ICsgZW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNpemUgPSBlbmQgLSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IGJ1Zi5sZW5ndGggLSBzdGFydDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgIHNpemUgPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0cmluZ0J1ZmZlck9mZnNldCArIHNpemUgPiBTVFJJTkdfQlVGRkVSX1NJWkUpIHtcbiAgICAgIHRoaXMuc3RyaW5nICs9IHRoaXMuc3RyaW5nQnVmZmVyLnRvU3RyaW5nKCd1dGY4JywgMCwgdGhpcy5zdHJpbmdCdWZmZXJPZmZzZXQpO1xuICAgICAgdGhpcy5zdHJpbmdCdWZmZXJPZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGJ1Zi5jb3B5KHRoaXMuc3RyaW5nQnVmZmVyLCB0aGlzLnN0cmluZ0J1ZmZlck9mZnNldCwgc3RhcnQsIGVuZCk7XG4gICAgdGhpcy5zdHJpbmdCdWZmZXJPZmZzZXQgKz0gc2l6ZTtcbiAgfTtcbiAgcHJvdG8ud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgaWYgKHR5cGVvZiBidWZmZXIgPT09IFwic3RyaW5nXCIpIGJ1ZmZlciA9IG5ldyBCdWZmZXIoYnVmZmVyKTtcbiAgICB2YXIgbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJ1ZmZlci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLnRTdGF0ZSA9PT0gU1RBUlQpe1xuICAgICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICBpZihuID09PSAweDdiKXsgdGhpcy5vblRva2VuKExFRlRfQlJBQ0UsIFwie1wiKTsgLy8ge1xuICAgICAgICB9ZWxzZSBpZihuID09PSAweDdkKXsgdGhpcy5vblRva2VuKFJJR0hUX0JSQUNFLCBcIn1cIik7IC8vIH1cbiAgICAgICAgfWVsc2UgaWYobiA9PT0gMHg1Yil7IHRoaXMub25Ub2tlbihMRUZUX0JSQUNLRVQsIFwiW1wiKTsgLy8gW1xuICAgICAgICB9ZWxzZSBpZihuID09PSAweDVkKXsgdGhpcy5vblRva2VuKFJJR0hUX0JSQUNLRVQsIFwiXVwiKTsgLy8gXVxuICAgICAgICB9ZWxzZSBpZihuID09PSAweDNhKXsgdGhpcy5vblRva2VuKENPTE9OLCBcIjpcIik7ICAvLyA6XG4gICAgICAgIH1lbHNlIGlmKG4gPT09IDB4MmMpeyB0aGlzLm9uVG9rZW4oQ09NTUEsIFwiLFwiKTsgLy8gLFxuICAgICAgICB9ZWxzZSBpZihuID09PSAweDc0KXsgdGhpcy50U3RhdGUgPSBUUlVFMTsgIC8vIHRcbiAgICAgICAgfWVsc2UgaWYobiA9PT0gMHg2Nil7IHRoaXMudFN0YXRlID0gRkFMU0UxOyAgLy8gZlxuICAgICAgICB9ZWxzZSBpZihuID09PSAweDZlKXsgdGhpcy50U3RhdGUgPSBOVUxMMTsgLy8gblxuICAgICAgICB9ZWxzZSBpZihuID09PSAweDIyKXsgLy8gXCJcbiAgICAgICAgICB0aGlzLnN0cmluZyA9IFwiXCI7XG4gICAgICAgICAgdGhpcy5zdHJpbmdCdWZmZXJPZmZzZXQgPSAwO1xuICAgICAgICAgIHRoaXMudFN0YXRlID0gU1RSSU5HMTtcbiAgICAgICAgfWVsc2UgaWYobiA9PT0gMHgyZCl7IHRoaXMuc3RyaW5nID0gXCItXCI7IHRoaXMudFN0YXRlID0gTlVNQkVSMTsgLy8gLVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBpZiAobiA+PSAweDMwICYmIG4gPCAweDQwKSB7IC8vIDEtOVxuICAgICAgICAgICAgdGhpcy5zdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG4pOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjM7XG4gICAgICAgICAgfSBlbHNlIGlmIChuID09PSAweDIwIHx8IG4gPT09IDB4MDkgfHwgbiA9PT0gMHgwYSB8fCBuID09PSAweDBkKSA7IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IFNUUklORzEpeyAvLyBBZnRlciBvcGVuIHF1b3RlXG4gICAgICAgIG4gPSBidWZmZXJbaV07IC8vIGdldCBjdXJyZW50IGJ5dGUgZnJvbSBidWZmZXJcbiAgICAgICAgLy8gY2hlY2sgZm9yIGNhcnJ5IG92ZXIgb2YgYSBtdWx0aSBieXRlIGNoYXIgc3BsaXQgYmV0d2VlbiBkYXRhIGNodW5rc1xuICAgICAgICAvLyAmIGZpbGwgdGVtcCBidWZmZXIgaXQgd2l0aCBzdGFydCBvZiB0aGlzIGRhdGEgY2h1bmsgdXAgdG8gdGhlIGJvdW5kYXJ5IGxpbWl0IHNldCBpbiB0aGUgbGFzdCBpdGVyYXRpb25cbiAgICAgICAgaWYgKHRoaXMuYnl0ZXNfcmVtYWluaW5nID4gMCkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5ieXRlc19yZW1haW5pbmc7IGorKykge1xuICAgICAgICAgICAgdGhpcy50ZW1wX2J1ZmZzW3RoaXMuYnl0ZXNfaW5fc2VxdWVuY2VdW3RoaXMuYnl0ZXNfaW5fc2VxdWVuY2UgLSB0aGlzLmJ5dGVzX3JlbWFpbmluZyArIGpdID0gYnVmZmVyW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYXBwZW5kU3RyaW5nQnVmKHRoaXMudGVtcF9idWZmc1t0aGlzLmJ5dGVzX2luX3NlcXVlbmNlXSk7XG4gICAgICAgICAgdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSA9IHRoaXMuYnl0ZXNfcmVtYWluaW5nID0gMDtcbiAgICAgICAgICBpID0gaSArIGogLSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXNfcmVtYWluaW5nID09PSAwICYmIG4gPj0gMTI4KSB7IC8vIGVsc2UgaWYgbm8gcmVtYWluZGVyIGJ5dGVzIGNhcnJpZWQgb3ZlciwgcGFyc2UgbXVsdGkgYnl0ZSAoPj0xMjgpIGNoYXJzIG9uZSBhdCBhIHRpbWVcbiAgICAgICAgICBpZiAobiA8PSAxOTMgfHwgbiA+IDI0NCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25FcnJvcihuZXcgRXJyb3IoXCJJbnZhbGlkIFVURi04IGNoYXJhY3RlciBhdCBwb3NpdGlvbiBcIiArIGkgKyBcIiBpbiBzdGF0ZSBcIiArIFBhcnNlci50b2tuYW0odGhpcy50U3RhdGUpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgobiA+PSAxOTQpICYmIChuIDw9IDIyMykpIHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UgPSAyO1xuICAgICAgICAgIGlmICgobiA+PSAyMjQpICYmIChuIDw9IDIzOSkpIHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UgPSAzO1xuICAgICAgICAgIGlmICgobiA+PSAyNDApICYmIChuIDw9IDI0NCkpIHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UgPSA0O1xuICAgICAgICAgIGlmICgodGhpcy5ieXRlc19pbl9zZXF1ZW5jZSArIGkpID4gYnVmZmVyLmxlbmd0aCkgeyAvLyBpZiBieXRlcyBuZWVkZWQgdG8gY29tcGxldGUgY2hhciBmYWxsIG91dHNpZGUgYnVmZmVyIGxlbmd0aCwgd2UgaGF2ZSBhIGJvdW5kYXJ5IHNwbGl0XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8PSAoYnVmZmVyLmxlbmd0aCAtIDEgLSBpKTsgaysrKSB7XG4gICAgICAgICAgICAgIHRoaXMudGVtcF9idWZmc1t0aGlzLmJ5dGVzX2luX3NlcXVlbmNlXVtrXSA9IGJ1ZmZlcltpICsga107IC8vIGZpbGwgdGVtcCBidWZmZXIgb2YgY29ycmVjdCBzaXplIHdpdGggYnl0ZXMgYXZhaWxhYmxlIGluIHRoaXMgY2h1bmtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnl0ZXNfcmVtYWluaW5nID0gKGkgKyB0aGlzLmJ5dGVzX2luX3NlcXVlbmNlKSAtIGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kU3RyaW5nQnVmKGJ1ZmZlciwgaSwgaSArIHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UpO1xuICAgICAgICAgICAgaSA9IGkgKyB0aGlzLmJ5dGVzX2luX3NlcXVlbmNlIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMHgyMikge1xuICAgICAgICAgIHRoaXMudFN0YXRlID0gU1RBUlQ7XG4gICAgICAgICAgdGhpcy5zdHJpbmcgKz0gdGhpcy5zdHJpbmdCdWZmZXIudG9TdHJpbmcoJ3V0ZjgnLCAwLCB0aGlzLnN0cmluZ0J1ZmZlck9mZnNldCk7XG4gICAgICAgICAgdGhpcy5zdHJpbmdCdWZmZXJPZmZzZXQgPSAwO1xuICAgICAgICAgIHRoaXMub25Ub2tlbihTVFJJTkcsIHRoaXMuc3RyaW5nKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCArPSBCdWZmZXIuYnl0ZUxlbmd0aCh0aGlzLnN0cmluZywgJ3V0ZjgnKSArIDE7XG4gICAgICAgICAgdGhpcy5zdHJpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiA9PT0gMHg1Yykge1xuICAgICAgICAgIHRoaXMudFN0YXRlID0gU1RSSU5HMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuID49IDB4MjApIHsgdGhpcy5hcHBlbmRTdHJpbmdDaGFyKG4pOyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gU1RSSU5HMil7IC8vIEFmdGVyIGJhY2tzbGFzaFxuICAgICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgICBpZihuID09PSAweDIyKXsgdGhpcy5hcHBlbmRTdHJpbmdDaGFyKG4pOyB0aGlzLnRTdGF0ZSA9IFNUUklORzE7XG4gICAgICAgIH1lbHNlIGlmKG4gPT09IDB4NWMpeyB0aGlzLmFwcGVuZFN0cmluZ0NoYXIoQkFDS19TTEFTSCk7IHRoaXMudFN0YXRlID0gU1RSSU5HMTtcbiAgICAgICAgfWVsc2UgaWYobiA9PT0gMHgyZil7IHRoaXMuYXBwZW5kU3RyaW5nQ2hhcihGT1JXQVJEX1NMQVNIKTsgdGhpcy50U3RhdGUgPSBTVFJJTkcxO1xuICAgICAgICB9ZWxzZSBpZihuID09PSAweDYyKXsgdGhpcy5hcHBlbmRTdHJpbmdDaGFyKEJBQ0tTUEFDRSk7IHRoaXMudFN0YXRlID0gU1RSSU5HMTtcbiAgICAgICAgfWVsc2UgaWYobiA9PT0gMHg2Nil7IHRoaXMuYXBwZW5kU3RyaW5nQ2hhcihGT1JNX0ZFRUQpOyB0aGlzLnRTdGF0ZSA9IFNUUklORzE7XG4gICAgICAgIH1lbHNlIGlmKG4gPT09IDB4NmUpeyB0aGlzLmFwcGVuZFN0cmluZ0NoYXIoTkVXTElORSk7IHRoaXMudFN0YXRlID0gU1RSSU5HMTtcbiAgICAgICAgfWVsc2UgaWYobiA9PT0gMHg3Mil7IHRoaXMuYXBwZW5kU3RyaW5nQ2hhcihDQVJSSUFHRV9SRVRVUk4pOyB0aGlzLnRTdGF0ZSA9IFNUUklORzE7XG4gICAgICAgIH1lbHNlIGlmKG4gPT09IDB4NzQpeyB0aGlzLmFwcGVuZFN0cmluZ0NoYXIoVEFCKTsgdGhpcy50U3RhdGUgPSBTVFJJTkcxO1xuICAgICAgICB9ZWxzZSBpZihuID09PSAweDc1KXsgdGhpcy51bmljb2RlID0gXCJcIjsgdGhpcy50U3RhdGUgPSBTVFJJTkczO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTtcbiAgICAgICAgfVxuICAgICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBTVFJJTkczIHx8IHRoaXMudFN0YXRlID09PSBTVFJJTkc0IHx8IHRoaXMudFN0YXRlID09PSBTVFJJTkc1IHx8IHRoaXMudFN0YXRlID09PSBTVFJJTkc2KXsgLy8gdW5pY29kZSBoZXggY29kZXNcbiAgICAgICAgbiA9IGJ1ZmZlcltpXTtcbiAgICAgICAgLy8gMC05IEEtRiBhLWZcbiAgICAgICAgaWYgKChuID49IDB4MzAgJiYgbiA8IDB4NDApIHx8IChuID4gMHg0MCAmJiBuIDw9IDB4NDYpIHx8IChuID4gMHg2MCAmJiBuIDw9IDB4NjYpKSB7XG4gICAgICAgICAgdGhpcy51bmljb2RlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobik7XG4gICAgICAgICAgaWYgKHRoaXMudFN0YXRlKysgPT09IFNUUklORzYpIHtcbiAgICAgICAgICAgIHZhciBpbnRWYWwgPSBwYXJzZUludCh0aGlzLnVuaWNvZGUsIDE2KTtcbiAgICAgICAgICAgIHRoaXMudW5pY29kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZ2hTdXJyb2dhdGUgIT09IHVuZGVmaW5lZCAmJiBpbnRWYWwgPj0gMHhEQzAwICYmIGludFZhbCA8ICgweERGRkYgKyAxKSkgeyAvLzw1NjMyMCw1NzM0Mz4gLSBsb3dTdXJyb2dhdGVcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRTdHJpbmdCdWYobmV3IEJ1ZmZlcihTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuaGlnaFN1cnJvZ2F0ZSwgaW50VmFsKSkpO1xuICAgICAgICAgICAgICB0aGlzLmhpZ2hTdXJyb2dhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGlnaFN1cnJvZ2F0ZSA9PT0gdW5kZWZpbmVkICYmIGludFZhbCA+PSAweEQ4MDAgJiYgaW50VmFsIDwgKDB4REJGRiArIDEpKSB7IC8vPDU1Mjk2LDU2MzE5PiAtIGhpZ2hTdXJyb2dhdGVcbiAgICAgICAgICAgICAgdGhpcy5oaWdoU3Vycm9nYXRlID0gaW50VmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaGlnaFN1cnJvZ2F0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRTdHJpbmdCdWYobmV3IEJ1ZmZlcihTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuaGlnaFN1cnJvZ2F0ZSkpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hTdXJyb2dhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRTdHJpbmdCdWYobmV3IEJ1ZmZlcihTdHJpbmcuZnJvbUNoYXJDb2RlKGludFZhbCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudFN0YXRlID0gU1RSSU5HMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IE5VTUJFUjEgfHwgdGhpcy50U3RhdGUgPT09IE5VTUJFUjMpIHtcbiAgICAgICAgICBuID0gYnVmZmVyW2ldO1xuXG4gICAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgICBjYXNlIDB4MzA6IC8vIDBcbiAgICAgICAgICAgIGNhc2UgMHgzMTogLy8gMVxuICAgICAgICAgICAgY2FzZSAweDMyOiAvLyAyXG4gICAgICAgICAgICBjYXNlIDB4MzM6IC8vIDNcbiAgICAgICAgICAgIGNhc2UgMHgzNDogLy8gNFxuICAgICAgICAgICAgY2FzZSAweDM1OiAvLyA1XG4gICAgICAgICAgICBjYXNlIDB4MzY6IC8vIDZcbiAgICAgICAgICAgIGNhc2UgMHgzNzogLy8gN1xuICAgICAgICAgICAgY2FzZSAweDM4OiAvLyA4XG4gICAgICAgICAgICBjYXNlIDB4Mzk6IC8vIDlcbiAgICAgICAgICAgIGNhc2UgMHgyZTogLy8gLlxuICAgICAgICAgICAgY2FzZSAweDY1OiAvLyBlXG4gICAgICAgICAgICBjYXNlIDB4NDU6IC8vIEVcbiAgICAgICAgICAgIGNhc2UgMHgyYjogLy8gK1xuICAgICAgICAgICAgY2FzZSAweDJkOiAvLyAtXG4gICAgICAgICAgICAgIHRoaXMuc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobik7XG4gICAgICAgICAgICAgIHRoaXMudFN0YXRlID0gTlVNQkVSMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aGlzLnRTdGF0ZSA9IFNUQVJUO1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gTnVtYmVyKHRoaXMuc3RyaW5nKTtcblxuICAgICAgICAgICAgICBpZiAoaXNOYU4ocmVzdWx0KSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoKHRoaXMuc3RyaW5nLm1hdGNoKC9bMC05XSsvKSA9PSB0aGlzLnN0cmluZykgJiYgKHJlc3VsdC50b1N0cmluZygpICE9IHRoaXMuc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIExvbmcgc3RyaW5nIG9mIGRpZ2l0cyB3aGljaCBpcyBhbiBJRCBzdHJpbmcgYW5kIG5vdCB2YWxpZCBhbmQvb3Igc2FmZSBKYXZhU2NyaXB0IGludGVnZXIgTnVtYmVyXG4gICAgICAgICAgICAgICAgdGhpcy5vblRva2VuKFNUUklORywgdGhpcy5zdHJpbmcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub25Ub2tlbihOVU1CRVIsIHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLm9mZnNldCArPSB0aGlzLnN0cmluZy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICB0aGlzLnN0cmluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IFRSVUUxKXsgLy8gclxuICAgICAgICBpZiAoYnVmZmVyW2ldID09PSAweDcyKSB7IHRoaXMudFN0YXRlID0gVFJVRTI7IH1cbiAgICAgICAgZWxzZSB7IHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IFRSVUUyKXsgLy8gdVxuICAgICAgICBpZiAoYnVmZmVyW2ldID09PSAweDc1KSB7IHRoaXMudFN0YXRlID0gVFJVRTM7IH1cbiAgICAgICAgZWxzZSB7IHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IFRSVUUzKXsgLy8gZVxuICAgICAgICBpZiAoYnVmZmVyW2ldID09PSAweDY1KSB7IHRoaXMudFN0YXRlID0gU1RBUlQ7IHRoaXMub25Ub2tlbihUUlVFLCB0cnVlKTsgdGhpcy5vZmZzZXQrPSAzOyB9XG4gICAgICAgIGVsc2UgeyByZXR1cm4gdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBGQUxTRTEpeyAvLyBhXG4gICAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NjEpIHsgdGhpcy50U3RhdGUgPSBGQUxTRTI7IH1cbiAgICAgICAgZWxzZSB7IHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IEZBTFNFMil7IC8vIGxcbiAgICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gMHg2YykgeyB0aGlzLnRTdGF0ZSA9IEZBTFNFMzsgfVxuICAgICAgICBlbHNlIHsgcmV0dXJuIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gRkFMU0UzKXsgLy8gc1xuICAgICAgICBpZiAoYnVmZmVyW2ldID09PSAweDczKSB7IHRoaXMudFN0YXRlID0gRkFMU0U0OyB9XG4gICAgICAgIGVsc2UgeyByZXR1cm4gdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBGQUxTRTQpeyAvLyBlXG4gICAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NjUpIHsgdGhpcy50U3RhdGUgPSBTVEFSVDsgdGhpcy5vblRva2VuKEZBTFNFLCBmYWxzZSk7IHRoaXMub2Zmc2V0Kz0gNDsgfVxuICAgICAgICBlbHNlIHsgcmV0dXJuIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVMTDEpeyAvLyB1XG4gICAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NzUpIHsgdGhpcy50U3RhdGUgPSBOVUxMMjsgfVxuICAgICAgICBlbHNlIHsgcmV0dXJuIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVMTDIpeyAvLyBsXG4gICAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NmMpIHsgdGhpcy50U3RhdGUgPSBOVUxMMzsgfVxuICAgICAgICBlbHNlIHsgcmV0dXJuIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVMTDMpeyAvLyBsXG4gICAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NmMpIHsgdGhpcy50U3RhdGUgPSBTVEFSVDsgdGhpcy5vblRva2VuKE5VTEwsIG51bGwpOyB0aGlzLm9mZnNldCArPSAzOyB9XG4gICAgICAgIGVsc2UgeyByZXR1cm4gdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcHJvdG8ub25Ub2tlbiA9IGZ1bmN0aW9uICh0b2tlbiwgdmFsdWUpIHtcbiAgICAvLyBPdmVycmlkZSB0aGlzIHRvIGdldCBldmVudHNcbiAgfTtcblxuICBwcm90by5wYXJzZUVycm9yID0gZnVuY3Rpb24gKHRva2VuLCB2YWx1ZSkge1xuICAgIHRoaXMudFN0YXRlID0gU1RPUDtcbiAgICB0aGlzLm9uRXJyb3IobmV3IEVycm9yKFwiVW5leHBlY3RlZCBcIiArIFBhcnNlci50b2tuYW0odG9rZW4pICsgKHZhbHVlID8gKFwiKFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgXCIpXCIpIDogXCJcIikgKyBcIiBpbiBzdGF0ZSBcIiArIFBhcnNlci50b2tuYW0odGhpcy5zdGF0ZSkpKTtcbiAgfTtcbiAgcHJvdG8ucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goe3ZhbHVlOiB0aGlzLnZhbHVlLCBrZXk6IHRoaXMua2V5LCBtb2RlOiB0aGlzLm1vZGV9KTtcbiAgfTtcbiAgcHJvdG8ucG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgdGhpcy52YWx1ZSA9IHBhcmVudC52YWx1ZTtcbiAgICB0aGlzLmtleSA9IHBhcmVudC5rZXk7XG4gICAgdGhpcy5tb2RlID0gcGFyZW50Lm1vZGU7XG4gICAgdGhpcy5lbWl0KHZhbHVlKTtcbiAgICBpZiAoIXRoaXMubW9kZSkgeyB0aGlzLnN0YXRlID0gVkFMVUU7IH1cbiAgfTtcbiAgcHJvdG8uZW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm1vZGUpIHsgdGhpcy5zdGF0ZSA9IENPTU1BOyB9XG4gICAgdGhpcy5vblZhbHVlKHZhbHVlKTtcbiAgfTtcbiAgcHJvdG8ub25WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIE92ZXJyaWRlIG1lXG4gIH07XG4gIHByb3RvLm9uVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIHZhbHVlKSB7XG4gICAgaWYodGhpcy5zdGF0ZSA9PT0gVkFMVUUpe1xuICAgICAgaWYodG9rZW4gPT09IFNUUklORyB8fCB0b2tlbiA9PT0gTlVNQkVSIHx8IHRva2VuID09PSBUUlVFIHx8IHRva2VuID09PSBGQUxTRSB8fCB0b2tlbiA9PT0gTlVMTCl7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZVt0aGlzLmtleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQodmFsdWUpO1xuICAgICAgfWVsc2UgaWYodG9rZW4gPT09IExFRlRfQlJBQ0Upe1xuICAgICAgICB0aGlzLnB1c2goKTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZVt0aGlzLmtleV0gPSB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBLRVk7XG4gICAgICAgIHRoaXMubW9kZSA9IE9CSkVDVDtcbiAgICAgIH1lbHNlIGlmKHRva2VuID09PSBMRUZUX0JSQUNLRVQpe1xuICAgICAgICB0aGlzLnB1c2goKTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZVt0aGlzLmtleV0gPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXkgPSAwO1xuICAgICAgICB0aGlzLm1vZGUgPSBBUlJBWTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFZBTFVFO1xuICAgICAgfWVsc2UgaWYodG9rZW4gPT09IFJJR0hUX0JSQUNFKXtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gT0JKRUNUKSB7XG4gICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKHRva2VuLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1lbHNlIGlmKHRva2VuID09PSBSSUdIVF9CUkFDS0VUKXtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gQVJSQVkpIHtcbiAgICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9ZWxzZSBpZih0aGlzLnN0YXRlID09PSBLRVkpe1xuICAgICAgaWYgKHRva2VuID09PSBTVFJJTkcpIHtcbiAgICAgICAgdGhpcy5rZXkgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENPTE9OO1xuICAgICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gUklHSFRfQlJBQ0UpIHtcbiAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9ZWxzZSBpZih0aGlzLnN0YXRlID09PSBDT0xPTil7XG4gICAgICBpZiAodG9rZW4gPT09IENPTE9OKSB7IHRoaXMuc3RhdGUgPSBWQUxVRTsgfVxuICAgICAgZWxzZSB7IHJldHVybiB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTsgfVxuICAgIH1lbHNlIGlmKHRoaXMuc3RhdGUgPT09IENPTU1BKXtcbiAgICAgIGlmICh0b2tlbiA9PT0gQ09NTUEpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gQVJSQVkpIHsgdGhpcy5rZXkrKzsgdGhpcy5zdGF0ZSA9IFZBTFVFOyB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gT0JKRUNUKSB7IHRoaXMuc3RhdGUgPSBLRVk7IH1cblxuICAgICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gUklHSFRfQlJBQ0tFVCAmJiB0aGlzLm1vZGUgPT09IEFSUkFZIHx8IHRva2VuID09PSBSSUdIVF9CUkFDRSAmJiB0aGlzLm1vZGUgPT09IE9CSkVDVCkge1xuICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcih0b2tlbiwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcih0b2tlbiwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBQYXJzZXIuQyA9IEM7XG5cbiAgdmFyIGpzb25wYXJzZSA9IFBhcnNlcjtcblxuICB2YXIgVHJhbnNmb3JtJDEgPSBTdHJlYW0uVHJhbnNmb3JtO1xuXG4gIHZhciBKU09OMkNTVlRyYW5zZm9ybSA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9UcmFuc2Zvcm0pIHtcbiAgICBfaW5oZXJpdHMoSlNPTjJDU1ZUcmFuc2Zvcm0sIF9UcmFuc2Zvcm0pO1xuXG4gICAgZnVuY3Rpb24gSlNPTjJDU1ZUcmFuc2Zvcm0ob3B0cywgdHJhbnNmb3JtT3B0cykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSlNPTjJDU1ZUcmFuc2Zvcm0pO1xuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihKU09OMkNTVlRyYW5zZm9ybSkuY2FsbCh0aGlzLCB0cmFuc2Zvcm1PcHRzKSk7IC8vIEluaGVyaXQgbWV0aG9kcyBmcm9tIEpTT04yQ1NWQmFzZSBzaW5jZSBleHRlbmRzIGRvZXNuJ3RcbiAgICAgIC8vIGFsbG93IG11bHRpcGxlIGluaGVyaXRhbmNlIGFuZCBtYW51YWxseSBwcmVwcm9jZXNzIG9wdHNcblxuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoSlNPTjJDU1ZCYXNlXzEucHJvdG90eXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzW2tleV0gPSBKU09OMkNTVkJhc2VfMS5wcm90b3R5cGVba2V5XTtcbiAgICAgIH0pO1xuICAgICAgX3RoaXMub3B0cyA9IF90aGlzLnByZXByb2Nlc3NPcHRzKG9wdHMpO1xuICAgICAgX3RoaXMuX2RhdGEgPSAnJztcbiAgICAgIF90aGlzLl9oYXNXcml0dGVuID0gZmFsc2U7XG5cbiAgICAgIGlmIChfdGhpcy5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgICAgIF90aGlzLmluaXRPYmplY3RNb2RlUGFyc2UoKTtcbiAgICAgIH0gZWxzZSBpZiAoX3RoaXMub3B0cy5uZGpzb24pIHtcbiAgICAgICAgX3RoaXMuaW5pdE5ESlNPTlBhcnNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5pbml0SlNPTlBhcnNlcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMub3B0cy53aXRoQk9NKSB7XG4gICAgICAgIF90aGlzLnB1c2goXCJcXHVGRUZGXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMub3B0cy5maWVsZHMpIHtcbiAgICAgICAgX3RoaXMub3B0cy5maWVsZHMgPSBfdGhpcy5wcmVwcm9jZXNzRmllbGRzSW5mbyhfdGhpcy5vcHRzLmZpZWxkcyk7XG5cbiAgICAgICAgX3RoaXMucHVzaEhlYWRlcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXQgdGhlIHRyYW5zZm9ybSB3aXRoIGEgcGFyc2VyIHRvIHByb2Nlc3MgZGF0YSBpbiBvYmplY3QgbW9kZS5cbiAgICAgKiBJdCByZWNlaXZlcyBKU09OIG9iamVjdHMgb25lIGJ5IG9uZSBhbmQgc2VuZCB0aGVtIHRvIGBwdXNoTGluZSBmb3IgcHJvY2Vzc2luZy5cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEpTT04yQ1NWVHJhbnNmb3JtLCBbe1xuICAgICAga2V5OiBcImluaXRPYmplY3RNb2RlUGFyc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0T2JqZWN0TW9kZVBhcnNlKCkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcztcbiAgICAgICAgdGhpcy5wYXJzZXIgPSB7XG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGxpbmUpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybS5wdXNoTGluZShsaW5lKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldFBlbmRpbmdEYXRhOiBmdW5jdGlvbiBnZXRQZW5kaW5nRGF0YSgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBJbml0IHRoZSB0cmFuc2Zvcm0gd2l0aCBhIHBhcnNlciB0byBwcm9jZXNzIE5ESlNPTiBkYXRhLlxuICAgICAgICogSXQgbWFpbnRhaW5zIGEgYnVmZmVyIG9mIHJlY2VpdmVkIGRhdGEsIHBhcnNlcyBlYWNoIGxpbmVcbiAgICAgICAqIGFzIEpTT04gYW5kIHNlbmQgaXQgdG8gYHB1c2hMaW5lIGZvciBwcm9jZXNzaW5nLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaW5pdE5ESlNPTlBhcnNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdE5ESlNPTlBhcnNlKCkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcztcbiAgICAgICAgdGhpcy5wYXJzZXIgPSB7XG4gICAgICAgICAgX2RhdGE6ICcnLFxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjaHVuaykge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSArPSBjaHVuay50b1N0cmluZygpO1xuXG4gICAgICAgICAgICB2YXIgbGluZXMgPSB0aGlzLl9kYXRhLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxpbmUudHJpbSgpO1xuICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsaW5lICE9PSAnJztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcGVuZGluZ0RhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUsIGkpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0ucHVzaExpbmUoSlNPTi5wYXJzZShsaW5lKSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgcGVuZGluZ0RhdGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBcIkludmFsaWQgSlNPTiAoXCIuY29uY2F0KGxpbmUsIFwiKVwiKTtcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gcGVuZGluZ0RhdGEgPyB0aGlzLl9kYXRhLnNsaWNlKHRoaXMuX2RhdGEubGFzdEluZGV4T2YoJ1xcbicpKSA6ICcnO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0UGVuZGluZ0RhdGE6IGZ1bmN0aW9uIGdldFBlbmRpbmdEYXRhKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBJbml0IHRoZSB0cmFuc2Zvcm0gd2l0aCBhIHBhcnNlciB0byBwcm9jZXNzIEpTT04gZGF0YS5cbiAgICAgICAqIEl0IG1haW50YWlucyBhIGJ1ZmZlciBvZiByZWNlaXZlZCBkYXRhLCBwYXJzZXMgZWFjaCBhcyBKU09OIFxuICAgICAgICogaXRlbSBpZiB0aGUgZGF0YSBpcyBhbiBhcnJheSBvciB0aGUgZGF0YSBpdHNlbGYgb3RoZXJ3aXNlXG4gICAgICAgKiBhbmQgc2VuZCBpdCB0byBgcHVzaExpbmVgIGZvciBwcm9jZXNzaW5nLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaW5pdEpTT05QYXJzZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0SlNPTlBhcnNlcigpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXM7XG4gICAgICAgIHRoaXMucGFyc2VyID0gbmV3IGpzb25wYXJzZSgpO1xuXG4gICAgICAgIHRoaXMucGFyc2VyLm9uVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggIT09IHRoaXMuZGVwdGhUb0VtaXQpIHJldHVybjtcbiAgICAgICAgICB0cmFuc2Zvcm0ucHVzaExpbmUodmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucGFyc2VyLl9vblRva2VuID0gdGhpcy5wYXJzZXIub25Ub2tlbjtcblxuICAgICAgICB0aGlzLnBhcnNlci5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuLCB2YWx1ZSkge1xuICAgICAgICAgIHRyYW5zZm9ybS5wYXJzZXIuX29uVG9rZW4odG9rZW4sIHZhbHVlKTtcblxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMCAmJiAhdHJhbnNmb3JtLm9wdHMuZmllbGRzICYmIHRoaXMubW9kZSAhPT0ganNvbnBhcnNlLkMuQVJSQVkgJiYgdGhpcy5tb2RlICE9PSBqc29ucGFyc2UuQy5PQkpFQ1QpIHtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihuZXcgRXJyb3IoJ0RhdGEgc2hvdWxkIG5vdCBiZSBlbXB0eSBvciB0aGUgXCJmaWVsZHNcIiBvcHRpb24gc2hvdWxkIGJlIGluY2x1ZGVkJykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVwdGhUb0VtaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAvLyBJZiBBcnJheSBlbWl0IGl0cyBjb250ZW50LCBlbHNlIGVtaXQgaXRzZWxmXG4gICAgICAgICAgICAgIHRoaXMuZGVwdGhUb0VtaXQgPSB0aGlzLm1vZGUgPT09IGpzb25wYXJzZS5DLkFSUkFZID8gMSA6IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRlcHRoVG9FbWl0ICE9PSAwICYmIHRoaXMuc3RhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gc3RvcmUgdGhlIHdob2xlIHJvb3QgYXJyYXkgaW4gbWVtb3J5XG4gICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucGFyc2VyLmdldFBlbmRpbmdEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucGFyc2VyLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKCdVbmV4cGVjdGVkJykpIHtcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID0gXCJJbnZhbGlkIEpTT04gKFwiLmNvbmNhdChlcnIubWVzc2FnZSwgXCIpXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyYW5zZm9ybS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIE1haW4gZnVuY3Rpb24gdGhhdCBzZW5kIGRhdGEgdG8gdGhlIHBhcnNlIHRvIGJlIHByb2Nlc3NlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgSW5jb21pbmcgZGF0YVxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGVuY29kaW5nIEVuY29kaW5nIG9mIHRoZSBpbmNvbWluZyBkYXRhLiBEZWZhdWx0cyB0byAndXRmOCdcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgQ2FsbGVkIHdoZW4gdGhlIHByb2NlZXNpbmcgb2YgdGhlIHN1cHBsaWVkIGNodW5rIGlzIGRvbmVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl90cmFuc2Zvcm1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgICAgICB0aGlzLnBhcnNlci53cml0ZShjaHVuayk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2ZsdXNoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZsdXNoKGRvbmUpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyc2VyLmdldFBlbmRpbmdEYXRhKCkpIHtcbiAgICAgICAgICBkb25lKG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHJlY2VpdmVkIGZyb20gc3RkaW4nLCB0aGlzLnBhcnNlci5nZXRQZW5kaW5nRGF0YSgpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEdlbmVyYXRlIHRoZSBjc3YgaGVhZGVyIGFuZCBwdXNoZXMgaXQgZG93bnN0cmVhbS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInB1c2hIZWFkZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoSGVhZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLmhlYWRlcikge1xuICAgICAgICAgIHZhciBoZWFkZXIgPSB0aGlzLmdldEhlYWRlcigpO1xuICAgICAgICAgIHRoaXMuZW1pdCgnaGVhZGVyJywgaGVhZGVyKTtcbiAgICAgICAgICB0aGlzLnB1c2goaGVhZGVyKTtcbiAgICAgICAgICB0aGlzLl9oYXNXcml0dGVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm1zIGFuIGluY29taW5nIGpzb24gZGF0YSB0byBjc3YgYW5kIHB1c2hlcyBpdCBkb3duc3RyZWFtLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEpTT04gb2JqZWN0IHRvIGJlIGNvbnZlcnRlZCBpbiBhIENTViByb3dcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInB1c2hMaW5lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaExpbmUoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IHRoaXMucHJlcHJvY2Vzc1JvdyhkYXRhKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2hhc1dyaXR0ZW4pIHtcbiAgICAgICAgICB0aGlzLm9wdHMuZmllbGRzID0gdGhpcy5vcHRzLmZpZWxkcyB8fCB0aGlzLnByZXByb2Nlc3NGaWVsZHNJbmZvKE9iamVjdC5rZXlzKHByb2Nlc3NlZERhdGFbMF0pKTtcbiAgICAgICAgICB0aGlzLnB1c2hIZWFkZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3NlZERhdGEuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgdmFyIGxpbmUgPSBfdGhpczIucHJvY2Vzc1Jvdyhyb3csIF90aGlzMi5vcHRzKTtcblxuICAgICAgICAgIGlmIChsaW5lID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgICAgIF90aGlzMi5lbWl0KCdsaW5lJywgbGluZSk7XG5cbiAgICAgICAgICBfdGhpczIucHVzaChfdGhpczIuX2hhc1dyaXR0ZW4gPyBfdGhpczIub3B0cy5lb2wgKyBsaW5lIDogbGluZSk7XG5cbiAgICAgICAgICBfdGhpczIuX2hhc1dyaXR0ZW4gPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSlNPTjJDU1ZUcmFuc2Zvcm07XG4gIH0oVHJhbnNmb3JtJDEpO1xuXG4gIHZhciBKU09OMkNTVlRyYW5zZm9ybV8xID0gSlNPTjJDU1ZUcmFuc2Zvcm07XG5cbiAgdmFyIFRyYW5zZm9ybSQyID0gU3RyZWFtLlRyYW5zZm9ybTtcbiAgdmFyIGZhc3RKb2luJDMgPSB1dGlscy5mYXN0Sm9pbjtcblxuICB2YXIgSlNPTjJDU1ZBc3luY1BhcnNlciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpTT04yQ1NWQXN5bmNQYXJzZXIob3B0cywgdHJhbnNmb3JtT3B0cykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEpTT04yQ1NWQXN5bmNQYXJzZXIpO1xuXG4gICAgICB0aGlzLmlucHV0ID0gbmV3IFRyYW5zZm9ybSQyKHRyYW5zZm9ybU9wdHMpO1xuXG4gICAgICB0aGlzLmlucHV0Ll9yZWFkID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgIHRoaXMudHJhbnNmb3JtID0gbmV3IEpTT04yQ1NWVHJhbnNmb3JtXzEob3B0cywgdHJhbnNmb3JtT3B0cyk7XG4gICAgICB0aGlzLnByb2Nlc3NvciA9IHRoaXMuaW5wdXQucGlwZSh0aGlzLnRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEpTT04yQ1NWQXN5bmNQYXJzZXIsIFt7XG4gICAgICBrZXk6IFwiZnJvbUlucHV0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUlucHV0KGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXN5bmMgcGFyc2VyIGFscmVhZHkgaGFzIGFuIGlucHV0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMuX2lucHV0LnBpcGUodGhpcy5wcm9jZXNzb3IpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidGhyb3VnaFRyYW5zZm9ybVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRocm91Z2hUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgYWRkIHRyYW5zZm9ybXMgb25jZSBhbiBvdXRwdXQgaGFzIGJlZW4gYWRkZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHRoaXMucHJvY2Vzc29yLnBpcGUodHJhbnNmb3JtKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInRvT3V0cHV0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9PdXRwdXQob3V0cHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FzeW5jIHBhcnNlciBhbHJlYWR5IGhhcyBhbiBvdXRwdXQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vdXRwdXQgPSBvdXRwdXQ7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gdGhpcy5wcm9jZXNzb3IucGlwZShvdXRwdXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJvbWlzZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb21pc2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHJldHVybkNTViA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpZiAoIXJldHVybkNTVikge1xuICAgICAgICAgICAgX3RoaXMucHJvY2Vzc29yLm9uKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNzdkJ1ZmZlciA9IFtdO1xuXG4gICAgICAgICAgX3RoaXMucHJvY2Vzc29yLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gY3N2QnVmZmVyLnB1c2goY2h1bmsudG9TdHJpbmcoKSk7XG4gICAgICAgICAgfSkub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZhc3RKb2luJDMoY3N2QnVmZmVyLCAnJykpO1xuICAgICAgICAgIH0pLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEpTT04yQ1NWQXN5bmNQYXJzZXI7XG4gIH0oKTtcblxuICB2YXIgSlNPTjJDU1ZBc3luY1BhcnNlcl8xID0gSlNPTjJDU1ZBc3luY1BhcnNlcjtcblxuICAvKipcbiAgICogUGVyZm9ybXMgdGhlIGZsYXR0ZW5pbmcgb2YgYSBkYXRhIHJvdyByZWN1cnNpdmVseVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VwYXJhdG9yIFNlcGFyYXRvciB0byBiZSB1c2VkIGFzIHRoZSBmbGF0dGVuZWQgZmllbGQgbmFtZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0ID0+IE9iamVjdH0gRmxhdHRlbmVkIG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gZmxhdHRlbigpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIF9yZWYkb2JqZWN0cyA9IF9yZWYub2JqZWN0cyxcbiAgICAgICAgb2JqZWN0cyA9IF9yZWYkb2JqZWN0cyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkb2JqZWN0cyxcbiAgICAgICAgX3JlZiRhcnJheXMgPSBfcmVmLmFycmF5cyxcbiAgICAgICAgYXJyYXlzID0gX3JlZiRhcnJheXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRhcnJheXMsXG4gICAgICAgIF9yZWYkc2VwYXJhdG9yID0gX3JlZi5zZXBhcmF0b3IsXG4gICAgICAgIHNlcGFyYXRvciA9IF9yZWYkc2VwYXJhdG9yID09PSB2b2lkIDAgPyAnLicgOiBfcmVmJHNlcGFyYXRvcjtcblxuICAgIGZ1bmN0aW9uIHN0ZXAob2JqLCBmbGF0RGF0YVJvdywgY3VycmVudFBhdGgpIHtcbiAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdQYXRoID0gY3VycmVudFBhdGggPyBcIlwiLmNvbmNhdChjdXJyZW50UGF0aCkuY29uY2F0KHNlcGFyYXRvcikuY29uY2F0KGtleSkgOiBrZXk7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICAgIGlmIChvYmplY3RzICYmIF90eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlLnRvSlNPTikgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScgJiYgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCkge1xuICAgICAgICAgIHN0ZXAodmFsdWUsIGZsYXREYXRhUm93LCBuZXdQYXRoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJyYXlzICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgc3RlcCh2YWx1ZSwgZmxhdERhdGFSb3csIG5ld1BhdGgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsYXREYXRhUm93W25ld1BhdGhdID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmbGF0RGF0YVJvdztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGFSb3cpIHtcbiAgICAgIHJldHVybiBzdGVwKGRhdGFSb3csIHt9KTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGZsYXR0ZW5fMSA9IGZsYXR0ZW47XG5cbiAgdmFyIHNldFByb3AkMSA9IHV0aWxzLnNldFByb3AsXG4gICAgICB1bnNldFByb3AkMSA9IHV0aWxzLnVuc2V0UHJvcCxcbiAgICAgIGZsYXR0ZW5SZWR1Y2VyJDMgPSB1dGlscy5mbGF0dGVuUmVkdWNlcjtcblxuICBmdW5jdGlvbiBnZXRVbndpbmRhYmxlUGF0aHMob2JqLCBjdXJyZW50UGF0aCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbiAodW53aW5kYWJsZVBhdGhzLCBrZXkpIHtcbiAgICAgIHZhciBuZXdQYXRoID0gY3VycmVudFBhdGggPyBcIlwiLmNvbmNhdChjdXJyZW50UGF0aCwgXCIuXCIpLmNvbmNhdChrZXkpIDoga2V5O1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgIGlmIChfdHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZS50b0pTT04pICE9PSAnW29iamVjdCBGdW5jdGlvbl0nICYmIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgpIHtcbiAgICAgICAgdW53aW5kYWJsZVBhdGhzID0gdW53aW5kYWJsZVBhdGhzLmNvbmNhdChnZXRVbndpbmRhYmxlUGF0aHModmFsdWUsIG5ld1BhdGgpKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdW53aW5kYWJsZVBhdGhzLnB1c2gobmV3UGF0aCk7XG4gICAgICAgIHVud2luZGFibGVQYXRocyA9IHVud2luZGFibGVQYXRocy5jb25jYXQodmFsdWUubWFwKGZ1bmN0aW9uIChhcnJPYmopIHtcbiAgICAgICAgICByZXR1cm4gZ2V0VW53aW5kYWJsZVBhdGhzKGFyck9iaiwgbmV3UGF0aCk7XG4gICAgICAgIH0pLnJlZHVjZShmbGF0dGVuUmVkdWNlciQzLCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBpbmRleCwgYXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGFyci5pbmRleE9mKGl0ZW0pICE9PSBpbmRleDtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW53aW5kYWJsZVBhdGhzO1xuICAgIH0sIFtdKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgdGhlIHVud2luZCByZWN1cnNpdmVseSBpbiBzcGVjaWZpZWQgc2VxdWVuY2VcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0gdW53aW5kUGF0aHMgVGhlIHBhdGhzIGFzIHN0cmluZ3MgdG8gYmUgdXNlZCB0byBkZWNvbnN0cnVjdCB0aGUgYXJyYXlcbiAgICogQHJldHVybnMge09iamVjdCA9PiBBcnJheX0gQXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIGFsbCByb3dzIGFmdGVyIHVud2luZCBvZiBjaG9zZW4gcGF0aHNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIHVud2luZCgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIF9yZWYkcGF0aHMgPSBfcmVmLnBhdGhzLFxuICAgICAgICBwYXRocyA9IF9yZWYkcGF0aHMgPT09IHZvaWQgMCA/IHVuZGVmaW5lZCA6IF9yZWYkcGF0aHMsXG4gICAgICAgIF9yZWYkYmxhbmtPdXQgPSBfcmVmLmJsYW5rT3V0LFxuICAgICAgICBibGFua091dCA9IF9yZWYkYmxhbmtPdXQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRibGFua091dDtcblxuICAgIGZ1bmN0aW9uIHVud2luZFJlZHVjZXIocm93cywgdW53aW5kUGF0aCkge1xuICAgICAgcmV0dXJuIHJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIHVud2luZEFycmF5ID0gbG9kYXNoX2dldChyb3csIHVud2luZFBhdGgpO1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh1bndpbmRBcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1bndpbmRBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdW5zZXRQcm9wJDEocm93LCB1bndpbmRQYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1bndpbmRBcnJheS5tYXAoZnVuY3Rpb24gKHVud2luZFJvdywgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgY2xvbmVkUm93ID0gYmxhbmtPdXQgJiYgaW5kZXggPiAwID8ge30gOiByb3c7XG4gICAgICAgICAgcmV0dXJuIHNldFByb3AkMShjbG9uZWRSb3csIHVud2luZFBhdGgsIHVud2luZFJvdyk7XG4gICAgICAgIH0pO1xuICAgICAgfSkucmVkdWNlKGZsYXR0ZW5SZWR1Y2VyJDMsIFtdKTtcbiAgICB9XG5cbiAgICBwYXRocyA9IEFycmF5LmlzQXJyYXkocGF0aHMpID8gcGF0aHMgOiBwYXRocyA/IFtwYXRoc10gOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhUm93KSB7XG4gICAgICByZXR1cm4gKHBhdGhzIHx8IGdldFVud2luZGFibGVQYXRocyhkYXRhUm93KSkucmVkdWNlKHVud2luZFJlZHVjZXIsIFtkYXRhUm93XSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB1bndpbmRfMSA9IHVud2luZDtcblxuICB2YXIgUmVhZGFibGUkMSA9IFN0cmVhbS5SZWFkYWJsZTtcbiAgdmFyIFBhcnNlciQxID0gSlNPTjJDU1ZQYXJzZXJfMTtcbiAgdmFyIEFzeW5jUGFyc2VyID0gSlNPTjJDU1ZBc3luY1BhcnNlcl8xO1xuICB2YXIgVHJhbnNmb3JtJDMgPSBKU09OMkNTVlRyYW5zZm9ybV8xOyAvLyBDb252ZW5pZW5jZSBtZXRob2QgdG8ga2VlcCB0aGUgQVBJIHNpbWlsYXIgdG8gdmVyc2lvbiAzLlhcblxuICB2YXIgcGFyc2UgPSBmdW5jdGlvbiBwYXJzZShkYXRhLCBvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBKU09OMkNTVlBhcnNlcl8xKG9wdHMpLnBhcnNlKGRhdGEpO1xuICB9O1xuXG4gIHZhciBwYXJzZUFzeW5jID0gZnVuY3Rpb24gcGFyc2VBc3luYyhkYXRhLCBvcHRzLCB0cmFuc2Zvcm1PcHRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBSZWFkYWJsZSQxKSkge1xuICAgICAgICB0cmFuc2Zvcm1PcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNmb3JtT3B0cywge1xuICAgICAgICAgIG9iamVjdE1vZGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhc3luY1BhcnNlciA9IG5ldyBKU09OMkNTVkFzeW5jUGFyc2VyXzEob3B0cywgdHJhbnNmb3JtT3B0cyk7XG4gICAgICB2YXIgcHJvbWlzZSA9IGFzeW5jUGFyc2VyLnByb21pc2UoKTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGFzeW5jUGFyc2VyLmlucHV0LnB1c2goaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhc3luY1BhcnNlci5pbnB1dC5wdXNoKG51bGwpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgUmVhZGFibGUkMSkge1xuICAgICAgICBhc3luY1BhcnNlci5mcm9tSW5wdXQoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3luY1BhcnNlci5pbnB1dC5wdXNoKGRhdGEpO1xuICAgICAgICBhc3luY1BhcnNlci5pbnB1dC5wdXNoKG51bGwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdHJhbnNmb3JtcyA9IHtcbiAgICBmbGF0dGVuOiBmbGF0dGVuXzEsXG4gICAgdW53aW5kOiB1bndpbmRfMVxuICB9O1xuICB2YXIganNvbjJjc3YgPSB7XG4gICAgUGFyc2VyOiBQYXJzZXIkMSxcbiAgICBBc3luY1BhcnNlcjogQXN5bmNQYXJzZXIsXG4gICAgVHJhbnNmb3JtOiBUcmFuc2Zvcm0kMyxcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgcGFyc2VBc3luYzogcGFyc2VBc3luYyxcbiAgICB0cmFuc2Zvcm1zOiB0cmFuc2Zvcm1zXG4gIH07XG5cbiAgZXhwb3J0cy5Bc3luY1BhcnNlciA9IEFzeW5jUGFyc2VyO1xuICBleHBvcnRzLlBhcnNlciA9IFBhcnNlciQxO1xuICBleHBvcnRzLlRyYW5zZm9ybSA9IFRyYW5zZm9ybSQzO1xuICBleHBvcnRzLmRlZmF1bHQgPSBqc29uMmNzdjtcbiAgZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuICBleHBvcnRzLnBhcnNlQXN5bmMgPSBwYXJzZUFzeW5jO1xuICBleHBvcnRzLnRyYW5zZm9ybXMgPSB0cmFuc2Zvcm1zO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsICIvLyB0aGVzZSBhcmVuJ3QgcmVhbGx5IHByaXZhdGUsIGJ1dCBub3IgYXJlIHRoZXkgcmVhbGx5IHVzZWZ1bCB0byBkb2N1bWVudFxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEx1eG9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkRGF0ZVRpbWVFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihgSW52YWxpZCBEYXRlVGltZTogJHtyZWFzb24udG9NZXNzYWdlKCl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEludGVydmFsRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIoYEludmFsaWQgSW50ZXJ2YWw6ICR7cmVhc29uLnRvTWVzc2FnZSgpfWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWREdXJhdGlvbkVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKGBJbnZhbGlkIER1cmF0aW9uOiAke3JlYXNvbi50b01lc3NhZ2UoKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige31cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFVuaXRFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih1bml0KSB7XG4gICAgc3VwZXIoYEludmFsaWQgdW5pdCAke3VuaXR9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEFyZ3VtZW50RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHt9XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFpvbmVJc0Fic3RyYWN0RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJab25lIGlzIGFuIGFic3RyYWN0IGNsYXNzXCIpO1xuICB9XG59XG4iLCAiLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNvbnN0IG4gPSBcIm51bWVyaWNcIixcbiAgcyA9IFwic2hvcnRcIixcbiAgbCA9IFwibG9uZ1wiO1xuXG5leHBvcnQgY29uc3QgREFURV9TSE9SVCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IG4sXG4gIGRheTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX01FRCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX01FRF9XSVRIX1dFRUtEQVkgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9GVUxMID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfSFVHRSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1NJTVBMRSA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfV0lUSF9TRUNPTkRTID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfU0hPUlRfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfV0lUSF9MT05HX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1NJTVBMRSA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9XSVRIX1NFQ09ORFMgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX1NIT1JUID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbixcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbixcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9NRUQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBzLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfRlVMTCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfSFVHRSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuIiwgIi8qXG4gIFRoaXMgaXMganVzdCBhIGp1bmsgZHJhd2VyLCBjb250YWluaW5nIGFueXRoaW5nIHVzZWQgYWNyb3NzIG11bHRpcGxlIGNsYXNzZXMuXG4gIEJlY2F1c2UgTHV4b24gaXMgc21hbGwoaXNoKSwgdGhpcyBzaG91bGQgc3RheSBzbWFsbCBhbmQgd2Ugd29uJ3Qgd29ycnkgYWJvdXQgc3BsaXR0aW5nXG4gIGl0IHVwIGludG8sIHNheSwgcGFyc2luZ1V0aWwuanMgYW5kIGJhc2ljVXRpbC5qcyBhbmQgc28gb24uIEJ1dCB0aGV5IGFyZSBkaXZpZGVkIHVwIGJ5IGZlYXR1cmUgYXJlYS5cbiovXG5cbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuLy8gVFlQRVNcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcInVuZGVmaW5lZFwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVnZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCIgJiYgbyAlIDEgPT09IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyhvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZShvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBEYXRlXVwiO1xufVxuXG4vLyBDQVBBQklMSVRJRVNcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1JlbGF0aXZlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgSW50bCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhIUludGwuUmVsYXRpdmVUaW1lRm9ybWF0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIE9CSkVDVFMgQU5EIEFSUkFZU1xuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVBcnJheSh0aGluZykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGluZykgPyB0aGluZyA6IFt0aGluZ107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiZXN0QnkoYXJyLCBieSwgY29tcGFyZSkge1xuICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGFyci5yZWR1Y2UoKGJlc3QsIG5leHQpID0+IHtcbiAgICBjb25zdCBwYWlyID0gW2J5KG5leHQpLCBuZXh0XTtcbiAgICBpZiAoIWJlc3QpIHtcbiAgICAgIHJldHVybiBwYWlyO1xuICAgIH0gZWxzZSBpZiAoY29tcGFyZShiZXN0WzBdLCBwYWlyWzBdKSA9PT0gYmVzdFswXSkge1xuICAgICAgcmV0dXJuIGJlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYWlyO1xuICAgIH1cbiAgfSwgbnVsbClbMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaWNrKG9iaiwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoKGEsIGspID0+IHtcbiAgICBhW2tdID0gb2JqW2tdO1xuICAgIHJldHVybiBhO1xuICB9LCB7fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG4vLyBOVU1CRVJTIEFORCBTVFJJTkdTXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlZ2VyQmV0d2Vlbih0aGluZywgYm90dG9tLCB0b3ApIHtcbiAgcmV0dXJuIGlzSW50ZWdlcih0aGluZykgJiYgdGhpbmcgPj0gYm90dG9tICYmIHRoaW5nIDw9IHRvcDtcbn1cblxuLy8geCAlIG4gYnV0IHRha2VzIHRoZSBzaWduIG9mIG4gaW5zdGVhZCBvZiB4XG5leHBvcnQgZnVuY3Rpb24gZmxvb3JNb2QoeCwgbikge1xuICByZXR1cm4geCAtIG4gKiBNYXRoLmZsb29yKHggLyBuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZFN0YXJ0KGlucHV0LCBuID0gMikge1xuICBjb25zdCBpc05lZyA9IGlucHV0IDwgMDtcbiAgbGV0IHBhZGRlZDtcbiAgaWYgKGlzTmVnKSB7XG4gICAgcGFkZGVkID0gXCItXCIgKyAoXCJcIiArIC1pbnB1dCkucGFkU3RhcnQobiwgXCIwXCIpO1xuICB9IGVsc2Uge1xuICAgIHBhZGRlZCA9IChcIlwiICsgaW5wdXQpLnBhZFN0YXJ0KG4sIFwiMFwiKTtcbiAgfVxuICByZXR1cm4gcGFkZGVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbnRlZ2VyKHN0cmluZykge1xuICBpZiAoaXNVbmRlZmluZWQoc3RyaW5nKSB8fCBzdHJpbmcgPT09IG51bGwgfHwgc3RyaW5nID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nLCAxMCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmxvYXRpbmcoc3RyaW5nKSB7XG4gIGlmIChpc1VuZGVmaW5lZChzdHJpbmcpIHx8IHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cmluZyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWlsbGlzKGZyYWN0aW9uKSB7XG4gIC8vIFJldHVybiB1bmRlZmluZWQgKGluc3RlYWQgb2YgMCkgaW4gdGhlc2UgY2FzZXMsIHdoZXJlIGZyYWN0aW9uIGlzIG5vdCBzZXRcbiAgaWYgKGlzVW5kZWZpbmVkKGZyYWN0aW9uKSB8fCBmcmFjdGlvbiA9PT0gbnVsbCB8fCBmcmFjdGlvbiA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZiA9IHBhcnNlRmxvYXQoXCIwLlwiICsgZnJhY3Rpb24pICogMTAwMDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihmKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcm91bmRUbyhudW1iZXIsIGRpZ2l0cywgdG93YXJkWmVybyA9IGZhbHNlKSB7XG4gIGNvbnN0IGZhY3RvciA9IDEwICoqIGRpZ2l0cyxcbiAgICByb3VuZGVyID0gdG93YXJkWmVybyA/IE1hdGgudHJ1bmMgOiBNYXRoLnJvdW5kO1xuICByZXR1cm4gcm91bmRlcihudW1iZXIgKiBmYWN0b3IpIC8gZmFjdG9yO1xufVxuXG4vLyBEQVRFIEJBU0lDU1xuXG5leHBvcnQgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gIGNvbnN0IG1vZE1vbnRoID0gZmxvb3JNb2QobW9udGggLSAxLCAxMikgKyAxLFxuICAgIG1vZFllYXIgPSB5ZWFyICsgKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG5cbiAgaWYgKG1vZE1vbnRoID09PSAyKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIobW9kWWVhcikgPyAyOSA6IDI4O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbMzEsIG51bGwsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVttb2RNb250aCAtIDFdO1xuICB9XG59XG5cbi8vIGNvdmVydCBhIGNhbGVuZGFyIG9iamVjdCB0byBhIGxvY2FsIHRpbWVzdGFtcCAoZXBvY2gsIGJ1dCB3aXRoIHRoZSBvZmZzZXQgYmFrZWQgaW4pXG5leHBvcnQgZnVuY3Rpb24gb2JqVG9Mb2NhbFRTKG9iaikge1xuICBsZXQgZCA9IERhdGUuVVRDKFxuICAgIG9iai55ZWFyLFxuICAgIG9iai5tb250aCAtIDEsXG4gICAgb2JqLmRheSxcbiAgICBvYmouaG91cixcbiAgICBvYmoubWludXRlLFxuICAgIG9iai5zZWNvbmQsXG4gICAgb2JqLm1pbGxpc2Vjb25kXG4gICk7XG5cbiAgLy8gZm9yIGxlZ2FjeSByZWFzb25zLCB5ZWFycyBiZXR3ZWVuIDAgYW5kIDk5IGFyZSBpbnRlcnByZXRlZCBhcyAxOVhYOyByZXZlcnQgdGhhdFxuICBpZiAob2JqLnllYXIgPCAxMDAgJiYgb2JqLnllYXIgPj0gMCkge1xuICAgIGQgPSBuZXcgRGF0ZShkKTtcbiAgICBkLnNldFVUQ0Z1bGxZZWFyKGQuZ2V0VVRDRnVsbFllYXIoKSAtIDE5MDApO1xuICB9XG4gIHJldHVybiArZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtzSW5XZWVrWWVhcih3ZWVrWWVhcikge1xuICBjb25zdCBwMSA9XG4gICAgICAod2Vla1llYXIgK1xuICAgICAgICBNYXRoLmZsb29yKHdlZWtZZWFyIC8gNCkgLVxuICAgICAgICBNYXRoLmZsb29yKHdlZWtZZWFyIC8gMTAwKSArXG4gICAgICAgIE1hdGguZmxvb3Iod2Vla1llYXIgLyA0MDApKSAlXG4gICAgICA3LFxuICAgIGxhc3QgPSB3ZWVrWWVhciAtIDEsXG4gICAgcDIgPSAobGFzdCArIE1hdGguZmxvb3IobGFzdCAvIDQpIC0gTWF0aC5mbG9vcihsYXN0IC8gMTAwKSArIE1hdGguZmxvb3IobGFzdCAvIDQwMCkpICUgNztcbiAgcmV0dXJuIHAxID09PSA0IHx8IHAyID09PSAzID8gNTMgOiA1Mjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXIpIHtcbiAgaWYgKHllYXIgPiA5OSkge1xuICAgIHJldHVybiB5ZWFyO1xuICB9IGVsc2UgcmV0dXJuIHllYXIgPiA2MCA/IDE5MDAgKyB5ZWFyIDogMjAwMCArIHllYXI7XG59XG5cbi8vIFBBUlNJTkdcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlWm9uZUluZm8odHMsIG9mZnNldEZvcm1hdCwgbG9jYWxlLCB0aW1lWm9uZSA9IG51bGwpIHtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRzKSxcbiAgICBpbnRsT3B0cyA9IHtcbiAgICAgIGhvdXJDeWNsZTogXCJoMjNcIixcbiAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICB9O1xuXG4gIGlmICh0aW1lWm9uZSkge1xuICAgIGludGxPcHRzLnRpbWVab25lID0gdGltZVpvbmU7XG4gIH1cblxuICBjb25zdCBtb2RpZmllZCA9IHsgdGltZVpvbmVOYW1lOiBvZmZzZXRGb3JtYXQsIC4uLmludGxPcHRzIH07XG5cbiAgY29uc3QgcGFyc2VkID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBtb2RpZmllZClcbiAgICAuZm9ybWF0VG9QYXJ0cyhkYXRlKVxuICAgIC5maW5kKChtKSA9PiBtLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0aW1lem9uZW5hbWVcIik7XG4gIHJldHVybiBwYXJzZWQgPyBwYXJzZWQudmFsdWUgOiBudWxsO1xufVxuXG4vLyBzaWduZWRPZmZzZXQoJy01JywgJzMwJykgLT4gLTMzMFxuZXhwb3J0IGZ1bmN0aW9uIHNpZ25lZE9mZnNldChvZmZIb3VyU3RyLCBvZmZNaW51dGVTdHIpIHtcbiAgbGV0IG9mZkhvdXIgPSBwYXJzZUludChvZmZIb3VyU3RyLCAxMCk7XG5cbiAgLy8gZG9uJ3QgfHwgdGhpcyBiZWNhdXNlIHdlIHdhbnQgdG8gcHJlc2VydmUgLTBcbiAgaWYgKE51bWJlci5pc05hTihvZmZIb3VyKSkge1xuICAgIG9mZkhvdXIgPSAwO1xuICB9XG5cbiAgY29uc3Qgb2ZmTWluID0gcGFyc2VJbnQob2ZmTWludXRlU3RyLCAxMCkgfHwgMCxcbiAgICBvZmZNaW5TaWduZWQgPSBvZmZIb3VyIDwgMCB8fCBPYmplY3QuaXMob2ZmSG91ciwgLTApID8gLW9mZk1pbiA6IG9mZk1pbjtcbiAgcmV0dXJuIG9mZkhvdXIgKiA2MCArIG9mZk1pblNpZ25lZDtcbn1cblxuLy8gQ09FUkNJT05cblxuZXhwb3J0IGZ1bmN0aW9uIGFzTnVtYmVyKHZhbHVlKSB7XG4gIGNvbnN0IG51bWVyaWNWYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHZhbHVlID09PSBcIlwiIHx8IE51bWJlci5pc05hTihudW1lcmljVmFsdWUpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgSW52YWxpZCB1bml0IHZhbHVlICR7dmFsdWV9YCk7XG4gIHJldHVybiBudW1lcmljVmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVPYmplY3Qob2JqLCBub3JtYWxpemVyKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgZm9yIChjb25zdCB1IGluIG9iaikge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIHUpKSB7XG4gICAgICBjb25zdCB2ID0gb2JqW3VdO1xuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplcih1KV0gPSBhc051bWJlcih2KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRPZmZzZXQob2Zmc2V0LCBmb3JtYXQpIHtcbiAgY29uc3QgaG91cnMgPSBNYXRoLnRydW5jKE1hdGguYWJzKG9mZnNldCAvIDYwKSksXG4gICAgbWludXRlcyA9IE1hdGgudHJ1bmMoTWF0aC5hYnMob2Zmc2V0ICUgNjApKSxcbiAgICBzaWduID0gb2Zmc2V0ID49IDAgPyBcIitcIiA6IFwiLVwiO1xuXG4gIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gYCR7c2lnbn0ke3BhZFN0YXJ0KGhvdXJzLCAyKX06JHtwYWRTdGFydChtaW51dGVzLCAyKX1gO1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBgJHtzaWdufSR7aG91cnN9JHttaW51dGVzID4gMCA/IGA6JHttaW51dGVzfWAgOiBcIlwifWA7XG4gICAgY2FzZSBcInRlY2hpZVwiOlxuICAgICAgcmV0dXJuIGAke3NpZ259JHtwYWRTdGFydChob3VycywgMil9JHtwYWRTdGFydChtaW51dGVzLCAyKX1gO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVmFsdWUgZm9ybWF0ICR7Zm9ybWF0fSBpcyBvdXQgb2YgcmFuZ2UgZm9yIHByb3BlcnR5IGZvcm1hdGApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lT2JqZWN0KG9iaikge1xuICByZXR1cm4gcGljayhvYmosIFtcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXSk7XG59XG5cbmV4cG9ydCBjb25zdCBpYW5hUmVnZXggPSAvW0EtWmEtel8rLV17MSwyNTZ9KDo/XFwvW0EtWmEtejAtOV8rLV17MSwyNTZ9KFxcL1tBLVphLXowLTlfKy1dezEsMjU2fSk/KT8vO1xuIiwgImltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHsgcGljayB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBPYmplY3Qua2V5cyhvYmopLnNvcnQoKSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgY29uc3QgbW9udGhzTG9uZyA9IFtcbiAgXCJKYW51YXJ5XCIsXG4gIFwiRmVicnVhcnlcIixcbiAgXCJNYXJjaFwiLFxuICBcIkFwcmlsXCIsXG4gIFwiTWF5XCIsXG4gIFwiSnVuZVwiLFxuICBcIkp1bHlcIixcbiAgXCJBdWd1c3RcIixcbiAgXCJTZXB0ZW1iZXJcIixcbiAgXCJPY3RvYmVyXCIsXG4gIFwiTm92ZW1iZXJcIixcbiAgXCJEZWNlbWJlclwiLFxuXTtcblxuZXhwb3J0IGNvbnN0IG1vbnRoc1Nob3J0ID0gW1xuICBcIkphblwiLFxuICBcIkZlYlwiLFxuICBcIk1hclwiLFxuICBcIkFwclwiLFxuICBcIk1heVwiLFxuICBcIkp1blwiLFxuICBcIkp1bFwiLFxuICBcIkF1Z1wiLFxuICBcIlNlcFwiLFxuICBcIk9jdFwiLFxuICBcIk5vdlwiLFxuICBcIkRlY1wiLFxuXTtcblxuZXhwb3J0IGNvbnN0IG1vbnRoc05hcnJvdyA9IFtcIkpcIiwgXCJGXCIsIFwiTVwiLCBcIkFcIiwgXCJNXCIsIFwiSlwiLCBcIkpcIiwgXCJBXCIsIFwiU1wiLCBcIk9cIiwgXCJOXCIsIFwiRFwiXTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1vbnRocyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLm1vbnRoc05hcnJvd107XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gWy4uLm1vbnRoc1Nob3J0XTtcbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNMb25nXTtcbiAgICBjYXNlIFwibnVtZXJpY1wiOlxuICAgICAgcmV0dXJuIFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiLCBcIjEwXCIsIFwiMTFcIiwgXCIxMlwiXTtcbiAgICBjYXNlIFwiMi1kaWdpdFwiOlxuICAgICAgcmV0dXJuIFtcIjAxXCIsIFwiMDJcIiwgXCIwM1wiLCBcIjA0XCIsIFwiMDVcIiwgXCIwNlwiLCBcIjA3XCIsIFwiMDhcIiwgXCIwOVwiLCBcIjEwXCIsIFwiMTFcIiwgXCIxMlwiXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHdlZWtkYXlzTG9uZyA9IFtcbiAgXCJNb25kYXlcIixcbiAgXCJUdWVzZGF5XCIsXG4gIFwiV2VkbmVzZGF5XCIsXG4gIFwiVGh1cnNkYXlcIixcbiAgXCJGcmlkYXlcIixcbiAgXCJTYXR1cmRheVwiLFxuICBcIlN1bmRheVwiLFxuXTtcblxuZXhwb3J0IGNvbnN0IHdlZWtkYXlzU2hvcnQgPSBbXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiwgXCJTdW5cIl07XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c05hcnJvdyA9IFtcIk1cIiwgXCJUXCIsIFwiV1wiLCBcIlRcIiwgXCJGXCIsIFwiU1wiLCBcIlNcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrZGF5cyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLndlZWtkYXlzTmFycm93XTtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNTaG9ydF07XG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNMb25nXTtcbiAgICBjYXNlIFwibnVtZXJpY1wiOlxuICAgICAgcmV0dXJuIFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIl07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBtZXJpZGllbXMgPSBbXCJBTVwiLCBcIlBNXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc0xvbmcgPSBbXCJCZWZvcmUgQ2hyaXN0XCIsIFwiQW5ubyBEb21pbmlcIl07XG5cbmV4cG9ydCBjb25zdCBlcmFzU2hvcnQgPSBbXCJCQ1wiLCBcIkFEXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc05hcnJvdyA9IFtcIkJcIiwgXCJBXCJdO1xuXG5leHBvcnQgZnVuY3Rpb24gZXJhcyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNOYXJyb3ddO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFsuLi5lcmFzU2hvcnRdO1xuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNMb25nXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmlkaWVtRm9yRGF0ZVRpbWUoZHQpIHtcbiAgcmV0dXJuIG1lcmlkaWVtc1tkdC5ob3VyIDwgMTIgPyAwIDogMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrZGF5Rm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gd2Vla2RheXMobGVuZ3RoKVtkdC53ZWVrZGF5IC0gMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb250aEZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG1vbnRocyhsZW5ndGgpW2R0Lm1vbnRoIC0gMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcmFGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiBlcmFzKGxlbmd0aClbZHQueWVhciA8IDAgPyAwIDogMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRSZWxhdGl2ZVRpbWUodW5pdCwgY291bnQsIG51bWVyaWMgPSBcImFsd2F5c1wiLCBuYXJyb3cgPSBmYWxzZSkge1xuICBjb25zdCB1bml0cyA9IHtcbiAgICB5ZWFyczogW1wieWVhclwiLCBcInlyLlwiXSxcbiAgICBxdWFydGVyczogW1wicXVhcnRlclwiLCBcInF0ci5cIl0sXG4gICAgbW9udGhzOiBbXCJtb250aFwiLCBcIm1vLlwiXSxcbiAgICB3ZWVrczogW1wid2Vla1wiLCBcIndrLlwiXSxcbiAgICBkYXlzOiBbXCJkYXlcIiwgXCJkYXlcIiwgXCJkYXlzXCJdLFxuICAgIGhvdXJzOiBbXCJob3VyXCIsIFwiaHIuXCJdLFxuICAgIG1pbnV0ZXM6IFtcIm1pbnV0ZVwiLCBcIm1pbi5cIl0sXG4gICAgc2Vjb25kczogW1wic2Vjb25kXCIsIFwic2VjLlwiXSxcbiAgfTtcblxuICBjb25zdCBsYXN0YWJsZSA9IFtcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIl0uaW5kZXhPZih1bml0KSA9PT0gLTE7XG5cbiAgaWYgKG51bWVyaWMgPT09IFwiYXV0b1wiICYmIGxhc3RhYmxlKSB7XG4gICAgY29uc3QgaXNEYXkgPSB1bml0ID09PSBcImRheXNcIjtcbiAgICBzd2l0Y2ggKGNvdW50KSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwidG9tb3Jyb3dcIiA6IGBuZXh0ICR7dW5pdHNbdW5pdF1bMF19YDtcbiAgICAgIGNhc2UgLTE6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwieWVzdGVyZGF5XCIgOiBgbGFzdCAke3VuaXRzW3VuaXRdWzBdfWA7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwidG9kYXlcIiA6IGB0aGlzICR7dW5pdHNbdW5pdF1bMF19YDtcbiAgICAgIGRlZmF1bHQ6IC8vIGZhbGwgdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGlzSW5QYXN0ID0gT2JqZWN0LmlzKGNvdW50LCAtMCkgfHwgY291bnQgPCAwLFxuICAgIGZtdFZhbHVlID0gTWF0aC5hYnMoY291bnQpLFxuICAgIHNpbmd1bGFyID0gZm10VmFsdWUgPT09IDEsXG4gICAgbGlsVW5pdHMgPSB1bml0c1t1bml0XSxcbiAgICBmbXRVbml0ID0gbmFycm93XG4gICAgICA/IHNpbmd1bGFyXG4gICAgICAgID8gbGlsVW5pdHNbMV1cbiAgICAgICAgOiBsaWxVbml0c1syXSB8fCBsaWxVbml0c1sxXVxuICAgICAgOiBzaW5ndWxhclxuICAgICAgPyB1bml0c1t1bml0XVswXVxuICAgICAgOiB1bml0O1xuICByZXR1cm4gaXNJblBhc3QgPyBgJHtmbXRWYWx1ZX0gJHtmbXRVbml0fSBhZ29gIDogYGluICR7Zm10VmFsdWV9ICR7Zm10VW5pdH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0U3RyaW5nKGtub3duRm9ybWF0KSB7XG4gIC8vIHRoZXNlIGFsbCBoYXZlIHRoZSBvZmZzZXRzIHJlbW92ZWQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGFjY2VzcyB0byB0aGVtXG4gIC8vIHdpdGhvdXQgYWxsIHRoZSBpbnRsIHN0dWZmIHRoaXMgaXMgYmFja2ZpbGxpbmdcbiAgY29uc3QgZmlsdGVyZWQgPSBwaWNrKGtub3duRm9ybWF0LCBbXG4gICAgICBcIndlZWtkYXlcIixcbiAgICAgIFwiZXJhXCIsXG4gICAgICBcInllYXJcIixcbiAgICAgIFwibW9udGhcIixcbiAgICAgIFwiZGF5XCIsXG4gICAgICBcImhvdXJcIixcbiAgICAgIFwibWludXRlXCIsXG4gICAgICBcInNlY29uZFwiLFxuICAgICAgXCJ0aW1lWm9uZU5hbWVcIixcbiAgICAgIFwiaG91ckN5Y2xlXCIsXG4gICAgXSksXG4gICAga2V5ID0gc3RyaW5naWZ5KGZpbHRlcmVkKSxcbiAgICBkYXRlVGltZUh1Z2UgPSBcIkVFRUUsIExMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX1NIT1JUKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX01FRCk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9NRURfV0lUSF9XRUVLREFZKTpcbiAgICAgIHJldHVybiBcIkVFRSwgTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfRlVMTCk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfSFVHRSk6XG4gICAgICByZXR1cm4gXCJFRUVFLCBMTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfU0lNUExFKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9TSU1QTEUpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkhIOm1tOnNzXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX1NIT1JUKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX01FRCk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9GVUxMKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9IVUdFKTpcbiAgICAgIHJldHVybiBkYXRlVGltZUh1Z2U7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXksIGg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9XRUVLREFZKTpcbiAgICAgIHJldHVybiBcIkVFRSwgZCBMTEwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiRUVFRSwgTExMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRhdGVUaW1lSHVnZTtcbiAgfVxufVxuIiwgImltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9mb3JtYXRzLmpzXCI7XG5pbXBvcnQgeyBwYWRTdGFydCB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZnVuY3Rpb24gc3RyaW5naWZ5VG9rZW5zKHNwbGl0cywgdG9rZW5Ub1N0cmluZykge1xuICBsZXQgcyA9IFwiXCI7XG4gIGZvciAoY29uc3QgdG9rZW4gb2Ygc3BsaXRzKSB7XG4gICAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICAgIHMgKz0gdG9rZW4udmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzICs9IHRva2VuVG9TdHJpbmcodG9rZW4udmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbmNvbnN0IG1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHMgPSB7XG4gIEQ6IEZvcm1hdHMuREFURV9TSE9SVCxcbiAgREQ6IEZvcm1hdHMuREFURV9NRUQsXG4gIERERDogRm9ybWF0cy5EQVRFX0ZVTEwsXG4gIEREREQ6IEZvcm1hdHMuREFURV9IVUdFLFxuICB0OiBGb3JtYXRzLlRJTUVfU0lNUExFLFxuICB0dDogRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUyxcbiAgdHR0OiBGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQsXG4gIHR0dHQ6IEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VULFxuICBUOiBGb3JtYXRzLlRJTUVfMjRfU0lNUExFLFxuICBUVDogRm9ybWF0cy5USU1FXzI0X1dJVEhfU0VDT05EUyxcbiAgVFRUOiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQsXG4gIFRUVFQ6IEZvcm1hdHMuVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VULFxuICBmOiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JULFxuICBmZjogRm9ybWF0cy5EQVRFVElNRV9NRUQsXG4gIGZmZjogRm9ybWF0cy5EQVRFVElNRV9GVUxMLFxuICBmZmZmOiBGb3JtYXRzLkRBVEVUSU1FX0hVR0UsXG4gIEY6IEZvcm1hdHMuREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTLFxuICBGRjogRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTLFxuICBGRkY6IEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMsXG4gIEZGRkY6IEZvcm1hdHMuREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMsXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9ybWF0dGVyIHtcbiAgc3RhdGljIGNyZWF0ZShsb2NhbGUsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgRm9ybWF0dGVyKGxvY2FsZSwgb3B0cyk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VGb3JtYXQoZm10KSB7XG4gICAgbGV0IGN1cnJlbnQgPSBudWxsLFxuICAgICAgY3VycmVudEZ1bGwgPSBcIlwiLFxuICAgICAgYnJhY2tldGVkID0gZmFsc2U7XG4gICAgY29uc3Qgc3BsaXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBmbXQuY2hhckF0KGkpO1xuICAgICAgaWYgKGMgPT09IFwiJ1wiKSB7XG4gICAgICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3BsaXRzLnB1c2goeyBsaXRlcmFsOiBicmFja2V0ZWQsIHZhbDogY3VycmVudEZ1bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRGdWxsID0gXCJcIjtcbiAgICAgICAgYnJhY2tldGVkID0gIWJyYWNrZXRlZDtcbiAgICAgIH0gZWxzZSBpZiAoYnJhY2tldGVkKSB7XG4gICAgICAgIGN1cnJlbnRGdWxsICs9IGM7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgY3VycmVudEZ1bGwgKz0gYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3BsaXRzLnB1c2goeyBsaXRlcmFsOiBmYWxzZSwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50RnVsbCA9IGM7XG4gICAgICAgIGN1cnJlbnQgPSBjO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICBzcGxpdHMucHVzaCh7IGxpdGVyYWw6IGJyYWNrZXRlZCwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3BsaXRzO1xuICB9XG5cbiAgc3RhdGljIG1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHModG9rZW4pIHtcbiAgICByZXR1cm4gbWFjcm9Ub2tlblRvRm9ybWF0T3B0c1t0b2tlbl07XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihsb2NhbGUsIGZvcm1hdE9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSBmb3JtYXRPcHRzO1xuICAgIHRoaXMubG9jID0gbG9jYWxlO1xuICAgIHRoaXMuc3lzdGVtTG9jID0gbnVsbDtcbiAgfVxuXG4gIGZvcm1hdFdpdGhTeXN0ZW1EZWZhdWx0KGR0LCBvcHRzKSB7XG4gICAgaWYgKHRoaXMuc3lzdGVtTG9jID09PSBudWxsKSB7XG4gICAgICB0aGlzLnN5c3RlbUxvYyA9IHRoaXMubG9jLnJlZGVmYXVsdFRvU3lzdGVtKCk7XG4gICAgfVxuICAgIGNvbnN0IGRmID0gdGhpcy5zeXN0ZW1Mb2MuZHRGb3JtYXR0ZXIoZHQsIHsgLi4udGhpcy5vcHRzLCAuLi5vcHRzIH0pO1xuICAgIHJldHVybiBkZi5mb3JtYXQoKTtcbiAgfVxuXG4gIGZvcm1hdERhdGVUaW1lKGR0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBkZiA9IHRoaXMubG9jLmR0Rm9ybWF0dGVyKGR0LCB7IC4uLnRoaXMub3B0cywgLi4ub3B0cyB9KTtcbiAgICByZXR1cm4gZGYuZm9ybWF0KCk7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZVBhcnRzKGR0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBkZiA9IHRoaXMubG9jLmR0Rm9ybWF0dGVyKGR0LCB7IC4uLnRoaXMub3B0cywgLi4ub3B0cyB9KTtcbiAgICByZXR1cm4gZGYuZm9ybWF0VG9QYXJ0cygpO1xuICB9XG5cbiAgcmVzb2x2ZWRPcHRpb25zKGR0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBkZiA9IHRoaXMubG9jLmR0Rm9ybWF0dGVyKGR0LCB7IC4uLnRoaXMub3B0cywgLi4ub3B0cyB9KTtcbiAgICByZXR1cm4gZGYucmVzb2x2ZWRPcHRpb25zKCk7XG4gIH1cblxuICBudW0obiwgcCA9IDApIHtcbiAgICAvLyB3ZSBnZXQgc29tZSBwZXJmIG91dCBvZiBkb2luZyB0aGlzIGhlcmUsIGFubm95aW5nbHlcbiAgICBpZiAodGhpcy5vcHRzLmZvcmNlU2ltcGxlKSB7XG4gICAgICByZXR1cm4gcGFkU3RhcnQobiwgcCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0cyA9IHsgLi4udGhpcy5vcHRzIH07XG5cbiAgICBpZiAocCA+IDApIHtcbiAgICAgIG9wdHMucGFkVG8gPSBwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxvYy5udW1iZXJGb3JtYXR0ZXIob3B0cykuZm9ybWF0KG4pO1xuICB9XG5cbiAgZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKGR0LCBmbXQpIHtcbiAgICBjb25zdCBrbm93bkVuZ2xpc2ggPSB0aGlzLmxvYy5saXN0aW5nTW9kZSgpID09PSBcImVuXCIsXG4gICAgICB1c2VEYXRlVGltZUZvcm1hdHRlciA9IHRoaXMubG9jLm91dHB1dENhbGVuZGFyICYmIHRoaXMubG9jLm91dHB1dENhbGVuZGFyICE9PSBcImdyZWdvcnlcIixcbiAgICAgIHN0cmluZyA9IChvcHRzLCBleHRyYWN0KSA9PiB0aGlzLmxvYy5leHRyYWN0KGR0LCBvcHRzLCBleHRyYWN0KSxcbiAgICAgIGZvcm1hdE9mZnNldCA9IChvcHRzKSA9PiB7XG4gICAgICAgIGlmIChkdC5pc09mZnNldEZpeGVkICYmIGR0Lm9mZnNldCA9PT0gMCAmJiBvcHRzLmFsbG93Wikge1xuICAgICAgICAgIHJldHVybiBcIlpcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkdC5pc1ZhbGlkID8gZHQuem9uZS5mb3JtYXRPZmZzZXQoZHQudHMsIG9wdHMuZm9ybWF0KSA6IFwiXCI7XG4gICAgICB9LFxuICAgICAgbWVyaWRpZW0gPSAoKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2hcbiAgICAgICAgICA/IEVuZ2xpc2gubWVyaWRpZW1Gb3JEYXRlVGltZShkdClcbiAgICAgICAgICA6IHN0cmluZyh7IGhvdXI6IFwibnVtZXJpY1wiLCBob3VyQ3ljbGU6IFwiaDEyXCIgfSwgXCJkYXlwZXJpb2RcIiksXG4gICAgICBtb250aCA9IChsZW5ndGgsIHN0YW5kYWxvbmUpID0+XG4gICAgICAgIGtub3duRW5nbGlzaFxuICAgICAgICAgID8gRW5nbGlzaC5tb250aEZvckRhdGVUaW1lKGR0LCBsZW5ndGgpXG4gICAgICAgICAgOiBzdHJpbmcoc3RhbmRhbG9uZSA/IHsgbW9udGg6IGxlbmd0aCB9IDogeyBtb250aDogbGVuZ3RoLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIiksXG4gICAgICB3ZWVrZGF5ID0gKGxlbmd0aCwgc3RhbmRhbG9uZSkgPT5cbiAgICAgICAga25vd25FbmdsaXNoXG4gICAgICAgICAgPyBFbmdsaXNoLndlZWtkYXlGb3JEYXRlVGltZShkdCwgbGVuZ3RoKVxuICAgICAgICAgIDogc3RyaW5nKFxuICAgICAgICAgICAgICBzdGFuZGFsb25lID8geyB3ZWVrZGF5OiBsZW5ndGggfSA6IHsgd2Vla2RheTogbGVuZ3RoLCBtb250aDogXCJsb25nXCIsIGRheTogXCJudW1lcmljXCIgfSxcbiAgICAgICAgICAgICAgXCJ3ZWVrZGF5XCJcbiAgICAgICAgICAgICksXG4gICAgICBtYXliZU1hY3JvID0gKHRva2VuKSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdE9wdHMgPSBGb3JtYXR0ZXIubWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbik7XG4gICAgICAgIGlmIChmb3JtYXRPcHRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0V2l0aFN5c3RlbURlZmF1bHQoZHQsIGZvcm1hdE9wdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVyYSA9IChsZW5ndGgpID0+XG4gICAgICAgIGtub3duRW5nbGlzaCA/IEVuZ2xpc2guZXJhRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkgOiBzdHJpbmcoeyBlcmE6IGxlbmd0aCB9LCBcImVyYVwiKSxcbiAgICAgIHRva2VuVG9TdHJpbmcgPSAodG9rZW4pID0+IHtcbiAgICAgICAgLy8gV2hlcmUgcG9zc2libGU6IGh0dHA6Ly9jbGRyLnVuaWNvZGUub3JnL3RyYW5zbGF0aW9uL2RhdGUtdGltZS0xL2RhdGUtdGltZSNUT0MtU3RhbmRhbG9uZS12cy4tRm9ybWF0LVN0eWxlc1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgLy8gbXNcbiAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbGxpc2Vjb25kKTtcbiAgICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICBjYXNlIFwiU1NTXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWlsbGlzZWNvbmQsIDMpO1xuICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LnNlY29uZCk7XG4gICAgICAgICAgY2FzZSBcInNzXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuc2Vjb25kLCAyKTtcbiAgICAgICAgICAvLyBmcmFjdGlvbmFsIHNlY29uZHNcbiAgICAgICAgICBjYXNlIFwidXVcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0Lm1pbGxpc2Vjb25kIC8gMTApLCAyKTtcbiAgICAgICAgICBjYXNlIFwidXV1XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oTWF0aC5mbG9vcihkdC5taWxsaXNlY29uZCAvIDEwMCkpO1xuICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbnV0ZSk7XG4gICAgICAgICAgY2FzZSBcIm1tXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWludXRlLCAyKTtcbiAgICAgICAgICAvLyBob3Vyc1xuICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91ciAlIDEyID09PSAwID8gMTIgOiBkdC5ob3VyICUgMTIpO1xuICAgICAgICAgIGNhc2UgXCJoaFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIgJSAxMiA9PT0gMCA/IDEyIDogZHQuaG91ciAlIDEyLCAyKTtcbiAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIpO1xuICAgICAgICAgIGNhc2UgXCJISFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIsIDIpO1xuICAgICAgICAgIC8vIG9mZnNldFxuICAgICAgICAgIGNhc2UgXCJaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICs2XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHsgZm9ybWF0OiBcIm5hcnJvd1wiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICswNjowMFxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJzaG9ydFwiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSArMDYwMFxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJ0ZWNoaWVcIiwgYWxsb3daOiB0aGlzLm9wdHMuYWxsb3daIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEVTVFxuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmUub2Zmc2V0TmFtZShkdC50cywgeyBmb3JtYXQ6IFwic2hvcnRcIiwgbG9jYWxlOiB0aGlzLmxvYy5sb2NhbGUgfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEVhc3Rlcm4gU3RhbmRhcmQgVGltZVxuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmUub2Zmc2V0TmFtZShkdC50cywgeyBmb3JtYXQ6IFwibG9uZ1wiLCBsb2NhbGU6IHRoaXMubG9jLmxvY2FsZSB9KTtcbiAgICAgICAgICAvLyB6b25lXG4gICAgICAgICAgY2FzZSBcInpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQW1lcmljYS9OZXdfWW9ya1xuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmVOYW1lO1xuICAgICAgICAgIC8vIG1lcmlkaWVtc1xuICAgICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgICByZXR1cm4gbWVyaWRpZW0oKTtcbiAgICAgICAgICAvLyBkYXRlc1xuICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyBkYXk6IFwibnVtZXJpY1wiIH0sIFwiZGF5XCIpIDogdGhpcy5udW0oZHQuZGF5KTtcbiAgICAgICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7IGRheTogXCIyLWRpZ2l0XCIgfSwgXCJkYXlcIikgOiB0aGlzLm51bShkdC5kYXksIDIpO1xuICAgICAgICAgIC8vIHdlZWtkYXlzIC0gc3RhbmRhbG9uZVxuICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrZGF5KTtcbiAgICAgICAgICBjYXNlIFwiY2NjXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJzaG9ydFwiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiY2NjY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlc2RheSdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibG9uZ1wiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiY2NjY2NcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1QnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcIm5hcnJvd1wiLCB0cnVlKTtcbiAgICAgICAgICAvLyB3ZWVrZGF5cyAtIGZvcm1hdFxuICAgICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrZGF5KTtcbiAgICAgICAgICBjYXNlIFwiRUVFXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJzaG9ydFwiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIkVFRUVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXNkYXknXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcImxvbmdcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJFRUVFRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVCdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibmFycm93XCIsIGZhbHNlKTtcbiAgICAgICAgICAvLyBtb250aHMgLSBzdGFuZGFsb25lXG4gICAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwibnVtZXJpY1wiLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCk7XG4gICAgICAgICAgY2FzZSBcIkxMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxLCBkb2Vzbid0IHNlZW0gdG8gd29ya1xuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwiMi1kaWdpdFwiLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCwgMik7XG4gICAgICAgICAgY2FzZSBcIkxMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW5cbiAgICAgICAgICAgIHJldHVybiBtb250aChcInNob3J0XCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJMTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphbnVhcnlcbiAgICAgICAgICAgIHJldHVybiBtb250aChcImxvbmdcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcIkxMTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEpcbiAgICAgICAgICAgIHJldHVybiBtb250aChcIm5hcnJvd1wiLCB0cnVlKTtcbiAgICAgICAgICAvLyBtb250aHMgLSBmb3JtYXRcbiAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoKTtcbiAgICAgICAgICBjYXNlIFwiTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDFcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIjItZGlnaXRcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgsIDIpO1xuICAgICAgICAgIGNhc2UgXCJNTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFuXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJzaG9ydFwiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFudWFyeVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibG9uZ1wiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIk1NTU1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEpcbiAgICAgICAgICAgIHJldHVybiBtb250aChcIm5hcnJvd1wiLCBmYWxzZSk7XG4gICAgICAgICAgLy8geWVhcnNcbiAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAyMDE0XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIikgOiB0aGlzLm51bShkdC55ZWFyKTtcbiAgICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMTRcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwiMi1kaWdpdFwiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIudG9TdHJpbmcoKS5zbGljZSgtMiksIDIpO1xuICAgICAgICAgIGNhc2UgXCJ5eXl5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAwMTJcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwibnVtZXJpY1wiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIsIDQpO1xuICAgICAgICAgIGNhc2UgXCJ5eXl5eXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDAwMDEyXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC55ZWFyLCA2KTtcbiAgICAgICAgICAvLyBlcmFzXG4gICAgICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQURcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJzaG9ydFwiKTtcbiAgICAgICAgICBjYXNlIFwiR0dcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQW5ubyBEb21pbmlcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJsb25nXCIpO1xuICAgICAgICAgIGNhc2UgXCJHR0dHR1wiOlxuICAgICAgICAgICAgcmV0dXJuIGVyYShcIm5hcnJvd1wiKTtcbiAgICAgICAgICBjYXNlIFwia2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrWWVhci50b1N0cmluZygpLnNsaWNlKC0yKSwgMik7XG4gICAgICAgICAgY2FzZSBcImtra2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrWWVhciwgNCk7XG4gICAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrTnVtYmVyKTtcbiAgICAgICAgICBjYXNlIFwiV1dcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrTnVtYmVyLCAyKTtcbiAgICAgICAgICBjYXNlIFwib1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm9yZGluYWwpO1xuICAgICAgICAgIGNhc2UgXCJvb29cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5vcmRpbmFsLCAzKTtcbiAgICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQucXVhcnRlcik7XG4gICAgICAgICAgY2FzZSBcInFxXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQucXVhcnRlciwgMik7XG4gICAgICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0LnRzIC8gMTAwMCkpO1xuICAgICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQudHMpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbWF5YmVNYWNybyh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5VG9rZW5zKEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLCB0b2tlblRvU3RyaW5nKTtcbiAgfVxuXG4gIGZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyhkdXIsIGZtdCkge1xuICAgIGNvbnN0IHRva2VuVG9GaWVsZCA9ICh0b2tlbikgPT4ge1xuICAgICAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kXCI7XG4gICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgIHJldHVybiBcInNlY29uZFwiO1xuICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJtaW51dGVcIjtcbiAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaG91clwiO1xuICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJkYXlcIjtcbiAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwibW9udGhcIjtcbiAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwieWVhclwiO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRva2VuVG9TdHJpbmcgPSAobGlsZHVyKSA9PiAodG9rZW4pID0+IHtcbiAgICAgICAgY29uc3QgbWFwcGVkID0gdG9rZW5Ub0ZpZWxkKHRva2VuKTtcbiAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm51bShsaWxkdXIuZ2V0KG1hcHBlZCksIHRva2VuLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9rZW5zID0gRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZtdCksXG4gICAgICByZWFsVG9rZW5zID0gdG9rZW5zLnJlZHVjZShcbiAgICAgICAgKGZvdW5kLCB7IGxpdGVyYWwsIHZhbCB9KSA9PiAobGl0ZXJhbCA/IGZvdW5kIDogZm91bmQuY29uY2F0KHZhbCkpLFxuICAgICAgICBbXVxuICAgICAgKSxcbiAgICAgIGNvbGxhcHNlZCA9IGR1ci5zaGlmdFRvKC4uLnJlYWxUb2tlbnMubWFwKHRva2VuVG9GaWVsZCkuZmlsdGVyKCh0KSA9PiB0KSk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVRva2Vucyh0b2tlbnMsIHRva2VuVG9TdHJpbmcoY29sbGFwc2VkKSk7XG4gIH1cbn1cbiIsICJleHBvcnQgZGVmYXVsdCBjbGFzcyBJbnZhbGlkIHtcbiAgY29uc3RydWN0b3IocmVhc29uLCBleHBsYW5hdGlvbikge1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuZXhwbGFuYXRpb24gPSBleHBsYW5hdGlvbjtcbiAgfVxuXG4gIHRvTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5leHBsYW5hdGlvbikge1xuICAgICAgcmV0dXJuIGAke3RoaXMucmVhc29ufTogJHt0aGlzLmV4cGxhbmF0aW9ufWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYXNvbjtcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBab25lSXNBYnN0cmFjdEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5cbi8qKlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBab25lIHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHpvbmVcbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoaXMgem9uZS5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgb2Zmc2V0IGlzIGtub3duIHRvIGJlIGZpeGVkIGZvciB0aGUgd2hvbGUgeWVhci5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgY29tbW9uIG5hbWUgKHN1Y2ggYXMgRVNUKSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcFxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIHRvIGFmZmVjdCB0aGUgZm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi4gQWNjZXB0cyAnbG9uZycgb3IgJ3Nob3J0Jy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubG9jYWxlIC0gV2hhdCBsb2NhbGUgdG8gcmV0dXJuIHRoZSBvZmZzZXQgbmFtZSBpbi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgb2Zmc2V0TmFtZSh0cywgb3B0cykge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgdmFsdWUgYXMgYSBzdHJpbmdcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBvZmZzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdHMgJ25hcnJvdycsICdzaG9ydCcsIG9yICd0ZWNoaWUnLiBSZXR1cm5pbmcgJys2JywgJyswNjowMCcsIG9yICcrMDYwMCcgcmVzcGVjdGl2ZWx5XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG9mZnNldCBpbiBtaW51dGVzIGZvciB0aGlzIHpvbmUgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGNvbXB1dGUgdGhlIG9mZnNldFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBvZmZzZXQodHMpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyBlcXVhbCB0byBhbm90aGVyIHpvbmVcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7Wm9uZX0gb3RoZXJab25lIC0gdGhlIHpvbmUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIHZhbGlkLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgZm9ybWF0T2Zmc2V0LCBwYXJzZVpvbmVJbmZvIH0gZnJvbSBcIi4uL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgbG9jYWwgem9uZSBmb3IgdGhpcyBKYXZhU2NyaXB0IGVudmlyb25tZW50LlxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5c3RlbVpvbmUgZXh0ZW5kcyBab25lIHtcbiAgLyoqXG4gICAqIEdldCBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGUgbG9jYWwgem9uZVxuICAgKiBAcmV0dXJuIHtTeXN0ZW1ab25lfVxuICAgKi9cbiAgc3RhdGljIGdldCBpbnN0YW5jZSgpIHtcbiAgICBpZiAoc2luZ2xldG9uID09PSBudWxsKSB7XG4gICAgICBzaW5nbGV0b24gPSBuZXcgU3lzdGVtWm9uZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc2luZ2xldG9uO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwic3lzdGVtXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKHRzLCB7IGZvcm1hdCwgbG9jYWxlIH0pIHtcbiAgICByZXR1cm4gcGFyc2Vab25lSW5mbyh0cywgZm9ybWF0LCBsb2NhbGUpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMub2Zmc2V0KHRzKSwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCh0cykge1xuICAgIHJldHVybiAtbmV3IERhdGUodHMpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcInN5c3RlbVwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBmb3JtYXRPZmZzZXQsIHBhcnNlWm9uZUluZm8sIGlzVW5kZWZpbmVkLCBpYW5hUmVnZXgsIG9ialRvTG9jYWxUUyB9IGZyb20gXCIuLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbmNvbnN0IG1hdGNoaW5nUmVnZXggPSBSZWdFeHAoYF4ke2lhbmFSZWdleC5zb3VyY2V9JGApO1xuXG5sZXQgZHRmQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIG1ha2VEVEYoem9uZSkge1xuICBpZiAoIWR0ZkNhY2hlW3pvbmVdKSB7XG4gICAgZHRmQ2FjaGVbem9uZV0gPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHtcbiAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICB0aW1lWm9uZTogem9uZSxcbiAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICAgIHNlY29uZDogXCIyLWRpZ2l0XCIsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGR0ZkNhY2hlW3pvbmVdO1xufVxuXG5jb25zdCB0eXBlVG9Qb3MgPSB7XG4gIHllYXI6IDAsXG4gIG1vbnRoOiAxLFxuICBkYXk6IDIsXG4gIGhvdXI6IDMsXG4gIG1pbnV0ZTogNCxcbiAgc2Vjb25kOiA1LFxufTtcblxuZnVuY3Rpb24gaGFja3lPZmZzZXQoZHRmLCBkYXRlKSB7XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGR0Zi5mb3JtYXQoZGF0ZSkucmVwbGFjZSgvXFx1MjAwRS9nLCBcIlwiKSxcbiAgICBwYXJzZWQgPSAvKFxcZCspXFwvKFxcZCspXFwvKFxcZCspLD8gKFxcZCspOihcXGQrKTooXFxkKykvLmV4ZWMoZm9ybWF0dGVkKSxcbiAgICBbLCBmTW9udGgsIGZEYXksIGZZZWFyLCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF0gPSBwYXJzZWQ7XG4gIHJldHVybiBbZlllYXIsIGZNb250aCwgZkRheSwgZkhvdXIsIGZNaW51dGUsIGZTZWNvbmRdO1xufVxuXG5mdW5jdGlvbiBwYXJ0c09mZnNldChkdGYsIGRhdGUpIHtcbiAgY29uc3QgZm9ybWF0dGVkID0gZHRmLmZvcm1hdFRvUGFydHMoZGF0ZSksXG4gICAgZmlsbGVkID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gZm9ybWF0dGVkW2ldLFxuICAgICAgcG9zID0gdHlwZVRvUG9zW3R5cGVdO1xuXG4gICAgaWYgKCFpc1VuZGVmaW5lZChwb3MpKSB7XG4gICAgICBmaWxsZWRbcG9zXSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWxsZWQ7XG59XG5cbmxldCBpYW5hWm9uZUNhY2hlID0ge307XG4vKipcbiAqIEEgem9uZSBpZGVudGlmaWVkIGJ5IGFuIElBTkEgaWRlbnRpZmllciwgbGlrZSBBbWVyaWNhL05ld19Zb3JrXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSUFOQVpvbmUgZXh0ZW5kcyBab25lIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gWm9uZSBuYW1lXG4gICAqIEByZXR1cm4ge0lBTkFab25lfVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZShuYW1lKSB7XG4gICAgaWYgKCFpYW5hWm9uZUNhY2hlW25hbWVdKSB7XG4gICAgICBpYW5hWm9uZUNhY2hlW25hbWVdID0gbmV3IElBTkFab25lKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gaWFuYVpvbmVDYWNoZVtuYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBsb2NhbCBjYWNoZXMuIFNob3VsZCBvbmx5IGJlIG5lY2Vzc2FyeSBpbiB0ZXN0aW5nIHNjZW5hcmlvcy5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHN0YXRpYyByZXNldENhY2hlKCkge1xuICAgIGlhbmFab25lQ2FjaGUgPSB7fTtcbiAgICBkdGZDYWNoZSA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgc3RyaW5nIGlzIGEgdmFsaWQgc3BlY2lmaWVyLiBUaGlzIG9ubHkgY2hlY2tzIHRoZSBzdHJpbmcncyBmb3JtYXQsIG5vdCB0aGF0IHRoZSBzcGVjaWZpZXIgaWRlbnRpZmllcyBhIGtub3duIHpvbmU7IHNlZSBpc1ZhbGlkWm9uZSBmb3IgdGhhdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgLSBUaGUgc3RyaW5nIHRvIGNoZWNrIHZhbGlkaXR5IG9uXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRTcGVjaWZpZXIoXCJBbWVyaWNhL05ld19Zb3JrXCIpIC8vPT4gdHJ1ZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkU3BlY2lmaWVyKFwiRmFudGFzaWEvQ2FzdGxlXCIpIC8vPT4gdHJ1ZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkU3BlY2lmaWVyKFwiU3BvcnR+fmJsb3JwXCIpIC8vPT4gZmFsc2VcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkU3BlY2lmaWVyKHMpIHtcbiAgICByZXR1cm4gISEocyAmJiBzLm1hdGNoKG1hdGNoaW5nUmVnZXgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHN0cmluZyBpZGVudGlmaWVzIGEgcmVhbCB6b25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6b25lIC0gVGhlIHN0cmluZyB0byBjaGVja1xuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIkFtZXJpY2EvTmV3X1lvcmtcIikgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiRmFudGFzaWEvQ2FzdGxlXCIpIC8vPT4gZmFsc2VcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJTcG9ydH5+YmxvcnBcIikgLy89PiBmYWxzZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRab25lKHpvbmUpIHtcbiAgICBpZiAoIXpvbmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwgeyB0aW1lWm9uZTogem9uZSB9KS5mb3JtYXQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy56b25lTmFtZSA9IG5hbWU7XG4gICAgLyoqIEBwcml2YXRlICoqL1xuICAgIHRoaXMudmFsaWQgPSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShuYW1lKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImlhbmFcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnpvbmVOYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUodHMsIHsgZm9ybWF0LCBsb2NhbGUgfSkge1xuICAgIHJldHVybiBwYXJzZVpvbmVJbmZvKHRzLCBmb3JtYXQsIGxvY2FsZSwgdGhpcy5uYW1lKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdE9mZnNldCh0aGlzLm9mZnNldCh0cyksIGZvcm1hdCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXQodHMpIHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodHMpO1xuXG4gICAgaWYgKGlzTmFOKGRhdGUpKSByZXR1cm4gTmFOO1xuXG4gICAgY29uc3QgZHRmID0gbWFrZURURih0aGlzLm5hbWUpLFxuICAgICAgW3llYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kXSA9IGR0Zi5mb3JtYXRUb1BhcnRzXG4gICAgICAgID8gcGFydHNPZmZzZXQoZHRmLCBkYXRlKVxuICAgICAgICA6IGhhY2t5T2Zmc2V0KGR0ZiwgZGF0ZSk7XG5cbiAgICAvLyBiZWNhdXNlIHdlJ3JlIHVzaW5nIGhvdXIxMiBhbmQgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTAyNTU2NCZjYW49MiZxPSUyMjI0JTNBMDAlMjIlMjBkYXRldGltZWZvcm1hdFxuICAgIGNvbnN0IGFkanVzdGVkSG91ciA9IGhvdXIgPT09IDI0ID8gMCA6IGhvdXI7XG5cbiAgICBjb25zdCBhc1VUQyA9IG9ialRvTG9jYWxUUyh7XG4gICAgICB5ZWFyLFxuICAgICAgbW9udGgsXG4gICAgICBkYXksXG4gICAgICBob3VyOiBhZGp1c3RlZEhvdXIsXG4gICAgICBtaW51dGUsXG4gICAgICBzZWNvbmQsXG4gICAgICBtaWxsaXNlY29uZDogMCxcbiAgICB9KTtcblxuICAgIGxldCBhc1RTID0gK2RhdGU7XG4gICAgY29uc3Qgb3ZlciA9IGFzVFMgJSAxMDAwO1xuICAgIGFzVFMgLT0gb3ZlciA+PSAwID8gb3ZlciA6IDEwMDAgKyBvdmVyO1xuICAgIHJldHVybiAoYXNVVEMgLSBhc1RTKSAvICg2MCAqIDEwMDApO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHJldHVybiBvdGhlclpvbmUudHlwZSA9PT0gXCJpYW5hXCIgJiYgb3RoZXJab25lLm5hbWUgPT09IHRoaXMubmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgZm9ybWF0T2Zmc2V0LCBzaWduZWRPZmZzZXQgfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5sZXQgc2luZ2xldG9uID0gbnVsbDtcblxuLyoqXG4gKiBBIHpvbmUgd2l0aCBhIGZpeGVkIG9mZnNldCAobWVhbmluZyBubyBEU1QpXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRml4ZWRPZmZzZXRab25lIGV4dGVuZHMgWm9uZSB7XG4gIC8qKlxuICAgKiBHZXQgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgVVRDXG4gICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBnZXQgdXRjSW5zdGFuY2UoKSB7XG4gICAgaWYgKHNpbmdsZXRvbiA9PT0gbnVsbCkge1xuICAgICAgc2luZ2xldG9uID0gbmV3IEZpeGVkT2Zmc2V0Wm9uZSgwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbmdsZXRvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugd2l0aCBhIHNwZWNpZmllZCBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgaW4gbWludXRlc1xuICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAqL1xuICBzdGF0aWMgaW5zdGFuY2Uob2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCA9PT0gMCA/IEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZSA6IG5ldyBGaXhlZE9mZnNldFpvbmUob2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugb2YgRml4ZWRPZmZzZXRab25lIGZyb20gYSBVVEMgb2Zmc2V0IHN0cmluZywgbGlrZSBcIlVUQys2XCJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgLSBUaGUgb2Zmc2V0IHN0cmluZyB0byBwYXJzZVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMrNlwiKVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMrMDZcIilcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDLTY6MDBcIilcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgc3RhdGljIHBhcnNlU3BlY2lmaWVyKHMpIHtcbiAgICBpZiAocykge1xuICAgICAgY29uc3QgciA9IHMubWF0Y2goL151dGMoPzooWystXVxcZHsxLDJ9KSg/OjooXFxkezJ9KSk/KT8kL2kpO1xuICAgICAgaWYgKHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE9mZnNldFpvbmUoc2lnbmVkT2Zmc2V0KHJbMV0sIHJbMl0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihvZmZzZXQpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBAcHJpdmF0ZSAqKi9cbiAgICB0aGlzLmZpeGVkID0gb2Zmc2V0O1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwiZml4ZWRcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmZpeGVkID09PSAwID8gXCJVVENcIiA6IGBVVEMke2Zvcm1hdE9mZnNldCh0aGlzLmZpeGVkLCBcIm5hcnJvd1wiKX1gO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMuZml4ZWQsIGZvcm1hdCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZml4ZWQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcImZpeGVkXCIgJiYgb3RoZXJab25lLmZpeGVkID09PSB0aGlzLmZpeGVkO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsICJpbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG4vKipcbiAqIEEgem9uZSB0aGF0IGZhaWxlZCB0byBwYXJzZS4gWW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW52YWxpZFpvbmUgZXh0ZW5kcyBab25lIHtcbiAgY29uc3RydWN0b3Ioem9uZU5hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiAgQHByaXZhdGUgKi9cbiAgICB0aGlzLnpvbmVOYW1lID0gem9uZU5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJpbnZhbGlkXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy56b25lTmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iLCAiLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBJbnZhbGlkWm9uZSBmcm9tIFwiLi4vem9uZXMvaW52YWxpZFpvbmUuanNcIjtcblxuaW1wb3J0IHsgaXNVbmRlZmluZWQsIGlzU3RyaW5nLCBpc051bWJlciB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVpvbmUoaW5wdXQsIGRlZmF1bHRab25lKSB7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChpc1VuZGVmaW5lZChpbnB1dCkgfHwgaW5wdXQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZGVmYXVsdFpvbmU7XG4gIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBab25lKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKGlucHV0KSkge1xuICAgIGNvbnN0IGxvd2VyZWQgPSBpbnB1dC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlcmVkID09PSBcImxvY2FsXCIgfHwgbG93ZXJlZCA9PT0gXCJzeXN0ZW1cIikgcmV0dXJuIGRlZmF1bHRab25lO1xuICAgIGVsc2UgaWYgKGxvd2VyZWQgPT09IFwidXRjXCIgfHwgbG93ZXJlZCA9PT0gXCJnbXRcIikgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZTtcbiAgICBlbHNlIGlmIChJQU5BWm9uZS5pc1ZhbGlkU3BlY2lmaWVyKGxvd2VyZWQpKSByZXR1cm4gSUFOQVpvbmUuY3JlYXRlKGlucHV0KTtcbiAgICBlbHNlIHJldHVybiBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIobG93ZXJlZCkgfHwgbmV3IEludmFsaWRab25lKGlucHV0KTtcbiAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICByZXR1cm4gRml4ZWRPZmZzZXRab25lLmluc3RhbmNlKGlucHV0KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIgJiYgaW5wdXQub2Zmc2V0ICYmIHR5cGVvZiBpbnB1dC5vZmZzZXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAvLyBUaGlzIGlzIGR1bWIsIGJ1dCB0aGUgaW5zdGFuY2VvZiBjaGVjayBhYm92ZSBkb2Vzbid0IHNlZW0gdG8gcmVhbGx5IHdvcmtcbiAgICAvLyBzbyB3ZSdyZSBkdWNrIGNoZWNraW5nIGl0XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgSW52YWxpZFpvbmUoaW5wdXQpO1xuICB9XG59XG4iLCAiaW1wb3J0IFN5c3RlbVpvbmUgZnJvbSBcIi4vem9uZXMvc3lzdGVtWm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5cbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5cbmxldCBub3cgPSAoKSA9PiBEYXRlLm5vdygpLFxuICBkZWZhdWx0Wm9uZSA9IFwic3lzdGVtXCIsXG4gIGRlZmF1bHRMb2NhbGUgPSBudWxsLFxuICBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtID0gbnVsbCxcbiAgZGVmYXVsdE91dHB1dENhbGVuZGFyID0gbnVsbCxcbiAgdGhyb3dPbkludmFsaWQ7XG5cbi8qKlxuICogU2V0dGluZ3MgY29udGFpbnMgc3RhdGljIGdldHRlcnMgYW5kIHNldHRlcnMgdGhhdCBjb250cm9sIEx1eG9uJ3Mgb3ZlcmFsbCBiZWhhdmlvci4gTHV4b24gaXMgYSBzaW1wbGUgbGlicmFyeSB3aXRoIGZldyBvcHRpb25zLCBidXQgdGhlIG9uZXMgaXQgZG9lcyBoYXZlIGxpdmUgaGVyZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2V0dGluZ3Mge1xuICAvKipcbiAgICogR2V0IHRoZSBjYWxsYmFjayBmb3IgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHRpbWVzdGFtcC5cbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKi9cbiAgc3RhdGljIGdldCBub3coKSB7XG4gICAgcmV0dXJuIG5vdztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNhbGxiYWNrIGZvciByZXR1cm5pbmcgdGhlIGN1cnJlbnQgdGltZXN0YW1wLlxuICAgKiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIG51bWJlciwgd2hpY2ggd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBhbiBFcG9jaCBtaWxsaXNlY29uZCBjb3VudFxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqIEBleGFtcGxlIFNldHRpbmdzLm5vdyA9ICgpID0+IERhdGUubm93KCkgKyAzMDAwIC8vIHByZXRlbmQgaXQgaXMgMyBzZWNvbmRzIGluIHRoZSBmdXR1cmVcbiAgICogQGV4YW1wbGUgU2V0dGluZ3Mubm93ID0gKCkgPT4gMCAvLyBhbHdheXMgcHJldGVuZCBpdCdzIEphbiAxLCAxOTcwIGF0IG1pZG5pZ2h0IGluIFVUQyB0aW1lXG4gICAqL1xuICBzdGF0aWMgc2V0IG5vdyhuKSB7XG4gICAgbm93ID0gbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgdGltZSB6b25lIHRvIGNyZWF0ZSBEYXRlVGltZXMgaW4uIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIFVzZSB0aGUgdmFsdWUgXCJzeXN0ZW1cIiB0byByZXNldCB0aGlzIHZhbHVlIHRvIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRab25lKHpvbmUpIHtcbiAgICBkZWZhdWx0Wm9uZSA9IHpvbmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IHRpbWUgem9uZSBvYmplY3QgY3VycmVudGx5IHVzZWQgdG8gY3JlYXRlIERhdGVUaW1lcy4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdGhlIHN5c3RlbSdzIHRpbWUgem9uZSAodGhlIG9uZSBzZXQgb24gdGhlIG1hY2hpbmUgdGhhdCBydW5zIHRoaXMgY29kZSkuXG4gICAqIEB0eXBlIHtab25lfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0Wm9uZSgpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplWm9uZShkZWZhdWx0Wm9uZSwgU3lzdGVtWm9uZS5pbnN0YW5jZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IGxvY2FsZSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRMb2NhbGUoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRMb2NhbGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IGxvY2FsZSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRMb2NhbGUobG9jYWxlKSB7XG4gICAgZGVmYXVsdExvY2FsZSA9IGxvY2FsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgbnVtYmVyaW5nIHN5c3RlbSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW07XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IG51bWJlcmluZyBzeXN0ZW0gdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtKG51bWJlcmluZ1N5c3RlbSkge1xuICAgIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gPSBudW1iZXJpbmdTeXN0ZW07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IG91dHB1dCBjYWxlbmRhciB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRPdXRwdXRDYWxlbmRhcigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE91dHB1dENhbGVuZGFyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBvdXRwdXQgY2FsZW5kYXIgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIob3V0cHV0Q2FsZW5kYXIpIHtcbiAgICBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIgPSBvdXRwdXRDYWxlbmRhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciBMdXhvbiB3aWxsIHRocm93IHdoZW4gaXQgZW5jb3VudGVycyBpbnZhbGlkIERhdGVUaW1lcywgRHVyYXRpb25zLCBvciBJbnRlcnZhbHNcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRocm93T25JbnZhbGlkKCkge1xuICAgIHJldHVybiB0aHJvd09uSW52YWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciBMdXhvbiB3aWxsIHRocm93IHdoZW4gaXQgZW5jb3VudGVycyBpbnZhbGlkIERhdGVUaW1lcywgRHVyYXRpb25zLCBvciBJbnRlcnZhbHNcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgc2V0IHRocm93T25JbnZhbGlkKHQpIHtcbiAgICB0aHJvd09uSW52YWxpZCA9IHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgTHV4b24ncyBnbG9iYWwgY2FjaGVzLiBTaG91bGQgb25seSBiZSBuZWNlc3NhcnkgaW4gdGVzdGluZyBzY2VuYXJpb3MuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBzdGF0aWMgcmVzZXRDYWNoZXMoKSB7XG4gICAgTG9jYWxlLnJlc2V0Q2FjaGUoKTtcbiAgICBJQU5BWm9uZS5yZXNldENhY2hlKCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBwYWRTdGFydCwgcm91bmRUbywgaGFzUmVsYXRpdmUgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcblxuLy8gdG9kbyAtIHJlbWFwIGNhY2hpbmdcblxubGV0IGludGxMRkNhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRMRihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBkdGYgPSBpbnRsTEZDYWNoZVtrZXldO1xuICBpZiAoIWR0Zikge1xuICAgIGR0ZiA9IG5ldyBJbnRsLkxpc3RGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsTEZDYWNoZVtrZXldID0gZHRmO1xuICB9XG4gIHJldHVybiBkdGY7XG59XG5cbmxldCBpbnRsRFRDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVkRFRGKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIG9wdHNdKTtcbiAgbGV0IGR0ZiA9IGludGxEVENhY2hlW2tleV07XG4gIGlmICghZHRmKSB7XG4gICAgZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsRFRDYWNoZVtrZXldID0gZHRmO1xuICB9XG4gIHJldHVybiBkdGY7XG59XG5cbmxldCBpbnRsTnVtQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldENhY2hlZElORihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBpbmYgPSBpbnRsTnVtQ2FjaGVba2V5XTtcbiAgaWYgKCFpbmYpIHtcbiAgICBpbmYgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsTnVtQ2FjaGVba2V5XSA9IGluZjtcbiAgfVxuICByZXR1cm4gaW5mO1xufVxuXG5sZXQgaW50bFJlbENhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRSVEYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBiYXNlLCAuLi5jYWNoZUtleU9wdHMgfSA9IG9wdHM7IC8vIGV4Y2x1ZGUgYGJhc2VgIGZyb20gdGhlIG9wdGlvbnNcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgY2FjaGVLZXlPcHRzXSk7XG4gIGxldCBpbmYgPSBpbnRsUmVsQ2FjaGVba2V5XTtcbiAgaWYgKCFpbmYpIHtcbiAgICBpbmYgPSBuZXcgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsUmVsQ2FjaGVba2V5XSA9IGluZjtcbiAgfVxuICByZXR1cm4gaW5mO1xufVxuXG5sZXQgc3lzTG9jYWxlQ2FjaGUgPSBudWxsO1xuZnVuY3Rpb24gc3lzdGVtTG9jYWxlKCkge1xuICBpZiAoc3lzTG9jYWxlQ2FjaGUpIHtcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH0gZWxzZSB7XG4gICAgc3lzTG9jYWxlQ2FjaGUgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZTtcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VMb2NhbGVTdHJpbmcobG9jYWxlU3RyKSB7XG4gIC8vIEkgcmVhbGx5IHdhbnQgdG8gYXZvaWQgd3JpdGluZyBhIEJDUCA0NyBwYXJzZXJcbiAgLy8gc2VlLCBlLmcuIGh0dHBzOi8vZ2l0aHViLmNvbS93b29vcm0vYmNwLTQ3XG4gIC8vIEluc3RlYWQsIHdlJ2xsIGRvIHRoaXM6XG5cbiAgLy8gYSkgaWYgdGhlIHN0cmluZyBoYXMgbm8gLXUgZXh0ZW5zaW9ucywganVzdCBsZWF2ZSBpdCBhbG9uZVxuICAvLyBiKSBpZiBpdCBkb2VzLCB1c2UgSW50bCB0byByZXNvbHZlIGV2ZXJ5dGhpbmdcbiAgLy8gYykgaWYgSW50bCBmYWlscywgdHJ5IGFnYWluIHdpdGhvdXQgdGhlIC11XG5cbiAgY29uc3QgdUluZGV4ID0gbG9jYWxlU3RyLmluZGV4T2YoXCItdS1cIik7XG4gIGlmICh1SW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIFtsb2NhbGVTdHJdO1xuICB9IGVsc2Uge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGNvbnN0IHNtYWxsZXIgPSBsb2NhbGVTdHIuc3Vic3RyaW5nKDAsIHVJbmRleCk7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMgPSBnZXRDYWNoZWREVEYobG9jYWxlU3RyKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvcHRpb25zID0gZ2V0Q2FjaGVkRFRGKHNtYWxsZXIpLnJlc29sdmVkT3B0aW9ucygpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhciB9ID0gb3B0aW9ucztcbiAgICAvLyByZXR1cm4gdGhlIHNtYWxsZXIgb25lIHNvIHRoYXQgd2UgY2FuIGFwcGVuZCB0aGUgY2FsZW5kYXIgYW5kIG51bWJlcmluZyBvdmVycmlkZXMgdG8gaXRcbiAgICByZXR1cm4gW3NtYWxsZXIsIG51bWJlcmluZ1N5c3RlbSwgY2FsZW5kYXJdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGxDb25maWdTdHJpbmcobG9jYWxlU3RyLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyKSB7XG4gIGlmIChvdXRwdXRDYWxlbmRhciB8fCBudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICBsb2NhbGVTdHIgKz0gXCItdVwiO1xuXG4gICAgaWYgKG91dHB1dENhbGVuZGFyKSB7XG4gICAgICBsb2NhbGVTdHIgKz0gYC1jYS0ke291dHB1dENhbGVuZGFyfWA7XG4gICAgfVxuXG4gICAgaWYgKG51bWJlcmluZ1N5c3RlbSkge1xuICAgICAgbG9jYWxlU3RyICs9IGAtbnUtJHtudW1iZXJpbmdTeXN0ZW19YDtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZVN0cjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbG9jYWxlU3RyO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcE1vbnRocyhmKSB7XG4gIGNvbnN0IG1zID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IDEyOyBpKyspIHtcbiAgICBjb25zdCBkdCA9IERhdGVUaW1lLnV0YygyMDE2LCBpLCAxKTtcbiAgICBtcy5wdXNoKGYoZHQpKTtcbiAgfVxuICByZXR1cm4gbXM7XG59XG5cbmZ1bmN0aW9uIG1hcFdlZWtkYXlzKGYpIHtcbiAgY29uc3QgbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gNzsgaSsrKSB7XG4gICAgY29uc3QgZHQgPSBEYXRlVGltZS51dGMoMjAxNiwgMTEsIDEzICsgaSk7XG4gICAgbXMucHVzaChmKGR0KSk7XG4gIH1cbiAgcmV0dXJuIG1zO1xufVxuXG5mdW5jdGlvbiBsaXN0U3R1ZmYobG9jLCBsZW5ndGgsIGRlZmF1bHRPSywgZW5nbGlzaEZuLCBpbnRsRm4pIHtcbiAgY29uc3QgbW9kZSA9IGxvYy5saXN0aW5nTW9kZShkZWZhdWx0T0spO1xuXG4gIGlmIChtb2RlID09PSBcImVycm9yXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChtb2RlID09PSBcImVuXCIpIHtcbiAgICByZXR1cm4gZW5nbGlzaEZuKGxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGludGxGbihsZW5ndGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzRmFzdE51bWJlcnMobG9jKSB7XG4gIGlmIChsb2MubnVtYmVyaW5nU3lzdGVtICYmIGxvYy5udW1iZXJpbmdTeXN0ZW0gIT09IFwibGF0blwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXG4gICAgICBsb2MubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIiB8fFxuICAgICAgIWxvYy5sb2NhbGUgfHxcbiAgICAgIGxvYy5sb2NhbGUuc3RhcnRzV2l0aChcImVuXCIpIHx8XG4gICAgICBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2MuaW50bCkucmVzb2x2ZWRPcHRpb25zKCkubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIlxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNsYXNzIFBvbHlOdW1iZXJGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihpbnRsLCBmb3JjZVNpbXBsZSwgb3B0cykge1xuICAgIHRoaXMucGFkVG8gPSBvcHRzLnBhZFRvIHx8IDA7XG4gICAgdGhpcy5mbG9vciA9IG9wdHMuZmxvb3IgfHwgZmFsc2U7XG5cbiAgICBjb25zdCB7IHBhZFRvLCBmbG9vciwgLi4ub3RoZXJPcHRzIH0gPSBvcHRzO1xuXG4gICAgaWYgKCFmb3JjZVNpbXBsZSB8fCBPYmplY3Qua2V5cyhvdGhlck9wdHMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGludGxPcHRzID0geyB1c2VHcm91cGluZzogZmFsc2UsIC4uLm9wdHMgfTtcbiAgICAgIGlmIChvcHRzLnBhZFRvID4gMCkgaW50bE9wdHMubWluaW11bUludGVnZXJEaWdpdHMgPSBvcHRzLnBhZFRvO1xuICAgICAgdGhpcy5pbmYgPSBnZXRDYWNoZWRJTkYoaW50bCwgaW50bE9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdChpKSB7XG4gICAgaWYgKHRoaXMuaW5mKSB7XG4gICAgICBjb25zdCBmaXhlZCA9IHRoaXMuZmxvb3IgPyBNYXRoLmZsb29yKGkpIDogaTtcbiAgICAgIHJldHVybiB0aGlzLmluZi5mb3JtYXQoZml4ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0byBtYXRjaCB0aGUgYnJvd3NlcidzIG51bWJlcmZvcm1hdHRlciBkZWZhdWx0c1xuICAgICAgY29uc3QgZml4ZWQgPSB0aGlzLmZsb29yID8gTWF0aC5mbG9vcihpKSA6IHJvdW5kVG8oaSwgMyk7XG4gICAgICByZXR1cm4gcGFkU3RhcnQoZml4ZWQsIHRoaXMucGFkVG8pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuY2xhc3MgUG9seURhdGVGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihkdCwgaW50bCwgb3B0cykge1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG5cbiAgICBsZXQgejtcbiAgICBpZiAoZHQuem9uZS5pc1VuaXZlcnNhbCkge1xuICAgICAgLy8gVVRDLTggb3IgRXRjL1VUQy04IGFyZSBub3QgcGFydCBvZiB0emRhdGEsIG9ubHkgRXRjL0dNVCs4IGFuZCB0aGUgbGlrZS5cbiAgICAgIC8vIFRoYXQgaXMgd2h5IGZpeGVkLW9mZnNldCBUWiBpcyBzZXQgdG8gdGhhdCB1bmxlc3MgaXQgaXM6XG4gICAgICAvLyAxLiBSZXByZXNlbnRpbmcgb2Zmc2V0IDAgd2hlbiBVVEMgaXMgdXNlZCB0byBtYWludGFpbiBwcmV2aW91cyBiZWhhdmlvciBhbmQgZG9lcyBub3QgYmVjb21lIEdNVC5cbiAgICAgIC8vIDIuIFVuc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyOlxuICAgICAgLy8gICAgLSBzb21lIGRvIG5vdCBzdXBwb3J0IEV0Yy9cbiAgICAgIC8vICAgIC0gPCBFdGMvR01ULTE0LCA+IEV0Yy9HTVQrMTIsIGFuZCAzMC1taW51dGUgb3IgNDUtbWludXRlIG9mZnNldHMgYXJlIG5vdCBwYXJ0IG9mIHR6ZGF0YVxuICAgICAgY29uc3QgZ210T2Zmc2V0ID0gLTEgKiAoZHQub2Zmc2V0IC8gNjApO1xuICAgICAgY29uc3Qgb2Zmc2V0WiA9IGdtdE9mZnNldCA+PSAwID8gYEV0Yy9HTVQrJHtnbXRPZmZzZXR9YCA6IGBFdGMvR01UJHtnbXRPZmZzZXR9YDtcbiAgICAgIGlmIChkdC5vZmZzZXQgIT09IDAgJiYgSUFOQVpvbmUuY3JlYXRlKG9mZnNldFopLnZhbGlkKSB7XG4gICAgICAgIHogPSBvZmZzZXRaO1xuICAgICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3QgYWxsIGZpeGVkLW9mZnNldCB6b25lcyBsaWtlIEV0Yy8rNDozMCBhcmUgcHJlc2VudCBpbiB0emRhdGEuXG4gICAgICAgIC8vIFNvIHdlIGhhdmUgdG8gbWFrZSBkby4gVHdvIGNhc2VzOlxuICAgICAgICAvLyAxLiBUaGUgZm9ybWF0IG9wdGlvbnMgdGVsbCB1cyB0byBzaG93IHRoZSB6b25lLiBXZSBjYW4ndCBkbyB0aGF0LCBzbyB0aGUgYmVzdFxuICAgICAgICAvLyB3ZSBjYW4gZG8gaXMgZm9ybWF0IHRoZSBkYXRlIGluIFVUQy5cbiAgICAgICAgLy8gMi4gVGhlIGZvcm1hdCBvcHRpb25zIGRvbid0IHRlbGwgdXMgdG8gc2hvdyB0aGUgem9uZS4gVGhlbiB3ZSBjYW4gYWRqdXN0IHRoZW1cbiAgICAgICAgLy8gdGhlIHRpbWUgYW5kIHRlbGwgdGhlIGZvcm1hdHRlciB0byBzaG93IGl0IHRvIHVzIGluIFVUQywgc28gdGhhdCB0aGUgdGltZSBpcyByaWdodFxuICAgICAgICAvLyBhbmQgdGhlIGJhZCB6b25lIGRvZXNuJ3Qgc2hvdyB1cC5cbiAgICAgICAgeiA9IFwiVVRDXCI7XG4gICAgICAgIGlmIChvcHRzLnRpbWVab25lTmFtZSkge1xuICAgICAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmR0ID0gZHQub2Zmc2V0ID09PSAwID8gZHQgOiBEYXRlVGltZS5mcm9tTWlsbGlzKGR0LnRzICsgZHQub2Zmc2V0ICogNjAgKiAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZHQuem9uZS50eXBlID09PSBcInN5c3RlbVwiKSB7XG4gICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgIHogPSBkdC56b25lLm5hbWU7XG4gICAgfVxuXG4gICAgY29uc3QgaW50bE9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuICAgIGlmICh6KSB7XG4gICAgICBpbnRsT3B0cy50aW1lWm9uZSA9IHo7XG4gICAgfVxuICAgIHRoaXMuZHRmID0gZ2V0Q2FjaGVkRFRGKGludGwsIGludGxPcHRzKTtcbiAgfVxuXG4gIGZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5kdGYuZm9ybWF0KHRoaXMuZHQudG9KU0RhdGUoKSk7XG4gIH1cblxuICBmb3JtYXRUb1BhcnRzKCkge1xuICAgIHJldHVybiB0aGlzLmR0Zi5mb3JtYXRUb1BhcnRzKHRoaXMuZHQudG9KU0RhdGUoKSk7XG4gIH1cblxuICByZXNvbHZlZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRmLnJlc29sdmVkT3B0aW9ucygpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUG9seVJlbEZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGludGwsIGlzRW5nbGlzaCwgb3B0cykge1xuICAgIHRoaXMub3B0cyA9IHsgc3R5bGU6IFwibG9uZ1wiLCAuLi5vcHRzIH07XG4gICAgaWYgKCFpc0VuZ2xpc2ggJiYgaGFzUmVsYXRpdmUoKSkge1xuICAgICAgdGhpcy5ydGYgPSBnZXRDYWNoZWRSVEYoaW50bCwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0KGNvdW50LCB1bml0KSB7XG4gICAgaWYgKHRoaXMucnRmKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydGYuZm9ybWF0KGNvdW50LCB1bml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEVuZ2xpc2guZm9ybWF0UmVsYXRpdmVUaW1lKHVuaXQsIGNvdW50LCB0aGlzLm9wdHMubnVtZXJpYywgdGhpcy5vcHRzLnN0eWxlICE9PSBcImxvbmdcIik7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0VG9QYXJ0cyhjb3VudCwgdW5pdCkge1xuICAgIGlmICh0aGlzLnJ0Zikge1xuICAgICAgcmV0dXJuIHRoaXMucnRmLmZvcm1hdFRvUGFydHMoY291bnQsIHVuaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhbGUge1xuICBzdGF0aWMgZnJvbU9wdHMob3B0cykge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKG9wdHMubG9jYWxlLCBvcHRzLm51bWJlcmluZ1N5c3RlbSwgb3B0cy5vdXRwdXRDYWxlbmRhciwgb3B0cy5kZWZhdWx0VG9FTik7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciwgZGVmYXVsdFRvRU4gPSBmYWxzZSkge1xuICAgIGNvbnN0IHNwZWNpZmllZExvY2FsZSA9IGxvY2FsZSB8fCBTZXR0aW5ncy5kZWZhdWx0TG9jYWxlO1xuICAgIC8vIHRoZSBzeXN0ZW0gbG9jYWxlIGlzIHVzZWZ1bCBmb3IgaHVtYW4gcmVhZGFibGUgc3RyaW5ncyBidXQgYW5ub3lpbmcgZm9yIHBhcnNpbmcvZm9ybWF0dGluZyBrbm93biBmb3JtYXRzXG4gICAgY29uc3QgbG9jYWxlUiA9IHNwZWNpZmllZExvY2FsZSB8fCAoZGVmYXVsdFRvRU4gPyBcImVuLVVTXCIgOiBzeXN0ZW1Mb2NhbGUoKSk7XG4gICAgY29uc3QgbnVtYmVyaW5nU3lzdGVtUiA9IG51bWJlcmluZ1N5c3RlbSB8fCBTZXR0aW5ncy5kZWZhdWx0TnVtYmVyaW5nU3lzdGVtO1xuICAgIGNvbnN0IG91dHB1dENhbGVuZGFyUiA9IG91dHB1dENhbGVuZGFyIHx8IFNldHRpbmdzLmRlZmF1bHRPdXRwdXRDYWxlbmRhcjtcbiAgICByZXR1cm4gbmV3IExvY2FsZShsb2NhbGVSLCBudW1iZXJpbmdTeXN0ZW1SLCBvdXRwdXRDYWxlbmRhclIsIHNwZWNpZmllZExvY2FsZSk7XG4gIH1cblxuICBzdGF0aWMgcmVzZXRDYWNoZSgpIHtcbiAgICBzeXNMb2NhbGVDYWNoZSA9IG51bGw7XG4gICAgaW50bERUQ2FjaGUgPSB7fTtcbiAgICBpbnRsTnVtQ2FjaGUgPSB7fTtcbiAgICBpbnRsUmVsQ2FjaGUgPSB7fTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tT2JqZWN0KHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcik7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihsb2NhbGUsIG51bWJlcmluZywgb3V0cHV0Q2FsZW5kYXIsIHNwZWNpZmllZExvY2FsZSkge1xuICAgIGNvbnN0IFtwYXJzZWRMb2NhbGUsIHBhcnNlZE51bWJlcmluZ1N5c3RlbSwgcGFyc2VkT3V0cHV0Q2FsZW5kYXJdID0gcGFyc2VMb2NhbGVTdHJpbmcobG9jYWxlKTtcblxuICAgIHRoaXMubG9jYWxlID0gcGFyc2VkTG9jYWxlO1xuICAgIHRoaXMubnVtYmVyaW5nU3lzdGVtID0gbnVtYmVyaW5nIHx8IHBhcnNlZE51bWJlcmluZ1N5c3RlbSB8fCBudWxsO1xuICAgIHRoaXMub3V0cHV0Q2FsZW5kYXIgPSBvdXRwdXRDYWxlbmRhciB8fCBwYXJzZWRPdXRwdXRDYWxlbmRhciB8fCBudWxsO1xuICAgIHRoaXMuaW50bCA9IGludGxDb25maWdTdHJpbmcodGhpcy5sb2NhbGUsIHRoaXMubnVtYmVyaW5nU3lzdGVtLCB0aGlzLm91dHB1dENhbGVuZGFyKTtcblxuICAgIHRoaXMud2Vla2RheXNDYWNoZSA9IHsgZm9ybWF0OiB7fSwgc3RhbmRhbG9uZToge30gfTtcbiAgICB0aGlzLm1vbnRoc0NhY2hlID0geyBmb3JtYXQ6IHt9LCBzdGFuZGFsb25lOiB7fSB9O1xuICAgIHRoaXMubWVyaWRpZW1DYWNoZSA9IG51bGw7XG4gICAgdGhpcy5lcmFDYWNoZSA9IHt9O1xuXG4gICAgdGhpcy5zcGVjaWZpZWRMb2NhbGUgPSBzcGVjaWZpZWRMb2NhbGU7XG4gICAgdGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9IG51bGw7XG4gIH1cblxuICBnZXQgZmFzdE51bWJlcnMoKSB7XG4gICAgaWYgKHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9IHN1cHBvcnRzRmFzdE51bWJlcnModGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQ7XG4gIH1cblxuICBsaXN0aW5nTW9kZSgpIHtcbiAgICBjb25zdCBpc0FjdHVhbGx5RW4gPSB0aGlzLmlzRW5nbGlzaCgpO1xuICAgIGNvbnN0IGhhc05vV2VpcmRuZXNzID1cbiAgICAgICh0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gbnVsbCB8fCB0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gXCJsYXRuXCIpICYmXG4gICAgICAodGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gbnVsbCB8fCB0aGlzLm91dHB1dENhbGVuZGFyID09PSBcImdyZWdvcnlcIik7XG4gICAgcmV0dXJuIGlzQWN0dWFsbHlFbiAmJiBoYXNOb1dlaXJkbmVzcyA/IFwiZW5cIiA6IFwiaW50bFwiO1xuICB9XG5cbiAgY2xvbmUoYWx0cykge1xuICAgIGlmICghYWx0cyB8fCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhbHRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShcbiAgICAgICAgYWx0cy5sb2NhbGUgfHwgdGhpcy5zcGVjaWZpZWRMb2NhbGUsXG4gICAgICAgIGFsdHMubnVtYmVyaW5nU3lzdGVtIHx8IHRoaXMubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBhbHRzLm91dHB1dENhbGVuZGFyIHx8IHRoaXMub3V0cHV0Q2FsZW5kYXIsXG4gICAgICAgIGFsdHMuZGVmYXVsdFRvRU4gfHwgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmVkZWZhdWx0VG9FTihhbHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7IC4uLmFsdHMsIGRlZmF1bHRUb0VOOiB0cnVlIH0pO1xuICB9XG5cbiAgcmVkZWZhdWx0VG9TeXN0ZW0oYWx0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoeyAuLi5hbHRzLCBkZWZhdWx0VG9FTjogZmFsc2UgfSk7XG4gIH1cblxuICBtb250aHMobGVuZ3RoLCBmb3JtYXQgPSBmYWxzZSwgZGVmYXVsdE9LID0gdHJ1ZSkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBkZWZhdWx0T0ssIEVuZ2xpc2gubW9udGhzLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnRsID0gZm9ybWF0ID8geyBtb250aDogbGVuZ3RoLCBkYXk6IFwibnVtZXJpY1wiIH0gOiB7IG1vbnRoOiBsZW5ndGggfSxcbiAgICAgICAgZm9ybWF0U3RyID0gZm9ybWF0ID8gXCJmb3JtYXRcIiA6IFwic3RhbmRhbG9uZVwiO1xuICAgICAgaWYgKCF0aGlzLm1vbnRoc0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSkge1xuICAgICAgICB0aGlzLm1vbnRoc0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSA9IG1hcE1vbnRocygoZHQpID0+IHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJtb250aFwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF07XG4gICAgfSk7XG4gIH1cblxuICB3ZWVrZGF5cyhsZW5ndGgsIGZvcm1hdCA9IGZhbHNlLCBkZWZhdWx0T0sgPSB0cnVlKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIGRlZmF1bHRPSywgRW5nbGlzaC53ZWVrZGF5cywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IGZvcm1hdFxuICAgICAgICAgID8geyB3ZWVrZGF5OiBsZW5ndGgsIHllYXI6IFwibnVtZXJpY1wiLCBtb250aDogXCJsb25nXCIsIGRheTogXCJudW1lcmljXCIgfVxuICAgICAgICAgIDogeyB3ZWVrZGF5OiBsZW5ndGggfSxcbiAgICAgICAgZm9ybWF0U3RyID0gZm9ybWF0ID8gXCJmb3JtYXRcIiA6IFwic3RhbmRhbG9uZVwiO1xuICAgICAgaWYgKCF0aGlzLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdKSB7XG4gICAgICAgIHRoaXMud2Vla2RheXNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0gPSBtYXBXZWVrZGF5cygoZHQpID0+XG4gICAgICAgICAgdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcIndlZWtkYXlcIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdO1xuICAgIH0pO1xuICB9XG5cbiAgbWVyaWRpZW1zKGRlZmF1bHRPSyA9IHRydWUpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKFxuICAgICAgdGhpcyxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGRlZmF1bHRPSyxcbiAgICAgICgpID0+IEVuZ2xpc2gubWVyaWRpZW1zLFxuICAgICAgKCkgPT4ge1xuICAgICAgICAvLyBJbiB0aGVvcnkgdGhlcmUgY291bGQgYmUgYXJpYml0cmFyeSBkYXkgcGVyaW9kcy4gV2UncmUgZ29ubmEgYXNzdW1lIHRoZXJlIGFyZSBleGFjdGx5IHR3b1xuICAgICAgICAvLyBmb3IgQU0gYW5kIFBNLiBUaGlzIGlzIHByb2JhYmx5IHdyb25nLCBidXQgaXQncyBtYWtlcyBwYXJzaW5nIHdheSBlYXNpZXIuXG4gICAgICAgIGlmICghdGhpcy5tZXJpZGllbUNhY2hlKSB7XG4gICAgICAgICAgY29uc3QgaW50bCA9IHsgaG91cjogXCJudW1lcmljXCIsIGhvdXJDeWNsZTogXCJoMTJcIiB9O1xuICAgICAgICAgIHRoaXMubWVyaWRpZW1DYWNoZSA9IFtEYXRlVGltZS51dGMoMjAxNiwgMTEsIDEzLCA5KSwgRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMywgMTkpXS5tYXAoXG4gICAgICAgICAgICAoZHQpID0+IHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJkYXlwZXJpb2RcIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubWVyaWRpZW1DYWNoZTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgZXJhcyhsZW5ndGgsIGRlZmF1bHRPSyA9IHRydWUpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKHRoaXMsIGxlbmd0aCwgZGVmYXVsdE9LLCBFbmdsaXNoLmVyYXMsICgpID0+IHtcbiAgICAgIGNvbnN0IGludGwgPSB7IGVyYTogbGVuZ3RoIH07XG5cbiAgICAgIC8vIFRoaXMgaXMgcHJvYmxlbWF0aWMuIERpZmZlcmVudCBjYWxlbmRhcnMgYXJlIGdvaW5nIHRvIGRlZmluZSBlcmFzIHRvdGFsbHkgZGlmZmVyZW50bHkuIFdoYXQgSSBuZWVkIGlzIHRoZSBtaW5pbXVtIHNldCBvZiBkYXRlc1xuICAgICAgLy8gdG8gZGVmaW5pdGVseSBlbnVtZXJhdGUgdGhlbS5cbiAgICAgIGlmICghdGhpcy5lcmFDYWNoZVtsZW5ndGhdKSB7XG4gICAgICAgIHRoaXMuZXJhQ2FjaGVbbGVuZ3RoXSA9IFtEYXRlVGltZS51dGMoLTQwLCAxLCAxKSwgRGF0ZVRpbWUudXRjKDIwMTcsIDEsIDEpXS5tYXAoKGR0KSA9PlxuICAgICAgICAgIHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJlcmFcIilcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZXJhQ2FjaGVbbGVuZ3RoXTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4dHJhY3QoZHQsIGludGxPcHRzLCBmaWVsZCkge1xuICAgIGNvbnN0IGRmID0gdGhpcy5kdEZvcm1hdHRlcihkdCwgaW50bE9wdHMpLFxuICAgICAgcmVzdWx0cyA9IGRmLmZvcm1hdFRvUGFydHMoKSxcbiAgICAgIG1hdGNoaW5nID0gcmVzdWx0cy5maW5kKChtKSA9PiBtLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZmllbGQpO1xuICAgIHJldHVybiBtYXRjaGluZyA/IG1hdGNoaW5nLnZhbHVlIDogbnVsbDtcbiAgfVxuXG4gIG51bWJlckZvcm1hdHRlcihvcHRzID0ge30pIHtcbiAgICAvLyB0aGlzIGZvcmNlc2ltcGxlIG9wdGlvbiBpcyBuZXZlciB1c2VkICh0aGUgb25seSBjYWxsZXIgc2hvcnQtY2lyY3VpdHMgb24gaXQsIGJ1dCBpdCBzZWVtcyBzYWZlciB0byBsZWF2ZSlcbiAgICAvLyAoaW4gY29udHJhc3QsIHRoZSByZXN0IG9mIHRoZSBjb25kaXRpb24gaXMgdXNlZCBoZWF2aWx5KVxuICAgIHJldHVybiBuZXcgUG9seU51bWJlckZvcm1hdHRlcih0aGlzLmludGwsIG9wdHMuZm9yY2VTaW1wbGUgfHwgdGhpcy5mYXN0TnVtYmVycywgb3B0cyk7XG4gIH1cblxuICBkdEZvcm1hdHRlcihkdCwgaW50bE9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUG9seURhdGVGb3JtYXR0ZXIoZHQsIHRoaXMuaW50bCwgaW50bE9wdHMpO1xuICB9XG5cbiAgcmVsRm9ybWF0dGVyKG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUG9seVJlbEZvcm1hdHRlcih0aGlzLmludGwsIHRoaXMuaXNFbmdsaXNoKCksIG9wdHMpO1xuICB9XG5cbiAgbGlzdEZvcm1hdHRlcihvcHRzID0ge30pIHtcbiAgICByZXR1cm4gZ2V0Q2FjaGVkTEYodGhpcy5pbnRsLCBvcHRzKTtcbiAgfVxuXG4gIGlzRW5nbGlzaCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5sb2NhbGUgPT09IFwiZW5cIiB8fFxuICAgICAgdGhpcy5sb2NhbGUudG9Mb3dlckNhc2UoKSA9PT0gXCJlbi11c1wiIHx8XG4gICAgICBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmludGwpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZS5zdGFydHNXaXRoKFwiZW4tdXNcIilcbiAgICApO1xuICB9XG5cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubG9jYWxlID09PSBvdGhlci5sb2NhbGUgJiZcbiAgICAgIHRoaXMubnVtYmVyaW5nU3lzdGVtID09PSBvdGhlci5udW1iZXJpbmdTeXN0ZW0gJiZcbiAgICAgIHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IG90aGVyLm91dHB1dENhbGVuZGFyXG4gICAgKTtcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIHVudHJ1bmNhdGVZZWFyLFxuICBzaWduZWRPZmZzZXQsXG4gIHBhcnNlSW50ZWdlcixcbiAgcGFyc2VNaWxsaXMsXG4gIGlhbmFSZWdleCxcbiAgaXNVbmRlZmluZWQsXG4gIHBhcnNlRmxvYXRpbmcsXG59IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5cbi8qXG4gKiBUaGlzIGZpbGUgaGFuZGxlcyBwYXJzaW5nIGZvciB3ZWxsLXNwZWNpZmllZCBmb3JtYXRzLiBIZXJlJ3MgaG93IGl0IHdvcmtzOlxuICogVHdvIHRoaW5ncyBnbyBpbnRvIHBhcnNpbmc6IGEgcmVnZXggdG8gbWF0Y2ggd2l0aCBhbmQgYW4gZXh0cmFjdG9yIHRvIHRha2UgYXBhcnQgdGhlIGdyb3VwcyBpbiB0aGUgbWF0Y2guXG4gKiBBbiBleHRyYWN0b3IgaXMganVzdCBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSByZWdleCBtYXRjaCBhcnJheSBhbmQgcmV0dXJucyBhIHsgeWVhcjogLi4uLCBtb250aDogLi4uIH0gb2JqZWN0XG4gKiBwYXJzZSgpIGRvZXMgdGhlIHdvcmsgb2YgZXhlY3V0aW5nIHRoZSByZWdleCBhbmQgYXBwbHlpbmcgdGhlIGV4dHJhY3Rvci4gSXQgdGFrZXMgbXVsdGlwbGUgcmVnZXgvZXh0cmFjdG9yIHBhaXJzIHRvIHRyeSBpbiBzZXF1ZW5jZS5cbiAqIEV4dHJhY3RvcnMgY2FuIHRha2UgYSBcImN1cnNvclwiIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0IGluIHRoZSBtYXRjaCB0byBsb29rIGF0LiBUaGlzIG1ha2VzIGl0IGVhc3kgdG8gY29tYmluZSBleHRyYWN0b3JzLlxuICogY29tYmluZUV4dHJhY3RvcnMoKSBkb2VzIHRoZSB3b3JrIG9mIGNvbWJpbmluZyB0aGVtLCBrZWVwaW5nIHRyYWNrIG9mIHRoZSBjdXJzb3IgdGhyb3VnaCBtdWx0aXBsZSBleHRyYWN0aW9ucy5cbiAqIFNvbWUgZXh0cmFjdGlvbnMgYXJlIHN1cGVyIGR1bWIgYW5kIHNpbXBsZVBhcnNlIGFuZCBmcm9tU3RyaW5ncyBoZWxwIERSWSB0aGVtLlxuICovXG5cbmZ1bmN0aW9uIGNvbWJpbmVSZWdleGVzKC4uLnJlZ2V4ZXMpIHtcbiAgY29uc3QgZnVsbCA9IHJlZ2V4ZXMucmVkdWNlKChmLCByKSA9PiBmICsgci5zb3VyY2UsIFwiXCIpO1xuICByZXR1cm4gUmVnRXhwKGBeJHtmdWxsfSRgKTtcbn1cblxuZnVuY3Rpb24gY29tYmluZUV4dHJhY3RvcnMoLi4uZXh0cmFjdG9ycykge1xuICByZXR1cm4gKG0pID0+XG4gICAgZXh0cmFjdG9yc1xuICAgICAgLnJlZHVjZShcbiAgICAgICAgKFttZXJnZWRWYWxzLCBtZXJnZWRab25lLCBjdXJzb3JdLCBleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IFt2YWwsIHpvbmUsIG5leHRdID0gZXgobSwgY3Vyc29yKTtcbiAgICAgICAgICByZXR1cm4gW3sgLi4ubWVyZ2VkVmFscywgLi4udmFsIH0sIG1lcmdlZFpvbmUgfHwgem9uZSwgbmV4dF07XG4gICAgICAgIH0sXG4gICAgICAgIFt7fSwgbnVsbCwgMV1cbiAgICAgIClcbiAgICAgIC5zbGljZSgwLCAyKTtcbn1cblxuZnVuY3Rpb24gcGFyc2UocywgLi4ucGF0dGVybnMpIHtcbiAgaWYgKHMgPT0gbnVsbCkge1xuICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gIH1cblxuICBmb3IgKGNvbnN0IFtyZWdleCwgZXh0cmFjdG9yXSBvZiBwYXR0ZXJucykge1xuICAgIGNvbnN0IG0gPSByZWdleC5leGVjKHMpO1xuICAgIGlmIChtKSB7XG4gICAgICByZXR1cm4gZXh0cmFjdG9yKG0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW251bGwsIG51bGxdO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVQYXJzZSguLi5rZXlzKSB7XG4gIHJldHVybiAobWF0Y2gsIGN1cnNvcikgPT4ge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldFtrZXlzW2ldXSA9IHBhcnNlSW50ZWdlcihtYXRjaFtjdXJzb3IgKyBpXSk7XG4gICAgfVxuICAgIHJldHVybiBbcmV0LCBudWxsLCBjdXJzb3IgKyBpXTtcbiAgfTtcbn1cblxuLy8gSVNPIGFuZCBTUUwgcGFyc2luZ1xuY29uc3Qgb2Zmc2V0UmVnZXggPSAvKD86KFopfChbKy1dXFxkXFxkKSg/Ojo/KFxcZFxcZCkpPykvLFxuICBpc29UaW1lQmFzZVJlZ2V4ID0gLyhcXGRcXGQpKD86Oj8oXFxkXFxkKSg/Ojo/KFxcZFxcZCkoPzpbLixdKFxcZHsxLDMwfSkpPyk/KT8vLFxuICBpc29UaW1lUmVnZXggPSBSZWdFeHAoYCR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9JHtvZmZzZXRSZWdleC5zb3VyY2V9P2ApLFxuICBpc29UaW1lRXh0ZW5zaW9uUmVnZXggPSBSZWdFeHAoYCg/OlQke2lzb1RpbWVSZWdleC5zb3VyY2V9KT9gKSxcbiAgaXNvWW1kUmVnZXggPSAvKFsrLV1cXGR7Nn18XFxkezR9KSg/Oi0/KFxcZFxcZCkoPzotPyhcXGRcXGQpKT8pPy8sXG4gIGlzb1dlZWtSZWdleCA9IC8oXFxkezR9KS0/VyhcXGRcXGQpKD86LT8oXFxkKSk/LyxcbiAgaXNvT3JkaW5hbFJlZ2V4ID0gLyhcXGR7NH0pLT8oXFxkezN9KS8sXG4gIGV4dHJhY3RJU09XZWVrRGF0YSA9IHNpbXBsZVBhcnNlKFwid2Vla1llYXJcIiwgXCJ3ZWVrTnVtYmVyXCIsIFwid2Vla0RheVwiKSxcbiAgZXh0cmFjdElTT09yZGluYWxEYXRhID0gc2ltcGxlUGFyc2UoXCJ5ZWFyXCIsIFwib3JkaW5hbFwiKSxcbiAgc3FsWW1kUmVnZXggPSAvKFxcZHs0fSktKFxcZFxcZCktKFxcZFxcZCkvLCAvLyBkdW1iZWQtZG93biB2ZXJzaW9uIG9mIHRoZSBJU08gb25lXG4gIHNxbFRpbWVSZWdleCA9IFJlZ0V4cChcbiAgICBgJHtpc29UaW1lQmFzZVJlZ2V4LnNvdXJjZX0gPyg/OiR7b2Zmc2V0UmVnZXguc291cmNlfXwoJHtpYW5hUmVnZXguc291cmNlfSkpP2BcbiAgKSxcbiAgc3FsVGltZUV4dGVuc2lvblJlZ2V4ID0gUmVnRXhwKGAoPzogJHtzcWxUaW1lUmVnZXguc291cmNlfSk/YCk7XG5cbmZ1bmN0aW9uIGludChtYXRjaCwgcG9zLCBmYWxsYmFjaykge1xuICBjb25zdCBtID0gbWF0Y2hbcG9zXTtcbiAgcmV0dXJuIGlzVW5kZWZpbmVkKG0pID8gZmFsbGJhY2sgOiBwYXJzZUludGVnZXIobSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09ZbWQobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBpdGVtID0ge1xuICAgIHllYXI6IGludChtYXRjaCwgY3Vyc29yKSxcbiAgICBtb250aDogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAxKSxcbiAgICBkYXk6IGludChtYXRjaCwgY3Vyc29yICsgMiwgMSksXG4gIH07XG5cbiAgcmV0dXJuIFtpdGVtLCBudWxsLCBjdXJzb3IgKyAzXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdElTT1RpbWUobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBpdGVtID0ge1xuICAgIGhvdXJzOiBpbnQobWF0Y2gsIGN1cnNvciwgMCksXG4gICAgbWludXRlczogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAwKSxcbiAgICBzZWNvbmRzOiBpbnQobWF0Y2gsIGN1cnNvciArIDIsIDApLFxuICAgIG1pbGxpc2Vjb25kczogcGFyc2VNaWxsaXMobWF0Y2hbY3Vyc29yICsgM10pLFxuICB9O1xuXG4gIHJldHVybiBbaXRlbSwgbnVsbCwgY3Vyc29yICsgNF07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09PZmZzZXQobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBsb2NhbCA9ICFtYXRjaFtjdXJzb3JdICYmICFtYXRjaFtjdXJzb3IgKyAxXSxcbiAgICBmdWxsT2Zmc2V0ID0gc2lnbmVkT2Zmc2V0KG1hdGNoW2N1cnNvciArIDFdLCBtYXRjaFtjdXJzb3IgKyAyXSksXG4gICAgem9uZSA9IGxvY2FsID8gbnVsbCA6IEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShmdWxsT2Zmc2V0KTtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgM107XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJQU5BWm9uZShtYXRjaCwgY3Vyc29yKSB7XG4gIGNvbnN0IHpvbmUgPSBtYXRjaFtjdXJzb3JdID8gSUFOQVpvbmUuY3JlYXRlKG1hdGNoW2N1cnNvcl0pIDogbnVsbDtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgMV07XG59XG5cbi8vIElTTyB0aW1lIHBhcnNpbmdcblxuY29uc3QgaXNvVGltZU9ubHkgPSBSZWdFeHAoYF5UPyR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9JGApO1xuXG4vLyBJU08gZHVyYXRpb24gcGFyc2luZ1xuXG5jb25zdCBpc29EdXJhdGlvbiA9XG4gIC9eLT9QKD86KD86KC0/XFxkezEsOX0oPzpcXC5cXGR7MSw5fSk/KVkpPyg/OigtP1xcZHsxLDl9KD86XFwuXFxkezEsOX0pPylNKT8oPzooLT9cXGR7MSw5fSg/OlxcLlxcZHsxLDl9KT8pVyk/KD86KC0/XFxkezEsOX0oPzpcXC5cXGR7MSw5fSk/KUQpPyg/OlQoPzooLT9cXGR7MSw5fSg/OlxcLlxcZHsxLDl9KT8pSCk/KD86KC0/XFxkezEsOX0oPzpcXC5cXGR7MSw5fSk/KU0pPyg/OigtP1xcZHsxLDIwfSkoPzpbLixdKC0/XFxkezEsOX0pKT9TKT8pPykkLztcblxuZnVuY3Rpb24gZXh0cmFjdElTT0R1cmF0aW9uKG1hdGNoKSB7XG4gIGNvbnN0IFtzLCB5ZWFyU3RyLCBtb250aFN0ciwgd2Vla1N0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0ciwgbWlsbGlzZWNvbmRzU3RyXSA9XG4gICAgbWF0Y2g7XG5cbiAgY29uc3QgaGFzTmVnYXRpdmVQcmVmaXggPSBzWzBdID09PSBcIi1cIjtcbiAgY29uc3QgbmVnYXRpdmVTZWNvbmRzID0gc2Vjb25kU3RyICYmIHNlY29uZFN0clswXSA9PT0gXCItXCI7XG5cbiAgY29uc3QgbWF5YmVOZWdhdGUgPSAobnVtLCBmb3JjZSA9IGZhbHNlKSA9PlxuICAgIG51bSAhPT0gdW5kZWZpbmVkICYmIChmb3JjZSB8fCAobnVtICYmIGhhc05lZ2F0aXZlUHJlZml4KSkgPyAtbnVtIDogbnVtO1xuXG4gIHJldHVybiBbXG4gICAge1xuICAgICAgeWVhcnM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcoeWVhclN0cikpLFxuICAgICAgbW9udGhzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKG1vbnRoU3RyKSksXG4gICAgICB3ZWVrczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyh3ZWVrU3RyKSksXG4gICAgICBkYXlzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKGRheVN0cikpLFxuICAgICAgaG91cnM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcoaG91clN0cikpLFxuICAgICAgbWludXRlczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhtaW51dGVTdHIpKSxcbiAgICAgIHNlY29uZHM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcoc2Vjb25kU3RyKSwgc2Vjb25kU3RyID09PSBcIi0wXCIpLFxuICAgICAgbWlsbGlzZWNvbmRzOiBtYXliZU5lZ2F0ZShwYXJzZU1pbGxpcyhtaWxsaXNlY29uZHNTdHIpLCBuZWdhdGl2ZVNlY29uZHMpLFxuICAgIH0sXG4gIF07XG59XG5cbi8vIFRoZXNlIGFyZSBhIGxpdHRsZSBicmFpbmRlYWQuIEVEVCAqc2hvdWxkKiB0ZWxsIHVzIHRoYXQgd2UncmUgaW4sIHNheSwgQW1lcmljYS9OZXdfWW9ya1xuLy8gYW5kIG5vdCBqdXN0IHRoYXQgd2UncmUgaW4gLTI0MCAqcmlnaHQgbm93Ki4gQnV0IHNpbmNlIEkgZG9uJ3QgdGhpbmsgdGhlc2UgYXJlIHVzZWQgdGhhdCBvZnRlblxuLy8gSSdtIGp1c3QgZ29pbmcgdG8gaWdub3JlIHRoYXRcbmNvbnN0IG9ic09mZnNldHMgPSB7XG4gIEdNVDogMCxcbiAgRURUOiAtNCAqIDYwLFxuICBFU1Q6IC01ICogNjAsXG4gIENEVDogLTUgKiA2MCxcbiAgQ1NUOiAtNiAqIDYwLFxuICBNRFQ6IC02ICogNjAsXG4gIE1TVDogLTcgKiA2MCxcbiAgUERUOiAtNyAqIDYwLFxuICBQU1Q6IC04ICogNjAsXG59O1xuXG5mdW5jdGlvbiBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cikge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgeWVhcjogeWVhclN0ci5sZW5ndGggPT09IDIgPyB1bnRydW5jYXRlWWVhcihwYXJzZUludGVnZXIoeWVhclN0cikpIDogcGFyc2VJbnRlZ2VyKHllYXJTdHIpLFxuICAgIG1vbnRoOiBFbmdsaXNoLm1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpICsgMSxcbiAgICBkYXk6IHBhcnNlSW50ZWdlcihkYXlTdHIpLFxuICAgIGhvdXI6IHBhcnNlSW50ZWdlcihob3VyU3RyKSxcbiAgICBtaW51dGU6IHBhcnNlSW50ZWdlcihtaW51dGVTdHIpLFxuICB9O1xuXG4gIGlmIChzZWNvbmRTdHIpIHJlc3VsdC5zZWNvbmQgPSBwYXJzZUludGVnZXIoc2Vjb25kU3RyKTtcbiAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICByZXN1bHQud2Vla2RheSA9XG4gICAgICB3ZWVrZGF5U3RyLmxlbmd0aCA+IDNcbiAgICAgICAgPyBFbmdsaXNoLndlZWtkYXlzTG9uZy5pbmRleE9mKHdlZWtkYXlTdHIpICsgMVxuICAgICAgICA6IEVuZ2xpc2gud2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpICsgMTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIFJGQyAyODIyLzUzMjJcbmNvbnN0IHJmYzI4MjIgPVxuICAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLFxccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoPzooWystXVxcZFxcZCkoXFxkXFxkKSkpJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RSRkMyODIyKG1hdGNoKSB7XG4gIGNvbnN0IFtcbiAgICAgICxcbiAgICAgIHdlZWtkYXlTdHIsXG4gICAgICBkYXlTdHIsXG4gICAgICBtb250aFN0cixcbiAgICAgIHllYXJTdHIsXG4gICAgICBob3VyU3RyLFxuICAgICAgbWludXRlU3RyLFxuICAgICAgc2Vjb25kU3RyLFxuICAgICAgb2JzT2Zmc2V0LFxuICAgICAgbWlsT2Zmc2V0LFxuICAgICAgb2ZmSG91clN0cixcbiAgICAgIG9mZk1pbnV0ZVN0cixcbiAgICBdID0gbWF0Y2gsXG4gICAgcmVzdWx0ID0gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpO1xuXG4gIGxldCBvZmZzZXQ7XG4gIGlmIChvYnNPZmZzZXQpIHtcbiAgICBvZmZzZXQgPSBvYnNPZmZzZXRzW29ic09mZnNldF07XG4gIH0gZWxzZSBpZiAobWlsT2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gMDtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXQgPSBzaWduZWRPZmZzZXQob2ZmSG91clN0ciwgb2ZmTWludXRlU3RyKTtcbiAgfVxuXG4gIHJldHVybiBbcmVzdWx0LCBuZXcgRml4ZWRPZmZzZXRab25lKG9mZnNldCldO1xufVxuXG5mdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gIHJldHVybiBzXG4gICAgLnJlcGxhY2UoL1xcKFteKV0qXFwpfFtcXG5cXHRdL2csIFwiIFwiKVxuICAgIC5yZXBsYWNlKC8oXFxzXFxzKykvZywgXCIgXCIpXG4gICAgLnRyaW0oKTtcbn1cblxuLy8gaHR0cCBkYXRlXG5cbmNvbnN0IHJmYzExMjMgPVxuICAgIC9eKE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksIChcXGRcXGQpIChKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYykgKFxcZHs0fSkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgR01UJC8sXG4gIHJmYzg1MCA9XG4gICAgL14oTW9uZGF5fFR1ZXNkYXl8V2Vkc2RheXxUaHVyc2RheXxGcmlkYXl8U2F0dXJkYXl8U3VuZGF5KSwgKFxcZFxcZCktKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKS0oXFxkXFxkKSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSBHTVQkLyxcbiAgYXNjaWkgPVxuICAgIC9eKE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1bikgKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKSAoIFxcZHxcXGRcXGQpIChcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpIChcXGR7NH0pJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RSRkMxMTIzT3I4NTAobWF0Y2gpIHtcbiAgY29uc3QgWywgd2Vla2RheVN0ciwgZGF5U3RyLCBtb250aFN0ciwgeWVhclN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHJdID0gbWF0Y2gsXG4gICAgcmVzdWx0ID0gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpO1xuICByZXR1cm4gW3Jlc3VsdCwgRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEFTQ0lJKG1hdGNoKSB7XG4gIGNvbnN0IFssIHdlZWtkYXlTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyLCB5ZWFyU3RyXSA9IG1hdGNoLFxuICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcbiAgcmV0dXJuIFtyZXN1bHQsIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZV07XG59XG5cbmNvbnN0IGlzb1ltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29ZbWRSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IGlzb1dlZWtXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvV2Vla1JlZ2V4LCBpc29UaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3QgaXNvT3JkaW5hbFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29PcmRpbmFsUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBpc29UaW1lQ29tYmluZWRSZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1RpbWVSZWdleCk7XG5cbmNvbnN0IGV4dHJhY3RJU09ZbWRUaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09ZbWQsXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0XG4pO1xuY29uc3QgZXh0cmFjdElTT1dlZWtUaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09XZWVrRGF0YSxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXRcbik7XG5jb25zdCBleHRyYWN0SVNPT3JkaW5hbERhdGVBbmRUaW1lID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09PcmRpbmFsRGF0YSxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXRcbik7XG5jb25zdCBleHRyYWN0SVNPVGltZUFuZE9mZnNldCA9IGNvbWJpbmVFeHRyYWN0b3JzKGV4dHJhY3RJU09UaW1lLCBleHRyYWN0SVNPT2Zmc2V0KTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlTT0RhdGUocykge1xuICByZXR1cm4gcGFyc2UoXG4gICAgcyxcbiAgICBbaXNvWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXRdLFxuICAgIFtpc29XZWVrV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT1dlZWtUaW1lQW5kT2Zmc2V0XSxcbiAgICBbaXNvT3JkaW5hbFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09PcmRpbmFsRGF0ZUFuZFRpbWVdLFxuICAgIFtpc29UaW1lQ29tYmluZWRSZWdleCwgZXh0cmFjdElTT1RpbWVBbmRPZmZzZXRdXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJGQzI4MjJEYXRlKHMpIHtcbiAgcmV0dXJuIHBhcnNlKHByZXByb2Nlc3NSRkMyODIyKHMpLCBbcmZjMjgyMiwgZXh0cmFjdFJGQzI4MjJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSFRUUERhdGUocykge1xuICByZXR1cm4gcGFyc2UoXG4gICAgcyxcbiAgICBbcmZjMTEyMywgZXh0cmFjdFJGQzExMjNPcjg1MF0sXG4gICAgW3JmYzg1MCwgZXh0cmFjdFJGQzExMjNPcjg1MF0sXG4gICAgW2FzY2lpLCBleHRyYWN0QVNDSUldXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlTT0R1cmF0aW9uKHMpIHtcbiAgcmV0dXJuIHBhcnNlKHMsIFtpc29EdXJhdGlvbiwgZXh0cmFjdElTT0R1cmF0aW9uXSk7XG59XG5cbmNvbnN0IGV4dHJhY3RJU09UaW1lT25seSA9IGNvbWJpbmVFeHRyYWN0b3JzKGV4dHJhY3RJU09UaW1lKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPVGltZU9ubHkocykge1xuICByZXR1cm4gcGFyc2UocywgW2lzb1RpbWVPbmx5LCBleHRyYWN0SVNPVGltZU9ubHldKTtcbn1cblxuY29uc3Qgc3FsWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKHNxbFltZFJlZ2V4LCBzcWxUaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3Qgc3FsVGltZUNvbWJpbmVkUmVnZXggPSBjb21iaW5lUmVnZXhlcyhzcWxUaW1lUmVnZXgpO1xuXG5jb25zdCBleHRyYWN0SVNPWW1kVGltZU9mZnNldEFuZElBTkFab25lID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09ZbWQsXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5jb25zdCBleHRyYWN0SVNPVGltZU9mZnNldEFuZElBTkFab25lID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNRTChzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtzcWxZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPWW1kVGltZU9mZnNldEFuZElBTkFab25lXSxcbiAgICBbc3FsVGltZUNvbWJpbmVkUmVnZXgsIGV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmVdXG4gICk7XG59XG4iLCAiaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIEludmFsaWREdXJhdGlvbkVycm9yLCBJbnZhbGlkVW5pdEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbXBsL2ludmFsaWQuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCB7IHBhcnNlSVNPRHVyYXRpb24sIHBhcnNlSVNPVGltZU9ubHkgfSBmcm9tIFwiLi9pbXBsL3JlZ2V4UGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBhc051bWJlcixcbiAgaGFzT3duUHJvcGVydHksXG4gIGlzSW50ZWdlcixcbiAgaXNOdW1iZXIsXG4gIGlzVW5kZWZpbmVkLFxuICBub3JtYWxpemVPYmplY3QsXG4gIHJvdW5kVG8sXG59IGZyb20gXCIuL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgRHVyYXRpb25cIjtcblxuLy8gdW5pdCBjb252ZXJzaW9uIGNvbnN0YW50c1xuZXhwb3J0IGNvbnN0IGxvd09yZGVyTWF0cml4ID0ge1xuICAgIHdlZWtzOiB7XG4gICAgICBkYXlzOiA3LFxuICAgICAgaG91cnM6IDcgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDcgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBkYXlzOiB7XG4gICAgICBob3VyczogMjQsXG4gICAgICBtaW51dGVzOiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgaG91cnM6IHsgbWludXRlczogNjAsIHNlY29uZHM6IDYwICogNjAsIG1pbGxpc2Vjb25kczogNjAgKiA2MCAqIDEwMDAgfSxcbiAgICBtaW51dGVzOiB7IHNlY29uZHM6IDYwLCBtaWxsaXNlY29uZHM6IDYwICogMTAwMCB9LFxuICAgIHNlY29uZHM6IHsgbWlsbGlzZWNvbmRzOiAxMDAwIH0sXG4gIH0sXG4gIGNhc3VhbE1hdHJpeCA9IHtcbiAgICB5ZWFyczoge1xuICAgICAgcXVhcnRlcnM6IDQsXG4gICAgICBtb250aHM6IDEyLFxuICAgICAgd2Vla3M6IDUyLFxuICAgICAgZGF5czogMzY1LFxuICAgICAgaG91cnM6IDM2NSAqIDI0LFxuICAgICAgbWludXRlczogMzY1ICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDM2NSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIHF1YXJ0ZXJzOiB7XG4gICAgICBtb250aHM6IDMsXG4gICAgICB3ZWVrczogMTMsXG4gICAgICBkYXlzOiA5MSxcbiAgICAgIGhvdXJzOiA5MSAqIDI0LFxuICAgICAgbWludXRlczogOTEgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogOTEgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDkxICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIG1vbnRoczoge1xuICAgICAgd2Vla3M6IDQsXG4gICAgICBkYXlzOiAzMCxcbiAgICAgIGhvdXJzOiAzMCAqIDI0LFxuICAgICAgbWludXRlczogMzAgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMzAgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDMwICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuXG4gICAgLi4ubG93T3JkZXJNYXRyaXgsXG4gIH0sXG4gIGRheXNJblllYXJBY2N1cmF0ZSA9IDE0NjA5Ny4wIC8gNDAwLFxuICBkYXlzSW5Nb250aEFjY3VyYXRlID0gMTQ2MDk3LjAgLyA0ODAwLFxuICBhY2N1cmF0ZU1hdHJpeCA9IHtcbiAgICB5ZWFyczoge1xuICAgICAgcXVhcnRlcnM6IDQsXG4gICAgICBtb250aHM6IDEyLFxuICAgICAgd2Vla3M6IGRheXNJblllYXJBY2N1cmF0ZSAvIDcsXG4gICAgICBkYXlzOiBkYXlzSW5ZZWFyQWNjdXJhdGUsXG4gICAgICBob3VyczogZGF5c0luWWVhckFjY3VyYXRlICogMjQsXG4gICAgICBtaW51dGVzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgcXVhcnRlcnM6IHtcbiAgICAgIG1vbnRoczogMyxcbiAgICAgIHdlZWtzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyAyOCxcbiAgICAgIGRheXM6IGRheXNJblllYXJBY2N1cmF0ZSAvIDQsXG4gICAgICBob3VyczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0KSAvIDQsXG4gICAgICBtaW51dGVzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCkgLyA0LFxuICAgICAgc2Vjb25kczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCkgLyA0LFxuICAgICAgbWlsbGlzZWNvbmRzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMCkgLyA0LFxuICAgIH0sXG4gICAgbW9udGhzOiB7XG4gICAgICB3ZWVrczogZGF5c0luTW9udGhBY2N1cmF0ZSAvIDcsXG4gICAgICBkYXlzOiBkYXlzSW5Nb250aEFjY3VyYXRlLFxuICAgICAgaG91cnM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICAuLi5sb3dPcmRlck1hdHJpeCxcbiAgfTtcblxuLy8gdW5pdHMgb3JkZXJlZCBieSBzaXplXG5jb25zdCBvcmRlcmVkVW5pdHMgPSBbXG4gIFwieWVhcnNcIixcbiAgXCJxdWFydGVyc1wiLFxuICBcIm1vbnRoc1wiLFxuICBcIndlZWtzXCIsXG4gIFwiZGF5c1wiLFxuICBcImhvdXJzXCIsXG4gIFwibWludXRlc1wiLFxuICBcInNlY29uZHNcIixcbiAgXCJtaWxsaXNlY29uZHNcIixcbl07XG5cbmNvbnN0IHJldmVyc2VVbml0cyA9IG9yZGVyZWRVbml0cy5zbGljZSgwKS5yZXZlcnNlKCk7XG5cbi8vIGNsb25lIHJlYWxseSBtZWFucyBcImNyZWF0ZSBhbm90aGVyIGluc3RhbmNlIGp1c3QgbGlrZSB0aGlzIG9uZSwgYnV0IHdpdGggdGhlc2UgY2hhbmdlc1wiXG5mdW5jdGlvbiBjbG9uZShkdXIsIGFsdHMsIGNsZWFyID0gZmFsc2UpIHtcbiAgLy8gZGVlcCBtZXJnZSBmb3IgdmFsc1xuICBjb25zdCBjb25mID0ge1xuICAgIHZhbHVlczogY2xlYXIgPyBhbHRzLnZhbHVlcyA6IHsgLi4uZHVyLnZhbHVlcywgLi4uKGFsdHMudmFsdWVzIHx8IHt9KSB9LFxuICAgIGxvYzogZHVyLmxvYy5jbG9uZShhbHRzLmxvYyksXG4gICAgY29udmVyc2lvbkFjY3VyYWN5OiBhbHRzLmNvbnZlcnNpb25BY2N1cmFjeSB8fCBkdXIuY29udmVyc2lvbkFjY3VyYWN5LFxuICB9O1xuICByZXR1cm4gbmV3IER1cmF0aW9uKGNvbmYpO1xufVxuXG5mdW5jdGlvbiBhbnRpVHJ1bmMobikge1xuICByZXR1cm4gbiA8IDAgPyBNYXRoLmZsb29yKG4pIDogTWF0aC5jZWlsKG4pO1xufVxuXG4vLyBOQjogbXV0YXRlcyBwYXJhbWV0ZXJzXG5mdW5jdGlvbiBjb252ZXJ0KG1hdHJpeCwgZnJvbU1hcCwgZnJvbVVuaXQsIHRvTWFwLCB0b1VuaXQpIHtcbiAgY29uc3QgY29udiA9IG1hdHJpeFt0b1VuaXRdW2Zyb21Vbml0XSxcbiAgICByYXcgPSBmcm9tTWFwW2Zyb21Vbml0XSAvIGNvbnYsXG4gICAgc2FtZVNpZ24gPSBNYXRoLnNpZ24ocmF3KSA9PT0gTWF0aC5zaWduKHRvTWFwW3RvVW5pdF0pLFxuICAgIC8vIG9rLCBzbyB0aGlzIGlzIHdpbGQsIGJ1dCBzZWUgdGhlIG1hdHJpeCBpbiB0aGUgdGVzdHNcbiAgICBhZGRlZCA9XG4gICAgICAhc2FtZVNpZ24gJiYgdG9NYXBbdG9Vbml0XSAhPT0gMCAmJiBNYXRoLmFicyhyYXcpIDw9IDEgPyBhbnRpVHJ1bmMocmF3KSA6IE1hdGgudHJ1bmMocmF3KTtcbiAgdG9NYXBbdG9Vbml0XSArPSBhZGRlZDtcbiAgZnJvbU1hcFtmcm9tVW5pdF0gLT0gYWRkZWQgKiBjb252O1xufVxuXG4vLyBOQjogbXV0YXRlcyBwYXJhbWV0ZXJzXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZXMobWF0cml4LCB2YWxzKSB7XG4gIHJldmVyc2VVbml0cy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh2YWxzW2N1cnJlbnRdKSkge1xuICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgIGNvbnZlcnQobWF0cml4LCB2YWxzLCBwcmV2aW91cywgdmFscywgY3VycmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgIH1cbiAgfSwgbnVsbCk7XG59XG5cbi8qKlxuICogQSBEdXJhdGlvbiBvYmplY3QgcmVwcmVzZW50cyBhIHBlcmlvZCBvZiB0aW1lLCBsaWtlIFwiMiBtb250aHNcIiBvciBcIjEgZGF5LCAxIGhvdXJcIi4gQ29uY2VwdHVhbGx5LCBpdCdzIGp1c3QgYSBtYXAgb2YgdW5pdHMgdG8gdGhlaXIgcXVhbnRpdGllcywgYWNjb21wYW5pZWQgYnkgc29tZSBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gYW5kIG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBwYXJzaW5nLCBpbnRlcnJvZ2F0aW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uIFRoZXkgY2FuIGJlIHVzZWQgb24gdGhlaXIgb3duIG9yIGluIGNvbmp1bmN0aW9uIHdpdGggb3RoZXIgTHV4b24gdHlwZXM7IGZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSB7QGxpbmsgRGF0ZVRpbWUjcGx1c30gdG8gYWRkIGEgRHVyYXRpb24gb2JqZWN0IHRvIGEgRGF0ZVRpbWUsIHByb2R1Y2luZyBhbm90aGVyIERhdGVUaW1lLlxuICpcbiAqIEhlcmUgaXMgYSBicmllZiBvdmVydmlldyBvZiBjb21tb25seSB1c2VkIG1ldGhvZHMgYW5kIGdldHRlcnMgaW4gRHVyYXRpb246XG4gKlxuICogKiAqKkNyZWF0aW9uKiogVG8gY3JlYXRlIGEgRHVyYXRpb24sIHVzZSB7QGxpbmsgRHVyYXRpb24jZnJvbU1pbGxpc30sIHtAbGluayBEdXJhdGlvbiNmcm9tT2JqZWN0fSwgb3Ige0BsaW5rIER1cmF0aW9uI2Zyb21JU099LlxuICogKiAqKlVuaXQgdmFsdWVzKiogU2VlIHRoZSB7QGxpbmsgRHVyYXRpb24jeWVhcnN9LCB7QGxpbmsgRHVyYXRpb24ubW9udGhzfSwge0BsaW5rIER1cmF0aW9uI3dlZWtzfSwge0BsaW5rIER1cmF0aW9uI2RheXN9LCB7QGxpbmsgRHVyYXRpb24jaG91cnN9LCB7QGxpbmsgRHVyYXRpb24jbWludXRlc30sIHtAbGluayBEdXJhdGlvbiNzZWNvbmRzfSwge0BsaW5rIER1cmF0aW9uI21pbGxpc2Vjb25kc30gYWNjZXNzb3JzLlxuICogKiAqKkNvbmZpZ3VyYXRpb24qKiBTZWUgIHtAbGluayBEdXJhdGlvbiNsb2NhbGV9IGFuZCB7QGxpbmsgRHVyYXRpb24jbnVtYmVyaW5nU3lzdGVtfSBhY2Nlc3NvcnMuXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKiBUbyBjcmVhdGUgbmV3IER1cmF0aW9ucyBvdXQgb2Ygb2xkIG9uZXMgdXNlIHtAbGluayBEdXJhdGlvbiNwbHVzfSwge0BsaW5rIER1cmF0aW9uI21pbnVzfSwge0BsaW5rIER1cmF0aW9uI25vcm1hbGl6ZX0sIHtAbGluayBEdXJhdGlvbiNzZXR9LCB7QGxpbmsgRHVyYXRpb24jcmVjb25maWd1cmV9LCB7QGxpbmsgRHVyYXRpb24jc2hpZnRUb30sIGFuZCB7QGxpbmsgRHVyYXRpb24jbmVnYXRlfS5cbiAqICogKipPdXRwdXQqKiBUbyBjb252ZXJ0IHRoZSBEdXJhdGlvbiBpbnRvIG90aGVyIHJlcHJlc2VudGF0aW9ucywgc2VlIHtAbGluayBEdXJhdGlvbiNhc30sIHtAbGluayBEdXJhdGlvbiN0b0lTT30sIHtAbGluayBEdXJhdGlvbiN0b0Zvcm1hdH0sIGFuZCB7QGxpbmsgRHVyYXRpb24jdG9KU09OfVxuICpcbiAqIFRoZXJlJ3MgYXJlIG1vcmUgbWV0aG9kcyBkb2N1bWVudGVkIGJlbG93LiBJbiBhZGRpdGlvbiwgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc3VidGxlciB0b3BpY3MgbGlrZSBpbnRlcm5hdGlvbmFsaXphdGlvbiBhbmQgdmFsaWRpdHksIHNlZSB0aGUgZXh0ZXJuYWwgZG9jdW1lbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHVyYXRpb24ge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGNvbnN0IGFjY3VyYXRlID0gY29uZmlnLmNvbnZlcnNpb25BY2N1cmFjeSA9PT0gXCJsb25ndGVybVwiIHx8IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmFsdWVzID0gY29uZmlnLnZhbHVlcztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxvYyA9IGNvbmZpZy5sb2MgfHwgTG9jYWxlLmNyZWF0ZSgpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY29udmVyc2lvbkFjY3VyYWN5ID0gYWNjdXJhdGUgPyBcImxvbmd0ZXJtXCIgOiBcImNhc3VhbFwiO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW52YWxpZCA9IGNvbmZpZy5pbnZhbGlkIHx8IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXRyaXggPSBhY2N1cmF0ZSA/IGFjY3VyYXRlTWF0cml4IDogY2FzdWFsTWF0cml4O1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNMdXhvbkR1cmF0aW9uID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgRHVyYXRpb24gZnJvbSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBvZiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21NaWxsaXMoY291bnQsIG9wdHMpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogY291bnQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFycycgYW5kICdob3VycycuXG4gICAqIElmIHRoaXMgb2JqZWN0IGlzIGVtcHR5IHRoZW4gYSB6ZXJvIG1pbGxpc2Vjb25kcyBkdXJhdGlvbiBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gY3JlYXRlIHRoZSBEYXRlVGltZSBmcm9tXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoueWVhcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5xdWFydGVyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1vbnRoc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouZGF5c1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmhvdXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWludXRlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnNlY29uZHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPVtdXSAtIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoaXMgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbU9iamVjdChvYmosIG9wdHMgPSB7fSkge1xuICAgIGlmIChvYmogPT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBEdXJhdGlvbi5mcm9tT2JqZWN0OiBhcmd1bWVudCBleHBlY3RlZCB0byBiZSBhbiBvYmplY3QsIGdvdCAke1xuICAgICAgICAgIG9iaiA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIG9ialxuICAgICAgICB9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IER1cmF0aW9uKHtcbiAgICAgIHZhbHVlczogbm9ybWFsaXplT2JqZWN0KG9iaiwgRHVyYXRpb24ubm9ybWFsaXplVW5pdCksXG4gICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpLFxuICAgICAgY29udmVyc2lvbkFjY3VyYWN5OiBvcHRzLmNvbnZlcnNpb25BY2N1cmFjeSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIER1cmF0aW9uTGlrZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3QgfCBudW1iZXIgfCBEdXJhdGlvbn0gZHVyYXRpb25MaWtlXG4gICAqIE9uZSBvZjpcbiAgICogLSBvYmplY3Qgd2l0aCBrZXlzIGxpa2UgJ3llYXJzJyBhbmQgJ2hvdXJzJy5cbiAgICogLSBudW1iZXIgcmVwcmVzZW50aW5nIG1pbGxpc2Vjb25kc1xuICAgKiAtIER1cmF0aW9uIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb25MaWtlKSB7XG4gICAgaWYgKGlzTnVtYmVyKGR1cmF0aW9uTGlrZSkpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tTWlsbGlzKGR1cmF0aW9uTGlrZSk7XG4gICAgfSBlbHNlIGlmIChEdXJhdGlvbi5pc0R1cmF0aW9uKGR1cmF0aW9uTGlrZSkpIHtcbiAgICAgIHJldHVybiBkdXJhdGlvbkxpa2U7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb25MaWtlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdChkdXJhdGlvbkxpa2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBVbmtub3duIGR1cmF0aW9uIGFyZ3VtZW50ICR7ZHVyYXRpb25MaWtlfSBvZiB0eXBlICR7dHlwZW9mIGR1cmF0aW9uTGlrZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGFuIElTTyA4NjAxIGR1cmF0aW9uIHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI0R1cmF0aW9uc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQM1k2TTFXNERUMTJIMzBNNVMnKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMywgbW9udGhzOiA2LCB3ZWVrczogMSwgZGF5czogNCwgaG91cnM6IDEyLCBtaW51dGVzOiAzMCwgc2Vjb25kczogNSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1BUMjNIJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDIzIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUDVZM00nKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogNSwgbW9udGhzOiAzIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzKSB7XG4gICAgY29uc3QgW3BhcnNlZF0gPSBwYXJzZUlTT0R1cmF0aW9uKHRleHQpO1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KHBhcnNlZCwgb3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGFuIElTTyA4NjAxIHRpbWUgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZXNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJzExOjIyOjMzLjQ0NCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMjIsIHNlY29uZHM6IDMzLCBtaWxsaXNlY29uZHM6IDQ0NCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCcxMTowMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCdUMTE6MDAnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnMTEwMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCdUMTEwMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21JU09UaW1lKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcGFyc2VkXSA9IHBhcnNlSVNPVGltZU9ubHkodGV4dCk7XG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QocGFyc2VkLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnZhbGlkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gc2ltcGxlIHN0cmluZyBvZiB3aHkgdGhpcyBkYXRldGltZSBpcyBpbnZhbGlkLiBTaG91bGQgbm90IGNvbnRhaW4gcGFyYW1ldGVycyBvciBhbnl0aGluZyBlbHNlIGRhdGEtZGVwZW5kZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwbGFuYXRpb249bnVsbF0gLSBsb25nZXIgZXhwbGFuYXRpb24sIG1heSBpbmNsdWRlIHBhcmFtZXRlcnMgYW5kIG90aGVyIHVzZWZ1bCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uID0gbnVsbCkge1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIER1cmF0aW9uIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IHJlYXNvbiBpbnN0YW5jZW9mIEludmFsaWQgPyByZWFzb24gOiBuZXcgSW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKTtcblxuICAgIGlmIChTZXR0aW5ncy50aHJvd09uSW52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREdXJhdGlvbkVycm9yKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IER1cmF0aW9uKHsgaW52YWxpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVVbml0KHVuaXQpIHtcbiAgICBjb25zdCBub3JtYWxpemVkID0ge1xuICAgICAgeWVhcjogXCJ5ZWFyc1wiLFxuICAgICAgeWVhcnM6IFwieWVhcnNcIixcbiAgICAgIHF1YXJ0ZXI6IFwicXVhcnRlcnNcIixcbiAgICAgIHF1YXJ0ZXJzOiBcInF1YXJ0ZXJzXCIsXG4gICAgICBtb250aDogXCJtb250aHNcIixcbiAgICAgIG1vbnRoczogXCJtb250aHNcIixcbiAgICAgIHdlZWs6IFwid2Vla3NcIixcbiAgICAgIHdlZWtzOiBcIndlZWtzXCIsXG4gICAgICBkYXk6IFwiZGF5c1wiLFxuICAgICAgZGF5czogXCJkYXlzXCIsXG4gICAgICBob3VyOiBcImhvdXJzXCIsXG4gICAgICBob3VyczogXCJob3Vyc1wiLFxuICAgICAgbWludXRlOiBcIm1pbnV0ZXNcIixcbiAgICAgIG1pbnV0ZXM6IFwibWludXRlc1wiLFxuICAgICAgc2Vjb25kOiBcInNlY29uZHNcIixcbiAgICAgIHNlY29uZHM6IFwic2Vjb25kc1wiLFxuICAgICAgbWlsbGlzZWNvbmQ6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBtaWxsaXNlY29uZHM6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgfVt1bml0ID8gdW5pdC50b0xvd2VyQ2FzZSgpIDogdW5pdF07XG5cbiAgICBpZiAoIW5vcm1hbGl6ZWQpIHRocm93IG5ldyBJbnZhbGlkVW5pdEVycm9yKHVuaXQpO1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGEgRHVyYXRpb24uIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0R1cmF0aW9uKG8pIHtcbiAgICByZXR1cm4gKG8gJiYgby5pc0x1eG9uRHVyYXRpb24pIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCAgdGhlIGxvY2FsZSBvZiBhIER1cmF0aW9uLCBzdWNoICdlbi1HQidcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBsb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLmxvY2FsZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXJpbmcgc3lzdGVtIG9mIGEgRHVyYXRpb24sIHN1Y2ggJ2JlbmcnLiBUaGUgbnVtYmVyaW5nIHN5c3RlbSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRHVyYXRpb25cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBudW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXQgc3RyaW5nLiBZb3UgbWF5IHVzZSB0aGVzZSB0b2tlbnM6XG4gICAqICogYFNgIGZvciBtaWxsaXNlY29uZHNcbiAgICogKiBgc2AgZm9yIHNlY29uZHNcbiAgICogKiBgbWAgZm9yIG1pbnV0ZXNcbiAgICogKiBgaGAgZm9yIGhvdXJzXG4gICAqICogYGRgIGZvciBkYXlzXG4gICAqICogYE1gIGZvciBtb250aHNcbiAgICogKiBgeWAgZm9yIHllYXJzXG4gICAqIE5vdGVzOlxuICAgKiAqIEFkZCBwYWRkaW5nIGJ5IHJlcGVhdGluZyB0aGUgdG9rZW4sIGUuZy4gXCJ5eVwiIHBhZHMgdGhlIHllYXJzIHRvIHR3byBkaWdpdHMsIFwiaGhoaFwiIHBhZHMgdGhlIGhvdXJzIG91dCB0byBmb3VyIGRpZ2l0c1xuICAgKiAqIFRoZSBkdXJhdGlvbiB3aWxsIGJlIGNvbnZlcnRlZCB0byB0aGUgc2V0IG9mIHVuaXRzIGluIHRoZSBmb3JtYXQgc3RyaW5nIHVzaW5nIHtAbGluayBEdXJhdGlvbiNzaGlmdFRvfSBhbmQgdGhlIER1cmF0aW9ucydzIGNvbnZlcnNpb24gYWNjdXJhY3kgc2V0dGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmZsb29yPXRydWVdIC0gZmxvb3IgbnVtZXJpY2FsIHZhbHVlc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5IGQgc1wiKSAvLz0+IFwiMSA2IDJcIlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5eSBkZCBzc3NcIikgLy89PiBcIjAxIDA2IDAwMlwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcIk0gU1wiKSAvLz0+IFwiMTIgNTE4NDAyMDAwXCJcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZm10LCBvcHRzID0ge30pIHtcbiAgICAvLyByZXZlcnNlLWNvbXBhdCBzaW5jZSAxLjI7IHdlIGFsd2F5cyByb3VuZCBkb3duIG5vdywgbmV2ZXIgdXAsIGFuZCB3ZSBkbyBpdCBieSBkZWZhdWx0XG4gICAgY29uc3QgZm10T3B0cyA9IHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBmbG9vcjogb3B0cy5yb3VuZCAhPT0gZmFsc2UgJiYgb3B0cy5mbG9vciAhPT0gZmFsc2UsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MsIGZtdE9wdHMpLmZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyh0aGlzLCBmbXQpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIER1cmF0aW9uIHdpdGggYWxsIHVuaXRzIGluY2x1ZGVkXG4gICAqIFRvIG1vZGlmeSBpdHMgYmVoYXZpb3IgdXNlIHRoZSBgbGlzdFN0eWxlYCBhbmQgYW55IEludGwuTnVtYmVyRm9ybWF0IG9wdGlvbiwgdGhvdWdoIGB1bml0RGlzcGxheWAgaXMgZXNwZWNpYWxseSByZWxldmFudC4gU2VlIHtAbGluayBJbnRsLk51bWJlckZvcm1hdH0uXG4gICAqIEBwYXJhbSBvcHRzIC0gT24gb3B0aW9uIG9iamVjdCB0byBvdmVycmlkZSB0aGUgZm9ybWF0dGluZy4gQWNjZXB0cyB0aGUgc2FtZSBrZXlzIGFzIHRoZSBvcHRpb25zIHBhcmFtZXRlciBvZiB0aGUgbmF0aXZlIGBJbnQuTnVtYmVyRm9ybWF0YCBjb25zdHJ1Y3RvciwgYXMgd2VsbCBhcyBgbGlzdFN0eWxlYC5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogdmFyIGR1ciA9IER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiAxLCBob3VyczogNSwgbWludXRlczogNiB9KVxuICAgKiBkdXIudG9IdW1hbigpIC8vPT4gJzEgZGF5LCA1IGhvdXJzLCA2IG1pbnV0ZXMnXG4gICAqIGR1ci50b0h1bWFuKHsgbGlzdFN0eWxlOiBcImxvbmdcIiB9KSAvLz0+ICcxIGRheSwgNSBob3VycywgYW5kIDYgbWludXRlcydcbiAgICogZHVyLnRvSHVtYW4oeyB1bml0RGlzcGxheTogXCJzaG9ydFwiIH0pIC8vPT4gJzEgZGF5LCA1IGhyLCA2IG1pbidcbiAgICogYGBgXG4gICAqL1xuICB0b0h1bWFuKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGwgPSBvcmRlcmVkVW5pdHNcbiAgICAgIC5tYXAoKHVuaXQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy52YWx1ZXNbdW5pdF07XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9jXG4gICAgICAgICAgLm51bWJlckZvcm1hdHRlcih7IHN0eWxlOiBcInVuaXRcIiwgdW5pdERpc3BsYXk6IFwibG9uZ1wiLCAuLi5vcHRzLCB1bml0OiB1bml0LnNsaWNlKDAsIC0xKSB9KVxuICAgICAgICAgIC5mb3JtYXQodmFsKTtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKChuKSA9PiBuKTtcblxuICAgIHJldHVybiB0aGlzLmxvY1xuICAgICAgLmxpc3RGb3JtYXR0ZXIoeyB0eXBlOiBcImNvbmp1bmN0aW9uXCIsIHN0eWxlOiBvcHRzLmxpc3RTdHlsZSB8fCBcIm5hcnJvd1wiLCAuLi5vcHRzIH0pXG4gICAgICAuZm9ybWF0KGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIHRoaXMgRHVyYXRpb24ncyB2YWx1ZXMuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvT2JqZWN0KCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4ge307XG4gICAgcmV0dXJuIHsgLi4udGhpcy52YWx1ZXMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbi5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNEdXJhdGlvbnNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAzLCBzZWNvbmRzOiA0NSB9KS50b0lTTygpIC8vPT4gJ1AzWVQ0NVMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDQsIHNlY29uZHM6IDQ1IH0pLnRvSVNPKCkgLy89PiAnUDRNVDQ1UydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogNSB9KS50b0lTTygpIC8vPT4gJ1A1TSdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbnV0ZXM6IDUgfSkudG9JU08oKSAvLz0+ICdQVDVNJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWlsbGlzZWNvbmRzOiA2IH0pLnRvSVNPKCkgLy89PiAnUFQwLjAwNlMnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPKCkge1xuICAgIC8vIHdlIGNvdWxkIHVzZSB0aGUgZm9ybWF0dGVyLCBidXQgdGhpcyBpcyBhbiBlYXNpZXIgd2F5IHRvIGdldCB0aGUgbWluaW11bSBzdHJpbmdcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG5cbiAgICBsZXQgcyA9IFwiUFwiO1xuICAgIGlmICh0aGlzLnllYXJzICE9PSAwKSBzICs9IHRoaXMueWVhcnMgKyBcIllcIjtcbiAgICBpZiAodGhpcy5tb250aHMgIT09IDAgfHwgdGhpcy5xdWFydGVycyAhPT0gMCkgcyArPSB0aGlzLm1vbnRocyArIHRoaXMucXVhcnRlcnMgKiAzICsgXCJNXCI7XG4gICAgaWYgKHRoaXMud2Vla3MgIT09IDApIHMgKz0gdGhpcy53ZWVrcyArIFwiV1wiO1xuICAgIGlmICh0aGlzLmRheXMgIT09IDApIHMgKz0gdGhpcy5kYXlzICsgXCJEXCI7XG4gICAgaWYgKHRoaXMuaG91cnMgIT09IDAgfHwgdGhpcy5taW51dGVzICE9PSAwIHx8IHRoaXMuc2Vjb25kcyAhPT0gMCB8fCB0aGlzLm1pbGxpc2Vjb25kcyAhPT0gMClcbiAgICAgIHMgKz0gXCJUXCI7XG4gICAgaWYgKHRoaXMuaG91cnMgIT09IDApIHMgKz0gdGhpcy5ob3VycyArIFwiSFwiO1xuICAgIGlmICh0aGlzLm1pbnV0ZXMgIT09IDApIHMgKz0gdGhpcy5taW51dGVzICsgXCJNXCI7XG4gICAgaWYgKHRoaXMuc2Vjb25kcyAhPT0gMCB8fCB0aGlzLm1pbGxpc2Vjb25kcyAhPT0gMClcbiAgICAgIC8vIHRoaXMgd2lsbCBoYW5kbGUgXCJmbG9hdGluZyBwb2ludCBtYWRuZXNzXCIgYnkgcmVtb3ZpbmcgZXh0cmEgZGVjaW1hbCBwbGFjZXNcbiAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU4ODAwNC9pcy1mbG9hdGluZy1wb2ludC1tYXRoLWJyb2tlblxuICAgICAgcyArPSByb3VuZFRvKHRoaXMuc2Vjb25kcyArIHRoaXMubWlsbGlzZWNvbmRzIC8gMTAwMCwgMykgKyBcIlNcIjtcbiAgICBpZiAocyA9PT0gXCJQXCIpIHMgKz0gXCJUMFNcIjtcbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiwgZm9ybWF0dGVkIGFzIGEgdGltZSBvZiBkYXkuXG4gICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIGR1cmF0aW9uIGlzIGludmFsaWQsIG5lZ2F0aXZlLCBvciBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMjQgaG91cnMuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NNaWxsaXNlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzU2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIHNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVQcmVmaXg9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgYFRgIHByZWZpeFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoKSAvLz0+ICcxMTowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgc3VwcHJlc3NNaWxsaXNlY29uZHM6IHRydWUgfSkgLy89PiAnMTE6MDA6MDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgc3VwcHJlc3NTZWNvbmRzOiB0cnVlIH0pIC8vPT4gJzExOjAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IGluY2x1ZGVQcmVmaXg6IHRydWUgfSkgLy89PiAnVDExOjAwOjAwLjAwMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMTEwMDAwLjAwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09UaW1lKG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IG1pbGxpcyA9IHRoaXMudG9NaWxsaXMoKTtcbiAgICBpZiAobWlsbGlzIDwgMCB8fCBtaWxsaXMgPj0gODY0MDAwMDApIHJldHVybiBudWxsO1xuXG4gICAgb3B0cyA9IHtcbiAgICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzOiBmYWxzZSxcbiAgICAgIHN1cHByZXNzU2Vjb25kczogZmFsc2UsXG4gICAgICBpbmNsdWRlUHJlZml4OiBmYWxzZSxcbiAgICAgIGZvcm1hdDogXCJleHRlbmRlZFwiLFxuICAgICAgLi4ub3B0cyxcbiAgICB9O1xuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnNoaWZ0VG8oXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCIpO1xuXG4gICAgbGV0IGZtdCA9IG9wdHMuZm9ybWF0ID09PSBcImJhc2ljXCIgPyBcImhobW1cIiA6IFwiaGg6bW1cIjtcblxuICAgIGlmICghb3B0cy5zdXBwcmVzc1NlY29uZHMgfHwgdmFsdWUuc2Vjb25kcyAhPT0gMCB8fCB2YWx1ZS5taWxsaXNlY29uZHMgIT09IDApIHtcbiAgICAgIGZtdCArPSBvcHRzLmZvcm1hdCA9PT0gXCJiYXNpY1wiID8gXCJzc1wiIDogXCI6c3NcIjtcbiAgICAgIGlmICghb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcyB8fCB2YWx1ZS5taWxsaXNlY29uZHMgIT09IDApIHtcbiAgICAgICAgZm10ICs9IFwiLlNTU1wiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzdHIgPSB2YWx1ZS50b0Zvcm1hdChmbXQpO1xuXG4gICAgaWYgKG9wdHMuaW5jbHVkZVByZWZpeCkge1xuICAgICAgc3RyID0gXCJUXCIgKyBzdHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBKU09OLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JU08oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBkZWJ1Z2dpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBtaWxsaXNlY29uZHMgdmFsdWUgb2YgdGhpcyBEdXJhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9NaWxsaXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXMoXCJtaWxsaXNlY29uZHNcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBtaWxsaXNlY29uZHMgdmFsdWUgb2YgdGhpcyBEdXJhdGlvbi4gQWxpYXMgb2Yge0BsaW5rIHRvTWlsbGlzfVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvTWlsbGlzKCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIER1cmF0aW9uIGxvbmdlciBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIGFkZC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBwbHVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbiksXG4gICAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoY29uc3QgayBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShkdXIudmFsdWVzLCBrKSB8fCBoYXNPd25Qcm9wZXJ0eSh0aGlzLnZhbHVlcywgaykpIHtcbiAgICAgICAgcmVzdWx0W2tdID0gZHVyLmdldChrKSArIHRoaXMuZ2V0KGspO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogcmVzdWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyBEdXJhdGlvbiBzaG9ydGVyIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbWludXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5wbHVzKGR1ci5uZWdhdGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogU2NhbGUgdGhpcyBEdXJhdGlvbiBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdW5pdC4gQXJpdHkgaXMgMSBvciAyOiB0aGUgdmFsdWUgb2YgdGhlIHVuaXQgYW5kLCBvcHRpb25hbGx5LCB0aGUgdW5pdCBuYW1lLiBNdXN0IHJldHVybiBhIG51bWJlci5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBtaW51dGVzOiAzMCB9KS5tYXBVbml0cyh4ID0+IHggKiAyKSAvLz0+IHsgaG91cnM6IDIsIG1pbnV0ZXM6IDYwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBtaW51dGVzOiAzMCB9KS5tYXBVbml0cygoeCwgdSkgPT4gdSA9PT0gXCJob3VyXCIgPyB4ICogMiA6IHgpIC8vPT4geyBob3VyczogMiwgbWludXRlczogMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG1hcFVuaXRzKGZuKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykpIHtcbiAgICAgIHJlc3VsdFtrXSA9IGFzTnVtYmVyKGZuKHRoaXMudmFsdWVzW2tdLCBrKSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogcmVzdWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlJyBvciAnZGF5J1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgneWVhcnMnKSAvLz0+IDJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ21vbnRocycpIC8vPT4gMFxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgnZGF5cycpIC8vPT4gM1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQodW5pdCkge1xuICAgIHJldHVybiB0aGlzW0R1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodW5pdCldO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdW5pdHMuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gYSBtYXBwaW5nIG9mIHVuaXRzIHRvIG51bWJlcnNcbiAgICogQGV4YW1wbGUgZHVyLnNldCh7IHllYXJzOiAyMDE3IH0pXG4gICAqIEBleGFtcGxlIGR1ci5zZXQoeyBob3VyczogOCwgbWludXRlczogMzAgfSlcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzZXQodmFsdWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgbWl4ZWQgPSB7IC4uLnRoaXMudmFsdWVzLCAuLi5ub3JtYWxpemVPYmplY3QodmFsdWVzLCBEdXJhdGlvbi5ub3JtYWxpemVVbml0KSB9O1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogbWl4ZWQgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlIGFuZC9vciBudW1iZXJpbmdTeXN0ZW0uICBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBleGFtcGxlIGR1ci5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogJ2VuLUdCJyB9KVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHJlY29uZmlndXJlKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIGNvbnZlcnNpb25BY2N1cmFjeSB9ID0ge30pIHtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmxvYy5jbG9uZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtIH0pLFxuICAgICAgb3B0cyA9IHsgbG9jIH07XG5cbiAgICBpZiAoY29udmVyc2lvbkFjY3VyYWN5KSB7XG4gICAgICBvcHRzLmNvbnZlcnNpb25BY2N1cmFjeSA9IGNvbnZlcnNpb25BY2N1cmFjeTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmUodGhpcywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGR1cmF0aW9uIGluIHRoZSBzcGVjaWZpZWQgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlcycgb3IgJ2RheXMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAxfSkuYXMoJ2RheXMnKSAvLz0+IDM2NVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMX0pLmFzKCdtb250aHMnKSAvLz0+IDEyXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe2hvdXJzOiA2MH0pLmFzKCdkYXlzJykgLy89PiAyLjVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgYXModW5pdCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnNoaWZ0VG8odW5pdCkuZ2V0KHVuaXQpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZHVjZSB0aGlzIER1cmF0aW9uIHRvIGl0cyBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gaW4gaXRzIGN1cnJlbnQgdW5pdHMuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMiwgZGF5czogNTAwMCB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMTUsIGRheXM6IDI1NSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTIsIG1pbnV0ZXM6IC00NSB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDE1IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBub3JtYWxpemUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHZhbHMgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgbm9ybWFsaXplVmFsdWVzKHRoaXMubWF0cml4LCB2YWxzKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHZhbHMgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGlzIER1cmF0aW9uIGludG8gaXRzIHJlcHJlc2VudGF0aW9uIGluIGEgZGlmZmVyZW50IHNldCBvZiB1bml0cy5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBzZWNvbmRzOiAzMCB9KS5zaGlmdFRvKCdtaW51dGVzJywgJ21pbGxpc2Vjb25kcycpLnRvT2JqZWN0KCkgLy89PiB7IG1pbnV0ZXM6IDYwLCBtaWxsaXNlY29uZHM6IDMwMDAwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzaGlmdFRvKC4uLnVuaXRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKHVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdW5pdHMgPSB1bml0cy5tYXAoKHUpID0+IER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodSkpO1xuXG4gICAgY29uc3QgYnVpbHQgPSB7fSxcbiAgICAgIGFjY3VtdWxhdGVkID0ge30sXG4gICAgICB2YWxzID0gdGhpcy50b09iamVjdCgpO1xuICAgIGxldCBsYXN0VW5pdDtcblxuICAgIGZvciAoY29uc3QgayBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmICh1bml0cy5pbmRleE9mKGspID49IDApIHtcbiAgICAgICAgbGFzdFVuaXQgPSBrO1xuXG4gICAgICAgIGxldCBvd24gPSAwO1xuXG4gICAgICAgIC8vIGFueXRoaW5nIHdlIGhhdmVuJ3QgYm9pbGVkIGRvd24geWV0IHNob3VsZCBnZXQgYm9pbGVkIHRvIHRoaXMgdW5pdFxuICAgICAgICBmb3IgKGNvbnN0IGFrIGluIGFjY3VtdWxhdGVkKSB7XG4gICAgICAgICAgb3duICs9IHRoaXMubWF0cml4W2FrXVtrXSAqIGFjY3VtdWxhdGVkW2FrXTtcbiAgICAgICAgICBhY2N1bXVsYXRlZFtha10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGx1cyBhbnl0aGluZyB0aGF0J3MgYWxyZWFkeSBpbiB0aGlzIHVuaXRcbiAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHNba10pKSB7XG4gICAgICAgICAgb3duICs9IHZhbHNba107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpID0gTWF0aC50cnVuYyhvd24pO1xuICAgICAgICBidWlsdFtrXSA9IGk7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gKG93biAqIDEwMDAgLSBpICogMTAwMCkgLyAxMDAwO1xuXG4gICAgICAgIC8vIHBsdXMgYW55dGhpbmcgZnVydGhlciBkb3duIHRoZSBjaGFpbiB0aGF0IHNob3VsZCBiZSByb2xsZWQgdXAgaW4gdG8gdGhpc1xuICAgICAgICBmb3IgKGNvbnN0IGRvd24gaW4gdmFscykge1xuICAgICAgICAgIGlmIChvcmRlcmVkVW5pdHMuaW5kZXhPZihkb3duKSA+IG9yZGVyZWRVbml0cy5pbmRleE9mKGspKSB7XG4gICAgICAgICAgICBjb252ZXJ0KHRoaXMubWF0cml4LCB2YWxzLCBkb3duLCBidWlsdCwgayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSwga2VlcCBpdCBpbiB0aGUgd2luZ3MgdG8gYm9pbCBpdCBsYXRlclxuICAgICAgfSBlbHNlIGlmIChpc051bWJlcih2YWxzW2tdKSkge1xuICAgICAgICBhY2N1bXVsYXRlZFtrXSA9IHZhbHNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYW55dGhpbmcgbGVmdG92ZXIgYmVjb21lcyB0aGUgZGVjaW1hbCBmb3IgdGhlIGxhc3QgdW5pdFxuICAgIC8vIGxhc3RVbml0IG11c3QgYmUgZGVmaW5lZCBzaW5jZSB1bml0cyBpcyBub3QgZW1wdHlcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhY2N1bXVsYXRlZCkge1xuICAgICAgaWYgKGFjY3VtdWxhdGVkW2tleV0gIT09IDApIHtcbiAgICAgICAgYnVpbHRbbGFzdFVuaXRdICs9XG4gICAgICAgICAga2V5ID09PSBsYXN0VW5pdCA/IGFjY3VtdWxhdGVkW2tleV0gOiBhY2N1bXVsYXRlZFtrZXldIC8gdGhpcy5tYXRyaXhbbGFzdFVuaXRdW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiBidWlsdCB9LCB0cnVlKS5ub3JtYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5lZ2F0aXZlIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgc2Vjb25kczogMzAgfSkubmVnYXRlKCkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IC0xLCBzZWNvbmRzOiAtMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG5lZ2F0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgbmVnYXRlZCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykpIHtcbiAgICAgIG5lZ2F0ZWRba10gPSAtdGhpcy52YWx1ZXNba107XG4gICAgfVxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogbmVnYXRlZCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHllYXJzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHllYXJzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy55ZWFycyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcXVhcnRlcnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgcXVhcnRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnF1YXJ0ZXJzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtb250aHMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbW9udGhzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5tb250aHMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWtzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLndlZWtzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXlzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLmRheXMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhvdXJzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhvdXJzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5ob3VycyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludXRlcy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaW51dGVzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5taW51dGVzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzZWNvbmRzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuc2Vjb25kcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWlsbGlzZWNvbmRzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWlsbGlzZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5taWxsaXNlY29uZHMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIER1cmF0aW9uIGlzIGludmFsaWQuIEludmFsaWQgZHVyYXRpb25zIGFyZSByZXR1cm5lZCBieSBkaWZmIG9wZXJhdGlvbnNcbiAgICogb24gaW52YWxpZCBEYXRlVGltZXMgb3IgSW50ZXJ2YWxzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBEdXJhdGlvbiBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRHVyYXRpb24gaXMgdmFsaWRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgRHVyYXRpb24gYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIER1cmF0aW9uIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEVxdWFsaXR5IGNoZWNrXG4gICAqIFR3byBEdXJhdGlvbnMgYXJlIGVxdWFsIGlmZiB0aGV5IGhhdmUgdGhlIHNhbWUgdW5pdHMgYW5kIHRoZSBzYW1lIHZhbHVlcyBmb3IgZWFjaCB1bml0LlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubG9jLmVxdWFscyhvdGhlci5sb2MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXEodjEsIHYyKSB7XG4gICAgICAvLyBDb25zaWRlciAwIGFuZCB1bmRlZmluZWQgYXMgZXF1YWxcbiAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkIHx8IHYxID09PSAwKSByZXR1cm4gdjIgPT09IHVuZGVmaW5lZCB8fCB2MiA9PT0gMDtcbiAgICAgIHJldHVybiB2MSA9PT0gdjI7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB1IG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKCFlcSh0aGlzLnZhbHVlc1t1XSwgb3RoZXIudmFsdWVzW3VdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGVUaW1lLCB7IGZyaWVuZGx5RGF0ZVRpbWUgfSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBJbnZhbGlkSW50ZXJ2YWxFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgSW50ZXJ2YWxcIjtcblxuLy8gY2hlY2tzIGlmIHRoZSBzdGFydCBpcyBlcXVhbCB0byBvciBiZWZvcmUgdGhlIGVuZFxuZnVuY3Rpb24gdmFsaWRhdGVTdGFydEVuZChzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQgfHwgIXN0YXJ0LmlzVmFsaWQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcIm1pc3Npbmcgb3IgaW52YWxpZCBzdGFydFwiKTtcbiAgfSBlbHNlIGlmICghZW5kIHx8ICFlbmQuaXNWYWxpZCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwibWlzc2luZyBvciBpbnZhbGlkIGVuZFwiKTtcbiAgfSBlbHNlIGlmIChlbmQgPCBzdGFydCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFxuICAgICAgXCJlbmQgYmVmb3JlIHN0YXJ0XCIsXG4gICAgICBgVGhlIGVuZCBvZiBhbiBpbnRlcnZhbCBtdXN0IGJlIGFmdGVyIGl0cyBzdGFydCwgYnV0IHlvdSBoYWQgc3RhcnQ9JHtzdGFydC50b0lTTygpfSBhbmQgZW5kPSR7ZW5kLnRvSVNPKCl9YFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBJbnRlcnZhbCBvYmplY3QgcmVwcmVzZW50cyBhIGhhbGYtb3BlbiBpbnRlcnZhbCBvZiB0aW1lLCB3aGVyZSBlYWNoIGVuZHBvaW50IGlzIGEge0BsaW5rIERhdGVUaW1lfS4gQ29uY2VwdHVhbGx5LCBpdCdzIGEgY29udGFpbmVyIGZvciB0aG9zZSB0d28gZW5kcG9pbnRzLCBhY2NvbXBhbmllZCBieSBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgY29tcGFyaW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgbWV0aG9kcyBhbmQgZ2V0dGVycyBpbiBJbnRlcnZhbDpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKiBUbyBjcmVhdGUgYW4gSW50ZXJ2YWwsIHVzZSB7QGxpbmsgSW50ZXJ2YWwjZnJvbURhdGVUaW1lc30sIHtAbGluayBJbnRlcnZhbCNhZnRlcn0sIHtAbGluayBJbnRlcnZhbCNiZWZvcmV9LCBvciB7QGxpbmsgSW50ZXJ2YWwjZnJvbUlTT30uXG4gKiAqICoqQWNjZXNzb3JzKiogVXNlIHtAbGluayBJbnRlcnZhbCNzdGFydH0gYW5kIHtAbGluayBJbnRlcnZhbCNlbmR9IHRvIGdldCB0aGUgc3RhcnQgYW5kIGVuZC5cbiAqICogKipJbnRlcnJvZ2F0aW9uKiogVG8gYW5hbHl6ZSB0aGUgSW50ZXJ2YWwsIHVzZSB7QGxpbmsgSW50ZXJ2YWwjY291bnR9LCB7QGxpbmsgSW50ZXJ2YWwjbGVuZ3RofSwge0BsaW5rIEludGVydmFsI2hhc1NhbWV9LCB7QGxpbmsgSW50ZXJ2YWwjY29udGFpbnN9LCB7QGxpbmsgSW50ZXJ2YWwjaXNBZnRlcn0sIG9yIHtAbGluayBJbnRlcnZhbCNpc0JlZm9yZX0uXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKiBUbyBjcmVhdGUgb3RoZXIgSW50ZXJ2YWxzIG91dCBvZiB0aGlzIG9uZSwgdXNlIHtAbGluayBJbnRlcnZhbCNzZXR9LCB7QGxpbmsgSW50ZXJ2YWwjc3BsaXRBdH0sIHtAbGluayBJbnRlcnZhbCNzcGxpdEJ5fSwge0BsaW5rIEludGVydmFsI2RpdmlkZUVxdWFsbHl9LCB7QGxpbmsgSW50ZXJ2YWwjbWVyZ2V9LCB7QGxpbmsgSW50ZXJ2YWwjeG9yfSwge0BsaW5rIEludGVydmFsI3VuaW9ufSwge0BsaW5rIEludGVydmFsI2ludGVyc2VjdGlvbn0sIG9yIHtAbGluayBJbnRlcnZhbCNkaWZmZXJlbmNlfS5cbiAqICogKipDb21wYXJpc29uKiogVG8gY29tcGFyZSB0aGlzIEludGVydmFsIHRvIGFub3RoZXIgb25lLCB1c2Uge0BsaW5rIEludGVydmFsI2VxdWFsc30sIHtAbGluayBJbnRlcnZhbCNvdmVybGFwc30sIHtAbGluayBJbnRlcnZhbCNhYnV0c1N0YXJ0fSwge0BsaW5rIEludGVydmFsI2FidXRzRW5kfSwge0BsaW5rIEludGVydmFsI2VuZ3VsZnN9XG4gKiAqICoqT3V0cHV0KiogVG8gY29udmVydCB0aGUgSW50ZXJ2YWwgaW50byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHNlZSB7QGxpbmsgSW50ZXJ2YWwjdG9TdHJpbmd9LCB7QGxpbmsgSW50ZXJ2YWwjdG9JU099LCB7QGxpbmsgSW50ZXJ2YWwjdG9JU09EYXRlfSwge0BsaW5rIEludGVydmFsI3RvSVNPVGltZX0sIHtAbGluayBJbnRlcnZhbCN0b0Zvcm1hdH0sIGFuZCB7QGxpbmsgSW50ZXJ2YWwjdG9EdXJhdGlvbn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVydmFsIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnMgPSBjb25maWcuc3RhcnQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lID0gY29uZmlnLmVuZDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBjb25maWcuaW52YWxpZCB8fCBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNMdXhvbkludGVydmFsID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgSW50ZXJ2YWwgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbiA9IG51bGwpIHtcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibmVlZCB0byBzcGVjaWZ5IGEgcmVhc29uIHRoZSBJbnRlcnZhbCBpcyBpbnZhbGlkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSW50ZXJ2YWxFcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh7IGludmFsaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGEgc3RhcnQgRGF0ZVRpbWUgYW5kIGFuIGVuZCBEYXRlVGltZS4gSW5jbHVzaXZlIG9mIHRoZSBzdGFydCBidXQgbm90IHRoZSBlbmQuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IHN0YXJ0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IGVuZFxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBmcm9tRGF0ZVRpbWVzKHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBidWlsdFN0YXJ0ID0gZnJpZW5kbHlEYXRlVGltZShzdGFydCksXG4gICAgICBidWlsdEVuZCA9IGZyaWVuZGx5RGF0ZVRpbWUoZW5kKTtcblxuICAgIGNvbnN0IHZhbGlkYXRlRXJyb3IgPSB2YWxpZGF0ZVN0YXJ0RW5kKGJ1aWx0U3RhcnQsIGJ1aWx0RW5kKTtcblxuICAgIGlmICh2YWxpZGF0ZUVycm9yID09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWwoe1xuICAgICAgICBzdGFydDogYnVpbHRTdGFydCxcbiAgICAgICAgZW5kOiBidWlsdEVuZCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGVFcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYSBzdGFydCBEYXRlVGltZSBhbmQgYSBEdXJhdGlvbiB0byBleHRlbmQgdG8uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IHN0YXJ0XG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSB0aGUgbGVuZ3RoIG9mIHRoZSBJbnRlcnZhbC5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgYWZ0ZXIoc3RhcnQsIGR1cmF0aW9uKSB7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbiksXG4gICAgICBkdCA9IGZyaWVuZGx5RGF0ZVRpbWUoc3RhcnQpO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0LCBkdC5wbHVzKGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGFuIGVuZCBEYXRlVGltZSBhbmQgYSBEdXJhdGlvbiB0byBleHRlbmQgYmFja3dhcmRzIHRvLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBlbmRcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsLlxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBiZWZvcmUoZW5kLCBkdXJhdGlvbikge1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLFxuICAgICAgZHQgPSBmcmllbmRseURhdGVUaW1lKGVuZCk7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQubWludXMoZHVyKSwgZHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGFuIElTTyA4NjAxIHN0cmluZy5cbiAgICogQWNjZXB0cyBgPHN0YXJ0Pi88ZW5kPmAsIGA8c3RhcnQ+LzxkdXJhdGlvbj5gLCBhbmQgYDxkdXJhdGlvbj4vPGVuZD5gIGZvcm1hdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIElTTyBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIG9wdGlvbnMgdG8gcGFzcyB7QGxpbmsgRGF0ZVRpbWUjZnJvbUlTT30gYW5kIG9wdGlvbmFsbHkge0BsaW5rIER1cmF0aW9uI2Zyb21JU099XG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzKSB7XG4gICAgY29uc3QgW3MsIGVdID0gKHRleHQgfHwgXCJcIikuc3BsaXQoXCIvXCIsIDIpO1xuICAgIGlmIChzICYmIGUpIHtcbiAgICAgIGxldCBzdGFydCwgc3RhcnRJc1ZhbGlkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhcnQgPSBEYXRlVGltZS5mcm9tSVNPKHMsIG9wdHMpO1xuICAgICAgICBzdGFydElzVmFsaWQgPSBzdGFydC5pc1ZhbGlkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzdGFydElzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGVuZCwgZW5kSXNWYWxpZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVuZCA9IERhdGVUaW1lLmZyb21JU08oZSwgb3B0cyk7XG4gICAgICAgIGVuZElzVmFsaWQgPSBlbmQuaXNWYWxpZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZW5kSXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRJc1ZhbGlkICYmIGVuZElzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQsIGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydElzVmFsaWQpIHtcbiAgICAgICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUlTTyhlLCBvcHRzKTtcbiAgICAgICAgaWYgKGR1ci5pc1ZhbGlkKSB7XG4gICAgICAgICAgcmV0dXJuIEludGVydmFsLmFmdGVyKHN0YXJ0LCBkdXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZElzVmFsaWQpIHtcbiAgICAgICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUlTTyhzLCBvcHRzKTtcbiAgICAgICAgaWYgKGR1ci5pc1ZhbGlkKSB7XG4gICAgICAgICAgcmV0dXJuIEludGVydmFsLmJlZm9yZShlbmQsIGR1cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGFuIEludGVydmFsLiBXb3JrcyBhY3Jvc3MgY29udGV4dCBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNJbnRlcnZhbChvKSB7XG4gICAgcmV0dXJuIChvICYmIG8uaXNMdXhvbkludGVydmFsKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGFydCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHR5cGUge0RhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IHN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnMgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVuZCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHR5cGUge0RhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5lIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhdCBsZWFzdCBpdHMgc3RhcnQsIG1lYW5pbmcgdGhhdCB0aGUgSW50ZXJ2YWwgaXNuJ3QgJ2JhY2t3YXJkcycuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZFJlYXNvbiA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBJbnRlcnZhbCBpcyBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBJbnRlcnZhbCBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgSW50ZXJ2YWwgYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIEludGVydmFsIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwgaW4gdGhlIHNwZWNpZmllZCB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byByZXR1cm4gdGhlIGxlbmd0aCBpbi5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgbGVuZ3RoKHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudG9EdXJhdGlvbiguLi5bdW5pdF0pLmdldCh1bml0KSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb3VudCBvZiBtaW51dGVzLCBob3VycywgZGF5cywgbW9udGhzLCBvciB5ZWFycyBpbmNsdWRlZCBpbiB0aGUgSW50ZXJ2YWwsIGV2ZW4gaW4gcGFydC5cbiAgICogVW5saWtlIHtAbGluayBJbnRlcnZhbCNsZW5ndGh9IHRoaXMgY291bnRzIHNlY3Rpb25zIG9mIHRoZSBjYWxlbmRhciwgbm90IHBlcmlvZHMgb2YgdGltZSwgZS5nLiBzcGVjaWZ5aW5nICdkYXknXG4gICAqIGFza3MgJ3doYXQgZGF0ZXMgYXJlIGluY2x1ZGVkIGluIHRoaXMgaW50ZXJ2YWw/Jywgbm90ICdob3cgbWFueSBkYXlzIGxvbmcgaXMgdGhpcyBpbnRlcnZhbD8nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdD0nbWlsbGlzZWNvbmRzJ10gLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjb3VudCh1bml0ID0gXCJtaWxsaXNlY29uZHNcIikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gTmFOO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGFydC5zdGFydE9mKHVuaXQpLFxuICAgICAgZW5kID0gdGhpcy5lbmQuc3RhcnRPZih1bml0KTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihlbmQuZGlmZihzdGFydCwgdW5pdCkuZ2V0KHVuaXQpKSArIDE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBzdGFydCBhbmQgZW5kIGFyZSBib3RoIGluIHRoZSBzYW1lIHVuaXQgb2YgdGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY2hlY2sgc2FtZW5lc3Mgb25cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1NhbWUodW5pdCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmlzRW1wdHkoKSB8fCB0aGlzLmUubWludXMoMSkuaGFzU2FtZSh0aGlzLnMsIHVuaXQpIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBoYXMgdGhlIHNhbWUgc3RhcnQgYW5kIGVuZCBEYXRlVGltZXMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnMudmFsdWVPZigpID09PSB0aGlzLmUudmFsdWVPZigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBzdGFydCBpcyBhZnRlciB0aGUgc3BlY2lmaWVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBkYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNBZnRlcihkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA+IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBlbmQgaXMgYmVmb3JlIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0JlZm9yZShkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuZSA8PSBkYXRlVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWlucyhkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA8PSBkYXRlVGltZSAmJiB0aGlzLmUgPiBkYXRlVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldHNcIiB0aGUgc3RhcnQgYW5kL29yIGVuZCBkYXRlcy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gdGhlIHZhbHVlcyB0byBzZXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gdmFsdWVzLnN0YXJ0IC0gdGhlIHN0YXJ0aW5nIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IHZhbHVlcy5lbmQgLSB0aGUgZW5kaW5nIERhdGVUaW1lXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc2V0KHsgc3RhcnQsIGVuZCB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQgfHwgdGhpcy5zLCBlbmQgfHwgdGhpcy5lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB0aGlzIEludGVydmFsIGF0IGVhY2ggb2YgdGhlIHNwZWNpZmllZCBEYXRlVGltZXNcbiAgICogQHBhcmFtIHsuLi5EYXRlVGltZX0gZGF0ZVRpbWVzIC0gdGhlIHVuaXQgb2YgdGltZSB0byBjb3VudC5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzcGxpdEF0KC4uLmRhdGVUaW1lcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gW107XG4gICAgY29uc3Qgc29ydGVkID0gZGF0ZVRpbWVzXG4gICAgICAgIC5tYXAoZnJpZW5kbHlEYXRlVGltZSlcbiAgICAgICAgLmZpbHRlcigoZCkgPT4gdGhpcy5jb250YWlucyhkKSlcbiAgICAgICAgLnNvcnQoKSxcbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICBsZXQgeyBzIH0gPSB0aGlzLFxuICAgICAgaSA9IDA7XG5cbiAgICB3aGlsZSAocyA8IHRoaXMuZSkge1xuICAgICAgY29uc3QgYWRkZWQgPSBzb3J0ZWRbaV0gfHwgdGhpcy5lLFxuICAgICAgICBuZXh0ID0gK2FkZGVkID4gK3RoaXMuZSA/IHRoaXMuZSA6IGFkZGVkO1xuICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMocywgbmV4dCkpO1xuICAgICAgcyA9IG5leHQ7XG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBpbnRvIHNtYWxsZXIgSW50ZXJ2YWxzLCBlYWNoIG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICAgKiBMZWZ0IG92ZXIgdGltZSBpcyBncm91cGVkIGludG8gYSBzbWFsbGVyIGludGVydmFsXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgbGVuZ3RoIG9mIGVhY2ggcmVzdWx0aW5nIGludGVydmFsLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHNwbGl0QnkoZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFkdXIuaXNWYWxpZCB8fCBkdXIuYXMoXCJtaWxsaXNlY29uZHNcIikgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgeyBzIH0gPSB0aGlzLFxuICAgICAgaWR4ID0gMSxcbiAgICAgIG5leHQ7XG5cbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgd2hpbGUgKHMgPCB0aGlzLmUpIHtcbiAgICAgIGNvbnN0IGFkZGVkID0gdGhpcy5zdGFydC5wbHVzKGR1ci5tYXBVbml0cygoeCkgPT4geCAqIGlkeCkpO1xuICAgICAgbmV4dCA9ICthZGRlZCA+ICt0aGlzLmUgPyB0aGlzLmUgOiBhZGRlZDtcbiAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIG5leHQpKTtcbiAgICAgIHMgPSBuZXh0O1xuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBpbnRvIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHNtYWxsZXIgaW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZQYXJ0cyAtIFRoZSBudW1iZXIgb2YgSW50ZXJ2YWxzIHRvIGRpdmlkZSB0aGUgSW50ZXJ2YWwgaW50by5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBkaXZpZGVFcXVhbGx5KG51bWJlck9mUGFydHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiB0aGlzLnNwbGl0QnkodGhpcy5sZW5ndGgoKSAvIG51bWJlck9mUGFydHMpLnNsaWNlKDAsIG51bWJlck9mUGFydHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgb3ZlcmxhcHMgd2l0aCB0aGUgc3BlY2lmaWVkIEludGVydmFsXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBvdmVybGFwcyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmUgPiBvdGhlci5zICYmIHRoaXMucyA8IG90aGVyLmU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhZGphY2VudCB0byB0aGUgc3BlY2lmaWVkIEludGVydmFsJ3Mgc3RhcnQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c1N0YXJ0KG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gK3RoaXMuZSA9PT0gK290aGVyLnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGlzIGFkamFjZW50IHRvIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwncyBlbmQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c0VuZChvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICtvdGhlci5lID09PSArdGhpcy5zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgZW5ndWxmcyB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZW5ndWxmcyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA8PSBvdGhlci5zICYmIHRoaXMuZSA+PSBvdGhlci5lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgaGFzIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQgYXMgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlci5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucy5lcXVhbHMob3RoZXIucykgJiYgdGhpcy5lLmVxdWFscyhvdGhlci5lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgcmVwcmVzZW50aW5nIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBJbnRlcnZhbCBhbmQgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgcmVzdWx0aW5nIEludGVydmFsIGhhcyB0aGUgbWF4aW11bSBzdGFydCB0aW1lIGFuZCB0aGUgbWluaW11bSBlbmQgdGltZSBvZiB0aGUgdHdvIEludGVydmFscy5cbiAgICogUmV0dXJucyBudWxsIGlmIHRoZSBpbnRlcnNlY3Rpb24gaXMgZW1wdHksIG1lYW5pbmcsIHRoZSBpbnRlcnZhbHMgZG9uJ3QgaW50ZXJzZWN0LlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIGludGVyc2VjdGlvbihvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBzID0gdGhpcy5zID4gb3RoZXIucyA/IHRoaXMucyA6IG90aGVyLnMsXG4gICAgICBlID0gdGhpcy5lIDwgb3RoZXIuZSA/IHRoaXMuZSA6IG90aGVyLmU7XG5cbiAgICBpZiAocyA+PSBlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMocywgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIHVuaW9uIG9mIHRoaXMgSW50ZXJ2YWwgYW5kIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHJlc3VsdGluZyBJbnRlcnZhbCBoYXMgdGhlIG1pbmltdW0gc3RhcnQgdGltZSBhbmQgdGhlIG1heGltdW0gZW5kIHRpbWUgb2YgdGhlIHR3byBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgdW5pb24ob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgcyA9IHRoaXMucyA8IG90aGVyLnMgPyB0aGlzLnMgOiBvdGhlci5zLFxuICAgICAgZSA9IHRoaXMuZSA+IG90aGVyLmUgPyB0aGlzLmUgOiBvdGhlci5lO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGFuIGFycmF5IG9mIEludGVydmFscyBpbnRvIGEgZXF1aXZhbGVudCBtaW5pbWFsIHNldCBvZiBJbnRlcnZhbHMuXG4gICAqIENvbWJpbmVzIG92ZXJsYXBwaW5nIGFuZCBhZGphY2VudCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtZXJnZShpbnRlcnZhbHMpIHtcbiAgICBjb25zdCBbZm91bmQsIGZpbmFsXSA9IGludGVydmFsc1xuICAgICAgLnNvcnQoKGEsIGIpID0+IGEucyAtIGIucylcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChbc29mYXIsIGN1cnJlbnRdLCBpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLCBpdGVtXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQub3ZlcmxhcHMoaXRlbSkgfHwgY3VycmVudC5hYnV0c1N0YXJ0KGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLCBjdXJyZW50LnVuaW9uKGl0ZW0pXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtzb2Zhci5jb25jYXQoW2N1cnJlbnRdKSwgaXRlbV07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbW10sIG51bGxdXG4gICAgICApO1xuICAgIGlmIChmaW5hbCkge1xuICAgICAgZm91bmQucHVzaChmaW5hbCk7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgSW50ZXJ2YWxzIHJlcHJlc2VudGluZyB0aGUgc3BhbnMgb2YgdGltZSB0aGF0IG9ubHkgYXBwZWFyIGluIG9uZSBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFscy5cbiAgICogQHBhcmFtIHtBcnJheX0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHhvcihpbnRlcnZhbHMpIHtcbiAgICBsZXQgc3RhcnQgPSBudWxsLFxuICAgICAgY3VycmVudENvdW50ID0gMDtcbiAgICBjb25zdCByZXN1bHRzID0gW10sXG4gICAgICBlbmRzID0gaW50ZXJ2YWxzLm1hcCgoaSkgPT4gW1xuICAgICAgICB7IHRpbWU6IGkucywgdHlwZTogXCJzXCIgfSxcbiAgICAgICAgeyB0aW1lOiBpLmUsIHR5cGU6IFwiZVwiIH0sXG4gICAgICBdKSxcbiAgICAgIGZsYXR0ZW5lZCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQoLi4uZW5kcyksXG4gICAgICBhcnIgPSBmbGF0dGVuZWQuc29ydCgoYSwgYikgPT4gYS50aW1lIC0gYi50aW1lKTtcblxuICAgIGZvciAoY29uc3QgaSBvZiBhcnIpIHtcbiAgICAgIGN1cnJlbnRDb3VudCArPSBpLnR5cGUgPT09IFwic1wiID8gMSA6IC0xO1xuXG4gICAgICBpZiAoY3VycmVudENvdW50ID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gaS50aW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXJ0ICYmICtzdGFydCAhPT0gK2kudGltZSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0LCBpLnRpbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gSW50ZXJ2YWwubWVyZ2UocmVzdWx0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgc3BhbiBvZiB0aW1lIGluIHRoaXMgSW50ZXJ2YWwgdGhhdCBkb2Vzbid0IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIHNwZWNpZmllZCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7Li4uSW50ZXJ2YWx9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGRpZmZlcmVuY2UoLi4uaW50ZXJ2YWxzKSB7XG4gICAgcmV0dXJuIEludGVydmFsLnhvcihbdGhpc10uY29uY2F0KGludGVydmFscykpXG4gICAgICAubWFwKChpKSA9PiB0aGlzLmludGVyc2VjdGlvbihpKSlcbiAgICAgIC5maWx0ZXIoKGkpID0+IGkgJiYgIWkuaXNFbXB0eSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgYXBwcm9wcmlhdGUgZm9yIGRlYnVnZ2luZy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgWyR7dGhpcy5zLnRvSVNPKCl9IFx1MjAxMyAke3RoaXMuZS50b0lTTygpfSlgO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIHNhbWUgb3B0aW9ucyBhcyB7QGxpbmsgRGF0ZVRpbWUjdG9JU099XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0lTTyhvcHRzKX0vJHt0aGlzLmUudG9JU08ob3B0cyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZGF0ZSBvZiB0aGlzIEludGVydmFsLlxuICAgKiBUaGUgdGltZSBjb21wb25lbnRzIGFyZSBpZ25vcmVkLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPRGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0lTT0RhdGUoKX0vJHt0aGlzLmUudG9JU09EYXRlKCl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGltZSBvZiB0aGlzIEludGVydmFsLlxuICAgKiBUaGUgZGF0ZSBjb21wb25lbnRzIGFyZSBpZ25vcmVkLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIHNhbWUgb3B0aW9ucyBhcyB7QGxpbmsgRGF0ZVRpbWUjdG9JU099XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZShvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9JU09UaW1lKG9wdHMpfS8ke3RoaXMuZS50b0lTT1RpbWUob3B0cyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlRm9ybWF0IC0gdGhlIGZvcm1hdCBzdHJpbmcuIFRoaXMgc3RyaW5nIGZvcm1hdHMgdGhlIHN0YXJ0IGFuZCBlbmQgdGltZS4gU2VlIHtAbGluayBEYXRlVGltZSN0b0Zvcm1hdH0gZm9yIGRldGFpbHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuc2VwYXJhdG9yID0gICcgXHUyMDEzICddIC0gYSBzZXBhcmF0b3IgdG8gcGxhY2UgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCByZXByZXNlbnRhdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZGF0ZUZvcm1hdCwgeyBzZXBhcmF0b3IgPSBcIiBcdTIwMTMgXCIgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9Gb3JtYXQoZGF0ZUZvcm1hdCl9JHtzZXBhcmF0b3J9JHt0aGlzLmUudG9Gb3JtYXQoZGF0ZUZvcm1hdCl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBEdXJhdGlvbiByZXByZXNlbnRpbmcgdGhlIHRpbWUgc3Bhbm5lZCBieSB0aGlzIGludGVydmFsLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3VuaXQ9WydtaWxsaXNlY29uZHMnXV0gLSB0aGUgdW5pdCBvciB1bml0cyAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gaW5jbHVkZSBpbiB0aGUgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCkudG9PYmplY3QoKSAvLz0+IHsgbWlsbGlzZWNvbmRzOiA4ODQ4OTI1NyB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oJ2RheXMnKS50b09iamVjdCgpIC8vPT4geyBkYXlzOiAxLjAyNDE4MTIxNTI3Nzc3NzggfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKFsnaG91cnMnLCAnbWludXRlcyddKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMjQsIG1pbnV0ZXM6IDM0LjgyMDk1IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbihbJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcyddKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMjQsIG1pbnV0ZXM6IDM0LCBzZWNvbmRzOiA0OS4yNTcgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCdzZWNvbmRzJykudG9PYmplY3QoKSAvLz0+IHsgc2Vjb25kczogODg0ODkuMjU3IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICB0b0R1cmF0aW9uKHVuaXQsIG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQodGhpcy5pbnZhbGlkUmVhc29uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZS5kaWZmKHRoaXMucywgdW5pdCwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUnVuIG1hcEZuIG9uIHRoZSBpbnRlcnZhbCBzdGFydCBhbmQgZW5kLCByZXR1cm5pbmcgYSBuZXcgSW50ZXJ2YWwgZnJvbSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtYXBGblxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikubWFwRW5kcG9pbnRzKGVuZHBvaW50ID0+IGVuZHBvaW50LnRvVVRDKCkpXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLm1hcEVuZHBvaW50cyhlbmRwb2ludCA9PiBlbmRwb2ludC5wbHVzKHsgaG91cnM6IDIgfSkpXG4gICAqL1xuICBtYXBFbmRwb2ludHMobWFwRm4pIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhtYXBGbih0aGlzLnMpLCBtYXBGbih0aGlzLmUpKTtcbiAgfVxufVxuIiwgImltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5cbmltcG9ydCB7IGhhc1JlbGF0aXZlIH0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5cbi8qKlxuICogVGhlIEluZm8gY2xhc3MgY29udGFpbnMgc3RhdGljIG1ldGhvZHMgZm9yIHJldHJpZXZpbmcgZ2VuZXJhbCB0aW1lIGFuZCBkYXRlIHJlbGF0ZWQgZGF0YS4gRm9yIGV4YW1wbGUsIGl0IGhhcyBtZXRob2RzIGZvciBmaW5kaW5nIG91dCBpZiBhIHRpbWUgem9uZSBoYXMgYSBEU1QsIGZvciBsaXN0aW5nIHRoZSBtb250aHMgaW4gYW55IHN1cHBvcnRlZCBsb2NhbGUsIGFuZCBmb3IgZGlzY292ZXJpbmcgd2hpY2ggb2YgTHV4b24gZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5mbyB7XG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgY29udGFpbnMgYSBEU1QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFt6b25lPSdsb2NhbCddIC0gWm9uZSB0byBjaGVjay4gRGVmYXVsdHMgdG8gdGhlIGVudmlyb25tZW50J3MgbG9jYWwgem9uZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBoYXNEU1Qoem9uZSA9IFNldHRpbmdzLmRlZmF1bHRab25lKSB7XG4gICAgY29uc3QgcHJvdG8gPSBEYXRlVGltZS5ub3coKS5zZXRab25lKHpvbmUpLnNldCh7IG1vbnRoOiAxMiB9KTtcblxuICAgIHJldHVybiAhem9uZS5pc1VuaXZlcnNhbCAmJiBwcm90by5vZmZzZXQgIT09IHByb3RvLnNldCh7IG1vbnRoOiA2IH0pLm9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgaXMgYSB2YWxpZCBJQU5BIHNwZWNpZmllci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmUgLSBab25lIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZElBTkFab25lKHpvbmUpIHtcbiAgICByZXR1cm4gSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcih6b25lKSAmJiBJQU5BWm9uZS5pc1ZhbGlkWm9uZSh6b25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgaW5wdXQgaW50byBhIHtAbGluayBab25lfSBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBJZiBgaW5wdXRgIGlzIGFscmVhZHkgYSBab25lIGluc3RhbmNlLCBpdCBpcyByZXR1cm5lZCB1bmNoYW5nZWQuXG4gICAqICogSWYgYGlucHV0YCBpcyBhIHN0cmluZyBjb250YWluaW5nIGEgdmFsaWQgdGltZSB6b25lIG5hbWUsIGEgWm9uZSBpbnN0YW5jZVxuICAgKiAgIHdpdGggdGhhdCBuYW1lIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYSBzdHJpbmcgdGhhdCBkb2Vzbid0IHJlZmVyIHRvIGEga25vd24gdGltZSB6b25lLCBhIFpvbmVcbiAgICogICBpbnN0YW5jZSB3aXRoIHtAbGluayBab25lI2lzVmFsaWR9ID09IGZhbHNlIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dCBpcyBhIG51bWJlciwgYSBab25lIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBmaXhlZCBvZmZzZXRcbiAgICogICBpbiBtaW51dGVzIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLCB0aGUgZGVmYXVsdCB6b25lIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfG51bWJlcn0gW2lucHV0XSAtIHRoZSB2YWx1ZSB0byBiZSBjb252ZXJ0ZWRcbiAgICogQHJldHVybiB7Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVab25lKGlucHV0KSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVpvbmUoaW5wdXQsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2Ygc3RhbmRhbG9uZSBtb250aCBuYW1lcy5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJudW1lcmljXCIsIFwiMi1kaWdpdFwiLCBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRwdXRDYWxlbmRhcj0nZ3JlZ29yeSddIC0gdGhlIGNhbGVuZGFyXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKClbMF0gLy89PiAnSmFudWFyeSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ3Nob3J0JylbMF0gLy89PiAnSmFuJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnbnVtZXJpYycpWzBdIC8vPT4gJzEnXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdzaG9ydCcsIHsgbG9jYWxlOiAnZnItQ0EnIH0gKVswXSAvLz0+ICdqYW52LidcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ251bWVyaWMnLCB7IGxvY2FsZTogJ2FyJyB9KVswXSAvLz0+ICdcdTA2NjEnXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdsb25nJywgeyBvdXRwdXRDYWxlbmRhcjogJ2lzbGFtaWMnIH0pWzBdIC8vPT4gJ1JhYmlcdTAyQkIgSSdcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbW9udGhzKFxuICAgIGxlbmd0aCA9IFwibG9uZ1wiLFxuICAgIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCwgb3V0cHV0Q2FsZW5kYXIgPSBcImdyZWdvcnlcIiB9ID0ge31cbiAgKSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpKS5tb250aHMobGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZm9ybWF0IG1vbnRoIG5hbWVzLlxuICAgKiBGb3JtYXQgbW9udGhzIGRpZmZlciBmcm9tIHN0YW5kYWxvbmUgbW9udGhzIGluIHRoYXQgdGhleSdyZSBtZWFudCB0byBhcHBlYXIgbmV4dCB0byB0aGUgZGF5IG9mIHRoZSBtb250aC4gSW4gc29tZSBsYW5ndWFnZXMsIHRoYXRcbiAgICogY2hhbmdlcyB0aGUgc3RyaW5nLlxuICAgKiBTZWUge0BsaW5rIEluZm8jbW9udGhzfVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJudW1lcmljXCIsIFwiMi1kaWdpdFwiLCBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRwdXRDYWxlbmRhcj0nZ3JlZ29yeSddIC0gdGhlIGNhbGVuZGFyXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1vbnRoc0Zvcm1hdChcbiAgICBsZW5ndGggPSBcImxvbmdcIixcbiAgICB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwsIG91dHB1dENhbGVuZGFyID0gXCJncmVnb3J5XCIgfSA9IHt9XG4gICkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyKSkubW9udGhzKGxlbmd0aCwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIHN0YW5kYWxvbmUgd2VlayBuYW1lcy5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgd2Vla2RheSByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKClbMF0gLy89PiAnTW9uZGF5J1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcpWzBdIC8vPT4gJ01vbidcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygnc2hvcnQnLCB7IGxvY2FsZTogJ2ZyLUNBJyB9KVswXSAvLz0+ICdsdW4uJ1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcsIHsgbG9jYWxlOiAnYXInIH0pWzBdIC8vPT4gJ1x1MDYyN1x1MDY0NFx1MDYyN1x1MDYyQlx1MDY0Nlx1MDY0QVx1MDY0NidcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgd2Vla2RheXMobGVuZ3RoID0gXCJsb25nXCIsIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCB9ID0ge30pIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBudWxsKSkud2Vla2RheXMobGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZm9ybWF0IHdlZWsgbmFtZXMuXG4gICAqIEZvcm1hdCB3ZWVrZGF5cyBkaWZmZXIgZnJvbSBzdGFuZGFsb25lIHdlZWtkYXlzIGluIHRoYXQgdGhleSdyZSBtZWFudCB0byBhcHBlYXIgbmV4dCB0byBtb3JlIGRhdGUgaW5mb3JtYXRpb24uIEluIHNvbWUgbGFuZ3VhZ2VzLCB0aGF0XG4gICAqIGNoYW5nZXMgdGhlIHN0cmluZy5cbiAgICogU2VlIHtAbGluayBJbmZvI3dlZWtkYXlzfVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9bnVsbF0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyB3ZWVrZGF5c0Zvcm1hdChcbiAgICBsZW5ndGggPSBcImxvbmdcIixcbiAgICB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9XG4gICkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG51bGwpKS53ZWVrZGF5cyhsZW5ndGgsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBtZXJpZGllbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAZXhhbXBsZSBJbmZvLm1lcmlkaWVtcygpIC8vPT4gWyAnQU0nLCAnUE0nIF1cbiAgICogQGV4YW1wbGUgSW5mby5tZXJpZGllbXMoeyBsb2NhbGU6ICdteScgfSkgLy89PiBbICdcdTEwMTRcdTEwMzZcdTEwMTRcdTEwMDBcdTEwM0EnLCAnXHUxMDBBXHUxMDE0XHUxMDMxJyBdXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1lcmlkaWVtcyh7IGxvY2FsZSA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlKS5tZXJpZGllbXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZXJhcywgc3VjaCBhcyBbJ0JDJywgJ0FEJ10uIFRoZSBsb2NhbGUgY2FuIGJlIHNwZWNpZmllZCwgYnV0IHRoZSBjYWxlbmRhciBzeXN0ZW0gaXMgYWx3YXlzIEdyZWdvcmlhbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J3Nob3J0J10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBlcmEgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJzaG9ydFwiIG9yIFwibG9uZ1wiLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCkgLy89PiBbICdCQycsICdBRCcgXVxuICAgKiBAZXhhbXBsZSBJbmZvLmVyYXMoJ2xvbmcnKSAvLz0+IFsgJ0JlZm9yZSBDaHJpc3QnLCAnQW5ubyBEb21pbmknIF1cbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCdsb25nJywgeyBsb2NhbGU6ICdmcicgfSkgLy89PiBbICdhdmFudCBKXHUwMEU5c3VzLUNocmlzdCcsICdhcHJcdTAwRThzIEpcdTAwRTlzdXMtQ2hyaXN0JyBdXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIGVyYXMobGVuZ3RoID0gXCJzaG9ydFwiLCB7IGxvY2FsZSA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlLCBudWxsLCBcImdyZWdvcnlcIikuZXJhcyhsZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc2V0IG9mIGF2YWlsYWJsZSBmZWF0dXJlcyBpbiB0aGlzIGVudmlyb25tZW50LlxuICAgKiBTb21lIGZlYXR1cmVzIG9mIEx1eG9uIGFyZSBub3QgYXZhaWxhYmxlIGluIGFsbCBlbnZpcm9ubWVudHMuIEZvciBleGFtcGxlLCBvbiBvbGRlciBicm93c2VycywgcmVsYXRpdmUgdGltZSBmb3JtYXR0aW5nIHN1cHBvcnQgaXMgbm90IGF2YWlsYWJsZS4gVXNlIHRoaXMgZnVuY3Rpb24gdG8gZmlndXJlIG91dCBpZiB0aGF0J3MgdGhlIGNhc2UuXG4gICAqIEtleXM6XG4gICAqICogYHJlbGF0aXZlYDogd2hldGhlciB0aGlzIGVudmlyb25tZW50IHN1cHBvcnRzIHJlbGF0aXZlIHRpbWUgZm9ybWF0dGluZ1xuICAgKiBAZXhhbXBsZSBJbmZvLmZlYXR1cmVzKCkgLy89PiB7IHJlbGF0aXZlOiBmYWxzZSB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBmZWF0dXJlcygpIHtcbiAgICByZXR1cm4geyByZWxhdGl2ZTogaGFzUmVsYXRpdmUoKSB9O1xuICB9XG59XG4iLCAiaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuLi9kdXJhdGlvbi5qc1wiO1xuXG5mdW5jdGlvbiBkYXlEaWZmKGVhcmxpZXIsIGxhdGVyKSB7XG4gIGNvbnN0IHV0Y0RheVN0YXJ0ID0gKGR0KSA9PiBkdC50b1VUQygwLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSkuc3RhcnRPZihcImRheVwiKS52YWx1ZU9mKCksXG4gICAgbXMgPSB1dGNEYXlTdGFydChsYXRlcikgLSB1dGNEYXlTdGFydChlYXJsaWVyKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoRHVyYXRpb24uZnJvbU1pbGxpcyhtcykuYXMoXCJkYXlzXCIpKTtcbn1cblxuZnVuY3Rpb24gaGlnaE9yZGVyRGlmZnMoY3Vyc29yLCBsYXRlciwgdW5pdHMpIHtcbiAgY29uc3QgZGlmZmVycyA9IFtcbiAgICBbXCJ5ZWFyc1wiLCAoYSwgYikgPT4gYi55ZWFyIC0gYS55ZWFyXSxcbiAgICBbXCJxdWFydGVyc1wiLCAoYSwgYikgPT4gYi5xdWFydGVyIC0gYS5xdWFydGVyXSxcbiAgICBbXCJtb250aHNcIiwgKGEsIGIpID0+IGIubW9udGggLSBhLm1vbnRoICsgKGIueWVhciAtIGEueWVhcikgKiAxMl0sXG4gICAgW1xuICAgICAgXCJ3ZWVrc1wiLFxuICAgICAgKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgZGF5cyA9IGRheURpZmYoYSwgYik7XG4gICAgICAgIHJldHVybiAoZGF5cyAtIChkYXlzICUgNykpIC8gNztcbiAgICAgIH0sXG4gICAgXSxcbiAgICBbXCJkYXlzXCIsIGRheURpZmZdLFxuICBdO1xuXG4gIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgbGV0IGxvd2VzdE9yZGVyLCBoaWdoV2F0ZXI7XG5cbiAgZm9yIChjb25zdCBbdW5pdCwgZGlmZmVyXSBvZiBkaWZmZXJzKSB7XG4gICAgaWYgKHVuaXRzLmluZGV4T2YodW5pdCkgPj0gMCkge1xuICAgICAgbG93ZXN0T3JkZXIgPSB1bml0O1xuXG4gICAgICBsZXQgZGVsdGEgPSBkaWZmZXIoY3Vyc29yLCBsYXRlcik7XG4gICAgICBoaWdoV2F0ZXIgPSBjdXJzb3IucGx1cyh7IFt1bml0XTogZGVsdGEgfSk7XG5cbiAgICAgIGlmIChoaWdoV2F0ZXIgPiBsYXRlcikge1xuICAgICAgICBjdXJzb3IgPSBjdXJzb3IucGx1cyh7IFt1bml0XTogZGVsdGEgLSAxIH0pO1xuICAgICAgICBkZWx0YSAtPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yID0gaGlnaFdhdGVyO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRzW3VuaXRdID0gZGVsdGE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtjdXJzb3IsIHJlc3VsdHMsIGhpZ2hXYXRlciwgbG93ZXN0T3JkZXJdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZWFybGllciwgbGF0ZXIsIHVuaXRzLCBvcHRzKSB7XG4gIGxldCBbY3Vyc29yLCByZXN1bHRzLCBoaWdoV2F0ZXIsIGxvd2VzdE9yZGVyXSA9IGhpZ2hPcmRlckRpZmZzKGVhcmxpZXIsIGxhdGVyLCB1bml0cyk7XG5cbiAgY29uc3QgcmVtYWluaW5nTWlsbGlzID0gbGF0ZXIgLSBjdXJzb3I7XG5cbiAgY29uc3QgbG93ZXJPcmRlclVuaXRzID0gdW5pdHMuZmlsdGVyKFxuICAgICh1KSA9PiBbXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCJdLmluZGV4T2YodSkgPj0gMFxuICApO1xuXG4gIGlmIChsb3dlck9yZGVyVW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGhpZ2hXYXRlciA8IGxhdGVyKSB7XG4gICAgICBoaWdoV2F0ZXIgPSBjdXJzb3IucGx1cyh7IFtsb3dlc3RPcmRlcl06IDEgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhpZ2hXYXRlciAhPT0gY3Vyc29yKSB7XG4gICAgICByZXN1bHRzW2xvd2VzdE9yZGVyXSA9IChyZXN1bHRzW2xvd2VzdE9yZGVyXSB8fCAwKSArIHJlbWFpbmluZ01pbGxpcyAvIChoaWdoV2F0ZXIgLSBjdXJzb3IpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGR1cmF0aW9uID0gRHVyYXRpb24uZnJvbU9iamVjdChyZXN1bHRzLCBvcHRzKTtcblxuICBpZiAobG93ZXJPcmRlclVuaXRzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU1pbGxpcyhyZW1haW5pbmdNaWxsaXMsIG9wdHMpXG4gICAgICAuc2hpZnRUbyguLi5sb3dlck9yZGVyVW5pdHMpXG4gICAgICAucGx1cyhkdXJhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9XG59XG4iLCAiY29uc3QgbnVtYmVyaW5nU3lzdGVtcyA9IHtcbiAgYXJhYjogXCJbXFx1MDY2MC1cXHUwNjY5XVwiLFxuICBhcmFiZXh0OiBcIltcXHUwNkYwLVxcdTA2RjldXCIsXG4gIGJhbGk6IFwiW1xcdTFCNTAtXFx1MUI1OV1cIixcbiAgYmVuZzogXCJbXFx1MDlFNi1cXHUwOUVGXVwiLFxuICBkZXZhOiBcIltcXHUwOTY2LVxcdTA5NkZdXCIsXG4gIGZ1bGx3aWRlOiBcIltcXHVGRjEwLVxcdUZGMTldXCIsXG4gIGd1anI6IFwiW1xcdTBBRTYtXFx1MEFFRl1cIixcbiAgaGFuaWRlYzogXCJbXHUzMDA3fFx1NEUwMHxcdTRFOEN8XHU0RTA5fFx1NTZEQnxcdTRFOTR8XHU1MTZEfFx1NEUwM3xcdTUxNkJ8XHU0RTVEXVwiLFxuICBraG1yOiBcIltcXHUxN0UwLVxcdTE3RTldXCIsXG4gIGtuZGE6IFwiW1xcdTBDRTYtXFx1MENFRl1cIixcbiAgbGFvbzogXCJbXFx1MEVEMC1cXHUwRUQ5XVwiLFxuICBsaW1iOiBcIltcXHUxOTQ2LVxcdTE5NEZdXCIsXG4gIG1seW06IFwiW1xcdTBENjYtXFx1MEQ2Rl1cIixcbiAgbW9uZzogXCJbXFx1MTgxMC1cXHUxODE5XVwiLFxuICBteW1yOiBcIltcXHUxMDQwLVxcdTEwNDldXCIsXG4gIG9yeWE6IFwiW1xcdTBCNjYtXFx1MEI2Rl1cIixcbiAgdGFtbGRlYzogXCJbXFx1MEJFNi1cXHUwQkVGXVwiLFxuICB0ZWx1OiBcIltcXHUwQzY2LVxcdTBDNkZdXCIsXG4gIHRoYWk6IFwiW1xcdTBFNTAtXFx1MEU1OV1cIixcbiAgdGlidDogXCJbXFx1MEYyMC1cXHUwRjI5XVwiLFxuICBsYXRuOiBcIlxcXFxkXCIsXG59O1xuXG5jb25zdCBudW1iZXJpbmdTeXN0ZW1zVVRGMTYgPSB7XG4gIGFyYWI6IFsxNjMyLCAxNjQxXSxcbiAgYXJhYmV4dDogWzE3NzYsIDE3ODVdLFxuICBiYWxpOiBbNjk5MiwgNzAwMV0sXG4gIGJlbmc6IFsyNTM0LCAyNTQzXSxcbiAgZGV2YTogWzI0MDYsIDI0MTVdLFxuICBmdWxsd2lkZTogWzY1Mjk2LCA2NTMwM10sXG4gIGd1anI6IFsyNzkwLCAyNzk5XSxcbiAga2htcjogWzYxMTIsIDYxMjFdLFxuICBrbmRhOiBbMzMwMiwgMzMxMV0sXG4gIGxhb286IFszNzkyLCAzODAxXSxcbiAgbGltYjogWzY0NzAsIDY0NzldLFxuICBtbHltOiBbMzQzMCwgMzQzOV0sXG4gIG1vbmc6IFs2MTYwLCA2MTY5XSxcbiAgbXltcjogWzQxNjAsIDQxNjldLFxuICBvcnlhOiBbMjkxOCwgMjkyN10sXG4gIHRhbWxkZWM6IFszMDQ2LCAzMDU1XSxcbiAgdGVsdTogWzMxNzQsIDMxODNdLFxuICB0aGFpOiBbMzY2NCwgMzY3M10sXG4gIHRpYnQ6IFszODcyLCAzODgxXSxcbn07XG5cbmNvbnN0IGhhbmlkZWNDaGFycyA9IG51bWJlcmluZ1N5c3RlbXMuaGFuaWRlYy5yZXBsYWNlKC9bXFxbfFxcXV0vZywgXCJcIikuc3BsaXQoXCJcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURpZ2l0cyhzdHIpIHtcbiAgbGV0IHZhbHVlID0gcGFyc2VJbnQoc3RyLCAxMCk7XG4gIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgaWYgKHN0cltpXS5zZWFyY2gobnVtYmVyaW5nU3lzdGVtcy5oYW5pZGVjKSAhPT0gLTEpIHtcbiAgICAgICAgdmFsdWUgKz0gaGFuaWRlY0NoYXJzLmluZGV4T2Yoc3RyW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG51bWJlcmluZ1N5c3RlbXNVVEYxNikge1xuICAgICAgICAgIGNvbnN0IFttaW4sIG1heF0gPSBudW1iZXJpbmdTeXN0ZW1zVVRGMTZba2V5XTtcbiAgICAgICAgICBpZiAoY29kZSA+PSBtaW4gJiYgY29kZSA8PSBtYXgpIHtcbiAgICAgICAgICAgIHZhbHVlICs9IGNvZGUgLSBtaW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlnaXRSZWdleCh7IG51bWJlcmluZ1N5c3RlbSB9LCBhcHBlbmQgPSBcIlwiKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKGAke251bWJlcmluZ1N5c3RlbXNbbnVtYmVyaW5nU3lzdGVtIHx8IFwibGF0blwiXX0ke2FwcGVuZH1gKTtcbn1cbiIsICJpbXBvcnQgeyBwYXJzZU1pbGxpcywgaXNVbmRlZmluZWQsIHVudHJ1bmNhdGVZZWFyLCBzaWduZWRPZmZzZXQsIGhhc093blByb3BlcnR5IH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IHsgZGlnaXRSZWdleCwgcGFyc2VEaWdpdHMgfSBmcm9tIFwiLi9kaWdpdHMuanNcIjtcbmltcG9ydCB7IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuXG5jb25zdCBNSVNTSU5HX0ZUUCA9IFwibWlzc2luZyBJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMgc3VwcG9ydFwiO1xuXG5mdW5jdGlvbiBpbnRVbml0KHJlZ2V4LCBwb3N0ID0gKGkpID0+IGkpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoW3NdKSA9PiBwb3N0KHBhcnNlRGlnaXRzKHMpKSB9O1xufVxuXG5jb25zdCBOQlNQID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxNjApO1xuY29uc3Qgc3BhY2VPck5CU1AgPSBgKCB8JHtOQlNQfSlgO1xuY29uc3Qgc3BhY2VPck5CU1BSZWdFeHAgPSBuZXcgUmVnRXhwKHNwYWNlT3JOQlNQLCBcImdcIik7XG5cbmZ1bmN0aW9uIGZpeExpc3RSZWdleChzKSB7XG4gIC8vIG1ha2UgZG90cyBvcHRpb25hbCBhbmQgYWxzbyBtYWtlIHRoZW0gbGl0ZXJhbFxuICAvLyBtYWtlIHNwYWNlIGFuZCBub24gYnJlYWthYmxlIHNwYWNlIGNoYXJhY3RlcnMgaW50ZXJjaGFuZ2VhYmxlXG4gIHJldHVybiBzLnJlcGxhY2UoL1xcLi9nLCBcIlxcXFwuP1wiKS5yZXBsYWNlKHNwYWNlT3JOQlNQUmVnRXhwLCBzcGFjZU9yTkJTUCk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwSW5zZW5zaXRpdml0aWVzKHMpIHtcbiAgcmV0dXJuIHNcbiAgICAucmVwbGFjZSgvXFwuL2csIFwiXCIpIC8vIGlnbm9yZSBkb3RzIHRoYXQgd2VyZSBtYWRlIG9wdGlvbmFsXG4gICAgLnJlcGxhY2Uoc3BhY2VPck5CU1BSZWdFeHAsIFwiIFwiKSAvLyBpbnRlcmNoYW5nZSBzcGFjZSBhbmQgbmJzcFxuICAgIC50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBvbmVPZihzdHJpbmdzLCBzdGFydEluZGV4KSB7XG4gIGlmIChzdHJpbmdzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2V4OiBSZWdFeHAoc3RyaW5ncy5tYXAoZml4TGlzdFJlZ2V4KS5qb2luKFwifFwiKSksXG4gICAgICBkZXNlcjogKFtzXSkgPT5cbiAgICAgICAgc3RyaW5ncy5maW5kSW5kZXgoKGkpID0+IHN0cmlwSW5zZW5zaXRpdml0aWVzKHMpID09PSBzdHJpcEluc2Vuc2l0aXZpdGllcyhpKSkgKyBzdGFydEluZGV4LFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gb2Zmc2V0KHJlZ2V4LCBncm91cHMpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoWywgaCwgbV0pID0+IHNpZ25lZE9mZnNldChoLCBtKSwgZ3JvdXBzIH07XG59XG5cbmZ1bmN0aW9uIHNpbXBsZShyZWdleCkge1xuICByZXR1cm4geyByZWdleCwgZGVzZXI6IChbc10pID0+IHMgfTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlVG9rZW4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiKTtcbn1cblxuZnVuY3Rpb24gdW5pdEZvclRva2VuKHRva2VuLCBsb2MpIHtcbiAgY29uc3Qgb25lID0gZGlnaXRSZWdleChsb2MpLFxuICAgIHR3byA9IGRpZ2l0UmVnZXgobG9jLCBcInsyfVwiKSxcbiAgICB0aHJlZSA9IGRpZ2l0UmVnZXgobG9jLCBcInszfVwiKSxcbiAgICBmb3VyID0gZGlnaXRSZWdleChsb2MsIFwiezR9XCIpLFxuICAgIHNpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns2fVwiKSxcbiAgICBvbmVPclR3byA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDJ9XCIpLFxuICAgIG9uZVRvVGhyZWUgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7MSwzfVwiKSxcbiAgICBvbmVUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDZ9XCIpLFxuICAgIG9uZVRvTmluZSA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDl9XCIpLFxuICAgIHR3b1RvRm91ciA9IGRpZ2l0UmVnZXgobG9jLCBcInsyLDR9XCIpLFxuICAgIGZvdXJUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns0LDZ9XCIpLFxuICAgIGxpdGVyYWwgPSAodCkgPT4gKHsgcmVnZXg6IFJlZ0V4cChlc2NhcGVUb2tlbih0LnZhbCkpLCBkZXNlcjogKFtzXSkgPT4gcywgbGl0ZXJhbDogdHJ1ZSB9KSxcbiAgICB1bml0YXRlID0gKHQpID0+IHtcbiAgICAgIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsKHQpO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0LnZhbCkge1xuICAgICAgICAvLyBlcmFcbiAgICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLmVyYXMoXCJzaG9ydFwiLCBmYWxzZSksIDApO1xuICAgICAgICBjYXNlIFwiR0dcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLmVyYXMoXCJsb25nXCIsIGZhbHNlKSwgMCk7XG4gICAgICAgIC8vIHllYXJzXG4gICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9TaXgpO1xuICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d29Ub0ZvdXIsIHVudHJ1bmNhdGVZZWFyKTtcbiAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcbiAgICAgICAgY2FzZSBcInl5eXl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoZm91clRvU2l4KTtcbiAgICAgICAgY2FzZSBcInl5eXl5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHNpeCk7XG4gICAgICAgIC8vIG1vbnRoc1xuICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIk1NXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwic2hvcnRcIiwgdHJ1ZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcImxvbmdcIiwgdHJ1ZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJMTFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJMTExcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcInNob3J0XCIsIGZhbHNlLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiTExMTFwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwibG9uZ1wiLCBmYWxzZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgLy8gZGF0ZXNcbiAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIC8vIG9yZGluYWxzXG4gICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9UaHJlZSk7XG4gICAgICAgIGNhc2UgXCJvb29cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0aHJlZSk7XG4gICAgICAgIC8vIHRpbWVcbiAgICAgICAgY2FzZSBcIkhIXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJoaFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwibW1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJxcVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwic3NcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvVGhyZWUpO1xuICAgICAgICBjYXNlIFwiU1NTXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodGhyZWUpO1xuICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUob25lVG9OaW5lKTtcbiAgICAgICAgY2FzZSBcInV1XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZShvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJ1dXVcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmUpO1xuICAgICAgICAvLyBtZXJpZGllbVxuICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubWVyaWRpZW1zKCksIDApO1xuICAgICAgICAvLyB3ZWVrWWVhciAoaylcbiAgICAgICAgY2FzZSBcImtra2tcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcbiAgICAgICAgY2FzZSBcImtrXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvVG9Gb3VyLCB1bnRydW5jYXRlWWVhcik7XG4gICAgICAgIC8vIHdlZWtOdW1iZXIgKFcpXG4gICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiV1dcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICAvLyB3ZWVrZGF5c1xuICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZSk7XG4gICAgICAgIGNhc2UgXCJFRUVcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwic2hvcnRcIiwgZmFsc2UsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJFRUVFXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcImxvbmdcIiwgZmFsc2UsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwic2hvcnRcIiwgdHJ1ZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcImNjY2NcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwibG9uZ1wiLCB0cnVlLCBmYWxzZSksIDEpO1xuICAgICAgICAvLyBvZmZzZXQvem9uZVxuICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICBjYXNlIFwiWlpcIjpcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0KG5ldyBSZWdFeHAoYChbKy1dJHtvbmVPclR3by5zb3VyY2V9KSg/OjooJHt0d28uc291cmNlfSkpP2ApLCAyKTtcbiAgICAgICAgY2FzZSBcIlpaWlwiOlxuICAgICAgICAgIHJldHVybiBvZmZzZXQobmV3IFJlZ0V4cChgKFsrLV0ke29uZU9yVHdvLnNvdXJjZX0pKCR7dHdvLnNvdXJjZX0pP2ApLCAyKTtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgc3VwcG9ydCBaWlpaIChQU1QpIG9yIFpaWlpaIChQYWNpZmljIFN0YW5kYXJkIFRpbWUpIGluIHBhcnNpbmdcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGFueSB3YXkgdG8gZmlndXJlIG91dCB3aGF0IHRoZXkgYXJlXG4gICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZSgvW2Etel8rLS9dezEsMjU2fT8vaSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGxpdGVyYWwodCk7XG4gICAgICB9XG4gICAgfTtcblxuICBjb25zdCB1bml0ID0gdW5pdGF0ZSh0b2tlbikgfHwge1xuICAgIGludmFsaWRSZWFzb246IE1JU1NJTkdfRlRQLFxuICB9O1xuXG4gIHVuaXQudG9rZW4gPSB0b2tlbjtcblxuICByZXR1cm4gdW5pdDtcbn1cblxuY29uc3QgcGFydFR5cGVTdHlsZVRvVG9rZW5WYWwgPSB7XG4gIHllYXI6IHtcbiAgICBcIjItZGlnaXRcIjogXCJ5eVwiLFxuICAgIG51bWVyaWM6IFwieXl5eXlcIixcbiAgfSxcbiAgbW9udGg6IHtcbiAgICBudW1lcmljOiBcIk1cIixcbiAgICBcIjItZGlnaXRcIjogXCJNTVwiLFxuICAgIHNob3J0OiBcIk1NTVwiLFxuICAgIGxvbmc6IFwiTU1NTVwiLFxuICB9LFxuICBkYXk6IHtcbiAgICBudW1lcmljOiBcImRcIixcbiAgICBcIjItZGlnaXRcIjogXCJkZFwiLFxuICB9LFxuICB3ZWVrZGF5OiB7XG4gICAgc2hvcnQ6IFwiRUVFXCIsXG4gICAgbG9uZzogXCJFRUVFXCIsXG4gIH0sXG4gIGRheXBlcmlvZDogXCJhXCIsXG4gIGRheVBlcmlvZDogXCJhXCIsXG4gIGhvdXI6IHtcbiAgICBudW1lcmljOiBcImhcIixcbiAgICBcIjItZGlnaXRcIjogXCJoaFwiLFxuICB9LFxuICBtaW51dGU6IHtcbiAgICBudW1lcmljOiBcIm1cIixcbiAgICBcIjItZGlnaXRcIjogXCJtbVwiLFxuICB9LFxuICBzZWNvbmQ6IHtcbiAgICBudW1lcmljOiBcInNcIixcbiAgICBcIjItZGlnaXRcIjogXCJzc1wiLFxuICB9LFxufTtcblxuZnVuY3Rpb24gdG9rZW5Gb3JQYXJ0KHBhcnQsIGxvY2FsZSwgZm9ybWF0T3B0cykge1xuICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBwYXJ0O1xuXG4gIGlmICh0eXBlID09PSBcImxpdGVyYWxcIikge1xuICAgIHJldHVybiB7XG4gICAgICBsaXRlcmFsOiB0cnVlLFxuICAgICAgdmFsOiB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3Qgc3R5bGUgPSBmb3JtYXRPcHRzW3R5cGVdO1xuXG4gIGxldCB2YWwgPSBwYXJ0VHlwZVN0eWxlVG9Ub2tlblZhbFt0eXBlXTtcbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIpIHtcbiAgICB2YWwgPSB2YWxbc3R5bGVdO1xuICB9XG5cbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXRlcmFsOiBmYWxzZSxcbiAgICAgIHZhbCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYnVpbGRSZWdleCh1bml0cykge1xuICBjb25zdCByZSA9IHVuaXRzLm1hcCgodSkgPT4gdS5yZWdleCkucmVkdWNlKChmLCByKSA9PiBgJHtmfSgke3Iuc291cmNlfSlgLCBcIlwiKTtcbiAgcmV0dXJuIFtgXiR7cmV9JGAsIHVuaXRzXTtcbn1cblxuZnVuY3Rpb24gbWF0Y2goaW5wdXQsIHJlZ2V4LCBoYW5kbGVycykge1xuICBjb25zdCBtYXRjaGVzID0gaW5wdXQubWF0Y2gocmVnZXgpO1xuXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3QgYWxsID0ge307XG4gICAgbGV0IG1hdGNoSW5kZXggPSAxO1xuICAgIGZvciAoY29uc3QgaSBpbiBoYW5kbGVycykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGhhbmRsZXJzLCBpKSkge1xuICAgICAgICBjb25zdCBoID0gaGFuZGxlcnNbaV0sXG4gICAgICAgICAgZ3JvdXBzID0gaC5ncm91cHMgPyBoLmdyb3VwcyArIDEgOiAxO1xuICAgICAgICBpZiAoIWgubGl0ZXJhbCAmJiBoLnRva2VuKSB7XG4gICAgICAgICAgYWxsW2gudG9rZW4udmFsWzBdXSA9IGguZGVzZXIobWF0Y2hlcy5zbGljZShtYXRjaEluZGV4LCBtYXRjaEluZGV4ICsgZ3JvdXBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hJbmRleCArPSBncm91cHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbWF0Y2hlcywgYWxsXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW21hdGNoZXMsIHt9XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRlVGltZUZyb21NYXRjaGVzKG1hdGNoZXMpIHtcbiAgY29uc3QgdG9GaWVsZCA9ICh0b2tlbikgPT4ge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kXCI7XG4gICAgICBjYXNlIFwic1wiOlxuICAgICAgICByZXR1cm4gXCJzZWNvbmRcIjtcbiAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuICAgICAgY2FzZSBcImhcIjpcbiAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgIHJldHVybiBcImhvdXJcIjtcbiAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgIHJldHVybiBcImRheVwiO1xuICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgcmV0dXJuIFwib3JkaW5hbFwiO1xuICAgICAgY2FzZSBcIkxcIjpcbiAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgIHJldHVybiBcIm1vbnRoXCI7XG4gICAgICBjYXNlIFwieVwiOlxuICAgICAgICByZXR1cm4gXCJ5ZWFyXCI7XG4gICAgICBjYXNlIFwiRVwiOlxuICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla2RheVwiO1xuICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla051bWJlclwiO1xuICAgICAgY2FzZSBcImtcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla1llYXJcIjtcbiAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgIHJldHVybiBcInF1YXJ0ZXJcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBsZXQgem9uZSA9IG51bGw7XG4gIGxldCBzcGVjaWZpY09mZnNldDtcbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnopKSB7XG4gICAgem9uZSA9IElBTkFab25lLmNyZWF0ZShtYXRjaGVzLnopO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLlopKSB7XG4gICAgaWYgKCF6b25lKSB7XG4gICAgICB6b25lID0gbmV3IEZpeGVkT2Zmc2V0Wm9uZShtYXRjaGVzLlopO1xuICAgIH1cbiAgICBzcGVjaWZpY09mZnNldCA9IG1hdGNoZXMuWjtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5xKSkge1xuICAgIG1hdGNoZXMuTSA9IChtYXRjaGVzLnEgLSAxKSAqIDMgKyAxO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLmgpKSB7XG4gICAgaWYgKG1hdGNoZXMuaCA8IDEyICYmIG1hdGNoZXMuYSA9PT0gMSkge1xuICAgICAgbWF0Y2hlcy5oICs9IDEyO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hlcy5oID09PSAxMiAmJiBtYXRjaGVzLmEgPT09IDApIHtcbiAgICAgIG1hdGNoZXMuaCA9IDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1hdGNoZXMuRyA9PT0gMCAmJiBtYXRjaGVzLnkpIHtcbiAgICBtYXRjaGVzLnkgPSAtbWF0Y2hlcy55O1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnUpKSB7XG4gICAgbWF0Y2hlcy5TID0gcGFyc2VNaWxsaXMobWF0Y2hlcy51KTtcbiAgfVxuXG4gIGNvbnN0IHZhbHMgPSBPYmplY3Qua2V5cyhtYXRjaGVzKS5yZWR1Y2UoKHIsIGspID0+IHtcbiAgICBjb25zdCBmID0gdG9GaWVsZChrKTtcbiAgICBpZiAoZikge1xuICAgICAgcltmXSA9IG1hdGNoZXNba107XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gW3ZhbHMsIHpvbmUsIHNwZWNpZmljT2Zmc2V0XTtcbn1cblxubGV0IGR1bW15RGF0ZVRpbWVDYWNoZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldER1bW15RGF0ZVRpbWUoKSB7XG4gIGlmICghZHVtbXlEYXRlVGltZUNhY2hlKSB7XG4gICAgZHVtbXlEYXRlVGltZUNhY2hlID0gRGF0ZVRpbWUuZnJvbU1pbGxpcygxNTU1NTU1NTU1NTU1KTtcbiAgfVxuXG4gIHJldHVybiBkdW1teURhdGVUaW1lQ2FjaGU7XG59XG5cbmZ1bmN0aW9uIG1heWJlRXhwYW5kTWFjcm9Ub2tlbih0b2tlbiwgbG9jYWxlKSB7XG4gIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0T3B0cyA9IEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuLnZhbCk7XG5cbiAgaWYgKCFmb3JtYXRPcHRzKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0dGVyID0gRm9ybWF0dGVyLmNyZWF0ZShsb2NhbGUsIGZvcm1hdE9wdHMpO1xuICBjb25zdCBwYXJ0cyA9IGZvcm1hdHRlci5mb3JtYXREYXRlVGltZVBhcnRzKGdldER1bW15RGF0ZVRpbWUoKSk7XG5cbiAgY29uc3QgdG9rZW5zID0gcGFydHMubWFwKChwKSA9PiB0b2tlbkZvclBhcnQocCwgbG9jYWxlLCBmb3JtYXRPcHRzKSk7XG5cbiAgaWYgKHRva2Vucy5pbmNsdWRlcyh1bmRlZmluZWQpKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuZnVuY3Rpb24gZXhwYW5kTWFjcm9Ub2tlbnModG9rZW5zLCBsb2NhbGUpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQoLi4udG9rZW5zLm1hcCgodCkgPT4gbWF5YmVFeHBhbmRNYWNyb1Rva2VuKHQsIGxvY2FsZSkpKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleHBsYWluRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpIHtcbiAgY29uc3QgdG9rZW5zID0gZXhwYW5kTWFjcm9Ub2tlbnMoRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZvcm1hdCksIGxvY2FsZSksXG4gICAgdW5pdHMgPSB0b2tlbnMubWFwKCh0KSA9PiB1bml0Rm9yVG9rZW4odCwgbG9jYWxlKSksXG4gICAgZGlzcXVhbGlmeWluZ1VuaXQgPSB1bml0cy5maW5kKCh0KSA9PiB0LmludmFsaWRSZWFzb24pO1xuXG4gIGlmIChkaXNxdWFsaWZ5aW5nVW5pdCkge1xuICAgIHJldHVybiB7IGlucHV0LCB0b2tlbnMsIGludmFsaWRSZWFzb246IGRpc3F1YWxpZnlpbmdVbml0LmludmFsaWRSZWFzb24gfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbcmVnZXhTdHJpbmcsIGhhbmRsZXJzXSA9IGJ1aWxkUmVnZXgodW5pdHMpLFxuICAgICAgcmVnZXggPSBSZWdFeHAocmVnZXhTdHJpbmcsIFwiaVwiKSxcbiAgICAgIFtyYXdNYXRjaGVzLCBtYXRjaGVzXSA9IG1hdGNoKGlucHV0LCByZWdleCwgaGFuZGxlcnMpLFxuICAgICAgW3Jlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXRdID0gbWF0Y2hlc1xuICAgICAgICA/IGRhdGVUaW1lRnJvbU1hdGNoZXMobWF0Y2hlcylcbiAgICAgICAgOiBbbnVsbCwgbnVsbCwgdW5kZWZpbmVkXTtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkobWF0Y2hlcywgXCJhXCIpICYmIGhhc093blByb3BlcnR5KG1hdGNoZXMsIFwiSFwiKSkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFxuICAgICAgICBcIkNhbid0IGluY2x1ZGUgbWVyaWRpZW0gd2hlbiBzcGVjaWZ5aW5nIDI0LWhvdXIgZm9ybWF0XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7IGlucHV0LCB0b2tlbnMsIHJlZ2V4LCByYXdNYXRjaGVzLCBtYXRjaGVzLCByZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0IH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpIHtcbiAgY29uc3QgeyByZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0LCBpbnZhbGlkUmVhc29uIH0gPSBleHBsYWluRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpO1xuICByZXR1cm4gW3Jlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRSZWFzb25dO1xufVxuIiwgImltcG9ydCB7XG4gIGludGVnZXJCZXR3ZWVuLFxuICBpc0xlYXBZZWFyLFxuICB0aW1lT2JqZWN0LFxuICBkYXlzSW5ZZWFyLFxuICBkYXlzSW5Nb250aCxcbiAgd2Vla3NJbldlZWtZZWFyLFxuICBpc0ludGVnZXIsXG59IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ludmFsaWQuanNcIjtcblxuY29uc3Qgbm9uTGVhcExhZGRlciA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF0sXG4gIGxlYXBMYWRkZXIgPSBbMCwgMzEsIDYwLCA5MSwgMTIxLCAxNTIsIDE4MiwgMjEzLCAyNDQsIDI3NCwgMzA1LCAzMzVdO1xuXG5mdW5jdGlvbiB1bml0T3V0T2ZSYW5nZSh1bml0LCB2YWx1ZSkge1xuICByZXR1cm4gbmV3IEludmFsaWQoXG4gICAgXCJ1bml0IG91dCBvZiByYW5nZVwiLFxuICAgIGB5b3Ugc3BlY2lmaWVkICR7dmFsdWV9IChvZiB0eXBlICR7dHlwZW9mIHZhbHVlfSkgYXMgYSAke3VuaXR9LCB3aGljaCBpcyBpbnZhbGlkYFxuICApO1xufVxuXG5mdW5jdGlvbiBkYXlPZldlZWsoeWVhciwgbW9udGgsIGRheSkge1xuICBjb25zdCBqcyA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5KSkuZ2V0VVRDRGF5KCk7XG4gIHJldHVybiBqcyA9PT0gMCA/IDcgOiBqcztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSkge1xuICByZXR1cm4gZGF5ICsgKGlzTGVhcFllYXIoeWVhcikgPyBsZWFwTGFkZGVyIDogbm9uTGVhcExhZGRlcilbbW9udGggLSAxXTtcbn1cblxuZnVuY3Rpb24gdW5jb21wdXRlT3JkaW5hbCh5ZWFyLCBvcmRpbmFsKSB7XG4gIGNvbnN0IHRhYmxlID0gaXNMZWFwWWVhcih5ZWFyKSA/IGxlYXBMYWRkZXIgOiBub25MZWFwTGFkZGVyLFxuICAgIG1vbnRoMCA9IHRhYmxlLmZpbmRJbmRleCgoaSkgPT4gaSA8IG9yZGluYWwpLFxuICAgIGRheSA9IG9yZGluYWwgLSB0YWJsZVttb250aDBdO1xuICByZXR1cm4geyBtb250aDogbW9udGgwICsgMSwgZGF5IH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ3JlZ29yaWFuVG9XZWVrKGdyZWdPYmopIHtcbiAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSBncmVnT2JqLFxuICAgIG9yZGluYWwgPSBjb21wdXRlT3JkaW5hbCh5ZWFyLCBtb250aCwgZGF5KSxcbiAgICB3ZWVrZGF5ID0gZGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBkYXkpO1xuXG4gIGxldCB3ZWVrTnVtYmVyID0gTWF0aC5mbG9vcigob3JkaW5hbCAtIHdlZWtkYXkgKyAxMCkgLyA3KSxcbiAgICB3ZWVrWWVhcjtcblxuICBpZiAod2Vla051bWJlciA8IDEpIHtcbiAgICB3ZWVrWWVhciA9IHllYXIgLSAxO1xuICAgIHdlZWtOdW1iZXIgPSB3ZWVrc0luV2Vla1llYXIod2Vla1llYXIpO1xuICB9IGVsc2UgaWYgKHdlZWtOdW1iZXIgPiB3ZWVrc0luV2Vla1llYXIoeWVhcikpIHtcbiAgICB3ZWVrWWVhciA9IHllYXIgKyAxO1xuICAgIHdlZWtOdW1iZXIgPSAxO1xuICB9IGVsc2Uge1xuICAgIHdlZWtZZWFyID0geWVhcjtcbiAgfVxuXG4gIHJldHVybiB7IHdlZWtZZWFyLCB3ZWVrTnVtYmVyLCB3ZWVrZGF5LCAuLi50aW1lT2JqZWN0KGdyZWdPYmopIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrVG9HcmVnb3JpYW4od2Vla0RhdGEpIHtcbiAgY29uc3QgeyB3ZWVrWWVhciwgd2Vla051bWJlciwgd2Vla2RheSB9ID0gd2Vla0RhdGEsXG4gICAgd2Vla2RheU9mSmFuNCA9IGRheU9mV2Vlayh3ZWVrWWVhciwgMSwgNCksXG4gICAgeWVhckluRGF5cyA9IGRheXNJblllYXIod2Vla1llYXIpO1xuXG4gIGxldCBvcmRpbmFsID0gd2Vla051bWJlciAqIDcgKyB3ZWVrZGF5IC0gd2Vla2RheU9mSmFuNCAtIDMsXG4gICAgeWVhcjtcblxuICBpZiAob3JkaW5hbCA8IDEpIHtcbiAgICB5ZWFyID0gd2Vla1llYXIgLSAxO1xuICAgIG9yZGluYWwgKz0gZGF5c0luWWVhcih5ZWFyKTtcbiAgfSBlbHNlIGlmIChvcmRpbmFsID4geWVhckluRGF5cykge1xuICAgIHllYXIgPSB3ZWVrWWVhciArIDE7XG4gICAgb3JkaW5hbCAtPSBkYXlzSW5ZZWFyKHdlZWtZZWFyKTtcbiAgfSBlbHNlIHtcbiAgICB5ZWFyID0gd2Vla1llYXI7XG4gIH1cblxuICBjb25zdCB7IG1vbnRoLCBkYXkgfSA9IHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCk7XG4gIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIC4uLnRpbWVPYmplY3Qod2Vla0RhdGEpIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmVnb3JpYW5Ub09yZGluYWwoZ3JlZ0RhdGEpIHtcbiAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSBncmVnRGF0YTtcbiAgY29uc3Qgb3JkaW5hbCA9IGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpO1xuICByZXR1cm4geyB5ZWFyLCBvcmRpbmFsLCAuLi50aW1lT2JqZWN0KGdyZWdEYXRhKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3JkaW5hbFRvR3JlZ29yaWFuKG9yZGluYWxEYXRhKSB7XG4gIGNvbnN0IHsgeWVhciwgb3JkaW5hbCB9ID0gb3JkaW5hbERhdGE7XG4gIGNvbnN0IHsgbW9udGgsIGRheSB9ID0gdW5jb21wdXRlT3JkaW5hbCh5ZWFyLCBvcmRpbmFsKTtcbiAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSwgLi4udGltZU9iamVjdChvcmRpbmFsRGF0YSkgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRXZWVrRGF0YShvYmopIHtcbiAgY29uc3QgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai53ZWVrWWVhciksXG4gICAgdmFsaWRXZWVrID0gaW50ZWdlckJldHdlZW4ob2JqLndlZWtOdW1iZXIsIDEsIHdlZWtzSW5XZWVrWWVhcihvYmoud2Vla1llYXIpKSxcbiAgICB2YWxpZFdlZWtkYXkgPSBpbnRlZ2VyQmV0d2VlbihvYmoud2Vla2RheSwgMSwgNyk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ3ZWVrWWVhclwiLCBvYmoud2Vla1llYXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZFdlZWspIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ3ZWVrXCIsIG9iai53ZWVrKTtcbiAgfSBlbHNlIGlmICghdmFsaWRXZWVrZGF5KSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla2RheVwiLCBvYmoud2Vla2RheSk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkT3JkaW5hbERhdGEob2JqKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoueWVhciksXG4gICAgdmFsaWRPcmRpbmFsID0gaW50ZWdlckJldHdlZW4ob2JqLm9yZGluYWwsIDEsIGRheXNJblllYXIob2JqLnllYXIpKTtcblxuICBpZiAoIXZhbGlkWWVhcikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcInllYXJcIiwgb2JqLnllYXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE9yZGluYWwpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJvcmRpbmFsXCIsIG9iai5vcmRpbmFsKTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhKG9iaikge1xuICBjb25zdCB2YWxpZFllYXIgPSBpc0ludGVnZXIob2JqLnllYXIpLFxuICAgIHZhbGlkTW9udGggPSBpbnRlZ2VyQmV0d2VlbihvYmoubW9udGgsIDEsIDEyKSxcbiAgICB2YWxpZERheSA9IGludGVnZXJCZXR3ZWVuKG9iai5kYXksIDEsIGRheXNJbk1vbnRoKG9iai55ZWFyLCBvYmoubW9udGgpKTtcblxuICBpZiAoIXZhbGlkWWVhcikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcInllYXJcIiwgb2JqLnllYXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1vbnRoKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibW9udGhcIiwgb2JqLm1vbnRoKTtcbiAgfSBlbHNlIGlmICghdmFsaWREYXkpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJkYXlcIiwgb2JqLmRheSk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkVGltZURhdGEob2JqKSB7XG4gIGNvbnN0IHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kIH0gPSBvYmo7XG4gIGNvbnN0IHZhbGlkSG91ciA9XG4gICAgICBpbnRlZ2VyQmV0d2Vlbihob3VyLCAwLCAyMykgfHxcbiAgICAgIChob3VyID09PSAyNCAmJiBtaW51dGUgPT09IDAgJiYgc2Vjb25kID09PSAwICYmIG1pbGxpc2Vjb25kID09PSAwKSxcbiAgICB2YWxpZE1pbnV0ZSA9IGludGVnZXJCZXR3ZWVuKG1pbnV0ZSwgMCwgNTkpLFxuICAgIHZhbGlkU2Vjb25kID0gaW50ZWdlckJldHdlZW4oc2Vjb25kLCAwLCA1OSksXG4gICAgdmFsaWRNaWxsaXNlY29uZCA9IGludGVnZXJCZXR3ZWVuKG1pbGxpc2Vjb25kLCAwLCA5OTkpO1xuXG4gIGlmICghdmFsaWRIb3VyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwiaG91clwiLCBob3VyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRNaW51dGUpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtaW51dGVcIiwgbWludXRlKTtcbiAgfSBlbHNlIGlmICghdmFsaWRTZWNvbmQpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJzZWNvbmRcIiwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmICghdmFsaWRNaWxsaXNlY29uZCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm1pbGxpc2Vjb25kXCIsIG1pbGxpc2Vjb25kKTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cbiIsICJpbXBvcnQgRHVyYXRpb24gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCBJbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgSW5mbyBmcm9tIFwiLi9pbmZvLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuaW1wb3J0IHtcbiAgaXNVbmRlZmluZWQsXG4gIG1heWJlQXJyYXksXG4gIGlzRGF0ZSxcbiAgaXNOdW1iZXIsXG4gIGJlc3RCeSxcbiAgZGF5c0luTW9udGgsXG4gIGRheXNJblllYXIsXG4gIGlzTGVhcFllYXIsXG4gIHdlZWtzSW5XZWVrWWVhcixcbiAgbm9ybWFsaXplT2JqZWN0LFxuICByb3VuZFRvLFxuICBvYmpUb0xvY2FsVFMsXG4gIHBhZFN0YXJ0LFxufSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5pbXBvcnQgZGlmZiBmcm9tIFwiLi9pbXBsL2RpZmYuanNcIjtcbmltcG9ydCB7IHBhcnNlUkZDMjgyMkRhdGUsIHBhcnNlSVNPRGF0ZSwgcGFyc2VIVFRQRGF0ZSwgcGFyc2VTUUwgfSBmcm9tIFwiLi9pbXBsL3JlZ2V4UGFyc2VyLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUZyb21Ub2tlbnMsIGV4cGxhaW5Gcm9tVG9rZW5zIH0gZnJvbSBcIi4vaW1wbC90b2tlblBhcnNlci5qc1wiO1xuaW1wb3J0IHtcbiAgZ3JlZ29yaWFuVG9XZWVrLFxuICB3ZWVrVG9HcmVnb3JpYW4sXG4gIGdyZWdvcmlhblRvT3JkaW5hbCxcbiAgb3JkaW5hbFRvR3JlZ29yaWFuLFxuICBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YSxcbiAgaGFzSW52YWxpZFdlZWtEYXRhLFxuICBoYXNJbnZhbGlkT3JkaW5hbERhdGEsXG4gIGhhc0ludmFsaWRUaW1lRGF0YSxcbn0gZnJvbSBcIi4vaW1wbC9jb252ZXJzaW9ucy5qc1wiO1xuaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9pbXBsL2Zvcm1hdHMuanNcIjtcbmltcG9ydCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcixcbiAgSW52YWxpZFVuaXRFcnJvcixcbiAgSW52YWxpZERhdGVUaW1lRXJyb3IsXG59IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgRGF0ZVRpbWVcIjtcbmNvbnN0IE1BWF9EQVRFID0gOC42NGUxNTtcblxuZnVuY3Rpb24gdW5zdXBwb3J0ZWRab25lKHpvbmUpIHtcbiAgcmV0dXJuIG5ldyBJbnZhbGlkKFwidW5zdXBwb3J0ZWQgem9uZVwiLCBgdGhlIHpvbmUgXCIke3pvbmUubmFtZX1cIiBpcyBub3Qgc3VwcG9ydGVkYCk7XG59XG5cbi8vIHdlIGNhY2hlIHdlZWsgZGF0YSBvbiB0aGUgRFQgb2JqZWN0IGFuZCB0aGlzIGludGVybWVkaWF0ZXMgdGhlIGNhY2hlXG5mdW5jdGlvbiBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKGR0KSB7XG4gIGlmIChkdC53ZWVrRGF0YSA9PT0gbnVsbCkge1xuICAgIGR0LndlZWtEYXRhID0gZ3JlZ29yaWFuVG9XZWVrKGR0LmMpO1xuICB9XG4gIHJldHVybiBkdC53ZWVrRGF0YTtcbn1cblxuLy8gY2xvbmUgcmVhbGx5IG1lYW5zLCBcIm1ha2UgYSBuZXcgb2JqZWN0IHdpdGggdGhlc2UgbW9kaWZpY2F0aW9uc1wiLiBhbGwgXCJzZXR0ZXJzXCIgcmVhbGx5IHVzZSB0aGlzXG4vLyB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IHdoaWxlIG9ubHkgY2hhbmdpbmcgc29tZSBvZiB0aGUgcHJvcGVydGllc1xuZnVuY3Rpb24gY2xvbmUoaW5zdCwgYWx0cykge1xuICBjb25zdCBjdXJyZW50ID0ge1xuICAgIHRzOiBpbnN0LnRzLFxuICAgIHpvbmU6IGluc3Quem9uZSxcbiAgICBjOiBpbnN0LmMsXG4gICAgbzogaW5zdC5vLFxuICAgIGxvYzogaW5zdC5sb2MsXG4gICAgaW52YWxpZDogaW5zdC5pbnZhbGlkLFxuICB9O1xuICByZXR1cm4gbmV3IERhdGVUaW1lKHsgLi4uY3VycmVudCwgLi4uYWx0cywgb2xkOiBjdXJyZW50IH0pO1xufVxuXG4vLyBmaW5kIHRoZSByaWdodCBvZmZzZXQgYSBnaXZlbiBsb2NhbCB0aW1lLiBUaGUgbyBpbnB1dCBpcyBvdXIgZ3Vlc3MsIHdoaWNoIGRldGVybWluZXMgd2hpY2hcbi8vIG9mZnNldCB3ZSdsbCBwaWNrIGluIGFtYmlndW91cyBjYXNlcyAoZS5nLiB0aGVyZSBhcmUgdHdvIDMgQU1zIGIvYyBGYWxsYmFjayBEU1QpXG5mdW5jdGlvbiBmaXhPZmZzZXQobG9jYWxUUywgbywgdHopIHtcbiAgLy8gT3VyIFVUQyB0aW1lIGlzIGp1c3QgYSBndWVzcyBiZWNhdXNlIG91ciBvZmZzZXQgaXMganVzdCBhIGd1ZXNzXG4gIGxldCB1dGNHdWVzcyA9IGxvY2FsVFMgLSBvICogNjAgKiAxMDAwO1xuXG4gIC8vIFRlc3Qgd2hldGhlciB0aGUgem9uZSBtYXRjaGVzIHRoZSBvZmZzZXQgZm9yIHRoaXMgdHNcbiAgY29uc3QgbzIgPSB0ei5vZmZzZXQodXRjR3Vlc3MpO1xuXG4gIC8vIElmIHNvLCBvZmZzZXQgZGlkbid0IGNoYW5nZSBhbmQgd2UncmUgZG9uZVxuICBpZiAobyA9PT0gbzIpIHtcbiAgICByZXR1cm4gW3V0Y0d1ZXNzLCBvXTtcbiAgfVxuXG4gIC8vIElmIG5vdCwgY2hhbmdlIHRoZSB0cyBieSB0aGUgZGlmZmVyZW5jZSBpbiB0aGUgb2Zmc2V0XG4gIHV0Y0d1ZXNzIC09IChvMiAtIG8pICogNjAgKiAxMDAwO1xuXG4gIC8vIElmIHRoYXQgZ2l2ZXMgdXMgdGhlIGxvY2FsIHRpbWUgd2Ugd2FudCwgd2UncmUgZG9uZVxuICBjb25zdCBvMyA9IHR6Lm9mZnNldCh1dGNHdWVzcyk7XG4gIGlmIChvMiA9PT0gbzMpIHtcbiAgICByZXR1cm4gW3V0Y0d1ZXNzLCBvMl07XG4gIH1cblxuICAvLyBJZiBpdCdzIGRpZmZlcmVudCwgd2UncmUgaW4gYSBob2xlIHRpbWUuIFRoZSBvZmZzZXQgaGFzIGNoYW5nZWQsIGJ1dCB0aGUgd2UgZG9uJ3QgYWRqdXN0IHRoZSB0aW1lXG4gIHJldHVybiBbbG9jYWxUUyAtIE1hdGgubWluKG8yLCBvMykgKiA2MCAqIDEwMDAsIE1hdGgubWF4KG8yLCBvMyldO1xufVxuXG4vLyBjb252ZXJ0IGFuIGVwb2NoIHRpbWVzdGFtcCBpbnRvIGEgY2FsZW5kYXIgb2JqZWN0IHdpdGggdGhlIGdpdmVuIG9mZnNldFxuZnVuY3Rpb24gdHNUb09iaih0cywgb2Zmc2V0KSB7XG4gIHRzICs9IG9mZnNldCAqIDYwICogMTAwMDtcblxuICBjb25zdCBkID0gbmV3IERhdGUodHMpO1xuXG4gIHJldHVybiB7XG4gICAgeWVhcjogZC5nZXRVVENGdWxsWWVhcigpLFxuICAgIG1vbnRoOiBkLmdldFVUQ01vbnRoKCkgKyAxLFxuICAgIGRheTogZC5nZXRVVENEYXRlKCksXG4gICAgaG91cjogZC5nZXRVVENIb3VycygpLFxuICAgIG1pbnV0ZTogZC5nZXRVVENNaW51dGVzKCksXG4gICAgc2Vjb25kOiBkLmdldFVUQ1NlY29uZHMoKSxcbiAgICBtaWxsaXNlY29uZDogZC5nZXRVVENNaWxsaXNlY29uZHMoKSxcbiAgfTtcbn1cblxuLy8gY29udmVydCBhIGNhbGVuZGFyIG9iamVjdCB0byBhIGVwb2NoIHRpbWVzdGFtcFxuZnVuY3Rpb24gb2JqVG9UUyhvYmosIG9mZnNldCwgem9uZSkge1xuICByZXR1cm4gZml4T2Zmc2V0KG9ialRvTG9jYWxUUyhvYmopLCBvZmZzZXQsIHpvbmUpO1xufVxuXG4vLyBjcmVhdGUgYSBuZXcgRFQgaW5zdGFuY2UgYnkgYWRkaW5nIGEgZHVyYXRpb24sIGFkanVzdGluZyBmb3IgRFNUc1xuZnVuY3Rpb24gYWRqdXN0VGltZShpbnN0LCBkdXIpIHtcbiAgY29uc3Qgb1ByZSA9IGluc3QubyxcbiAgICB5ZWFyID0gaW5zdC5jLnllYXIgKyBNYXRoLnRydW5jKGR1ci55ZWFycyksXG4gICAgbW9udGggPSBpbnN0LmMubW9udGggKyBNYXRoLnRydW5jKGR1ci5tb250aHMpICsgTWF0aC50cnVuYyhkdXIucXVhcnRlcnMpICogMyxcbiAgICBjID0ge1xuICAgICAgLi4uaW5zdC5jLFxuICAgICAgeWVhcixcbiAgICAgIG1vbnRoLFxuICAgICAgZGF5OlxuICAgICAgICBNYXRoLm1pbihpbnN0LmMuZGF5LCBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkpICtcbiAgICAgICAgTWF0aC50cnVuYyhkdXIuZGF5cykgK1xuICAgICAgICBNYXRoLnRydW5jKGR1ci53ZWVrcykgKiA3LFxuICAgIH0sXG4gICAgbWlsbGlzVG9BZGQgPSBEdXJhdGlvbi5mcm9tT2JqZWN0KHtcbiAgICAgIHllYXJzOiBkdXIueWVhcnMgLSBNYXRoLnRydW5jKGR1ci55ZWFycyksXG4gICAgICBxdWFydGVyczogZHVyLnF1YXJ0ZXJzIC0gTWF0aC50cnVuYyhkdXIucXVhcnRlcnMpLFxuICAgICAgbW9udGhzOiBkdXIubW9udGhzIC0gTWF0aC50cnVuYyhkdXIubW9udGhzKSxcbiAgICAgIHdlZWtzOiBkdXIud2Vla3MgLSBNYXRoLnRydW5jKGR1ci53ZWVrcyksXG4gICAgICBkYXlzOiBkdXIuZGF5cyAtIE1hdGgudHJ1bmMoZHVyLmRheXMpLFxuICAgICAgaG91cnM6IGR1ci5ob3VycyxcbiAgICAgIG1pbnV0ZXM6IGR1ci5taW51dGVzLFxuICAgICAgc2Vjb25kczogZHVyLnNlY29uZHMsXG4gICAgICBtaWxsaXNlY29uZHM6IGR1ci5taWxsaXNlY29uZHMsXG4gICAgfSkuYXMoXCJtaWxsaXNlY29uZHNcIiksXG4gICAgbG9jYWxUUyA9IG9ialRvTG9jYWxUUyhjKTtcblxuICBsZXQgW3RzLCBvXSA9IGZpeE9mZnNldChsb2NhbFRTLCBvUHJlLCBpbnN0LnpvbmUpO1xuXG4gIGlmIChtaWxsaXNUb0FkZCAhPT0gMCkge1xuICAgIHRzICs9IG1pbGxpc1RvQWRkO1xuICAgIC8vIHRoYXQgY291bGQgaGF2ZSBjaGFuZ2VkIHRoZSBvZmZzZXQgYnkgZ29pbmcgb3ZlciBhIERTVCwgYnV0IHdlIHdhbnQgdG8ga2VlcCB0aGUgdHMgdGhlIHNhbWVcbiAgICBvID0gaW5zdC56b25lLm9mZnNldCh0cyk7XG4gIH1cblxuICByZXR1cm4geyB0cywgbyB9O1xufVxuXG4vLyBoZWxwZXIgdXNlZnVsIGluIHR1cm5pbmcgdGhlIHJlc3VsdHMgb2YgcGFyc2luZyBpbnRvIHJlYWwgZGF0ZXNcbi8vIGJ5IGhhbmRsaW5nIHRoZSB6b25lIG9wdGlvbnNcbmZ1bmN0aW9uIHBhcnNlRGF0YVRvRGF0ZVRpbWUocGFyc2VkLCBwYXJzZWRab25lLCBvcHRzLCBmb3JtYXQsIHRleHQsIHNwZWNpZmljT2Zmc2V0KSB7XG4gIGNvbnN0IHsgc2V0Wm9uZSwgem9uZSB9ID0gb3B0cztcbiAgaWYgKHBhcnNlZCAmJiBPYmplY3Qua2V5cyhwYXJzZWQpLmxlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IGludGVycHJldGF0aW9uWm9uZSA9IHBhcnNlZFpvbmUgfHwgem9uZSxcbiAgICAgIGluc3QgPSBEYXRlVGltZS5mcm9tT2JqZWN0KHBhcnNlZCwge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICB6b25lOiBpbnRlcnByZXRhdGlvblpvbmUsXG4gICAgICAgIHNwZWNpZmljT2Zmc2V0LFxuICAgICAgfSk7XG4gICAgcmV0dXJuIHNldFpvbmUgPyBpbnN0IDogaW5zdC5zZXRab25lKHpvbmUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKFxuICAgICAgbmV3IEludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzICR7Zm9ybWF0fWApXG4gICAgKTtcbiAgfVxufVxuXG4vLyBpZiB5b3Ugd2FudCB0byBvdXRwdXQgYSB0ZWNobmljYWwgZm9ybWF0IChlLmcuIFJGQyAyODIyKSwgdGhpcyBoZWxwZXJcbi8vIGhlbHBzIGhhbmRsZSB0aGUgZGV0YWlsc1xuZnVuY3Rpb24gdG9UZWNoRm9ybWF0KGR0LCBmb3JtYXQsIGFsbG93WiA9IHRydWUpIHtcbiAgcmV0dXJuIGR0LmlzVmFsaWRcbiAgICA/IEZvcm1hdHRlci5jcmVhdGUoTG9jYWxlLmNyZWF0ZShcImVuLVVTXCIpLCB7XG4gICAgICAgIGFsbG93WixcbiAgICAgICAgZm9yY2VTaW1wbGU6IHRydWUsXG4gICAgICB9KS5mb3JtYXREYXRlVGltZUZyb21TdHJpbmcoZHQsIGZvcm1hdClcbiAgICA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHRvSVNPRGF0ZShvLCBleHRlbmRlZCkge1xuICBjb25zdCBsb25nRm9ybWF0ID0gby5jLnllYXIgPiA5OTk5IHx8IG8uYy55ZWFyIDwgMDtcbiAgbGV0IGMgPSBcIlwiO1xuICBpZiAobG9uZ0Zvcm1hdCAmJiBvLmMueWVhciA+PSAwKSBjICs9IFwiK1wiO1xuICBjICs9IHBhZFN0YXJ0KG8uYy55ZWFyLCBsb25nRm9ybWF0ID8gNiA6IDQpO1xuXG4gIGlmIChleHRlbmRlZCkge1xuICAgIGMgKz0gXCItXCI7XG4gICAgYyArPSBwYWRTdGFydChvLmMubW9udGgpO1xuICAgIGMgKz0gXCItXCI7XG4gICAgYyArPSBwYWRTdGFydChvLmMuZGF5KTtcbiAgfSBlbHNlIHtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5tb250aCk7XG4gICAgYyArPSBwYWRTdGFydChvLmMuZGF5KTtcbiAgfVxuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gdG9JU09UaW1lKG8sIGV4dGVuZGVkLCBzdXBwcmVzc1NlY29uZHMsIHN1cHByZXNzTWlsbGlzZWNvbmRzLCBpbmNsdWRlT2Zmc2V0KSB7XG4gIGxldCBjID0gcGFkU3RhcnQoby5jLmhvdXIpO1xuICBpZiAoZXh0ZW5kZWQpIHtcbiAgICBjICs9IFwiOlwiO1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLm1pbnV0ZSk7XG4gICAgaWYgKG8uYy5zZWNvbmQgIT09IDAgfHwgIXN1cHByZXNzU2Vjb25kcykge1xuICAgICAgYyArPSBcIjpcIjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYyArPSBwYWRTdGFydChvLmMubWludXRlKTtcbiAgfVxuXG4gIGlmIChvLmMuc2Vjb25kICE9PSAwIHx8ICFzdXBwcmVzc1NlY29uZHMpIHtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5zZWNvbmQpO1xuXG4gICAgaWYgKG8uYy5taWxsaXNlY29uZCAhPT0gMCB8fCAhc3VwcHJlc3NNaWxsaXNlY29uZHMpIHtcbiAgICAgIGMgKz0gXCIuXCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KG8uYy5taWxsaXNlY29uZCwgMyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGluY2x1ZGVPZmZzZXQpIHtcbiAgICBpZiAoby5pc09mZnNldEZpeGVkICYmIG8ub2Zmc2V0ID09PSAwKSB7XG4gICAgICBjICs9IFwiWlwiO1xuICAgIH0gZWxzZSBpZiAoby5vIDwgMCkge1xuICAgICAgYyArPSBcIi1cIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYygtby5vIC8gNjApKTtcbiAgICAgIGMgKz0gXCI6XCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoLW8ubyAlIDYwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgKz0gXCIrXCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoby5vIC8gNjApKTtcbiAgICAgIGMgKz0gXCI6XCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoby5vICUgNjApKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbi8vIGRlZmF1bHRzIGZvciB1bnNwZWNpZmllZCB1bml0cyBpbiB0aGUgc3VwcG9ydGVkIGNhbGVuZGFyc1xuY29uc3QgZGVmYXVsdFVuaXRWYWx1ZXMgPSB7XG4gICAgbW9udGg6IDEsXG4gICAgZGF5OiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfSxcbiAgZGVmYXVsdFdlZWtVbml0VmFsdWVzID0ge1xuICAgIHdlZWtOdW1iZXI6IDEsXG4gICAgd2Vla2RheTogMSxcbiAgICBob3VyOiAwLFxuICAgIG1pbnV0ZTogMCxcbiAgICBzZWNvbmQ6IDAsXG4gICAgbWlsbGlzZWNvbmQ6IDAsXG4gIH0sXG4gIGRlZmF1bHRPcmRpbmFsVW5pdFZhbHVlcyA9IHtcbiAgICBvcmRpbmFsOiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfTtcblxuLy8gVW5pdHMgaW4gdGhlIHN1cHBvcnRlZCBjYWxlbmRhcnMsIHNvcnRlZCBieSBiaWduZXNzXG5jb25zdCBvcmRlcmVkVW5pdHMgPSBbXCJ5ZWFyXCIsIFwibW9udGhcIiwgXCJkYXlcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl0sXG4gIG9yZGVyZWRXZWVrVW5pdHMgPSBbXG4gICAgXCJ3ZWVrWWVhclwiLFxuICAgIFwid2Vla051bWJlclwiLFxuICAgIFwid2Vla2RheVwiLFxuICAgIFwiaG91clwiLFxuICAgIFwibWludXRlXCIsXG4gICAgXCJzZWNvbmRcIixcbiAgICBcIm1pbGxpc2Vjb25kXCIsXG4gIF0sXG4gIG9yZGVyZWRPcmRpbmFsVW5pdHMgPSBbXCJ5ZWFyXCIsIFwib3JkaW5hbFwiLCBcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXTtcblxuLy8gc3RhbmRhcmRpemUgY2FzZSBhbmQgcGx1cmFsaXR5IGluIHVuaXRzXG5mdW5jdGlvbiBub3JtYWxpemVVbml0KHVuaXQpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHtcbiAgICB5ZWFyOiBcInllYXJcIixcbiAgICB5ZWFyczogXCJ5ZWFyXCIsXG4gICAgbW9udGg6IFwibW9udGhcIixcbiAgICBtb250aHM6IFwibW9udGhcIixcbiAgICBkYXk6IFwiZGF5XCIsXG4gICAgZGF5czogXCJkYXlcIixcbiAgICBob3VyOiBcImhvdXJcIixcbiAgICBob3VyczogXCJob3VyXCIsXG4gICAgbWludXRlOiBcIm1pbnV0ZVwiLFxuICAgIG1pbnV0ZXM6IFwibWludXRlXCIsXG4gICAgcXVhcnRlcjogXCJxdWFydGVyXCIsXG4gICAgcXVhcnRlcnM6IFwicXVhcnRlclwiLFxuICAgIHNlY29uZDogXCJzZWNvbmRcIixcbiAgICBzZWNvbmRzOiBcInNlY29uZFwiLFxuICAgIG1pbGxpc2Vjb25kOiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgbWlsbGlzZWNvbmRzOiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgd2Vla2RheTogXCJ3ZWVrZGF5XCIsXG4gICAgd2Vla2RheXM6IFwid2Vla2RheVwiLFxuICAgIHdlZWtudW1iZXI6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWtzbnVtYmVyOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVrbnVtYmVyczogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla3llYXI6IFwid2Vla1llYXJcIixcbiAgICB3ZWVreWVhcnM6IFwid2Vla1llYXJcIixcbiAgICBvcmRpbmFsOiBcIm9yZGluYWxcIixcbiAgfVt1bml0LnRvTG93ZXJDYXNlKCldO1xuXG4gIGlmICghbm9ybWFsaXplZCkgdGhyb3cgbmV3IEludmFsaWRVbml0RXJyb3IodW5pdCk7XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbi8vIHRoaXMgaXMgYSBkdW1iZWQgZG93biB2ZXJzaW9uIG9mIGZyb21PYmplY3QoKSB0aGF0IHJ1bnMgYWJvdXQgNjAlIGZhc3RlclxuLy8gYnV0IGRvZXNuJ3QgZG8gYW55IHZhbGlkYXRpb24sIG1ha2VzIGEgYnVuY2ggb2YgYXNzdW1wdGlvbnMgYWJvdXQgd2hhdCB1bml0c1xuLy8gYXJlIHByZXNlbnQsIGFuZCBzbyBvbi5cblxuLy8gdGhpcyBpcyBhIGR1bWJlZCBkb3duIHZlcnNpb24gb2YgZnJvbU9iamVjdCgpIHRoYXQgcnVucyBhYm91dCA2MCUgZmFzdGVyXG4vLyBidXQgZG9lc24ndCBkbyBhbnkgdmFsaWRhdGlvbiwgbWFrZXMgYSBidW5jaCBvZiBhc3N1bXB0aW9ucyBhYm91dCB3aGF0IHVuaXRzXG4vLyBhcmUgcHJlc2VudCwgYW5kIHNvIG9uLlxuZnVuY3Rpb24gcXVpY2tEVChvYmosIG9wdHMpIHtcbiAgY29uc3Qgem9uZSA9IG5vcm1hbGl6ZVpvbmUob3B0cy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSksXG4gICAgbG9jID0gTG9jYWxlLmZyb21PYmplY3Qob3B0cyksXG4gICAgdHNOb3cgPSBTZXR0aW5ncy5ub3coKTtcblxuICBsZXQgdHMsIG87XG5cbiAgLy8gYXNzdW1lIHdlIGhhdmUgdGhlIGhpZ2hlci1vcmRlciB1bml0c1xuICBpZiAoIWlzVW5kZWZpbmVkKG9iai55ZWFyKSkge1xuICAgIGZvciAoY29uc3QgdSBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmIChpc1VuZGVmaW5lZChvYmpbdV0pKSB7XG4gICAgICAgIG9ialt1XSA9IGRlZmF1bHRVbml0VmFsdWVzW3VdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShvYmopIHx8IGhhc0ludmFsaWRUaW1lRGF0YShvYmopO1xuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9XG5cbiAgICBjb25zdCBvZmZzZXRQcm92aXMgPSB6b25lLm9mZnNldCh0c05vdyk7XG4gICAgW3RzLCBvXSA9IG9ialRvVFMob2JqLCBvZmZzZXRQcm92aXMsIHpvbmUpO1xuICB9IGVsc2Uge1xuICAgIHRzID0gdHNOb3c7XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGVUaW1lKHsgdHMsIHpvbmUsIGxvYywgbyB9KTtcbn1cblxuZnVuY3Rpb24gZGlmZlJlbGF0aXZlKHN0YXJ0LCBlbmQsIG9wdHMpIHtcbiAgY29uc3Qgcm91bmQgPSBpc1VuZGVmaW5lZChvcHRzLnJvdW5kKSA/IHRydWUgOiBvcHRzLnJvdW5kLFxuICAgIGZvcm1hdCA9IChjLCB1bml0KSA9PiB7XG4gICAgICBjID0gcm91bmRUbyhjLCByb3VuZCB8fCBvcHRzLmNhbGVuZGFyeSA/IDAgOiAyLCB0cnVlKTtcbiAgICAgIGNvbnN0IGZvcm1hdHRlciA9IGVuZC5sb2MuY2xvbmUob3B0cykucmVsRm9ybWF0dGVyKG9wdHMpO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoYywgdW5pdCk7XG4gICAgfSxcbiAgICBkaWZmZXIgPSAodW5pdCkgPT4ge1xuICAgICAgaWYgKG9wdHMuY2FsZW5kYXJ5KSB7XG4gICAgICAgIGlmICghZW5kLmhhc1NhbWUoc3RhcnQsIHVuaXQpKSB7XG4gICAgICAgICAgcmV0dXJuIGVuZC5zdGFydE9mKHVuaXQpLmRpZmYoc3RhcnQuc3RhcnRPZih1bml0KSwgdW5pdCkuZ2V0KHVuaXQpO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZW5kLmRpZmYoc3RhcnQsIHVuaXQpLmdldCh1bml0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIGlmIChvcHRzLnVuaXQpIHtcbiAgICByZXR1cm4gZm9ybWF0KGRpZmZlcihvcHRzLnVuaXQpLCBvcHRzLnVuaXQpO1xuICB9XG5cbiAgZm9yIChjb25zdCB1bml0IG9mIG9wdHMudW5pdHMpIHtcbiAgICBjb25zdCBjb3VudCA9IGRpZmZlcih1bml0KTtcbiAgICBpZiAoTWF0aC5hYnMoY291bnQpID49IDEpIHtcbiAgICAgIHJldHVybiBmb3JtYXQoY291bnQsIHVuaXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZm9ybWF0KHN0YXJ0ID4gZW5kID8gLTAgOiAwLCBvcHRzLnVuaXRzW29wdHMudW5pdHMubGVuZ3RoIC0gMV0pO1xufVxuXG5mdW5jdGlvbiBsYXN0T3B0cyhhcmdMaXN0KSB7XG4gIGxldCBvcHRzID0ge30sXG4gICAgYXJncztcbiAgaWYgKGFyZ0xpc3QubGVuZ3RoID4gMCAmJiB0eXBlb2YgYXJnTGlzdFthcmdMaXN0Lmxlbmd0aCAtIDFdID09PSBcIm9iamVjdFwiKSB7XG4gICAgb3B0cyA9IGFyZ0xpc3RbYXJnTGlzdC5sZW5ndGggLSAxXTtcbiAgICBhcmdzID0gQXJyYXkuZnJvbShhcmdMaXN0KS5zbGljZSgwLCBhcmdMaXN0Lmxlbmd0aCAtIDEpO1xuICB9IGVsc2Uge1xuICAgIGFyZ3MgPSBBcnJheS5mcm9tKGFyZ0xpc3QpO1xuICB9XG4gIHJldHVybiBbb3B0cywgYXJnc107XG59XG5cbi8qKlxuICogQSBEYXRlVGltZSBpcyBhbiBpbW11dGFibGUgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGEgc3BlY2lmaWMgZGF0ZSBhbmQgdGltZSBhbmQgYWNjb21wYW55aW5nIG1ldGhvZHMuIEl0IGNvbnRhaW5zIGNsYXNzIGFuZCBpbnN0YW5jZSBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgdHJhbnNmb3JtaW5nLCBhbmQgZm9ybWF0dGluZyB0aGVtLlxuICpcbiAqIEEgRGF0ZVRpbWUgY29tcHJpc2VzIG9mOlxuICogKiBBIHRpbWVzdGFtcC4gRWFjaCBEYXRlVGltZSBpbnN0YW5jZSByZWZlcnMgdG8gYSBzcGVjaWZpYyBtaWxsaXNlY29uZCBvZiB0aGUgVW5peCBlcG9jaC5cbiAqICogQSB0aW1lIHpvbmUuIEVhY2ggaW5zdGFuY2UgaXMgY29uc2lkZXJlZCBpbiB0aGUgY29udGV4dCBvZiBhIHNwZWNpZmljIHpvbmUgKGJ5IGRlZmF1bHQgdGhlIGxvY2FsIHN5c3RlbSdzIHpvbmUpLlxuICogKiBDb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdGhhdCBlZmZlY3QgaG93IG91dHB1dCBzdHJpbmdzIGFyZSBmb3JtYXR0ZWQsIHN1Y2ggYXMgYGxvY2FsZWAsIGBudW1iZXJpbmdTeXN0ZW1gLCBhbmQgYG91dHB1dENhbGVuZGFyYC5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBmdW5jdGlvbmFsaXR5IGl0IHByb3ZpZGVzOlxuICpcbiAqICogKipDcmVhdGlvbioqOiBUbyBjcmVhdGUgYSBEYXRlVGltZSBmcm9tIGl0cyBjb21wb25lbnRzLCB1c2Ugb25lIG9mIGl0cyBmYWN0b3J5IGNsYXNzIG1ldGhvZHM6IHtAbGluayBEYXRlVGltZSNsb2NhbH0sIHtAbGluayBEYXRlVGltZSN1dGN9LCBhbmQgKG1vc3QgZmxleGlibHkpIHtAbGluayBEYXRlVGltZSNmcm9tT2JqZWN0fS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgc3RhbmRhcmQgc3RyaW5nIGZvcm1hdCwgdXNlIHtAbGluayBEYXRlVGltZSNmcm9tSVNPfSwge0BsaW5rIERhdGVUaW1lI2Zyb21IVFRQfSwgYW5kIHtAbGluayBEYXRlVGltZSNmcm9tUkZDMjgyMn0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIGN1c3RvbSBzdHJpbmcgZm9ybWF0LCB1c2Uge0BsaW5rIERhdGVUaW1lI2Zyb21Gb3JtYXR9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBuYXRpdmUgSlMgZGF0ZSwgdXNlIHtAbGluayBEYXRlVGltZSNmcm9tSlNEYXRlfS5cbiAqICogKipHcmVnb3JpYW4gY2FsZW5kYXIgYW5kIHRpbWUqKjogVG8gZXhhbWluZSB0aGUgR3JlZ29yaWFuIHByb3BlcnRpZXMgb2YgYSBEYXRlVGltZSBpbmRpdmlkdWFsbHkgKGkuZSBhcyBvcHBvc2VkIHRvIGNvbGxlY3RpdmVseSB0aHJvdWdoIHtAbGluayBEYXRlVGltZSN0b09iamVjdH0pLCB1c2UgdGhlIHtAbGluayBEYXRlVGltZSN5ZWFyfSwge0BsaW5rIERhdGVUaW1lI21vbnRofSxcbiAqIHtAbGluayBEYXRlVGltZSNkYXl9LCB7QGxpbmsgRGF0ZVRpbWUjaG91cn0sIHtAbGluayBEYXRlVGltZSNtaW51dGV9LCB7QGxpbmsgRGF0ZVRpbWUjc2Vjb25kfSwge0BsaW5rIERhdGVUaW1lI21pbGxpc2Vjb25kfSBhY2Nlc3NvcnMuXG4gKiAqICoqV2VlayBjYWxlbmRhcioqOiBGb3IgSVNPIHdlZWsgY2FsZW5kYXIgYXR0cmlidXRlcywgc2VlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjd2Vla1llYXJ9LCB7QGxpbmsgRGF0ZVRpbWUjd2Vla051bWJlcn0sIGFuZCB7QGxpbmsgRGF0ZVRpbWUjd2Vla2RheX0gYWNjZXNzb3JzLlxuICogKiAqKkNvbmZpZ3VyYXRpb24qKiBTZWUgdGhlIHtAbGluayBEYXRlVGltZSNsb2NhbGV9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjbnVtYmVyaW5nU3lzdGVtfSBhY2Nlc3NvcnMuXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKjogVG8gdHJhbnNmb3JtIHRoZSBEYXRlVGltZSBpbnRvIG90aGVyIERhdGVUaW1lcywgdXNlIHtAbGluayBEYXRlVGltZSNzZXR9LCB7QGxpbmsgRGF0ZVRpbWUjcmVjb25maWd1cmV9LCB7QGxpbmsgRGF0ZVRpbWUjc2V0Wm9uZX0sIHtAbGluayBEYXRlVGltZSNzZXRMb2NhbGV9LCB7QGxpbmsgRGF0ZVRpbWUucGx1c30sIHtAbGluayBEYXRlVGltZSNtaW51c30sIHtAbGluayBEYXRlVGltZSNlbmRPZn0sIHtAbGluayBEYXRlVGltZSNzdGFydE9mfSwge0BsaW5rIERhdGVUaW1lI3RvVVRDfSwgYW5kIHtAbGluayBEYXRlVGltZSN0b0xvY2FsfS5cbiAqICogKipPdXRwdXQqKjogVG8gY29udmVydCB0aGUgRGF0ZVRpbWUgdG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCB1c2UgdGhlIHtAbGluayBEYXRlVGltZSN0b1JlbGF0aXZlfSwge0BsaW5rIERhdGVUaW1lI3RvUmVsYXRpdmVDYWxlbmRhcn0sIHtAbGluayBEYXRlVGltZSN0b0pTT059LCB7QGxpbmsgRGF0ZVRpbWUjdG9JU099LCB7QGxpbmsgRGF0ZVRpbWUjdG9IVFRQfSwge0BsaW5rIERhdGVUaW1lI3RvT2JqZWN0fSwge0BsaW5rIERhdGVUaW1lI3RvUkZDMjgyMn0sIHtAbGluayBEYXRlVGltZSN0b1N0cmluZ30sIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30sIHtAbGluayBEYXRlVGltZSN0b0Zvcm1hdH0sIHtAbGluayBEYXRlVGltZSN0b01pbGxpc30gYW5kIHtAbGluayBEYXRlVGltZSN0b0pTRGF0ZX0uXG4gKlxuICogVGhlcmUncyBwbGVudHkgb3RoZXJzIGRvY3VtZW50ZWQgYmVsb3cuIEluIGFkZGl0aW9uLCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBzdWJ0bGVyIHRvcGljcyBsaWtlIGludGVybmF0aW9uYWxpemF0aW9uLCB0aW1lIHpvbmVzLCBhbHRlcm5hdGl2ZSBjYWxlbmRhcnMsIHZhbGlkaXR5LCBhbmQgc28gb24sIHNlZSB0aGUgZXh0ZXJuYWwgZG9jdW1lbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0ZVRpbWUge1xuICAvKipcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBjb25zdCB6b25lID0gY29uZmlnLnpvbmUgfHwgU2V0dGluZ3MuZGVmYXVsdFpvbmU7XG5cbiAgICBsZXQgaW52YWxpZCA9XG4gICAgICBjb25maWcuaW52YWxpZCB8fFxuICAgICAgKE51bWJlci5pc05hTihjb25maWcudHMpID8gbmV3IEludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpIDogbnVsbCkgfHxcbiAgICAgICghem9uZS5pc1ZhbGlkID8gdW5zdXBwb3J0ZWRab25lKHpvbmUpIDogbnVsbCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50cyA9IGlzVW5kZWZpbmVkKGNvbmZpZy50cykgPyBTZXR0aW5ncy5ub3coKSA6IGNvbmZpZy50cztcblxuICAgIGxldCBjID0gbnVsbCxcbiAgICAgIG8gPSBudWxsO1xuICAgIGlmICghaW52YWxpZCkge1xuICAgICAgY29uc3QgdW5jaGFuZ2VkID0gY29uZmlnLm9sZCAmJiBjb25maWcub2xkLnRzID09PSB0aGlzLnRzICYmIGNvbmZpZy5vbGQuem9uZS5lcXVhbHMoem9uZSk7XG5cbiAgICAgIGlmICh1bmNoYW5nZWQpIHtcbiAgICAgICAgW2MsIG9dID0gW2NvbmZpZy5vbGQuYywgY29uZmlnLm9sZC5vXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG90ID0gem9uZS5vZmZzZXQodGhpcy50cyk7XG4gICAgICAgIGMgPSB0c1RvT2JqKHRoaXMudHMsIG90KTtcbiAgICAgICAgaW52YWxpZCA9IE51bWJlci5pc05hTihjLnllYXIpID8gbmV3IEludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpIDogbnVsbDtcbiAgICAgICAgYyA9IGludmFsaWQgPyBudWxsIDogYztcbiAgICAgICAgbyA9IGludmFsaWQgPyBudWxsIDogb3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fem9uZSA9IHpvbmU7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2MgPSBjb25maWcubG9jIHx8IExvY2FsZS5jcmVhdGUoKTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBpbnZhbGlkO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMud2Vla0RhdGEgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYyA9IGM7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vID0gbztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTHV4b25EYXRlVGltZSA9IHRydWU7XG4gIH1cblxuICAvLyBDT05TVFJVQ1RcblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZm9yIHRoZSBjdXJyZW50IGluc3RhbnQsIGluIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUuXG4gICAqXG4gICAqIFVzZSBTZXR0aW5ncyB0byBvdmVycmlkZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpZiBuZWVkZWQuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKCkgLy9+PiBub3cgaW4gdGhlIElTTyBmb3JtYXRcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgbm93KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxvY2FsIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYGxvY2FsKClgIHdpdGggbm8gYXJndW1lbnRzKSwgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttb250aD0xXSAtIFRoZSBtb250aCwgMS1pbmRleGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF5PTFdIC0gVGhlIGRheSBvZiB0aGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hvdXI9MF0gLSBUaGUgaG91ciBvZiB0aGUgZGF5LCBpbiAyNC1ob3VyIHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW51dGU9MF0gLSBUaGUgbWludXRlIG9mIHRoZSBob3VyLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmQ9MF0gLSBUaGUgc2Vjb25kIG9mIHRoZSBtaW51dGUsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbGxpc2Vjb25kPTBdIC0gVGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA5OTlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IG5vd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCh7IHpvbmU6IFwiQW1lcmljYS9OZXdfWW9ya1wiIH0pICAgICAgLy9+PiBub3csIGluIFVTIGVhc3QgY29hc3QgdGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMS0wMVQwMDowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0wMVQwMDowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgeyBsb2NhbGU6IFwiZnJcIiB9KSAgICAgLy9+PiAyMDE3LTAzLTEyVDAwOjAwOjAwLCB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSkgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgeyB6b25lOiBcInV0Y1wiIH0pICAgLy9+PiAyMDE3LTAzLTEyVDA1OjAwOjAwLCBpbiBVVENcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1KSAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCkgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCwgNzY1KSAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTAuNzY1XG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGxvY2FsKCkge1xuICAgIGNvbnN0IFtvcHRzLCBhcmdzXSA9IGxhc3RPcHRzKGFyZ3VtZW50cyksXG4gICAgICBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXSA9IGFyZ3M7XG4gICAgcmV0dXJuIHF1aWNrRFQoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgaW4gVVRDXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYHV0YygpYCB3aXRoIG5vIGFyZ3VtZW50cyksIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbW9udGg9MV0gLSBUaGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RheT0xXSAtIFRoZSBkYXkgb2YgdGhlIG1vbnRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaG91cj0wXSAtIFRoZSBob3VyIG9mIHRoZSBkYXksIGluIDI0LWhvdXIgdGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbnV0ZT0wXSAtIFRoZSBtaW51dGUgb2YgdGhlIGhvdXIsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZD0wXSAtIFRoZSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWlsbGlzZWNvbmQ9MF0gLSBUaGUgbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDk5OVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm91dHB1dENhbGVuZGFyXSAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm51bWJlcmluZ1N5c3RlbV0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IG5vd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDEtMDFUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0wMVQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUpICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NTowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgeyBsb2NhbGU6IFwiZnJcIiB9KSAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBaIHdpdGggYSBGcmVuY2ggbG9jYWxlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUsIDEwKSAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTAsIDc2NSwgeyBsb2NhbGU6IFwiZnJcIiB9KSAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTAuNzY1WiB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyB1dGMoKSB7XG4gICAgY29uc3QgW29wdHMsIGFyZ3NdID0gbGFzdE9wdHMoYXJndW1lbnRzKSxcbiAgICAgIFt5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdID0gYXJncztcblxuICAgIG9wdHMuem9uZSA9IEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZTtcbiAgICByZXR1cm4gcXVpY2tEVCh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCB9LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgSmF2YVNjcmlwdCBEYXRlIG9iamVjdC4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgLSBhIEphdmFTY3JpcHQgRGF0ZSBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUpTRGF0ZShkYXRlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB0cyA9IGlzRGF0ZShkYXRlKSA/IGRhdGUudmFsdWVPZigpIDogTmFOO1xuICAgIGlmIChOdW1iZXIuaXNOYU4odHMpKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcImludmFsaWQgaW5wdXRcIik7XG4gICAgfVxuXG4gICAgY29uc3Qgem9uZVRvVXNlID0gbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgICBpZiAoIXpvbmVUb1VzZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZVRvVXNlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgICB0czogdHMsXG4gICAgICB6b25lOiB6b25lVG9Vc2UsXG4gICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaCAobWVhbmluZyBzaW5jZSAxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLiBVc2VzIHRoZSBkZWZhdWx0IHpvbmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaWxsaXNlY29uZHMgLSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgMTk3MCBVVENcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsZV0gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbU1pbGxpcyhtaWxsaXNlY29uZHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNOdW1iZXIobWlsbGlzZWNvbmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgZnJvbU1pbGxpcyByZXF1aXJlcyBhIG51bWVyaWNhbCBpbnB1dCwgYnV0IHJlY2VpdmVkIGEgJHt0eXBlb2YgbWlsbGlzZWNvbmRzfSB3aXRoIHZhbHVlICR7bWlsbGlzZWNvbmRzfWBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChtaWxsaXNlY29uZHMgPCAtTUFYX0RBVEUgfHwgbWlsbGlzZWNvbmRzID4gTUFYX0RBVEUpIHtcbiAgICAgIC8vIHRoaXMgaXNuJ3QgcGVyZmVjdCBiZWNhdXNlIGJlY2F1c2Ugd2UgY2FuIHN0aWxsIGVuZCB1cCBvdXQgb2YgcmFuZ2UgYmVjYXVzZSBvZiBhZGRpdGlvbmFsIHNoaWZ0aW5nLCBidXQgaXQncyBhIHN0YXJ0XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcIlRpbWVzdGFtcCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogbWlsbGlzZWNvbmRzLFxuICAgICAgICB6b25lOiBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpLFxuICAgICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggKG1lYW5pbmcgc2luY2UgMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Vjb25kcyAtIGEgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgMTk3MCBVVENcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsZV0gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVNlY29uZHMoc2Vjb25kcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc051bWJlcihzZWNvbmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiZnJvbVNlY29uZHMgcmVxdWlyZXMgYSBudW1lcmljYWwgaW5wdXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogc2Vjb25kcyAqIDEwMDAsXG4gICAgICAgIHpvbmU6IG5vcm1hbGl6ZVpvbmUob3B0aW9ucy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSksXG4gICAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob3B0aW9ucyksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFyJyBhbmQgJ2hvdXInIHdpdGggcmVhc29uYWJsZSBkZWZhdWx0cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gY3JlYXRlIHRoZSBEYXRlVGltZSBmcm9tXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoueWVhciAtIGEgeWVhciwgc3VjaCBhcyAxOTg3XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubW9udGggLSBhIG1vbnRoLCAxLTEyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouZGF5IC0gYSBkYXkgb2YgdGhlIG1vbnRoLCAxLTMxLCBkZXBlbmRpbmcgb24gdGhlIG1vbnRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoub3JkaW5hbCAtIGRheSBvZiB0aGUgeWVhciwgMS0zNjUgb3IgMzY2XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla1llYXIgLSBhbiBJU08gd2VlayB5ZWFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla051bWJlciAtIGFuIElTTyB3ZWVrIG51bWJlciwgYmV0d2VlbiAxIGFuZCA1MiBvciA1MywgZGVwZW5kaW5nIG9uIHRoZSB5ZWFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla2RheSAtIGFuIElTTyB3ZWVrZGF5LCAxLTcsIHdoZXJlIDEgaXMgTW9uZGF5IGFuZCA3IGlzIFN1bmRheVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmhvdXIgLSBob3VyIG9mIHRoZSBkYXksIDAtMjNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taW51dGUgLSBtaW51dGUgb2YgdGhlIGhvdXIsIDAtNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5zZWNvbmQgLSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSwgMC01OVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbGxpc2Vjb25kIC0gbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCwgMC05OTlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSBpbnRlcnByZXQgdGhlIG51bWJlcnMgaW4gdGhlIGNvbnRleHQgb2YgYSBwYXJ0aWN1bGFyIHpvbmUuIENhbiB0YWtlIGFueSB2YWx1ZSB0YWtlbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gc2V0Wm9uZSgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyLCBtb250aDogNSwgZGF5OiAyNX0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDUtMjUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyIH0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDEtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0pIC8vfj4gdG9kYXkgYXQgMTA6MjY6MDZcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSwgeyB6b25lOiAndXRjJyB9KSxcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSwgeyB6b25lOiAnbG9jYWwnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0sIHsgem9uZTogJ0FtZXJpY2EvTmV3X1lvcmsnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB3ZWVrWWVhcjogMjAxNiwgd2Vla051bWJlcjogMiwgd2Vla2RheTogMyB9KS50b0lTT0RhdGUoKSAvLz0+ICcyMDE2LTAxLTEzJ1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tT2JqZWN0KG9iaiwgb3B0cyA9IHt9KSB7XG4gICAgb2JqID0gb2JqIHx8IHt9O1xuICAgIGNvbnN0IHpvbmVUb1VzZSA9IG5vcm1hbGl6ZVpvbmUob3B0cy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gICAgaWYgKCF6b25lVG9Vc2UuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmVUb1VzZSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHRzTm93ID0gU2V0dGluZ3Mubm93KCksXG4gICAgICBvZmZzZXRQcm92aXMgPSAhaXNVbmRlZmluZWQob3B0cy5zcGVjaWZpY09mZnNldClcbiAgICAgICAgPyBvcHRzLnNwZWNpZmljT2Zmc2V0XG4gICAgICAgIDogem9uZVRvVXNlLm9mZnNldCh0c05vdyksXG4gICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplT2JqZWN0KG9iaiwgbm9ybWFsaXplVW5pdCksXG4gICAgICBjb250YWluc09yZGluYWwgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yWWVhciA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLnllYXIpLFxuICAgICAgY29udGFpbnNHcmVnb3JNRCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm1vbnRoKSB8fCAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpLFxuICAgICAgY29udGFpbnNHcmVnb3IgPSBjb250YWluc0dyZWdvclllYXIgfHwgY29udGFpbnNHcmVnb3JNRCxcbiAgICAgIGRlZmluaXRlV2Vla0RlZiA9IG5vcm1hbGl6ZWQud2Vla1llYXIgfHwgbm9ybWFsaXplZC53ZWVrTnVtYmVyLFxuICAgICAgbG9jID0gTG9jYWxlLmZyb21PYmplY3Qob3B0cyk7XG5cbiAgICAvLyBjYXNlczpcbiAgICAvLyBqdXN0IGEgd2Vla2RheSAtPiB0aGlzIHdlZWsncyBpbnN0YW5jZSBvZiB0aGF0IHdlZWtkYXksIG5vIHdvcnJpZXNcbiAgICAvLyAoZ3JlZ29yaWFuIGRhdGEgb3Igb3JkaW5hbCkgKyAod2Vla1llYXIgb3Igd2Vla051bWJlcikgLT4gZXJyb3JcbiAgICAvLyAoZ3JlZ29yaWFuIG1vbnRoIG9yIGRheSkgKyBvcmRpbmFsIC0+IGVycm9yXG4gICAgLy8gb3RoZXJ3aXNlIGp1c3QgdXNlIHdlZWtzIG9yIG9yZGluYWxzIG9yIGdyZWdvcmlhbiwgZGVwZW5kaW5nIG9uIHdoYXQncyBzcGVjaWZpZWRcblxuICAgIGlmICgoY29udGFpbnNHcmVnb3IgfHwgY29udGFpbnNPcmRpbmFsKSAmJiBkZWZpbml0ZVdlZWtEZWYpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW4ndCBtaXggd2Vla1llYXIvd2Vla051bWJlciB1bml0cyB3aXRoIHllYXIvbW9udGgvZGF5IG9yIG9yZGluYWxzXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5zR3JlZ29yTUQgJiYgY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXCJDYW4ndCBtaXggb3JkaW5hbCBkYXRlcyB3aXRoIG1vbnRoL2RheVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VXZWVrRGF0YSA9IGRlZmluaXRlV2Vla0RlZiB8fCAobm9ybWFsaXplZC53ZWVrZGF5ICYmICFjb250YWluc0dyZWdvcik7XG5cbiAgICAvLyBjb25maWd1cmUgb3Vyc2VsdmVzIHRvIGRlYWwgd2l0aCBncmVnb3JpYW4gZGF0ZXMgb3Igd2VlayBzdHVmZlxuICAgIGxldCB1bml0cyxcbiAgICAgIGRlZmF1bHRWYWx1ZXMsXG4gICAgICBvYmpOb3cgPSB0c1RvT2JqKHRzTm93LCBvZmZzZXRQcm92aXMpO1xuICAgIGlmICh1c2VXZWVrRGF0YSkge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkV2Vla1VuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRXZWVrVW5pdFZhbHVlcztcbiAgICAgIG9iak5vdyA9IGdyZWdvcmlhblRvV2VlayhvYmpOb3cpO1xuICAgIH0gZWxzZSBpZiAoY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRPcmRpbmFsVW5pdHM7XG4gICAgICBkZWZhdWx0VmFsdWVzID0gZGVmYXVsdE9yZGluYWxVbml0VmFsdWVzO1xuICAgICAgb2JqTm93ID0gZ3JlZ29yaWFuVG9PcmRpbmFsKG9iak5vdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZFVuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRVbml0VmFsdWVzO1xuICAgIH1cblxuICAgIC8vIHNldCBkZWZhdWx0IHZhbHVlcyBmb3IgbWlzc2luZyBzdHVmZlxuICAgIGxldCBmb3VuZEZpcnN0ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB1IG9mIHVuaXRzKSB7XG4gICAgICBjb25zdCB2ID0gbm9ybWFsaXplZFt1XTtcbiAgICAgIGlmICghaXNVbmRlZmluZWQodikpIHtcbiAgICAgICAgZm91bmRGaXJzdCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGZvdW5kRmlyc3QpIHtcbiAgICAgICAgbm9ybWFsaXplZFt1XSA9IGRlZmF1bHRWYWx1ZXNbdV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkW3VdID0gb2JqTm93W3VdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGUgdmFsdWVzIHdlIGhhdmUgYXJlIGluIHJhbmdlXG4gICAgY29uc3QgaGlnaGVyT3JkZXJJbnZhbGlkID0gdXNlV2Vla0RhdGFcbiAgICAgICAgPyBoYXNJbnZhbGlkV2Vla0RhdGEobm9ybWFsaXplZClcbiAgICAgICAgOiBjb250YWluc09yZGluYWxcbiAgICAgICAgPyBoYXNJbnZhbGlkT3JkaW5hbERhdGEobm9ybWFsaXplZClcbiAgICAgICAgOiBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShub3JtYWxpemVkKSxcbiAgICAgIGludmFsaWQgPSBoaWdoZXJPcmRlckludmFsaWQgfHwgaGFzSW52YWxpZFRpbWVEYXRhKG5vcm1hbGl6ZWQpO1xuXG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgdGhlIGFjdHVhbCB0aW1lXG4gICAgY29uc3QgZ3JlZ29yaWFuID0gdXNlV2Vla0RhdGFcbiAgICAgICAgPyB3ZWVrVG9HcmVnb3JpYW4obm9ybWFsaXplZClcbiAgICAgICAgOiBjb250YWluc09yZGluYWxcbiAgICAgICAgPyBvcmRpbmFsVG9HcmVnb3JpYW4obm9ybWFsaXplZClcbiAgICAgICAgOiBub3JtYWxpemVkLFxuICAgICAgW3RzRmluYWwsIG9mZnNldEZpbmFsXSA9IG9ialRvVFMoZ3JlZ29yaWFuLCBvZmZzZXRQcm92aXMsIHpvbmVUb1VzZSksXG4gICAgICBpbnN0ID0gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IHRzRmluYWwsXG4gICAgICAgIHpvbmU6IHpvbmVUb1VzZSxcbiAgICAgICAgbzogb2Zmc2V0RmluYWwsXG4gICAgICAgIGxvYyxcbiAgICAgIH0pO1xuXG4gICAgLy8gZ3JlZ29yaWFuIGRhdGEgKyB3ZWVrZGF5IHNlcnZlcyBvbmx5IHRvIHZhbGlkYXRlXG4gICAgaWYgKG5vcm1hbGl6ZWQud2Vla2RheSAmJiBjb250YWluc0dyZWdvciAmJiBvYmoud2Vla2RheSAhPT0gaW5zdC53ZWVrZGF5KSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcbiAgICAgICAgXCJtaXNtYXRjaGVkIHdlZWtkYXlcIixcbiAgICAgICAgYHlvdSBjYW4ndCBzcGVjaWZ5IGJvdGggYSB3ZWVrZGF5IG9mICR7bm9ybWFsaXplZC53ZWVrZGF5fSBhbmQgYSBkYXRlIG9mICR7aW5zdC50b0lTTygpfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBJU08gODYwMSBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSVNPIHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXJdIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMrMDY6MDAnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMyswNjowMCcsIHtzZXRab25lOiB0cnVlfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMnLCB7em9uZTogJ3V0Yyd9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LVcwNS00JylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZUlTT0RhdGUodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJJU08gODYwMVwiLCB0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIFJGQyAyODIyIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBSRkMgMjgyMiBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIGNvbnZlcnQgdGhlIHRpbWUgdG8gdGhpcyB6b25lLiBTaW5jZSB0aGUgb2Zmc2V0IGlzIGFsd2F5cyBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIHRoaXMgaGFzIG5vIGVmZmVjdCBvbiB0aGUgaW50ZXJwcmV0YXRpb24gb2Ygc3RyaW5nLCBtZXJlbHkgdGhlIHpvbmUgdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpcyBleHByZXNzZWQgaW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgZml4ZWQtb2Zmc2V0IHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCcyNSBOb3YgMjAxNiAxMzoyMzoxMiBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tUkZDMjgyMignRnJpLCAyNSBOb3YgMjAxNiAxMzoyMzoxMiArMDYwMCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCcyNSBOb3YgMjAxNiAxMzoyMyBaJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVJGQzI4MjIodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VSRkMyODIyRGF0ZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIlJGQyAyODIyXCIsIHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gSFRUUCBoZWFkZXIgZGF0ZVxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9Qcm90b2NvbHMvcmZjMjYxNi9yZmMyNjE2LXNlYzMuaHRtbCNzZWMzLjMuMVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBIVFRQIGhlYWRlciBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSBjb252ZXJ0IHRoZSB0aW1lIHRvIHRoaXMgem9uZS4gU2luY2UgSFRUUCBkYXRlcyBhcmUgYWx3YXlzIGluIFVUQywgdGhpcyBoYXMgbm8gZWZmZWN0IG9uIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBzdHJpbmcsIG1lcmVseSB0aGUgem9uZSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGlzIGV4cHJlc3NlZCBpbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggdGhlIGZpeGVkLW9mZnNldCB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nLiBGb3IgSFRUUCBkYXRlcywgdGhpcyBpcyBhbHdheXMgVVRDLCBzbyB0aGlzIG9wdGlvbiBpcyBlcXVpdmFsZW50IHRvIHNldHRpbmcgdGhlIGB6b25lYCBvcHRpb24gdG8gJ3V0YycsIGJ1dCB0aGlzIG9wdGlvbiBpcyBpbmNsdWRlZCBmb3IgY29uc2lzdGVuY3kgd2l0aCBzaW1pbGFyIG1ldGhvZHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21IVFRQKCdTdW4sIDA2IE5vdiAxOTk0IDA4OjQ5OjM3IEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21IVFRQKCdTdW5kYXksIDA2LU5vdi05NCAwODo0OTozNyBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuIE5vdiAgNiAwODo0OTozNyAxOTk0JylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUhUVFAodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VIVFRQRGF0ZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIkhUVFBcIiwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBpbnB1dCBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmcuXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZS4gRm9yIGEgdGFibGUgb2YgdG9rZW5zIGFuZCB0aGVpciBpbnRlcnByZXRhdGlvbnMsIHNlZSBbaGVyZV0oaHR0cHM6Ly9tb21lbnQuZ2l0aHViLmlvL2x1eG9uLyMvcGFyc2luZz9pZD10YWJsZS1vZi10b2tlbnMpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgdGhlIHN0cmluZyBpcyBleHBlY3RlZCB0byBiZSBpbiAoc2VlIHRoZSBsaW5rIGJlbG93IGZvciB0aGUgZm9ybWF0cylcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSBhIGxvY2FsZSBzdHJpbmcgdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIHRvIHRoaXMgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUZvcm1hdCh0ZXh0LCBmbXQsIG9wdHMgPSB7fSkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh0ZXh0KSB8fCBpc1VuZGVmaW5lZChmbXQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJmcm9tRm9ybWF0IHJlcXVpcmVzIGFuIGlucHV0IHN0cmluZyBhbmQgYSBmb3JtYXRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsIH0gPSBvcHRzLFxuICAgICAgbG9jYWxlVG9Vc2UgPSBMb2NhbGUuZnJvbU9wdHMoe1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgZGVmYXVsdFRvRU46IHRydWUsXG4gICAgICB9KSxcbiAgICAgIFt2YWxzLCBwYXJzZWRab25lLCBzcGVjaWZpY09mZnNldCwgaW52YWxpZF0gPSBwYXJzZUZyb21Ub2tlbnMobG9jYWxlVG9Vc2UsIHRleHQsIGZtdCk7XG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBgZm9ybWF0ICR7Zm10fWAsIHRleHQsIHNwZWNpZmljT2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXQgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcodGV4dCwgZm10LCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUZvcm1hdCh0ZXh0LCBmbXQsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBTUUwgZGF0ZSwgdGltZSwgb3IgZGF0ZXRpbWVcbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyB6b25lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIGEgbG9jYWxlIHN0cmluZyB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSBEYXRlVGltZSB0byB0aGlzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgdG8gdGhpcyBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1JylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIrMDY6MDAnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MiBBbWVyaWNhL0xvc19BbmdlbGVzJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIgQW1lcmljYS9Mb3NfQW5nZWxlcycsIHsgc2V0Wm9uZTogdHJ1ZSB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MicsIHsgem9uZTogJ0FtZXJpY2EvTG9zX0FuZ2VsZXMnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzA5OjEyOjM0LjM0MicpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21TUUwodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VTUUwodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJTUUxcIiwgdGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIERhdGVUaW1lIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm5lZWQgdG8gc3BlY2lmeSBhIHJlYXNvbiB0aGUgRGF0ZVRpbWUgaXMgaW52YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGVUaW1lRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoeyBpbnZhbGlkIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYSBEYXRlVGltZS4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRGF0ZVRpbWUobykge1xuICAgIHJldHVybiAobyAmJiBvLmlzTHV4b25EYXRlVGltZSkgfHwgZmFsc2U7XG4gIH1cblxuICAvLyBJTkZPXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlJyBvciAnZGF5J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA3LCA0KS5nZXQoJ21vbnRoJyk7IC8vPT4gN1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA3LCA0KS5nZXQoJ2RheScpOyAvLz0+IDRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0KHVuaXQpIHtcbiAgICByZXR1cm4gdGhpc1t1bml0XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIERhdGVUaW1lIGlzIHZhbGlkLiBJbnZhbGlkIERhdGVUaW1lcyBvY2N1ciB3aGVuOlxuICAgKiAqIFRoZSBEYXRlVGltZSB3YXMgY3JlYXRlZCBmcm9tIGludmFsaWQgY2FsZW5kYXIgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIDEzdGggbW9udGggb3IgRmVicnVhcnkgMzBcbiAgICogKiBUaGUgRGF0ZVRpbWUgd2FzIGNyZWF0ZWQgYnkgYW4gb3BlcmF0aW9uIG9uIGFub3RoZXIgaW52YWxpZCBkYXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBEYXRlVGltZSBpcyBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEYXRlVGltZSBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgRGF0ZVRpbWUgYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIERhdGVUaW1lIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbG9jYWxlIG9mIGEgRGF0ZVRpbWUsIHN1Y2ggJ2VuLUdCJy4gVGhlIGxvY2FsZSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRGF0ZVRpbWVcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBsb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLmxvY2FsZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXJpbmcgc3lzdGVtIG9mIGEgRGF0ZVRpbWUsIHN1Y2ggJ2JlbmcnLiBUaGUgbnVtYmVyaW5nIHN5c3RlbSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRGF0ZVRpbWVcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBudW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvdXRwdXQgY2FsZW5kYXIgb2YgYSBEYXRlVGltZSwgc3VjaCAnaXNsYW1pYycuIFRoZSBvdXRwdXQgY2FsZW5kYXIgaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgb3V0cHV0Q2FsZW5kYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm91dHB1dENhbGVuZGFyIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRpbWUgem9uZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBEYXRlVGltZS5cbiAgICogQHR5cGUge1pvbmV9XG4gICAqL1xuICBnZXQgem9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fem9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWUgb2YgdGhlIHRpbWUgem9uZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB6b25lTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy56b25lLm5hbWUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgeWVhclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkueWVhciAvLz0+IDIwMTdcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB5ZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMueWVhciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHF1YXJ0ZXJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnF1YXJ0ZXIgLy89PiAyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgcXVhcnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gTWF0aC5jZWlsKHRoaXMuYy5tb250aCAvIDMpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9udGggKDEtMTIpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkubW9udGggLy89PiA1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbW9udGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5tb250aCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBvZiB0aGUgbW9udGggKDEtMzBpc2gpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkuZGF5IC8vPT4gMjVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5kYXkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBob3VyIG9mIHRoZSBkYXkgKDAtMjMpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSkuaG91ciAvLz0+IDlcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBob3VyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMuaG91ciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbnV0ZSBvZiB0aGUgaG91ciAoMC01OSkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5LCAzMCkubWludXRlIC8vPT4gMzBcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaW51dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5taW51dGUgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSAoMC01OSkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5LCAzMCwgNTIpLnNlY29uZCAvLz0+IDUyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMuc2Vjb25kIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCAoMC05OTkpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzAsIDUyLCA2NTQpLm1pbGxpc2Vjb25kIC8vPT4gNjU0XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWlsbGlzZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5taWxsaXNlY29uZCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWsgeWVhclxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMTIsIDMxKS53ZWVrWWVhciAvLz0+IDIwMTVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrWWVhciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWsgbnVtYmVyIG9mIHRoZSB3ZWVrIHllYXIgKDEtNTJpc2gpLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLndlZWtOdW1iZXIgLy89PiAyMVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEodGhpcykud2Vla051bWJlciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBvZiB0aGUgd2Vlay5cbiAgICogMSBpcyBNb25kYXkgYW5kIDcgaXMgU3VuZGF5XG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAxMSwgMzEpLndlZWtkYXkgLy89PiA0XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla2RheSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrZGF5IDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3JkaW5hbCAobWVhbmluZyB0aGUgZGF5IG9mIHRoZSB5ZWFyKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkub3JkaW5hbCAvLz0+IDE0NVxuICAgKiBAdHlwZSB7bnVtYmVyfERhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IG9yZGluYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IGdyZWdvcmlhblRvT3JkaW5hbCh0aGlzLmMpLm9yZGluYWwgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBzaG9ydCBtb250aCBuYW1lLCBzdWNoIGFzICdPY3QnLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS5tb250aFNob3J0IC8vPT4gT2N0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbW9udGhTaG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby5tb250aHMoXCJzaG9ydFwiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy5tb250aCAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIGxvbmcgbW9udGggbmFtZSwgc3VjaCBhcyAnT2N0b2JlcicuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLm1vbnRoTG9uZyAvLz0+IE9jdG9iZXJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBtb250aExvbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ubW9udGhzKFwibG9uZ1wiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy5tb250aCAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIHNob3J0IHdlZWtkYXksIHN1Y2ggYXMgJ01vbicuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLndlZWtkYXlTaG9ydCAvLz0+IE1vblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHdlZWtkYXlTaG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby53ZWVrZGF5cyhcInNob3J0XCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLndlZWtkYXkgLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBsb25nIHdlZWtkYXksIHN1Y2ggYXMgJ01vbmRheScuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLndlZWtkYXlMb25nIC8vPT4gTW9uZGF5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgd2Vla2RheUxvbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ud2Vla2RheXMoXCJsb25nXCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLndlZWtkYXkgLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBVVEMgb2Zmc2V0IG9mIHRoaXMgRGF0ZVRpbWUgaW4gbWludXRlc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5vZmZzZXQgLy89PiAtMjQwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLm9mZnNldCAvLz0+IDBcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/ICt0aGlzLm8gOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaG9ydCBodW1hbiBuYW1lIGZvciB0aGUgem9uZSdzIGN1cnJlbnQgb2Zmc2V0LCBmb3IgZXhhbXBsZSBcIkVTVFwiIG9yIFwiRURUXCIuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG9mZnNldE5hbWVTaG9ydCgpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy56b25lLm9mZnNldE5hbWUodGhpcy50cywge1xuICAgICAgICBmb3JtYXQ6IFwic2hvcnRcIixcbiAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsb25nIGh1bWFuIG5hbWUgZm9yIHRoZSB6b25lJ3MgY3VycmVudCBvZmZzZXQsIGZvciBleGFtcGxlIFwiRWFzdGVybiBTdGFuZGFyZCBUaW1lXCIgb3IgXCJFYXN0ZXJuIERheWxpZ2h0IFRpbWVcIi5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgb2Zmc2V0TmFtZUxvbmcoKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuem9uZS5vZmZzZXROYW1lKHRoaXMudHMsIHtcbiAgICAgICAgZm9ybWF0OiBcImxvbmdcIixcbiAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgdGhpcyB6b25lJ3Mgb2Zmc2V0IGV2ZXIgY2hhbmdlcywgYXMgaW4gYSBEU1QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzT2Zmc2V0Rml4ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuem9uZS5pc1VuaXZlcnNhbCA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgdGhlIERhdGVUaW1lIGlzIGluIGEgRFNULlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc0luRFNUKCkge1xuICAgIGlmICh0aGlzLmlzT2Zmc2V0Rml4ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5vZmZzZXQgPiB0aGlzLnNldCh7IG1vbnRoOiAxIH0pLm9mZnNldCB8fCB0aGlzLm9mZnNldCA+IHRoaXMuc2V0KHsgbW9udGg6IDUgfSkub2Zmc2V0XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBEYXRlVGltZSBpcyBpbiBhIGxlYXAgeWVhciwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYpLmlzSW5MZWFwWWVhciAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykuaXNJbkxlYXBZZWFyIC8vPT4gZmFsc2VcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNJbkxlYXBZZWFyKCkge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhpcyBEYXRlVGltZSdzIG1vbnRoXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYsIDIpLmRheXNJbk1vbnRoIC8vPT4gMjlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNiwgMykuZGF5c0luTW9udGggLy89PiAzMVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXNJbk1vbnRoKCkge1xuICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIsIHRoaXMubW9udGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoaXMgRGF0ZVRpbWUncyB5ZWFyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYpLmRheXNJblllYXIgLy89PiAzNjZcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykuZGF5c0luWWVhciAvLz0+IDM2NVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXNJblllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IGRheXNJblllYXIodGhpcy55ZWFyKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygd2Vla3MgaW4gdGhpcyBEYXRlVGltZSdzIHllYXJcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMDQpLndlZWtzSW5XZWVrWWVhciAvLz0+IDUzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLndlZWtzSW5XZWVrWWVhciAvLz0+IDUyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla3NJbldlZWtZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB3ZWVrc0luV2Vla1llYXIodGhpcy53ZWVrWWVhcikgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x2ZWQgSW50bCBvcHRpb25zIGZvciB0aGlzIERhdGVUaW1lLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBpbiB1bmRlcnN0YW5kaW5nIHRoZSBiZWhhdmlvciBvZiBmb3JtYXR0aW5nIG1ldGhvZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSB0aGUgc2FtZSBvcHRpb25zIGFzIHRvTG9jYWxlU3RyaW5nXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHJlc29sdmVkTG9jYWxlT3B0aW9ucyhvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhciB9ID0gRm9ybWF0dGVyLmNyZWF0ZShcbiAgICAgIHRoaXMubG9jLmNsb25lKG9wdHMpLFxuICAgICAgb3B0c1xuICAgICkucmVzb2x2ZWRPcHRpb25zKHRoaXMpO1xuICAgIHJldHVybiB7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcjogY2FsZW5kYXIgfTtcbiAgfVxuXG4gIC8vIFRSQU5TRk9STVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gVVRDLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8ge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9KCd1dGMnKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIG9wdGlvbmFsbHksIGFuIG9mZnNldCBmcm9tIFVUQyBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV0gLSBvcHRpb25zIHRvIHBhc3MgdG8gYHNldFpvbmUoKWBcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICB0b1VUQyhvZmZzZXQgPSAwLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5zZXRab25lKEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShvZmZzZXQpLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gdGhlIGhvc3QncyBsb2NhbCB6b25lLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8gYHNldFpvbmUoJ2xvY2FsJylgXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgdG9Mb2NhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRab25lKFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gc3BlY2lmaWVkIHpvbmUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHNldHRlciBrZWVwcyB0aGUgdW5kZXJseWluZyB0aW1lIHRoZSBzYW1lIChhcyBpbiwgdGhlIHNhbWUgdGltZXN0YW1wKSwgYnV0IHRoZSBuZXcgaW5zdGFuY2Ugd2lsbCByZXBvcnQgZGlmZmVyZW50IGxvY2FsIHRpbWVzIGFuZCBjb25zaWRlciBEU1RzIHdoZW4gbWFraW5nIGNvbXB1dGF0aW9ucywgYXMgd2l0aCB7QGxpbmsgRGF0ZVRpbWUjcGx1c30uIFlvdSBtYXkgd2lzaCB0byB1c2Uge0BsaW5rIERhdGVUaW1lI3RvTG9jYWx9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9VVEN9IHdoaWNoIHByb3ZpZGUgc2ltcGxlIGNvbnZlbmllbmNlIHdyYXBwZXJzIGZvciBjb21tb25seSB1c2VkIHpvbmVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbem9uZT0nbG9jYWwnXSAtIGEgem9uZSBpZGVudGlmaWVyLiBBcyBhIHN0cmluZywgdGhhdCBjYW4gYmUgYW55IElBTkEgem9uZSBzdXBwb3J0ZWQgYnkgdGhlIGhvc3QgZW52aXJvbm1lbnQsIG9yIGEgZml4ZWQtb2Zmc2V0IG5hbWUgb2YgdGhlIGZvcm0gJ1VUQyszJywgb3IgdGhlIHN0cmluZ3MgJ2xvY2FsJyBvciAndXRjJy4gWW91IG1heSBhbHNvIHN1cHBseSBhbiBpbnN0YW5jZSBvZiBhIHtAbGluayBEYXRlVGltZSNab25lfSBjbGFzcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMua2VlcExvY2FsVGltZT1mYWxzZV0gLSBJZiB0cnVlLCBhZGp1c3QgdGhlIHVuZGVybHlpbmcgdGltZSBzbyB0aGF0IHRoZSBsb2NhbCB0aW1lIHN0YXlzIHRoZSBzYW1lLCBidXQgaW4gdGhlIHRhcmdldCB6b25lLiBZb3Ugc2hvdWxkIHJhcmVseSBuZWVkIHRoaXMuXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc2V0Wm9uZSh6b25lLCB7IGtlZXBMb2NhbFRpbWUgPSBmYWxzZSwga2VlcENhbGVuZGFyVGltZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIHpvbmUgPSBub3JtYWxpemVab25lKHpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgICBpZiAoem9uZS5lcXVhbHModGhpcy56b25lKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICghem9uZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmV3VFMgPSB0aGlzLnRzO1xuICAgICAgaWYgKGtlZXBMb2NhbFRpbWUgfHwga2VlcENhbGVuZGFyVGltZSkge1xuICAgICAgICBjb25zdCBvZmZzZXRHdWVzcyA9IHpvbmUub2Zmc2V0KHRoaXMudHMpO1xuICAgICAgICBjb25zdCBhc09iaiA9IHRoaXMudG9PYmplY3QoKTtcbiAgICAgICAgW25ld1RTXSA9IG9ialRvVFMoYXNPYmosIG9mZnNldEd1ZXNzLCB6b25lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHRzOiBuZXdUUywgem9uZSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG9yIG91dHB1dENhbGVuZGFyLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gdGhlIHByb3BlcnRpZXMgdG8gc2V0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogJ2VuLUdCJyB9KVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHJlY29uZmlndXJlKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0gPSB7fSkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMubG9jLmNsb25lKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0pO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IGxvYyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogSnVzdCBhIGNvbnZlbmllbnQgYWxpYXMgZm9yIHJlY29uZmlndXJlKHsgbG9jYWxlIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5zZXRMb2NhbGUoJ2VuLUdCJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzZXRMb2NhbGUobG9jYWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb25maWd1cmUoeyBsb2NhbGUgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgdmFsdWVzIG9mIHNwZWNpZmllZCB1bml0cy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKiBZb3UgY2FuIG9ubHkgc2V0IHVuaXRzIHdpdGggdGhpcyBtZXRob2Q7IGZvciBcInNldHRpbmdcIiBtZXRhZGF0YSwgc2VlIHtAbGluayBEYXRlVGltZSNyZWNvbmZpZ3VyZX0gYW5kIHtAbGluayBEYXRlVGltZSNzZXRab25lfS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIGEgbWFwcGluZyBvZiB1bml0cyB0byBudW1iZXJzXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHllYXI6IDIwMTcgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgaG91cjogOCwgbWludXRlOiAzMCB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyB3ZWVrZGF5OiA1IH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHllYXI6IDIwMDUsIG9yZGluYWw6IDIzNCB9KVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHNldCh2YWx1ZXMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplT2JqZWN0KHZhbHVlcywgbm9ybWFsaXplVW5pdCksXG4gICAgICBzZXR0aW5nV2Vla1N0dWZmID1cbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla1llYXIpIHx8XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtOdW1iZXIpIHx8XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtkYXkpLFxuICAgICAgY29udGFpbnNPcmRpbmFsID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQub3JkaW5hbCksXG4gICAgICBjb250YWluc0dyZWdvclllYXIgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC55ZWFyKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yTUQgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5tb250aCkgfHwgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yID0gY29udGFpbnNHcmVnb3JZZWFyIHx8IGNvbnRhaW5zR3JlZ29yTUQsXG4gICAgICBkZWZpbml0ZVdlZWtEZWYgPSBub3JtYWxpemVkLndlZWtZZWFyIHx8IG5vcm1hbGl6ZWQud2Vla051bWJlcjtcblxuICAgIGlmICgoY29udGFpbnNHcmVnb3IgfHwgY29udGFpbnNPcmRpbmFsKSAmJiBkZWZpbml0ZVdlZWtEZWYpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW4ndCBtaXggd2Vla1llYXIvd2Vla051bWJlciB1bml0cyB3aXRoIHllYXIvbW9udGgvZGF5IG9yIG9yZGluYWxzXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5zR3JlZ29yTUQgJiYgY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXCJDYW4ndCBtaXggb3JkaW5hbCBkYXRlcyB3aXRoIG1vbnRoL2RheVwiKTtcbiAgICB9XG5cbiAgICBsZXQgbWl4ZWQ7XG4gICAgaWYgKHNldHRpbmdXZWVrU3R1ZmYpIHtcbiAgICAgIG1peGVkID0gd2Vla1RvR3JlZ29yaWFuKHsgLi4uZ3JlZ29yaWFuVG9XZWVrKHRoaXMuYyksIC4uLm5vcm1hbGl6ZWQgfSk7XG4gICAgfSBlbHNlIGlmICghaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSkge1xuICAgICAgbWl4ZWQgPSBvcmRpbmFsVG9HcmVnb3JpYW4oeyAuLi5ncmVnb3JpYW5Ub09yZGluYWwodGhpcy5jKSwgLi4ubm9ybWFsaXplZCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWl4ZWQgPSB7IC4uLnRoaXMudG9PYmplY3QoKSwgLi4ubm9ybWFsaXplZCB9O1xuXG4gICAgICAvLyBpZiB3ZSBkaWRuJ3Qgc2V0IHRoZSBkYXkgYnV0IHdlIGVuZGVkIHVwIG9uIGFuIG92ZXJmbG93IGRhdGUsXG4gICAgICAvLyB1c2UgdGhlIGxhc3QgZGF5IG9mIHRoZSByaWdodCBtb250aFxuICAgICAgaWYgKGlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSkge1xuICAgICAgICBtaXhlZC5kYXkgPSBNYXRoLm1pbihkYXlzSW5Nb250aChtaXhlZC55ZWFyLCBtaXhlZC5tb250aCksIG1peGVkLmRheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgW3RzLCBvXSA9IG9ialRvVFMobWl4ZWQsIHRoaXMubywgdGhpcy56b25lKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB0cywgbyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBwZXJpb2Qgb2YgdGltZSB0byB0aGlzIERhdGVUaW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBEYXRlVGltZVxuICAgKlxuICAgKiBBZGRpbmcgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG9yIG1pbGxpc2Vjb25kcyBpbmNyZWFzZXMgdGhlIHRpbWVzdGFtcCBieSB0aGUgcmlnaHQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy4gQWRkaW5nIGRheXMsIG1vbnRocywgb3IgeWVhcnMgc2hpZnRzIHRoZSBjYWxlbmRhciwgYWNjb3VudGluZyBmb3IgRFNUcyBhbmQgbGVhcCB5ZWFycyBhbG9uZyB0aGUgd2F5LiBUaHVzLCBgZHQucGx1cyh7IGhvdXJzOiAyNCB9KWAgbWF5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0aW1lIHRoYW4gYGR0LnBsdXMoeyBkYXlzOiAxIH0pYCBpZiB0aGVyZSdzIGEgRFNUIHNoaWZ0IGluIGJldHdlZW4uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIGFkZC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cygxMjMpIC8vfj4gaW4gMTIzIG1pbGxpc2Vjb25kc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgbWludXRlczogMTUgfSkgLy9+PiBpbiAxNSBtaW51dGVzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pIC8vfj4gdGhpcyB0aW1lIHRvbW9ycm93XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAtMSB9KSAvL34+IHRoaXMgdGltZSB5ZXN0ZXJkYXlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGhvdXJzOiAzLCBtaW51dGVzOiAxMyB9KSAvL34+IGluIDMgaHIsIDEzIG1pblxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMywgbWludXRlczogMTMgfSkpIC8vfj4gaW4gMyBociwgMTMgbWluXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgcGx1cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgYWRqdXN0VGltZSh0aGlzLCBkdXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdCBhIHBlcmlvZCBvZiB0aW1lIHRvIHRoaXMgRGF0ZVRpbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lXG4gICAqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjcGx1c31cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIG1pbnVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLm5lZ2F0ZSgpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBhZGp1c3RUaW1lKHRoaXMsIGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhpcyBEYXRlVGltZSB0byB0aGUgYmVnaW5uaW5nIG9mIGEgdW5pdCBvZiB0aW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIFRoZSB1bml0IHRvIGdvIHRvIHRoZSBiZWdpbm5pbmcgb2YuIENhbiBiZSAneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsIG9yICdtaWxsaXNlY29uZCcuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ21vbnRoJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDMtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ3llYXInKS50b0lTT0RhdGUoKTsgLy89PiAnMjAxNC0wMS0wMSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuc3RhcnRPZignd2VlaycpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAzLTAzJywgd2Vla3MgYWx3YXlzIHN0YXJ0IG9uIE1vbmRheXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLnN0YXJ0T2YoJ2RheScpLnRvSVNPVGltZSgpOyAvLz0+ICcwMDowMC4wMDAtMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5zdGFydE9mKCdob3VyJykudG9JU09UaW1lKCk7IC8vPT4gJzA1OjAwOjAwLjAwMC0wNTowMCdcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGFydE9mKHVuaXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgbyA9IHt9LFxuICAgICAgbm9ybWFsaXplZFVuaXQgPSBEdXJhdGlvbi5ub3JtYWxpemVVbml0KHVuaXQpO1xuICAgIHN3aXRjaCAobm9ybWFsaXplZFVuaXQpIHtcbiAgICAgIGNhc2UgXCJ5ZWFyc1wiOlxuICAgICAgICBvLm1vbnRoID0gMTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJxdWFydGVyc1wiOlxuICAgICAgY2FzZSBcIm1vbnRoc1wiOlxuICAgICAgICBvLmRheSA9IDE7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwid2Vla3NcIjpcbiAgICAgIGNhc2UgXCJkYXlzXCI6XG4gICAgICAgIG8uaG91ciA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwiaG91cnNcIjpcbiAgICAgICAgby5taW51dGUgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcIm1pbnV0ZXNcIjpcbiAgICAgICAgby5zZWNvbmQgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcInNlY29uZHNcIjpcbiAgICAgICAgby5taWxsaXNlY29uZCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pbGxpc2Vjb25kc1wiOlxuICAgICAgICBicmVhaztcbiAgICAgIC8vIG5vIGRlZmF1bHQsIGludmFsaWQgdW5pdHMgdGhyb3cgaW4gbm9ybWFsaXplVW5pdCgpXG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcIndlZWtzXCIpIHtcbiAgICAgIG8ud2Vla2RheSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcInF1YXJ0ZXJzXCIpIHtcbiAgICAgIGNvbnN0IHEgPSBNYXRoLmNlaWwodGhpcy5tb250aCAvIDMpO1xuICAgICAgby5tb250aCA9IChxIC0gMSkgKiAzICsgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQobyk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGlzIERhdGVUaW1lIHRvIHRoZSBlbmQgKG1lYW5pbmcgdGhlIGxhc3QgbWlsbGlzZWNvbmQpIG9mIGEgdW5pdCBvZiB0aW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gVGhlIHVuaXQgdG8gZ28gdG8gdGhlIGVuZCBvZi4gQ2FuIGJlICd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgb3IgJ21pbGxpc2Vjb25kJy5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ21vbnRoJykudG9JU08oKTsgLy89PiAnMjAxNC0wMy0zMVQyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCd5ZWFyJykudG9JU08oKTsgLy89PiAnMjAxNC0xMi0zMVQyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCd3ZWVrJykudG9JU08oKTsgLy8gPT4gJzIwMTQtMDMtMDlUMjM6NTk6NTkuOTk5LTA1OjAwJywgd2Vla3Mgc3RhcnQgb24gTW9uZGF5c1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuZW5kT2YoJ2RheScpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMDNUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuZW5kT2YoJ2hvdXInKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTAzVDA1OjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBlbmRPZih1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyB0aGlzLnBsdXMoeyBbdW5pdF06IDEgfSlcbiAgICAgICAgICAuc3RhcnRPZih1bml0KVxuICAgICAgICAgIC5taW51cygxKVxuICAgICAgOiB0aGlzO1xuICB9XG5cbiAgLy8gT1VUUFVUXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgZm9ybWF0IHN0cmluZy5cbiAgICogKipZb3UgbWF5IG5vdCB3YW50IHRoaXMuKiogU2VlIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9yIGEgbW9yZSBmbGV4aWJsZSBmb3JtYXR0aW5nIHRvb2wuIEZvciBhIHRhYmxlIG9mIHRva2VucyBhbmQgdGhlaXIgaW50ZXJwcmV0YXRpb25zLCBzZWUgW2hlcmVdKGh0dHBzOi8vbW9tZW50LmdpdGh1Yi5pby9sdXhvbi8jL2Zvcm1hdHRpbmc/aWQ9dGFibGUtb2YtdG9rZW5zKS5cbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRzIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb24gdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnKSAvLz0+ICcyMDE3IEFwciAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKCdmcicpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcpIC8vPT4gJzIwMTcgYXZyLiAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJywgeyBsb2NhbGU6IFwiZnJcIiB9KSAvLz0+ICcyMDE3IGF2ci4gMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KFwiSEggJ2hvdXJzIGFuZCcgbW0gJ21pbnV0ZXMnXCIpIC8vPT4gJzIwIGhvdXJzIGFuZCA1NSBtaW51dGVzJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdChmbXQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5yZWRlZmF1bHRUb0VOKG9wdHMpKS5mb3JtYXREYXRlVGltZUZyb21TdHJpbmcodGhpcywgZm10KVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIGRhdGUuIEFjY2VwdHMgdGhlIHNhbWUgb3B0aW9ucyBhcyB0aGUgSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBhbmQgYW55IHByZXNldHMgZGVmaW5lZCBieSBMdXhvbiwgc3VjaCBhcyBgRGF0ZVRpbWUuREFURV9GVUxMYCBvciBgRGF0ZVRpbWUuVElNRV9TSU1QTEVgLlxuICAgKiBUaGUgZXhhY3QgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2QgaXMgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGluIGdlbmVyYWwgaXQgd2lsbCByZXR1cm4gYW4gYXBwcm9wcmlhdGUgcmVwcmVzZW50YXRpb25cbiAgICogb2YgdGhlIERhdGVUaW1lIGluIHRoZSBhc3NpZ25lZCBsb2NhbGUuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSBmb3JtYXRPcHRzIHtPYmplY3R9IC0gSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBvcHRpb25zIGFuZCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRzIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb24gdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZygpOyAvLz0+IDQvMjAvMjAxN1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoJ2VuLWdiJykudG9Mb2NhbGVTdHJpbmcoKTsgLy89PiAnMjAvMDQvMjAxNydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyBsb2NhbGU6ICdlbi1nYicgfSk7IC8vPT4gJzIwLzA0LzIwMTcnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCk7IC8vPT4gJ0FwcmlsIDIwLCAyMDE3J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5USU1FX1NJTVBMRSk7IC8vPT4gJzExOjMyIEFNJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFVElNRV9TSE9SVCk7IC8vPT4gJzQvMjAvMjAxNywgMTE6MzIgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgd2Vla2RheTogJ2xvbmcnLCBtb250aDogJ2xvbmcnLCBkYXk6ICcyLWRpZ2l0JyB9KTsgLy89PiAnVGh1cnNkYXksIEFwcmlsIDIwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyh7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICcyLWRpZ2l0JywgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JyB9KTsgLy89PiAnVGh1LCBBcHIgMjAsIDExOjI3IEFNJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyh7IGhvdXI6ICcyLWRpZ2l0JywgbWludXRlOiAnMi1kaWdpdCcsIGhvdXJDeWNsZTogJ2gyMycgfSk7IC8vPT4gJzExOjMyJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0xvY2FsZVN0cmluZyhmb3JtYXRPcHRzID0gRm9ybWF0cy5EQVRFX1NIT1JULCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MuY2xvbmUob3B0cyksIGZvcm1hdE9wdHMpLmZvcm1hdERhdGVUaW1lKHRoaXMpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBmb3JtYXQgXCJwYXJ0c1wiLCBtZWFuaW5nIGluZGl2aWR1YWwgdG9rZW5zIGFsb25nIHdpdGggbWV0YWRhdGEuIFRoaXMgaXMgYWxsb3dzIGNhbGxlcnMgdG8gcG9zdC1wcm9jZXNzIGluZGl2aWR1YWwgc2VjdGlvbnMgb2YgdGhlIGZvcm1hdHRlZCBvdXRwdXQuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0L2Zvcm1hdFRvUGFydHNcbiAgICogQHBhcmFtIG9wdHMge09iamVjdH0gLSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIG9wdGlvbnMsIHNhbWUgYXMgYHRvTG9jYWxlU3RyaW5nYC5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVQYXJ0cygpOyAvLz0+IFtcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdkYXknLCB2YWx1ZTogJzI1JyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogJy8nIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbW9udGgnLCB2YWx1ZTogJzA1JyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogJy8nIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAneWVhcicsIHZhbHVlOiAnMTk4MicgfVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiBdXG4gICAqL1xuICB0b0xvY2FsZVBhcnRzKG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5jbG9uZShvcHRzKSwgb3B0cykuZm9ybWF0RGF0ZVRpbWVQYXJ0cyh0aGlzKVxuICAgICAgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgzLCA1LCAyNSkudG9JU08oKSAvLz0+ICcxOTgyLTA1LTI1VDAwOjAwOjAwLjAwMFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKCkgLy89PiAnMjAxNy0wNC0yMlQyMDo0NzowNS4zMzUtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNy0wNC0yMlQyMDo0NzowNS4zMzUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzIwMTcwNDIyVDIwNDcwNS4zMzUtMDQwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU08oe1xuICAgIGZvcm1hdCA9IFwiZXh0ZW5kZWRcIixcbiAgICBzdXBwcmVzc1NlY29uZHMgPSBmYWxzZSxcbiAgICBzdXBwcmVzc01pbGxpc2Vjb25kcyA9IGZhbHNlLFxuICAgIGluY2x1ZGVPZmZzZXQgPSB0cnVlLFxuICB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZXh0ID0gZm9ybWF0ID09PSBcImV4dGVuZGVkXCI7XG5cbiAgICBsZXQgYyA9IHRvSVNPRGF0ZSh0aGlzLCBleHQpO1xuICAgIGMgKz0gXCJUXCI7XG4gICAgYyArPSB0b0lTT1RpbWUodGhpcywgZXh0LCBzdXBwcmVzc1NlY29uZHMsIHN1cHByZXNzTWlsbGlzZWNvbmRzLCBpbmNsdWRlT2Zmc2V0KTtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIGRhdGUgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODIsIDUsIDI1KS50b0lTT0RhdGUoKSAvLz0+ICcxOTgyLTA1LTI1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPRGF0ZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcxOTgyMDUyNSdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09EYXRlKHsgZm9ybWF0ID0gXCJleHRlbmRlZFwiIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9JU09EYXRlKHRoaXMsIGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIHdlZWsgZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPV2Vla0RhdGUoKSAvLz0+ICcxOTgyLVcyMS0yJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1dlZWtEYXRlKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgXCJra2trLSdXJ1dXLWNcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUncyB0aW1lIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlUHJlZml4PWZhbHNlXSAtIGluY2x1ZGUgdGhlIGBUYCBwcmVmaXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKCkgLy89PiAnMDc6MzQ6MTkuMzYxWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCwgc2Vjb25kczogMCwgbWlsbGlzZWNvbmRzOiAwIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzU2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcwNzozNFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzA3MzQxOS4zNjFaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSh7IGluY2x1ZGVQcmVmaXg6IHRydWUgfSkgLy89PiAnVDA3OjM0OjE5LjM2MVonXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZSh7XG4gICAgc3VwcHJlc3NNaWxsaXNlY29uZHMgPSBmYWxzZSxcbiAgICBzdXBwcmVzc1NlY29uZHMgPSBmYWxzZSxcbiAgICBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSxcbiAgICBpbmNsdWRlUHJlZml4ID0gZmFsc2UsXG4gICAgZm9ybWF0ID0gXCJleHRlbmRlZFwiLFxuICB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGMgPSBpbmNsdWRlUHJlZml4ID8gXCJUXCIgOiBcIlwiO1xuICAgIHJldHVybiAoXG4gICAgICBjICtcbiAgICAgIHRvSVNPVGltZSh0aGlzLCBmb3JtYXQgPT09IFwiZXh0ZW5kZWRcIiwgc3VwcHJlc3NTZWNvbmRzLCBzdXBwcmVzc01pbGxpc2Vjb25kcywgaW5jbHVkZU9mZnNldClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gUkZDIDI4MjItY29tcGF0aWJsZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvUkZDMjgyMigpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMDA6MDA6MDAgKzAwMDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1JGQzI4MjIoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwIC0wNDAwJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1JGQzI4MjIoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBcIkVFRSwgZGQgTExMIHl5eXkgSEg6bW06c3MgWlpaXCIsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBIVFRQIGhlYWRlcnMuIFRoZSBvdXRwdXQgaXMgYWx3YXlzIGV4cHJlc3NlZCBpbiBHTVQuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHN0cmluZyBjb25mb3JtcyB0byBSRkMgMTEyMy5cbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWMzLmh0bWwjc2VjMy4zLjFcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b0hUVFAoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwIEdNVCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzLCAxOSkudG9IVFRQKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAxOTowMDowMCBHTVQnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSFRUUCgpIHtcbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMudG9VVEMoKSwgXCJFRUUsIGRkIExMTCB5eXl5IEhIOm1tOnNzICdHTVQnXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBEYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9TUUxEYXRlKCkgLy89PiAnMjAxNC0wNy0xMydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TUUxEYXRlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRvSVNPRGF0ZSh0aGlzLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlWm9uZT1mYWxzZV0gLSBpbmNsdWRlIHRoZSB6b25lLCBzdWNoIGFzICdBbWVyaWNhL05ld19Zb3JrJy4gT3ZlcnJpZGVzIGluY2x1ZGVPZmZzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkudG9TUUwoKSAvLz0+ICcwNToxNToxNi4zNDUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvU1FMKCkgLy89PiAnMDU6MTU6MTYuMzQ1IC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoeyBpbmNsdWRlT2Zmc2V0OiBmYWxzZSB9KSAvLz0+ICcwNToxNToxNi4zNDUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvU1FMKHsgaW5jbHVkZVpvbmU6IGZhbHNlIH0pIC8vPT4gJzA1OjE1OjE2LjM0NSBBbWVyaWNhL05ld19Zb3JrJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1NRTFRpbWUoeyBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSwgaW5jbHVkZVpvbmUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBsZXQgZm10ID0gXCJISDptbTpzcy5TU1NcIjtcblxuICAgIGlmIChpbmNsdWRlWm9uZSB8fCBpbmNsdWRlT2Zmc2V0KSB7XG4gICAgICBmbXQgKz0gXCIgXCI7XG4gICAgICBpZiAoaW5jbHVkZVpvbmUpIHtcbiAgICAgICAgZm10ICs9IFwielwiO1xuICAgICAgfSBlbHNlIGlmIChpbmNsdWRlT2Zmc2V0KSB7XG4gICAgICAgIGZtdCArPSBcIlpaXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBmbXQsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBEYXRlVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlWm9uZT1mYWxzZV0gLSBpbmNsdWRlIHRoZSB6b25lLCBzdWNoIGFzICdBbWVyaWNhL05ld19Zb3JrJy4gT3ZlcnJpZGVzIGluY2x1ZGVPZmZzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvU1FMKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCh7IGluY2x1ZGVab25lOiB0cnVlIH0pIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIEFtZXJpY2EvTmV3X1lvcmsnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU1FMKG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7dGhpcy50b1NRTERhdGUoKX0gJHt0aGlzLnRvU1FMVGltZShvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgZGVidWdnaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRvSVNPKCkgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIG1pbGxpc2Vjb25kcyBvZiB0aGlzIERhdGVUaW1lLiBBbGlhcyBvZiB7QGxpbmsgRGF0ZVRpbWUjdG9NaWxsaXN9XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9NaWxsaXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBtaWxsaXNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9NaWxsaXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggc2Vjb25kcyBvZiB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b1NlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgLyAxMDAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIEpTT04uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0lTTygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBCU09OIHNlcmlhbGl6YWJsZSBlcXVpdmFsZW50IHRvIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge0RhdGV9XG4gICAqL1xuICB0b0JTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9KU0RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCB0aGlzIERhdGVUaW1lJ3MgeWVhciwgbW9udGgsIGRheSwgYW5kIHNvIG9uLlxuICAgKiBAcGFyYW0gb3B0cyAtIG9wdGlvbnMgZm9yIGdlbmVyYXRpbmcgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVDb25maWc9ZmFsc2VdIC0gaW5jbHVkZSBjb25maWd1cmF0aW9uIGF0dHJpYnV0ZXMgaW4gdGhlIG91dHB1dFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b09iamVjdCgpIC8vPT4geyB5ZWFyOiAyMDE3LCBtb250aDogNCwgZGF5OiAyMiwgaG91cjogMjAsIG1pbnV0ZTogNDksIHNlY29uZDogNDIsIG1pbGxpc2Vjb25kOiAyNjggfVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b09iamVjdChvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHt9O1xuXG4gICAgY29uc3QgYmFzZSA9IHsgLi4udGhpcy5jIH07XG5cbiAgICBpZiAob3B0cy5pbmNsdWRlQ29uZmlnKSB7XG4gICAgICBiYXNlLm91dHB1dENhbGVuZGFyID0gdGhpcy5vdXRwdXRDYWxlbmRhcjtcbiAgICAgIGJhc2UubnVtYmVyaW5nU3lzdGVtID0gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtO1xuICAgICAgYmFzZS5sb2NhbGUgPSB0aGlzLmxvYy5sb2NhbGU7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhU2NyaXB0IERhdGUgZXF1aXZhbGVudCB0byB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfVxuICAgKi9cbiAgdG9KU0RhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgOiBOYU4pO1xuICB9XG5cbiAgLy8gQ09NUEFSRVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gRGF0ZVRpbWVzIGFzIGEgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgRGF0ZVRpbWUgdG8gY29tcGFyZSB0aGlzIG9uZSB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3VuaXQ9WydtaWxsaXNlY29uZHMnXV0gLSB0aGUgdW5pdCBvciBhcnJheSBvZiB1bml0cyAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gaW5jbHVkZSBpbiB0aGUgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgaTEgPSBEYXRlVGltZS5mcm9tSVNPKCcxOTgyLTA1LTI1VDA5OjQ1JyksXG4gICAqICAgICBpMiA9IERhdGVUaW1lLmZyb21JU08oJzE5ODMtMTAtMTRUMTA6MzAnKTtcbiAgICogaTIuZGlmZihpMSkudG9PYmplY3QoKSAvLz0+IHsgbWlsbGlzZWNvbmRzOiA0MzgwNzUwMDAwMCB9XG4gICAqIGkyLmRpZmYoaTEsICdob3VycycpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMjE2OC43NSB9XG4gICAqIGkyLmRpZmYoaTEsIFsnbW9udGhzJywgJ2RheXMnXSkudG9PYmplY3QoKSAvLz0+IHsgbW9udGhzOiAxNiwgZGF5czogMTkuMDMxMjUgfVxuICAgKiBpMi5kaWZmKGkxLCBbJ21vbnRocycsICdkYXlzJywgJ2hvdXJzJ10pLnRvT2JqZWN0KCkgLy89PiB7IG1vbnRoczogMTYsIGRheXM6IDE5LCBob3VyczogMC43NSB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgZGlmZihvdGhlckRhdGVUaW1lLCB1bml0ID0gXCJtaWxsaXNlY29uZHNcIiwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyRGF0ZVRpbWUuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJjcmVhdGVkIGJ5IGRpZmZpbmcgYW4gaW52YWxpZCBEYXRlVGltZVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBkdXJPcHRzID0geyBsb2NhbGU6IHRoaXMubG9jYWxlLCBudW1iZXJpbmdTeXN0ZW06IHRoaXMubnVtYmVyaW5nU3lzdGVtLCAuLi5vcHRzIH07XG5cbiAgICBjb25zdCB1bml0cyA9IG1heWJlQXJyYXkodW5pdCkubWFwKER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQpLFxuICAgICAgb3RoZXJJc0xhdGVyID0gb3RoZXJEYXRlVGltZS52YWx1ZU9mKCkgPiB0aGlzLnZhbHVlT2YoKSxcbiAgICAgIGVhcmxpZXIgPSBvdGhlcklzTGF0ZXIgPyB0aGlzIDogb3RoZXJEYXRlVGltZSxcbiAgICAgIGxhdGVyID0gb3RoZXJJc0xhdGVyID8gb3RoZXJEYXRlVGltZSA6IHRoaXMsXG4gICAgICBkaWZmZWQgPSBkaWZmKGVhcmxpZXIsIGxhdGVyLCB1bml0cywgZHVyT3B0cyk7XG5cbiAgICByZXR1cm4gb3RoZXJJc0xhdGVyID8gZGlmZmVkLm5lZ2F0ZSgpIDogZGlmZmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgRGF0ZVRpbWUgYW5kIHJpZ2h0IG5vdy5cbiAgICogU2VlIHtAbGluayBEYXRlVGltZSNkaWZmfVxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3VuaXQ9WydtaWxsaXNlY29uZHMnXV0gLSB0aGUgdW5pdCBvciB1bml0cyB1bml0cyAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gaW5jbHVkZSBpbiB0aGUgZHVyYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgZGlmZk5vdyh1bml0ID0gXCJtaWxsaXNlY29uZHNcIiwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlmZihEYXRlVGltZS5ub3coKSwgdW5pdCwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHNwYW5uaW5nIGJldHdlZW4gdGhpcyBEYXRlVGltZSBhbmQgYW5vdGhlciBEYXRlVGltZVxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlckRhdGVUaW1lIC0gdGhlIG90aGVyIGVuZCBwb2ludCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICB1bnRpbChvdGhlckRhdGVUaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEludGVydmFsLmZyb21EYXRlVGltZXModGhpcywgb3RoZXJEYXRlVGltZSkgOiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgRGF0ZVRpbWUgaXMgaW4gdGhlIHNhbWUgdW5pdCBvZiB0aW1lIGFzIGFub3RoZXIgRGF0ZVRpbWUuXG4gICAqIEhpZ2hlci1vcmRlciB1bml0cyBtdXN0IGFsc28gYmUgaWRlbnRpY2FsIGZvciB0aGlzIGZ1bmN0aW9uIHRvIHJldHVybiBgdHJ1ZWAuXG4gICAqIE5vdGUgdGhhdCB0aW1lIHpvbmVzIGFyZSAqKmlnbm9yZWQqKiBpbiB0aGlzIGNvbXBhcmlzb24sIHdoaWNoIGNvbXBhcmVzIHRoZSAqKmxvY2FsKiogY2FsZW5kYXIgdGltZS4gVXNlIHtAbGluayBEYXRlVGltZSNzZXRab25lfSB0byBjb252ZXJ0IG9uZSBvZiB0aGUgZGF0ZXMgaWYgbmVlZGVkLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlckRhdGVUaW1lIC0gdGhlIG90aGVyIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gdGhlIHVuaXQgb2YgdGltZSB0byBjaGVjayBzYW1lbmVzcyBvblxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5oYXNTYW1lKG90aGVyRFQsICdkYXknKTsgLy9+PiB0cnVlIGlmIG90aGVyRFQgaXMgaW4gdGhlIHNhbWUgY3VycmVudCBjYWxlbmRhciBkYXlcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1NhbWUob3RoZXJEYXRlVGltZSwgdW5pdCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBpbnB1dE1zID0gb3RoZXJEYXRlVGltZS52YWx1ZU9mKCk7XG4gICAgY29uc3QgYWRqdXN0ZWRUb1pvbmUgPSB0aGlzLnNldFpvbmUob3RoZXJEYXRlVGltZS56b25lLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSk7XG4gICAgcmV0dXJuIGFkanVzdGVkVG9ab25lLnN0YXJ0T2YodW5pdCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IGFkanVzdGVkVG9ab25lLmVuZE9mKHVuaXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVxdWFsaXR5IGNoZWNrXG4gICAqIFR3byBEYXRlVGltZXMgYXJlIGVxdWFsIGlmZiB0aGV5IHJlcHJlc2VudCB0aGUgc2FtZSBtaWxsaXNlY29uZCwgaGF2ZSB0aGUgc2FtZSB6b25lIGFuZCBsb2NhdGlvbiwgYW5kIGFyZSBib3RoIHZhbGlkLlxuICAgKiBUbyBjb21wYXJlIGp1c3QgdGhlIG1pbGxpc2Vjb25kIHZhbHVlcywgdXNlIGArZHQxID09PSArZHQyYC5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXIgLSB0aGUgb3RoZXIgRGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmlzVmFsaWQgJiZcbiAgICAgIG90aGVyLmlzVmFsaWQgJiZcbiAgICAgIHRoaXMudmFsdWVPZigpID09PSBvdGhlci52YWx1ZU9mKCkgJiZcbiAgICAgIHRoaXMuem9uZS5lcXVhbHMob3RoZXIuem9uZSkgJiZcbiAgICAgIHRoaXMubG9jLmVxdWFscyhvdGhlci5sb2MpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdGhpcyB0aW1lIHJlbGF0aXZlIHRvIG5vdywgc3VjaCBhcyBcImluIHR3byBkYXlzXCIuIENhbiBvbmx5IGludGVybmF0aW9uYWxpemUgaWYgeW91clxuICAgKiBwbGF0Zm9ybSBzdXBwb3J0cyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC4gUm91bmRzIGRvd24gYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBvdXRwdXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gW29wdGlvbnMuYmFzZT1EYXRlVGltZS5ub3coKV0gLSB0aGUgRGF0ZVRpbWUgdG8gdXNlIGFzIHRoZSBiYXNpcyB0byB3aGljaCB0aGlzIHRpbWUgaXMgY29tcGFyZWQuIERlZmF1bHRzIHRvIG5vdy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN0eWxlPVwibG9uZ1wiXSAtIHRoZSBzdHlsZSBvZiB1bml0cywgbXVzdCBiZSBcImxvbmdcIiwgXCJzaG9ydFwiLCBvciBcIm5hcnJvd1wiXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBvcHRpb25zLnVuaXQgLSB1c2UgYSBzcGVjaWZpYyB1bml0IG9yIGFycmF5IG9mIHVuaXRzOyBpZiBvbWl0dGVkLCBvciBhbiBhcnJheSwgdGhlIG1ldGhvZCB3aWxsIHBpY2sgdGhlIGJlc3QgdW5pdC4gVXNlIGFuIGFycmF5IG9yIG9uZSBvZiBcInllYXJzXCIsIFwicXVhcnRlcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgb3IgXCJzZWNvbmRzXCJcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yb3VuZD10cnVlXSAtIHdoZXRoZXIgdG8gcm91bmQgdGhlIG51bWJlcnMgaW4gdGhlIG91dHB1dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnBhZGRpbmc9MF0gLSBwYWRkaW5nIGluIG1pbGxpc2Vjb25kcy4gVGhpcyBhbGxvd3MgeW91IHRvIHJvdW5kIHVwIHRoZSByZXN1bHQgaWYgaXQgZml0cyBpbnNpZGUgdGhlIHRocmVzaG9sZC4gRG9uJ3QgdXNlIGluIGNvbWJpbmF0aW9uIHdpdGgge3JvdW5kOiBmYWxzZX0gYmVjYXVzZSB0aGUgZGVjaW1hbCBvdXRwdXQgd2lsbCBpbmNsdWRlIHRoZSBwYWRkaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2NhbGUgLSBvdmVycmlkZSB0aGUgbG9jYWxlIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gb3ZlcnJpZGUgdGhlIG51bWJlcmluZ1N5c3RlbSBvZiB0aGlzIERhdGVUaW1lLiBUaGUgSW50bCBzeXN0ZW0gbWF5IGNob29zZSBub3QgdG8gaG9ub3IgdGhpc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKCkgLy89PiBcImluIDEgZGF5XCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKFwiZXNcIikudG9SZWxhdGl2ZSh7IGRheXM6IDEgfSkgLy89PiBcImRlbnRybyBkZSAxIGRcdTAwRURhXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSh7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gXCJkYW5zIDIzIGhldXJlc1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlKCkgLy89PiBcIjIgZGF5cyBhZ29cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZSh7IHVuaXQ6IFwiaG91cnNcIiB9KSAvLz0+IFwiNDggaG91cnMgYWdvXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBob3VyczogMzYgfSkudG9SZWxhdGl2ZSh7IHJvdW5kOiBmYWxzZSB9KSAvLz0+IFwiMS41IGRheXMgYWdvXCJcbiAgICovXG4gIHRvUmVsYXRpdmUob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGJhc2UgPSBvcHRpb25zLmJhc2UgfHwgRGF0ZVRpbWUuZnJvbU9iamVjdCh7fSwgeyB6b25lOiB0aGlzLnpvbmUgfSksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nID8gKHRoaXMgPCBiYXNlID8gLW9wdGlvbnMucGFkZGluZyA6IG9wdGlvbnMucGFkZGluZykgOiAwO1xuICAgIGxldCB1bml0cyA9IFtcInllYXJzXCIsIFwibW9udGhzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIl07XG4gICAgbGV0IHVuaXQgPSBvcHRpb25zLnVuaXQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy51bml0KSkge1xuICAgICAgdW5pdHMgPSBvcHRpb25zLnVuaXQ7XG4gICAgICB1bml0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZGlmZlJlbGF0aXZlKGJhc2UsIHRoaXMucGx1cyhwYWRkaW5nKSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIG51bWVyaWM6IFwiYWx3YXlzXCIsXG4gICAgICB1bml0cyxcbiAgICAgIHVuaXQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGRhdGUgcmVsYXRpdmUgdG8gdG9kYXksIHN1Y2ggYXMgXCJ5ZXN0ZXJkYXlcIiBvciBcIm5leHQgbW9udGhcIi5cbiAgICogT25seSBpbnRlcm5hdGlvbmFsaXplcyBvbiBwbGF0Zm9ybXMgdGhhdCBzdXBwb3J0cyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBvdXRwdXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gW29wdGlvbnMuYmFzZT1EYXRlVGltZS5ub3coKV0gLSB0aGUgRGF0ZVRpbWUgdG8gdXNlIGFzIHRoZSBiYXNpcyB0byB3aGljaCB0aGlzIHRpbWUgaXMgY29tcGFyZWQuIERlZmF1bHRzIHRvIG5vdy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9jYWxlIC0gb3ZlcnJpZGUgdGhlIGxvY2FsZSBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVuaXQgLSB1c2UgYSBzcGVjaWZpYyB1bml0OyBpZiBvbWl0dGVkLCB0aGUgbWV0aG9kIHdpbGwgcGljayB0aGUgdW5pdC4gVXNlIG9uZSBvZiBcInllYXJzXCIsIFwicXVhcnRlcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBvciBcImRheXNcIlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSBvdmVycmlkZSB0aGUgbnVtYmVyaW5nU3lzdGVtIG9mIHRoaXMgRGF0ZVRpbWUuIFRoZSBJbnRsIHN5c3RlbSBtYXkgY2hvb3NlIG5vdCB0byBob25vciB0aGlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmVDYWxlbmRhcigpIC8vPT4gXCJ0b21vcnJvd1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZShcImVzXCIpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiXCJtYVx1MDBGMWFuYVwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmVDYWxlbmRhcih7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gXCJkZW1haW5cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKCkgLy89PiBcIjIgZGF5cyBhZ29cIlxuICAgKi9cbiAgdG9SZWxhdGl2ZUNhbGVuZGFyKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiBkaWZmUmVsYXRpdmUob3B0aW9ucy5iYXNlIHx8IERhdGVUaW1lLmZyb21PYmplY3Qoe30sIHsgem9uZTogdGhpcy56b25lIH0pLCB0aGlzLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgbnVtZXJpYzogXCJhdXRvXCIsXG4gICAgICB1bml0czogW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCJdLFxuICAgICAgY2FsZW5kYXJ5OiB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWluIG9mIHNldmVyYWwgZGF0ZSB0aW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgRGF0ZVRpbWVzIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtaW5pbXVtXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgbWluIERhdGVUaW1lLCBvciB1bmRlZmluZWQgaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRcbiAgICovXG4gIHN0YXRpYyBtaW4oLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCFkYXRlVGltZXMuZXZlcnkoRGF0ZVRpbWUuaXNEYXRlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1pbiByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGJlIERhdGVUaW1lc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlc3RCeShkYXRlVGltZXMsIChpKSA9PiBpLnZhbHVlT2YoKSwgTWF0aC5taW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWF4IG9mIHNldmVyYWwgZGF0ZSB0aW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgRGF0ZVRpbWVzIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtYXhpbXVtXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgbWF4IERhdGVUaW1lLCBvciB1bmRlZmluZWQgaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRcbiAgICovXG4gIHN0YXRpYyBtYXgoLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCFkYXRlVGltZXMuZXZlcnkoRGF0ZVRpbWUuaXNEYXRlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1heCByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGJlIERhdGVUaW1lc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlc3RCeShkYXRlVGltZXMsIChpKSA9PiBpLnZhbHVlT2YoKSwgTWF0aC5tYXgpO1xuICB9XG5cbiAgLy8gTUlTQ1xuXG4gIC8qKlxuICAgKiBFeHBsYWluIGhvdyBhIHN0cmluZyB3b3VsZCBiZSBwYXJzZWQgYnkgZnJvbUZvcm1hdCgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCB0aGUgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIGJlIGluIChzZWUgZGVzY3JpcHRpb24pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0YWtlbiBieSBmcm9tRm9ybWF0KClcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGZyb21Gb3JtYXRFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsIH0gPSBvcHRpb25zLFxuICAgICAgbG9jYWxlVG9Vc2UgPSBMb2NhbGUuZnJvbU9wdHMoe1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgZGVmYXVsdFRvRU46IHRydWUsXG4gICAgICB9KTtcbiAgICByZXR1cm4gZXhwbGFpbkZyb21Ub2tlbnMobG9jYWxlVG9Vc2UsIHRleHQsIGZtdCk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXRFeHBsYWluIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nRXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tRm9ybWF0RXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gRk9STUFUIFBSRVNFVFNcblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAxMC8xNC8xOTgzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfU0hPUlQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9TSE9SVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3QgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfTUVEKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfTUVEO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaSwgT2N0IDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX01FRF9XSVRIX1dFRUtEQVkoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9NRURfV0lUSF9XRUVLREFZO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfRlVMTCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX0ZVTEw7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnVHVlc2RheSwgT2N0b2JlciAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9IVUdFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfSFVHRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1NJTVBMRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1NJTVBMRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9XSVRIX1NIT1JUX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfTE9OR19PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfU0lNUExFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfU0lNUExFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEVEVCcsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgRWFzdGVybiBEYXlsaWdodCBUaW1lJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMTAvMTQvMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9TSE9SVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9TSE9SVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcxMC8xNC8xOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9NRUQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmksIDE0IE9jdCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVkoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVEVCcuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9GVUxMKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0ZVTEw7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MywgOTozMDozMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9IVUdFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0hVR0U7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwOjMzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUztcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcmllbmRseURhdGVUaW1lKGRhdGVUaW1laXNoKSB7XG4gIGlmIChEYXRlVGltZS5pc0RhdGVUaW1lKGRhdGVUaW1laXNoKSkge1xuICAgIHJldHVybiBkYXRlVGltZWlzaDtcbiAgfSBlbHNlIGlmIChkYXRlVGltZWlzaCAmJiBkYXRlVGltZWlzaC52YWx1ZU9mICYmIGlzTnVtYmVyKGRhdGVUaW1laXNoLnZhbHVlT2YoKSkpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUpTRGF0ZShkYXRlVGltZWlzaCk7XG4gIH0gZWxzZSBpZiAoZGF0ZVRpbWVpc2ggJiYgdHlwZW9mIGRhdGVUaW1laXNoID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21PYmplY3QoZGF0ZVRpbWVpc2gpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgIGBVbmtub3duIGRhdGV0aW1lIGFyZ3VtZW50OiAke2RhdGVUaW1laXNofSwgb2YgdHlwZSAke3R5cGVvZiBkYXRlVGltZWlzaH1gXG4gICAgKTtcbiAgfVxufVxuIiwgImltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgSW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCBJbmZvIGZyb20gXCIuL2luZm8uanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuL3pvbmUuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBJbnZhbGlkWm9uZSBmcm9tIFwiLi96b25lcy9pbnZhbGlkWm9uZS5qc1wiO1xuaW1wb3J0IFN5c3RlbVpvbmUgZnJvbSBcIi4vem9uZXMvc3lzdGVtWm9uZS5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5cbmNvbnN0IFZFUlNJT04gPSBcIjIuMy4wXCI7XG5cbmV4cG9ydCB7XG4gIFZFUlNJT04sXG4gIERhdGVUaW1lLFxuICBEdXJhdGlvbixcbiAgSW50ZXJ2YWwsXG4gIEluZm8sXG4gIFpvbmUsXG4gIEZpeGVkT2Zmc2V0Wm9uZSxcbiAgSUFOQVpvbmUsXG4gIEludmFsaWRab25lLFxuICBTeXN0ZW1ab25lLFxuICBTZXR0aW5ncyxcbn07XG4iLCAiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZmVhdGhlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJmZWF0aGVyXCJdID0gZmFjdG9yeSgpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsICIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuIiwgIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTYgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBjbGFzc05hbWVzID0gKGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkb24ndCBpbmhlcml0IGZyb20gT2JqZWN0IHNvIHdlIGNhbiBza2lwIGhhc093blByb3BlcnR5IGNoZWNrIGxhdGVyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNTUxODMyOC9jcmVhdGluZy1qcy1vYmplY3Qtd2l0aC1vYmplY3QtY3JlYXRlbnVsbCNhbnN3ZXItMjEwNzkyMzJcblx0XHRmdW5jdGlvbiBTdG9yYWdlT2JqZWN0KCkge31cblx0XHRTdG9yYWdlT2JqZWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblx0XHRmdW5jdGlvbiBfcGFyc2VBcnJheSAocmVzdWx0U2V0LCBhcnJheSkge1xuXHRcdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdFx0XHRfcGFyc2UocmVzdWx0U2V0LCBhcnJheVtpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdFx0ZnVuY3Rpb24gX3BhcnNlTnVtYmVyIChyZXN1bHRTZXQsIG51bSkge1xuXHRcdFx0cmVzdWx0U2V0W251bV0gPSB0cnVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIF9wYXJzZU9iamVjdCAocmVzdWx0U2V0LCBvYmplY3QpIHtcblx0XHRcdGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmIChoYXNPd24uY2FsbChvYmplY3QsIGspKSB7XG5cdFx0XHRcdFx0Ly8gc2V0IHZhbHVlIHRvIGZhbHNlIGluc3RlYWQgb2YgZGVsZXRpbmcgaXQgdG8gYXZvaWQgY2hhbmdpbmcgb2JqZWN0IHN0cnVjdHVyZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vd3d3LnNtYXNoaW5nbWFnYXppbmUuY29tLzIwMTIvMTEvd3JpdGluZy1mYXN0LW1lbW9yeS1lZmZpY2llbnQtamF2YXNjcmlwdC8jZGUtcmVmZXJlbmNpbmctbWlzY29uY2VwdGlvbnNcblx0XHRcdFx0XHRyZXN1bHRTZXRba10gPSAhIW9iamVjdFtrXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBTUEFDRSA9IC9cXHMrLztcblx0XHRmdW5jdGlvbiBfcGFyc2VTdHJpbmcgKHJlc3VsdFNldCwgc3RyKSB7XG5cdFx0XHR2YXIgYXJyYXkgPSBzdHIuc3BsaXQoU1BBQ0UpO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdFx0XHRyZXN1bHRTZXRbYXJyYXlbaV1dID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBfcGFyc2UgKHJlc3VsdFNldCwgYXJnKSB7XG5cdFx0XHRpZiAoIWFyZykgcmV0dXJuO1xuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHQvLyAnZm9vIGJhcidcblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRfcGFyc2VTdHJpbmcocmVzdWx0U2V0LCBhcmcpO1xuXG5cdFx0XHQvLyBbJ2ZvbycsICdiYXInLCAuLi5dXG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRfcGFyc2VBcnJheShyZXN1bHRTZXQsIGFyZyk7XG5cblx0XHRcdC8vIHsgJ2Zvbyc6IHRydWUsIC4uLiB9XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdF9wYXJzZU9iamVjdChyZXN1bHRTZXQsIGFyZyk7XG5cblx0XHRcdC8vICcxMzAnXG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdF9wYXJzZU51bWJlcihyZXN1bHRTZXQsIGFyZyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gX2NsYXNzTmFtZXMgKCkge1xuXHRcdFx0Ly8gZG9uJ3QgbGVhayBhcmd1bWVudHNcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvd2lraS9PcHRpbWl6YXRpb24ta2lsbGVycyMzMi1sZWFraW5nLWFyZ3VtZW50c1xuXHRcdFx0dmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0XHR2YXIgYXJncyA9IEFycmF5KGxlbik7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjbGFzc1NldCA9IG5ldyBTdG9yYWdlT2JqZWN0KCk7XG5cdFx0XHRfcGFyc2VBcnJheShjbGFzc1NldCwgYXJncyk7XG5cblx0XHRcdHZhciBsaXN0ID0gW107XG5cblx0XHRcdGZvciAodmFyIGsgaW4gY2xhc3NTZXQpIHtcblx0XHRcdFx0aWYgKGNsYXNzU2V0W2tdKSB7XG5cdFx0XHRcdFx0bGlzdC5wdXNoKGspXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGxpc3Quam9pbignICcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBfY2xhc3NOYW1lcztcblx0fSkoKTtcblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuIiwgInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLmFycmF5LmZyb20nKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi4vLi4vaW50ZXJuYWxzL3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXRoLkFycmF5LmZyb207XG4iLCAibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhpdCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsICJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhpdCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2JpbmQtY29udGV4dCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcnKTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4vLyBgQXJyYXkuZnJvbWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5mcm9tXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xuICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgbWFwZm4gPSBhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKE8pO1xuICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICBpZiAobWFwcGluZykgbWFwZm4gPSBiaW5kKG1hcGZuLCBhcmd1bWVudHNMZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgLy8gaWYgdGhlIHRhcmdldCBpcyBub3QgaXRlcmFibGUgb3IgaXQncyBhbiBhcnJheSB3aXRoIHRoZSBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIGEgc2ltcGxlIGNhc2VcbiAgaWYgKGl0ZXJhdG9yTWV0aG9kICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJhdG9yTWV0aG9kKSkpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhdG9yTWV0aG9kLmNhbGwoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEMoKTtcbiAgICBmb3IgKDshKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmdcbiAgICAgICAgPyBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSlcbiAgICAgICAgOiBzdGVwLnZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgcmVzdWx0ID0gbmV3IEMobGVuZ3RoKTtcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCAidmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwgInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQpO1xuICAgIH07XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwgInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxuLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgRU5UUklFUykge1xuICB0cnkge1xuICAgIHJldHVybiBFTlRSSUVTID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdmFyIHJldHVybk1ldGhvZCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0dXJuTWV0aG9kICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldHVybk1ldGhvZC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG4iLCAidmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciBjYWxsZWQgPSAwO1xuICB2YXIgaXRlcmF0b3JXaXRoUmV0dXJuID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGRvbmU6ICEhY2FsbGVkKysgfTtcbiAgICB9LFxuICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShpdGVyYXRvcldpdGhSZXR1cm4sIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIFNLSVBfQ0xPU0lORykge1xuICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICBvYmplY3RbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IElURVJBVElPTl9TVVBQT1JUID0gdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhlYyhvYmplY3QpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBJVEVSQVRJT05fU1VQUE9SVDtcbn07XG4iLCAidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuIiwgInZhciBjbGFzc29mUmF3ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2Bcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG4iLCAidmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL293bi1rZXlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICghaGFzKHRhcmdldCwga2V5KSkgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICB9XG59O1xuIiwgInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMtY29yZScpLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSwgdHJ1ZSk7XG4gIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XG4gIHJldHVybiBJdGVyYXRvckNvbnN0cnVjdG9yO1xufTtcbiIsICJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlLZXkgPSB0b1ByaW1pdGl2ZShrZXkpO1xuICBpZiAocHJvcGVydHlLZXkgaW4gb2JqZWN0KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwgcHJvcGVydHlLZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3InKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciBJdGVyYXRvcnNDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJyk7XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG4gICAgc3dpdGNoIChLSU5EKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBFTlRSSUVTOiByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xuICB9O1xuXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdXG4gICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgaWYgKCFJU19QVVJFICYmIGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBoaWRlKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUsIHRydWUpO1xuICAgICAgaWYgKElTX1BVUkUpIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XG4gICAgfVxuICB9XG5cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gdHJ1ZTtcbiAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuYXRpdmVJdGVyYXRvci5jYWxsKHRoaXMpOyB9O1xuICB9XG5cbiAgLy8gZGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUlTX1BVUkUgfHwgRk9SQ0VEKSAmJiBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuICAgIGhpZGUoSXRlcmFibGVQcm90b3R5cGUsIElURVJBVE9SLCBkZWZhdWx0SXRlcmF0b3IpO1xuICB9XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IGRlZmF1bHRJdGVyYXRvcjtcblxuICAvLyBleHBvcnQgYWRkaXRpb25hbCBtZXRob2RzXG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiBnZXRJdGVyYXRpb25NZXRob2QoRU5UUklFUylcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcbiAgICAgIGlmIChCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB8fCAhKEtFWSBpbiBJdGVyYWJsZVByb3RvdHlwZSkpIHtcbiAgICAgICAgcmVkZWZpbmUoSXRlcmFibGVQcm90b3R5cGUsIEtFWSwgbWV0aG9kc1tLRVldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgJCh7IHRhcmdldDogTkFNRSwgcHJvdG86IHRydWUsIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfSwgbWV0aG9kcyk7XG4gIH1cblxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCAidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsICJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBleGlzdCA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGV4aXN0ID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCAiLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG4iLCAidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMubm9UYXJnZXRHZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbFtUQVJHRVRdIHx8IHNldEdsb2JhbChUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLm5vVGFyZ2V0R2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgaGlkZShzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG4iLCAibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsICJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYXJlZCgnbmF0aXZlLWZ1bmN0aW9uLXRvLXN0cmluZycsIEZ1bmN0aW9uLnRvU3RyaW5nKTtcbiIsICJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCAidmFyIE8gPSAnb2JqZWN0JztcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbm1vZHVsZS5leHBvcnRzID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09IE8gJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSBPICYmIHdpbmRvdykgfHxcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gTyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsID09IE8gJiYgZ2xvYmFsKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiIsICJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCAibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsICJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwgInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCAidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjcmVhdGVFbGVtZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50Jyk7XG5cbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIURFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcbiIsICIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xuXG52YXIgc3BsaXQgPSAnJy5zcGxpdDtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICByZXR1cm4gIU9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YoaXQpID09ICdTdHJpbmcnID8gc3BsaXQuY2FsbChpdCwgJycpIDogT2JqZWN0KGl0KTtcbn0gOiBPYmplY3Q7XG4iLCAidmFyIE5BVElWRV9XRUFLX01BUCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRlJyk7XG52YXIgb2JqZWN0SGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xuXG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgIH0gcmV0dXJuIHN0YXRlO1xuICB9O1xufTtcblxuaWYgKE5BVElWRV9XRUFLX01BUCkge1xuICB2YXIgc3RvcmUgPSBuZXcgV2Vha01hcCgpO1xuICB2YXIgd21nZXQgPSBzdG9yZS5nZXQ7XG4gIHZhciB3bWhhcyA9IHN0b3JlLmhhcztcbiAgdmFyIHdtc2V0ID0gc3RvcmUuc2V0O1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgd21zZXQuY2FsbChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldC5jYWxsKHN0b3JlLCBpdCkgfHwge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWhhcy5jYWxsKHN0b3JlLCBpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGhpZGUoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXQsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG4iLCAidmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvdHlwZVtJVEVSQVRPUl0gPT09IGl0KTtcbn07XG4iLCAidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogdHlwZW9mIGRldGVjdGlvbiA9PSAnZnVuY3Rpb24nID8gZmFpbHMoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGb3JjZWQ7XG4iLCAibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCAibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbiIsICIndXNlIHN0cmljdCc7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbmlmIChJdGVyYXRvclByb3RvdHlwZSA9PSB1bmRlZmluZWQpIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5pZiAoIUlTX1BVUkUgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUsXG4gIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlNcbn07XG4iLCAibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsICJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHJldHVybiAhU3RyaW5nKFN5bWJvbCgpKTtcbn0pO1xuIiwgInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgbmF0aXZlRnVuY3Rpb25Ub1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi10by1zdHJpbmcnKTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QobmF0aXZlRnVuY3Rpb25Ub1N0cmluZy5jYWxsKFdlYWtNYXApKTtcbiIsICJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaHRtbCcpO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG5cbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBzY3JpcHQgPSAnc2NyaXB0JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIganMgPSAnamF2YScgKyBzY3JpcHQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhqcyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyBzY3JpcHQgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvJyArIHNjcmlwdCArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChsZW5ndGgtLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cbmhpZGRlbktleXNbSUVfUFJPVE9dID0gdHJ1ZTtcbiIsICJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaSsrXSwgUHJvcGVydGllc1trZXldKTtcbiAgcmV0dXJuIE87XG59O1xuIiwgInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG5cbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwgInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lJyk7XG5cbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG4iLCAiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwgImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCAidmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXInKTtcblxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG5tb2R1bGUuZXhwb3J0cyA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90b3R5cGUgOiBudWxsO1xufTtcbiIsICJ2YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG5cbnZhciBhcnJheUluZGV4T2YgPSBhcnJheUluY2x1ZGVzKGZhbHNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhcyhoaWRkZW5LZXlzLCBrZXkpICYmIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwgInZhciBpbnRlcm5hbE9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzJyk7XG5cbi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcbnZhciBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmICFuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuZXhwb3J0cy5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIFYpO1xuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsICJ2YXIgdmFsaWRhdGVTZXRQcm90b3R5cGVPZkFyZ3VtZW50cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy92YWxpZGF0ZS1zZXQtcHJvdG90eXBlLW9mLWFyZ3VtZW50cycpO1xuXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb3JyZWN0U2V0dGVyID0gZmFsc2U7XG4gIHZhciB0ZXN0ID0ge307XG4gIHZhciBzZXR0ZXI7XG4gIHRyeSB7XG4gICAgc2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0O1xuICAgIHNldHRlci5jYWxsKHRlc3QsIFtdKTtcbiAgICBjb3JyZWN0U2V0dGVyID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIHZhbGlkYXRlU2V0UHJvdG90eXBlT2ZBcmd1bWVudHMoTywgcHJvdG8pO1xuICAgIGlmIChjb3JyZWN0U2V0dGVyKSBzZXR0ZXIuY2FsbChPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcbiIsICJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xuXG52YXIgUmVmbGVjdCA9IGdsb2JhbC5SZWZsZWN0O1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3QgJiYgUmVmbGVjdC5vd25LZXlzIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcbiIsICJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbiIsICJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgc2V0R2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1nbG9iYWwnKTtcbnZhciBuYXRpdmVGdW5jdGlvblRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXRvLXN0cmluZycpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcblxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBURU1QTEFURSA9IFN0cmluZyhuYXRpdmVGdW5jdGlvblRvU3RyaW5nKS5zcGxpdCgndG9TdHJpbmcnKTtcblxuc2hhcmVkKCdpbnNwZWN0U291cmNlJywgZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBuYXRpdmVGdW5jdGlvblRvU3RyaW5nLmNhbGwoaXQpO1xufSk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB1bnNhZmUgPSBvcHRpb25zID8gISFvcHRpb25zLnVuc2FmZSA6IGZhbHNlO1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5lbnVtZXJhYmxlIDogZmFsc2U7XG4gIHZhciBub1RhcmdldEdldCA9IG9wdGlvbnMgPyAhIW9wdGlvbnMubm9UYXJnZXRHZXQgOiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgJiYgIWhhcyh2YWx1ZSwgJ25hbWUnKSkgaGlkZSh2YWx1ZSwgJ25hbWUnLCBrZXkpO1xuICAgIGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKS5zb3VyY2UgPSBURU1QTEFURS5qb2luKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyBrZXkgOiAnJyk7XG4gIH1cbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2Ugc2V0R2xvYmFsKGtleSwgdmFsdWUpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICghdW5zYWZlKSB7XG4gICAgZGVsZXRlIE9ba2V5XTtcbiAgfSBlbHNlIGlmICghbm9UYXJnZXRHZXQgJiYgT1trZXldKSB7XG4gICAgc2ltcGxlID0gdHJ1ZTtcbiAgfVxuICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgZWxzZSBoaWRlKE8sIGtleSwgdmFsdWUpO1xuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBuYXRpdmVGdW5jdGlvblRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTtcbiIsICIvLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsICJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgaGlkZShnbG9iYWwsIGtleSwgdmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbFtrZXldID0gdmFsdWU7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcbiIsICJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRBRywgU1RBVElDKSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gU1RBVElDID8gaXQgOiBpdC5wcm90b3R5cGUsIFRPX1NUUklOR19UQUcpKSB7XG4gICAgZGVmaW5lUHJvcGVydHkoaXQsIFRPX1NUUklOR19UQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xuICB9XG59O1xuIiwgInZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xuXG52YXIga2V5cyA9IHNoYXJlZCgna2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xufTtcbiIsICJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHNldEdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtZ2xvYmFsJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IHNldEdsb2JhbChTSEFSRUQsIHt9KTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjEuMycsXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnXHUwMEE5IDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcbiIsICJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG4vLyBDT05WRVJUX1RPX1NUUklORzogdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBDT05WRVJUX1RPX1NUUklORzogZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBwb3MsIENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gIHZhciBTID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhhdCkpO1xuICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXIocG9zKTtcbiAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgdmFyIGZpcnN0LCBzZWNvbmQ7XG4gIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gIGZpcnN0ID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgcmV0dXJuIGZpcnN0IDwgMHhEODAwIHx8IGZpcnN0ID4gMHhEQkZGIHx8IHBvc2l0aW9uICsgMSA9PT0gc2l6ZVxuICAgIHx8IChzZWNvbmQgPSBTLmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSkgPCAweERDMDAgfHwgc2Vjb25kID4gMHhERkZGXG4gICAgICA/IENPTlZFUlRfVE9fU1RSSU5HID8gUy5jaGFyQXQocG9zaXRpb24pIDogZmlyc3RcbiAgICAgIDogQ09OVkVSVF9UT19TVFJJTkcgPyBTLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpIDogKGZpcnN0IC0gMHhEODAwIDw8IDEwKSArIChzZWNvbmQgLSAweERDMDApICsgMHgxMDAwMDtcbn07XG4iLCAidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihsZW5ndGgsIGxlbmd0aCkuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluKGludGVnZXIsIGxlbmd0aCk7XG59O1xuIiwgIi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoaXQpKTtcbn07XG4iLCAidmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgVG9JbnRlZ2VyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvaW50ZWdlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzTmFOKGFyZ3VtZW50ID0gK2FyZ3VtZW50KSA/IDAgOiAoYXJndW1lbnQgPiAwID8gZmxvb3IgOiBjZWlsKShhcmd1bWVudCk7XG59O1xuIiwgInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xuXG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXIoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCAidmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b29iamVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KSk7XG59O1xuIiwgInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxuLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsICJ2YXIgaWQgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBwb3N0Zml4KS50b1N0cmluZygzNikpO1xufTtcbiIsICJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIHByb3RvKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBpZiAoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbid0IHNldCBcIiArIFN0cmluZyhwcm90bykgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG4gIH1cbn07XG4iLCAidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xudmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbCcpO1xuXG52YXIgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBzdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9IE5BVElWRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdXG4gICAgfHwgKE5BVElWRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG4iLCAidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZnJvbSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1mcm9tJyk7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbicpO1xuXG52YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIEFycmF5LmZyb20oaXRlcmFibGUpO1xufSk7XG5cbi8vIGBBcnJheS5mcm9tYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cbiQoeyB0YXJnZXQ6ICdBcnJheScsIHN0YXQ6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XG4gIGZyb206IGZyb21cbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcbnZhciBjb2RlUG9pbnRBdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctYXQnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yJyk7XG5cbnZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxuZGVmaW5lSXRlcmF0b3IoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IFNUUklOR19JVEVSQVRPUixcbiAgICBzdHJpbmc6IFN0cmluZyhpdGVyYXRlZCksXG4gICAgaW5kZXg6IDBcbiAgfSk7XG4vLyBgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSBjb2RlUG9pbnRBdChzdHJpbmcsIGluZGV4LCB0cnVlKTtcbiAgc3RhdGUuaW5kZXggKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsICJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoIChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcbiIsICJpbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzL2RlZHVwZSc7XG5cbmltcG9ydCBERUZBVUxUX0FUVFJTIGZyb20gJy4vZGVmYXVsdC1hdHRycy5qc29uJztcblxuY2xhc3MgSWNvbiB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGNvbnRlbnRzLCB0YWdzID0gW10pIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY29udGVudHMgPSBjb250ZW50cztcbiAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgIHRoaXMuYXR0cnMgPSB7XG4gICAgICAuLi5ERUZBVUxUX0FUVFJTLFxuICAgICAgLi4ueyBjbGFzczogYGZlYXRoZXIgZmVhdGhlci0ke25hbWV9YCB9LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIFNWRyBzdHJpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdmcoYXR0cnMgPSB7fSkge1xuICAgIGNvbnN0IGNvbWJpbmVkQXR0cnMgPSB7XG4gICAgICAuLi50aGlzLmF0dHJzLFxuICAgICAgLi4uYXR0cnMsXG4gICAgICAuLi57IGNsYXNzOiBjbGFzc25hbWVzKHRoaXMuYXR0cnMuY2xhc3MsIGF0dHJzLmNsYXNzKSB9LFxuICAgIH07XG5cbiAgICByZXR1cm4gYDxzdmcgJHthdHRyc1RvU3RyaW5nKGNvbWJpbmVkQXR0cnMpfT4ke3RoaXMuY29udGVudHN9PC9zdmc+YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGBJY29uYC5cbiAgICpcbiAgICogQWRkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIElmIG9sZCBjb2RlIGV4cGVjdHMgYGZlYXRoZXIuaWNvbnMuPG5hbWU+YFxuICAgKiB0byBiZSBhIHN0cmluZywgYHRvU3RyaW5nKClgIHdpbGwgZ2V0IGltcGxpY2l0bHkgY2FsbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHM7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGF0dHJpYnV0ZXMgb2JqZWN0IHRvIHN0cmluZyBvZiBIVE1MIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGF0dHJzVG9TdHJpbmcoYXR0cnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHJzKVxuICAgIC5tYXAoa2V5ID0+IGAke2tleX09XCIke2F0dHJzW2tleV19XCJgKVxuICAgIC5qb2luKCcgJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEljb247XG4iLCAiaW1wb3J0IEljb24gZnJvbSAnLi9pY29uJztcbmltcG9ydCBpY29ucyBmcm9tICcuLi9kaXN0L2ljb25zLmpzb24nO1xuaW1wb3J0IHRhZ3MgZnJvbSAnLi90YWdzLmpzb24nO1xuXG5leHBvcnQgZGVmYXVsdCBPYmplY3Qua2V5cyhpY29ucylcbiAgLm1hcChrZXkgPT4gbmV3IEljb24oa2V5LCBpY29uc1trZXldLCB0YWdzW2tleV0pKVxuICAucmVkdWNlKChvYmplY3QsIGljb24pID0+IHtcbiAgICBvYmplY3RbaWNvbi5uYW1lXSA9IGljb247XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSwge30pO1xuIiwgImltcG9ydCBpY29ucyBmcm9tICcuL2ljb25zJztcbmltcG9ydCB0b1N2ZyBmcm9tICcuL3RvLXN2Zyc7XG5pbXBvcnQgcmVwbGFjZSBmcm9tICcuL3JlcGxhY2UnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgaWNvbnMsIHRvU3ZnLCByZXBsYWNlIH07XG4iLCAiLyogZXNsaW50LWVudiBicm93c2VyICovXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzL2RlZHVwZSc7XG5cbmltcG9ydCBpY29ucyBmcm9tICcuL2ljb25zJztcblxuLyoqXG4gKiBSZXBsYWNlIGFsbCBIVE1MIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIGBkYXRhLWZlYXRoZXJgIGF0dHJpYnV0ZSB3aXRoIFNWRyBtYXJrdXBcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGVsZW1lbnQncyBgZGF0YS1mZWF0aGVyYCBhdHRyaWJ1dGUgdmFsdWUuXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cnNcbiAqL1xuZnVuY3Rpb24gcmVwbGFjZShhdHRycyA9IHt9KSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZmVhdGhlci5yZXBsYWNlKClgIG9ubHkgd29ya3MgaW4gYSBicm93c2VyIGVudmlyb25tZW50LicpO1xuICB9XG5cbiAgY29uc3QgZWxlbWVudHNUb1JlcGxhY2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1mZWF0aGVyXScpO1xuXG4gIEFycmF5LmZyb20oZWxlbWVudHNUb1JlcGxhY2UpLmZvckVhY2goZWxlbWVudCA9PlxuICAgIHJlcGxhY2VFbGVtZW50KGVsZW1lbnQsIGF0dHJzKSxcbiAgKTtcbn1cblxuLyoqXG4gKiBSZXBsYWNlIGEgc2luZ2xlIEhUTUwgZWxlbWVudCB3aXRoIFNWRyBtYXJrdXBcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGVsZW1lbnQncyBgZGF0YS1mZWF0aGVyYCBhdHRyaWJ1dGUgdmFsdWUuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cnNcbiAqL1xuZnVuY3Rpb24gcmVwbGFjZUVsZW1lbnQoZWxlbWVudCwgYXR0cnMgPSB7fSkge1xuICBjb25zdCBlbGVtZW50QXR0cnMgPSBnZXRBdHRycyhlbGVtZW50KTtcbiAgY29uc3QgbmFtZSA9IGVsZW1lbnRBdHRyc1snZGF0YS1mZWF0aGVyJ107XG4gIGRlbGV0ZSBlbGVtZW50QXR0cnNbJ2RhdGEtZmVhdGhlciddO1xuXG4gIGNvbnN0IHN2Z1N0cmluZyA9IGljb25zW25hbWVdLnRvU3ZnKHtcbiAgICAuLi5hdHRycyxcbiAgICAuLi5lbGVtZW50QXR0cnMsXG4gICAgLi4ueyBjbGFzczogY2xhc3NuYW1lcyhhdHRycy5jbGFzcywgZWxlbWVudEF0dHJzLmNsYXNzKSB9LFxuICB9KTtcbiAgY29uc3Qgc3ZnRG9jdW1lbnQgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKFxuICAgIHN2Z1N0cmluZyxcbiAgICAnaW1hZ2Uvc3ZnK3htbCcsXG4gICk7XG4gIGNvbnN0IHN2Z0VsZW1lbnQgPSBzdmdEb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdmcnKTtcblxuICBlbGVtZW50LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHN2Z0VsZW1lbnQsIGVsZW1lbnQpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXR0cmlidXRlcyBvZiBhbiBIVE1MIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRBdHRycyhlbGVtZW50KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuYXR0cmlidXRlcykucmVkdWNlKChhdHRycywgYXR0cikgPT4ge1xuICAgIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgIHJldHVybiBhdHRycztcbiAgfSwge30pO1xufVxuXG5leHBvcnQgZGVmYXVsdCByZXBsYWNlO1xuIiwgImltcG9ydCBpY29ucyBmcm9tICcuL2ljb25zJztcblxuLyoqXG4gKiBDcmVhdGUgYW4gU1ZHIHN0cmluZy5cbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b1N2ZyhuYW1lLCBhdHRycyA9IHt9KSB7XG4gIGNvbnNvbGUud2FybihcbiAgICAnZmVhdGhlci50b1N2ZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgZmVhdGhlci5pY29uc1tuYW1lXS50b1N2ZygpIGluc3RlYWQuJyxcbiAgKTtcblxuICBpZiAoIW5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZXF1aXJlZCBga2V5YCAoaWNvbiBuYW1lKSBwYXJhbWV0ZXIgaXMgbWlzc2luZy4nKTtcbiAgfVxuXG4gIGlmICghaWNvbnNbbmFtZV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgTm8gaWNvbiBtYXRjaGluZyAnJHtcbiAgICAgICAgbmFtZVxuICAgICAgfScuIFNlZSB0aGUgY29tcGxldGUgbGlzdCBvZiBpY29ucyBhdCBodHRwczovL2ZlYXRoZXJpY29ucy5jb21gLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gaWNvbnNbbmFtZV0udG9TdmcoYXR0cnMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b1N2ZztcbiIsICIvKiBWZXJzaW9uOiAwLjQuMjEgLSBOb3ZlbWJlciAyMCwgMjAyMSAxNDo0MToxNyAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBEdW1teSBwcm9wZXJ0eSB0byBhdm9pZCBzb21lIHJvbGx1cCB3YXJuaW5ncyBhYm91dCBhbiBcImVtcHR5IGNodW5rXCIgKHNpbmNlIHRoaXMgaXMgb25seSB0eXBpbmdzKS5cclxuY29uc3QgREFUQVZJRVdfUExBQ0VIT0xERVJfVkFMVUUgPSBudWxsO1xuXG5leHBvcnRzLkRBVEFWSUVXX1BMQUNFSE9MREVSX1ZBTFVFID0gREFUQVZJRVdfUExBQ0VIT0xERVJfVkFMVUU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiIsICIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLm5vVWlTbGlkZXIgPSB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZXhwb3J0cy5QaXBzTW9kZSA9IHZvaWQgMDtcbiAgICAoZnVuY3Rpb24gKFBpcHNNb2RlKSB7XG4gICAgICAgIFBpcHNNb2RlW1wiUmFuZ2VcIl0gPSBcInJhbmdlXCI7XG4gICAgICAgIFBpcHNNb2RlW1wiU3RlcHNcIl0gPSBcInN0ZXBzXCI7XG4gICAgICAgIFBpcHNNb2RlW1wiUG9zaXRpb25zXCJdID0gXCJwb3NpdGlvbnNcIjtcbiAgICAgICAgUGlwc01vZGVbXCJDb3VudFwiXSA9IFwiY291bnRcIjtcbiAgICAgICAgUGlwc01vZGVbXCJWYWx1ZXNcIl0gPSBcInZhbHVlc1wiO1xuICAgIH0pKGV4cG9ydHMuUGlwc01vZGUgfHwgKGV4cG9ydHMuUGlwc01vZGUgPSB7fSkpO1xuICAgIGV4cG9ydHMuUGlwc1R5cGUgPSB2b2lkIDA7XG4gICAgKGZ1bmN0aW9uIChQaXBzVHlwZSkge1xuICAgICAgICBQaXBzVHlwZVtQaXBzVHlwZVtcIk5vbmVcIl0gPSAtMV0gPSBcIk5vbmVcIjtcbiAgICAgICAgUGlwc1R5cGVbUGlwc1R5cGVbXCJOb1ZhbHVlXCJdID0gMF0gPSBcIk5vVmFsdWVcIjtcbiAgICAgICAgUGlwc1R5cGVbUGlwc1R5cGVbXCJMYXJnZVZhbHVlXCJdID0gMV0gPSBcIkxhcmdlVmFsdWVcIjtcbiAgICAgICAgUGlwc1R5cGVbUGlwc1R5cGVbXCJTbWFsbFZhbHVlXCJdID0gMl0gPSBcIlNtYWxsVmFsdWVcIjtcbiAgICB9KShleHBvcnRzLlBpcHNUeXBlIHx8IChleHBvcnRzLlBpcHNUeXBlID0ge30pKTtcbiAgICAvL3JlZ2lvbiBIZWxwZXIgTWV0aG9kc1xuICAgIGZ1bmN0aW9uIGlzVmFsaWRGb3JtYXR0ZXIoZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWRQYXJ0aWFsRm9ybWF0dGVyKGVudHJ5KSAmJiB0eXBlb2YgZW50cnkuZnJvbSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZhbGlkUGFydGlhbEZvcm1hdHRlcihlbnRyeSkge1xuICAgICAgICAvLyBwYXJ0aWFsIGZvcm1hdHRlcnMgb25seSBuZWVkIGEgdG8gZnVuY3Rpb24gYW5kIG5vdCBhIGZyb20gZnVuY3Rpb25cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlbnRyeSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZW50cnkudG8gPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChlbCkge1xuICAgICAgICBlbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEJpbmRhYmxlIHZlcnNpb25cbiAgICBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlcyBkdXBsaWNhdGVzIGZyb20gYW4gYXJyYXkuXG4gICAgZnVuY3Rpb24gdW5pcXVlKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBhcnJheS5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpc1thXSA/ICh0aGlzW2FdID0gdHJ1ZSkgOiBmYWxzZTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvLyBSb3VuZCBhIHZhbHVlIHRvIHRoZSBjbG9zZXN0ICd0bycuXG4gICAgZnVuY3Rpb24gY2xvc2VzdCh2YWx1ZSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgLyB0bykgKiB0bztcbiAgICB9XG4gICAgLy8gQ3VycmVudCBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudC5cbiAgICBmdW5jdGlvbiBvZmZzZXQoZWxlbSwgb3JpZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuICAgICAgICB2YXIgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHZhciBwYWdlT2Zmc2V0ID0gZ2V0UGFnZU9mZnNldChkb2MpO1xuICAgICAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgY29udGFpbnMgbGVmdCBzY3JvbGwgaW4gQ2hyb21lIG9uIEFuZHJvaWQuXG4gICAgICAgIC8vIEkgaGF2ZW4ndCBmb3VuZCBhIGZlYXR1cmUgZGV0ZWN0aW9uIHRoYXQgcHJvdmVzIHRoaXMuIFdvcnN0IGNhc2VcbiAgICAgICAgLy8gc2NlbmFyaW8gb24gbWlzLW1hdGNoOiB0aGUgJ3RhcCcgZmVhdHVyZSBvbiBob3Jpem9udGFsIHNsaWRlcnMgYnJlYWtzLlxuICAgICAgICBpZiAoL3dlYmtpdC4qQ2hyb21lLipNb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICBwYWdlT2Zmc2V0LnggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmllbnRhdGlvbiA/IHJlY3QudG9wICsgcGFnZU9mZnNldC55IC0gZG9jRWxlbS5jbGllbnRUb3AgOiByZWN0LmxlZnQgKyBwYWdlT2Zmc2V0LnggLSBkb2NFbGVtLmNsaWVudExlZnQ7XG4gICAgfVxuICAgIC8vIENoZWNrcyB3aGV0aGVyIGEgdmFsdWUgaXMgbnVtZXJpY2FsLlxuICAgIGZ1bmN0aW9uIGlzTnVtZXJpYyhhKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4oYSkgJiYgaXNGaW5pdGUoYSk7XG4gICAgfVxuICAgIC8vIFNldHMgYSBjbGFzcyBhbmQgcmVtb3ZlcyBpdCBhZnRlciBbZHVyYXRpb25dIG1zLlxuICAgIGZ1bmN0aW9uIGFkZENsYXNzRm9yKGVsZW1lbnQsIGNsYXNzTmFtZSwgZHVyYXRpb24pIHtcbiAgICAgICAgaWYgKGR1cmF0aW9uID4gMCkge1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9LCBkdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTGltaXRzIGEgdmFsdWUgdG8gMCAtIDEwMFxuICAgIGZ1bmN0aW9uIGxpbWl0KGEpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGEsIDEwMCksIDApO1xuICAgIH1cbiAgICAvLyBXcmFwcyBhIHZhcmlhYmxlIGFzIGFuIGFycmF5LCBpZiBpdCBpc24ndCBvbmUgeWV0LlxuICAgIC8vIE5vdGUgdGhhdCBhbiBpbnB1dCBhcnJheSBpcyByZXR1cm5lZCBieSByZWZlcmVuY2UhXG4gICAgZnVuY3Rpb24gYXNBcnJheShhKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGEpID8gYSA6IFthXTtcbiAgICB9XG4gICAgLy8gQ291bnRzIGRlY2ltYWxzXG4gICAgZnVuY3Rpb24gY291bnREZWNpbWFscyhudW1TdHIpIHtcbiAgICAgICAgbnVtU3RyID0gU3RyaW5nKG51bVN0cik7XG4gICAgICAgIHZhciBwaWVjZXMgPSBudW1TdHIuc3BsaXQoXCIuXCIpO1xuICAgICAgICByZXR1cm4gcGllY2VzLmxlbmd0aCA+IDEgPyBwaWVjZXNbMV0ubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgLy8gaHR0cDovL3lvdW1pZ2h0bm90bmVlZGpxdWVyeS5jb20vI2FkZF9jbGFzc1xuICAgIGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKGVsLmNsYXNzTGlzdCAmJiAhL1xccy8udGVzdChjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaHR0cDovL3lvdW1pZ2h0bm90bmVlZGpxdWVyeS5jb20vI3JlbW92ZV9jbGFzc1xuICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKGVsLmNsYXNzTGlzdCAmJiAhL1xccy8udGVzdChjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZShuZXcgUmVnRXhwKFwiKF58XFxcXGIpXCIgKyBjbGFzc05hbWUuc3BsaXQoXCIgXCIpLmpvaW4oXCJ8XCIpICsgXCIoXFxcXGJ8JClcIiwgXCJnaVwiKSwgXCIgXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vcGxhaW5qcy5jb20vamF2YXNjcmlwdC9hdHRyaWJ1dGVzL2FkZGluZy1yZW1vdmluZy1hbmQtdGVzdGluZy1mb3ItY2xhc3Nlcy05L1xuICAgIGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgICAgcmV0dXJuIGVsLmNsYXNzTGlzdCA/IGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpIDogbmV3IFJlZ0V4cChcIlxcXFxiXCIgKyBjbGFzc05hbWUgKyBcIlxcXFxiXCIpLnRlc3QoZWwuY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9zY3JvbGxZI05vdGVzXG4gICAgZnVuY3Rpb24gZ2V0UGFnZU9mZnNldChkb2MpIHtcbiAgICAgICAgdmFyIHN1cHBvcnRQYWdlT2Zmc2V0ID0gd2luZG93LnBhZ2VYT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBpc0NTUzFDb21wYXQgPSAoZG9jLmNvbXBhdE1vZGUgfHwgXCJcIikgPT09IFwiQ1NTMUNvbXBhdFwiO1xuICAgICAgICB2YXIgeCA9IHN1cHBvcnRQYWdlT2Zmc2V0XG4gICAgICAgICAgICA/IHdpbmRvdy5wYWdlWE9mZnNldFxuICAgICAgICAgICAgOiBpc0NTUzFDb21wYXRcbiAgICAgICAgICAgICAgICA/IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdFxuICAgICAgICAgICAgICAgIDogZG9jLmJvZHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgdmFyIHkgPSBzdXBwb3J0UGFnZU9mZnNldFxuICAgICAgICAgICAgPyB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICAgICAgICAgIDogaXNDU1MxQ29tcGF0XG4gICAgICAgICAgICAgICAgPyBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgICAgIDogZG9jLmJvZHkuc2Nyb2xsVG9wO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gd2UgcHJvdmlkZSBhIGZ1bmN0aW9uIHRvIGNvbXB1dGUgY29uc3RhbnRzIGluc3RlYWRcbiAgICAvLyBvZiBhY2Nlc3Npbmcgd2luZG93LiogYXMgc29vbiBhcyB0aGUgbW9kdWxlIG5lZWRzIGl0XG4gICAgLy8gc28gdGhhdCB3ZSBkbyBub3QgY29tcHV0ZSBhbnl0aGluZyBpZiBub3QgbmVlZGVkXG4gICAgZnVuY3Rpb24gZ2V0QWN0aW9ucygpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBldmVudHMgdG8gYmluZC4gSUUxMSBpbXBsZW1lbnRzIHBvaW50ZXJFdmVudHMgd2l0aG91dFxuICAgICAgICAvLyBhIHByZWZpeCwgd2hpY2ggYnJlYWtzIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgSUUxMCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBcInBvaW50ZXJkb3duXCIsXG4gICAgICAgICAgICAgICAgbW92ZTogXCJwb2ludGVybW92ZVwiLFxuICAgICAgICAgICAgICAgIGVuZDogXCJwb2ludGVydXBcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFwiTVNQb2ludGVyRG93blwiLFxuICAgICAgICAgICAgICAgICAgICBtb3ZlOiBcIk1TUG9pbnRlck1vdmVcIixcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBcIk1TUG9pbnRlclVwXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBcIm1vdXNlZG93biB0b3VjaHN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIG1vdmU6IFwibW91c2Vtb3ZlIHRvdWNobW92ZVwiLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IFwibW91c2V1cCB0b3VjaGVuZFwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9leHBsYWluZXIubWRcbiAgICAvLyBJc3N1ZSAjNzg1XG4gICAgZnVuY3Rpb24gZ2V0U3VwcG9ydHNQYXNzaXZlKCkge1xuICAgICAgICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJwYXNzaXZlXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCBudWxsLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuQ1NTICYmIENTUy5zdXBwb3J0cyAmJiBDU1Muc3VwcG9ydHMoXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpO1xuICAgIH1cbiAgICAvL2VuZHJlZ2lvblxuICAgIC8vcmVnaW9uIFJhbmdlIENhbGN1bGF0aW9uXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIGEgc3ViLXJhbmdlIGluIHJlbGF0aW9uIHRvIGEgZnVsbCByYW5nZS5cbiAgICBmdW5jdGlvbiBzdWJSYW5nZVJhdGlvKHBhLCBwYikge1xuICAgICAgICByZXR1cm4gMTAwIC8gKHBiIC0gcGEpO1xuICAgIH1cbiAgICAvLyAocGVyY2VudGFnZSkgSG93IG1hbnkgcGVyY2VudCBpcyB0aGlzIHZhbHVlIG9mIHRoaXMgcmFuZ2U/XG4gICAgZnVuY3Rpb24gZnJvbVBlcmNlbnRhZ2UocmFuZ2UsIHZhbHVlLCBzdGFydFJhbmdlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgKiAxMDApIC8gKHJhbmdlW3N0YXJ0UmFuZ2UgKyAxXSAtIHJhbmdlW3N0YXJ0UmFuZ2VdKTtcbiAgICB9XG4gICAgLy8gKHBlcmNlbnRhZ2UpIFdoZXJlIGlzIHRoaXMgdmFsdWUgb24gdGhpcyByYW5nZT9cbiAgICBmdW5jdGlvbiB0b1BlcmNlbnRhZ2UocmFuZ2UsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmcm9tUGVyY2VudGFnZShyYW5nZSwgcmFuZ2VbMF0gPCAwID8gdmFsdWUgKyBNYXRoLmFicyhyYW5nZVswXSkgOiB2YWx1ZSAtIHJhbmdlWzBdLCAwKTtcbiAgICB9XG4gICAgLy8gKHZhbHVlKSBIb3cgbXVjaCBpcyB0aGlzIHBlcmNlbnRhZ2Ugb24gdGhpcyByYW5nZT9cbiAgICBmdW5jdGlvbiBpc1BlcmNlbnRhZ2UocmFuZ2UsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgKiAocmFuZ2VbMV0gLSByYW5nZVswXSkpIC8gMTAwICsgcmFuZ2VbMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEoodmFsdWUsIGFycikge1xuICAgICAgICB2YXIgaiA9IDE7XG4gICAgICAgIHdoaWxlICh2YWx1ZSA+PSBhcnJbal0pIHtcbiAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gajtcbiAgICB9XG4gICAgLy8gKHBlcmNlbnRhZ2UpIElucHV0IGEgdmFsdWUsIGZpbmQgd2hlcmUsIG9uIGEgc2NhbGUgb2YgMC0xMDAsIGl0IGFwcGxpZXMuXG4gICAgZnVuY3Rpb24gdG9TdGVwcGluZyh4VmFsLCB4UGN0LCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPj0geFZhbC5zbGljZSgtMSlbMF0pIHtcbiAgICAgICAgICAgIHJldHVybiAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB4VmFsKTtcbiAgICAgICAgdmFyIHZhID0geFZhbFtqIC0gMV07XG4gICAgICAgIHZhciB2YiA9IHhWYWxbal07XG4gICAgICAgIHZhciBwYSA9IHhQY3RbaiAtIDFdO1xuICAgICAgICB2YXIgcGIgPSB4UGN0W2pdO1xuICAgICAgICByZXR1cm4gcGEgKyB0b1BlcmNlbnRhZ2UoW3ZhLCB2Yl0sIHZhbHVlKSAvIHN1YlJhbmdlUmF0aW8ocGEsIHBiKTtcbiAgICB9XG4gICAgLy8gKHZhbHVlKSBJbnB1dCBhIHBlcmNlbnRhZ2UsIGZpbmQgd2hlcmUgaXQgaXMgb24gdGhlIHNwZWNpZmllZCByYW5nZS5cbiAgICBmdW5jdGlvbiBmcm9tU3RlcHBpbmcoeFZhbCwgeFBjdCwgdmFsdWUpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gcmFuZ2UgZ3JvdXAgdGhhdCBmaXRzIDEwMFxuICAgICAgICBpZiAodmFsdWUgPj0gMTAwKSB7XG4gICAgICAgICAgICByZXR1cm4geFZhbC5zbGljZSgtMSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB4UGN0KTtcbiAgICAgICAgdmFyIHZhID0geFZhbFtqIC0gMV07XG4gICAgICAgIHZhciB2YiA9IHhWYWxbal07XG4gICAgICAgIHZhciBwYSA9IHhQY3RbaiAtIDFdO1xuICAgICAgICB2YXIgcGIgPSB4UGN0W2pdO1xuICAgICAgICByZXR1cm4gaXNQZXJjZW50YWdlKFt2YSwgdmJdLCAodmFsdWUgLSBwYSkgKiBzdWJSYW5nZVJhdGlvKHBhLCBwYikpO1xuICAgIH1cbiAgICAvLyAocGVyY2VudGFnZSkgR2V0IHRoZSBzdGVwIHRoYXQgYXBwbGllcyBhdCBhIGNlcnRhaW4gdmFsdWUuXG4gICAgZnVuY3Rpb24gZ2V0U3RlcCh4UGN0LCB4U3RlcHMsIHNuYXAsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB4UGN0KTtcbiAgICAgICAgdmFyIGEgPSB4UGN0W2ogLSAxXTtcbiAgICAgICAgdmFyIGIgPSB4UGN0W2pdO1xuICAgICAgICAvLyBJZiAnc25hcCcgaXMgc2V0LCBzdGVwcyBhcmUgdXNlZCBhcyBmaXhlZCBwb2ludHMgb24gdGhlIHNsaWRlci5cbiAgICAgICAgaWYgKHNuYXApIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgcG9zaXRpb24sIGEgb3IgYi5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAtIGEgPiAoYiAtIGEpIC8gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF4U3RlcHNbaiAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhQY3RbaiAtIDFdICsgY2xvc2VzdCh2YWx1ZSAtIHhQY3RbaiAtIDFdLCB4U3RlcHNbaiAtIDFdKTtcbiAgICB9XG4gICAgLy9lbmRyZWdpb25cbiAgICAvL3JlZ2lvbiBTcGVjdHJ1bVxuICAgIHZhciBTcGVjdHJ1bSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3BlY3RydW0oZW50cnksIHNuYXAsIHNpbmdsZVN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMueFBjdCA9IFtdO1xuICAgICAgICAgICAgdGhpcy54VmFsID0gW107XG4gICAgICAgICAgICB0aGlzLnhTdGVwcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy54TnVtU3RlcHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXAgPSBbXTtcbiAgICAgICAgICAgIHRoaXMueFN0ZXBzID0gW3NpbmdsZVN0ZXAgfHwgZmFsc2VdO1xuICAgICAgICAgICAgdGhpcy54TnVtU3RlcHMgPSBbZmFsc2VdO1xuICAgICAgICAgICAgdGhpcy5zbmFwID0gc25hcDtcbiAgICAgICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgICAgIHZhciBvcmRlcmVkID0gW107XG4gICAgICAgICAgICAvLyBNYXAgdGhlIG9iamVjdCBrZXlzIHRvIGFuIGFycmF5LlxuICAgICAgICAgICAgT2JqZWN0LmtleXMoZW50cnkpLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgb3JkZXJlZC5wdXNoKFthc0FycmF5KGVudHJ5W2luZGV4XSksIGluZGV4XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFNvcnQgYWxsIGVudHJpZXMgYnkgdmFsdWUgKG51bWVyaWMgc29ydCkuXG4gICAgICAgICAgICBvcmRlcmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVswXVswXSAtIGJbMF1bMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgYWxsIGVudHJpZXMgdG8gc3VicmFuZ2VzLlxuICAgICAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgb3JkZXJlZC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVudHJ5UG9pbnQob3JkZXJlZFtpbmRleF1bMV0sIG9yZGVyZWRbaW5kZXhdWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBhY3R1YWwgc3RlcCB2YWx1ZXMuXG4gICAgICAgICAgICAvLyB4U3RlcHMgaXMgc29ydGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHhQY3QgYW5kIHhWYWwuXG4gICAgICAgICAgICB0aGlzLnhOdW1TdGVwcyA9IHRoaXMueFN0ZXBzLnNsaWNlKDApO1xuICAgICAgICAgICAgLy8gQ29udmVydCBhbGwgbnVtZXJpYyBzdGVwcyB0byB0aGUgcGVyY2VudGFnZSBvZiB0aGUgc3VicmFuZ2UgdGhleSByZXByZXNlbnQuXG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnhOdW1TdGVwcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN0ZXBQb2ludChpbmRleCwgdGhpcy54TnVtU3RlcHNbaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnhOdW1TdGVwcy5sZW5ndGggLSAxOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzW2luZGV4XSA9IGZyb21QZXJjZW50YWdlKHRoaXMueFZhbCwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZXM7XG4gICAgICAgIH07XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcGVyY2VudHVhbCBkaXN0YW5jZSBvdmVyIHRoZSB3aG9sZSBzY2FsZSBvZiByYW5nZXMuXG4gICAgICAgIC8vIGRpcmVjdGlvbjogMCA9IGJhY2t3YXJkcyAvIDEgPSBmb3J3YXJkc1xuICAgICAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0QWJzb2x1dGVEaXN0YW5jZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZGlzdGFuY2VzLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB4UGN0X2luZGV4ID0gMDtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSByYW5nZSB3aGVyZSB0byBzdGFydCBjYWxjdWxhdGlvblxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgdGhpcy54UGN0W3RoaXMueFBjdC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh2YWx1ZSA+IHRoaXMueFBjdFt4UGN0X2luZGV4ICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgeFBjdF9pbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSB0aGlzLnhQY3RbdGhpcy54UGN0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgeFBjdF9pbmRleCA9IHRoaXMueFBjdC5sZW5ndGggLSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgbG9va2luZyBiYWNrd2FyZHMgYW5kIHRoZSB2YWx1ZSBpcyBleGFjdGx5IGF0IGEgcmFuZ2Ugc2VwYXJhdG9yIHRoZW4gbG9vayBvbmUgcmFuZ2UgZnVydGhlclxuICAgICAgICAgICAgaWYgKCFkaXJlY3Rpb24gJiYgdmFsdWUgPT09IHRoaXMueFBjdFt4UGN0X2luZGV4ICsgMV0pIHtcbiAgICAgICAgICAgICAgICB4UGN0X2luZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2VzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhcnRfZmFjdG9yO1xuICAgICAgICAgICAgdmFyIHJlc3RfZmFjdG9yID0gMTtcbiAgICAgICAgICAgIHZhciByZXN0X3JlbF9kaXN0YW5jZSA9IGRpc3RhbmNlc1t4UGN0X2luZGV4XTtcbiAgICAgICAgICAgIHZhciByYW5nZV9wY3QgPSAwO1xuICAgICAgICAgICAgdmFyIHJlbF9yYW5nZV9kaXN0YW5jZSA9IDA7XG4gICAgICAgICAgICB2YXIgYWJzX2Rpc3RhbmNlX2NvdW50ZXIgPSAwO1xuICAgICAgICAgICAgdmFyIHJhbmdlX2NvdW50ZXIgPSAwO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHdoYXQgcGFydCBvZiB0aGUgc3RhcnQgcmFuZ2UgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRfZmFjdG9yID0gKHZhbHVlIC0gdGhpcy54UGN0W3hQY3RfaW5kZXhdKSAvICh0aGlzLnhQY3RbeFBjdF9pbmRleCArIDFdIC0gdGhpcy54UGN0W3hQY3RfaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0X2ZhY3RvciA9ICh0aGlzLnhQY3RbeFBjdF9pbmRleCArIDFdIC0gdmFsdWUpIC8gKHRoaXMueFBjdFt4UGN0X2luZGV4ICsgMV0gLSB0aGlzLnhQY3RbeFBjdF9pbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG8gdW50aWwgdGhlIGNvbXBsZXRlIGRpc3RhbmNlIGFjcm9zcyByYW5nZXMgaXMgY2FsY3VsYXRlZFxuICAgICAgICAgICAgd2hpbGUgKHJlc3RfcmVsX2Rpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcGVyY2VudGFnZSBvZiB0b3RhbCByYW5nZVxuICAgICAgICAgICAgICAgIHJhbmdlX3BjdCA9IHRoaXMueFBjdFt4UGN0X2luZGV4ICsgMSArIHJhbmdlX2NvdW50ZXJdIC0gdGhpcy54UGN0W3hQY3RfaW5kZXggKyByYW5nZV9jb3VudGVyXTtcbiAgICAgICAgICAgICAgICAvLyBEZXRlY3QgaWYgdGhlIG1hcmdpbiwgcGFkZGluZyBvciBsaW1pdCBpcyBsYXJnZXIgdGhlbiB0aGUgY3VycmVudCByYW5nZSBhbmQgY2FsY3VsYXRlXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlc1t4UGN0X2luZGV4ICsgcmFuZ2VfY291bnRlcl0gKiByZXN0X2ZhY3RvciArIDEwMCAtIHN0YXJ0X2ZhY3RvciAqIDEwMCA+IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBsYXJnZXIgdGhlbiB0YWtlIHRoZSBwZXJjZW50dWFsIGRpc3RhbmNlIG9mIHRoZSB3aG9sZSByYW5nZVxuICAgICAgICAgICAgICAgICAgICByZWxfcmFuZ2VfZGlzdGFuY2UgPSByYW5nZV9wY3QgKiBzdGFydF9mYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3QgZmFjdG9yIG9mIHJlbGF0aXZlIHBlcmNlbnR1YWwgZGlzdGFuY2Ugc3RpbGwgdG8gYmUgY2FsY3VsYXRlZFxuICAgICAgICAgICAgICAgICAgICByZXN0X2ZhY3RvciA9IChyZXN0X3JlbF9kaXN0YW5jZSAtIDEwMCAqIHN0YXJ0X2ZhY3RvcikgLyBkaXN0YW5jZXNbeFBjdF9pbmRleCArIHJhbmdlX2NvdW50ZXJdO1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgc3RhcnQgZmFjdG9yIHRvIDEgYXMgZm9yIG5leHQgcmFuZ2UgaXQgZG9lcyBub3QgYXBwbHkuXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X2ZhY3RvciA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzbWFsbGVyIG9yIGVxdWFsIHRoZW4gdGFrZSB0aGUgcGVyY2VudHVhbCBkaXN0YW5jZSBvZiB0aGUgY2FsY3VsYXRlIHBlcmNlbnR1YWwgcGFydCBvZiB0aGF0IHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIHJlbF9yYW5nZV9kaXN0YW5jZSA9ICgoZGlzdGFuY2VzW3hQY3RfaW5kZXggKyByYW5nZV9jb3VudGVyXSAqIHJhbmdlX3BjdCkgLyAxMDApICogcmVzdF9mYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHJlc3QgbGVmdCBhcyB0aGUgcmVzdCBmaXRzIGluIGN1cnJlbnQgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgcmVzdF9mYWN0b3IgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGFic19kaXN0YW5jZV9jb3VudGVyID0gYWJzX2Rpc3RhbmNlX2NvdW50ZXIgLSByZWxfcmFuZ2VfZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIExpbWl0IHJhbmdlIHRvIGZpcnN0IHJhbmdlIHdoZW4gZGlzdGFuY2UgYmVjb21lcyBvdXRzaWRlIG9mIG1pbmltdW0gcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMueFBjdC5sZW5ndGggKyByYW5nZV9jb3VudGVyID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlX2NvdW50ZXItLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWJzX2Rpc3RhbmNlX2NvdW50ZXIgPSBhYnNfZGlzdGFuY2VfY291bnRlciArIHJlbF9yYW5nZV9kaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGltaXQgcmFuZ2UgdG8gbGFzdCByYW5nZSB3aGVuIGRpc3RhbmNlIGJlY29tZXMgb3V0c2lkZSBvZiBtYXhpbXVtIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnhQY3QubGVuZ3RoIC0gcmFuZ2VfY291bnRlciA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZV9jb3VudGVyKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVzdCBvZiByZWxhdGl2ZSBwZXJjZW50dWFsIGRpc3RhbmNlIHN0aWxsIHRvIGJlIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgICAgICByZXN0X3JlbF9kaXN0YW5jZSA9IGRpc3RhbmNlc1t4UGN0X2luZGV4ICsgcmFuZ2VfY291bnRlcl0gKiByZXN0X2ZhY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSArIGFic19kaXN0YW5jZV9jb3VudGVyO1xuICAgICAgICB9O1xuICAgICAgICBTcGVjdHJ1bS5wcm90b3R5cGUudG9TdGVwcGluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0b1N0ZXBwaW5nKHRoaXMueFZhbCwgdGhpcy54UGN0LCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS5mcm9tU3RlcHBpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tU3RlcHBpbmcodGhpcy54VmFsLCB0aGlzLnhQY3QsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgU3BlY3RydW0ucHJvdG90eXBlLmdldFN0ZXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0U3RlcCh0aGlzLnhQY3QsIHRoaXMueFN0ZXBzLCB0aGlzLnNuYXAsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgU3BlY3RydW0ucHJvdG90eXBlLmdldERlZmF1bHRTdGVwID0gZnVuY3Rpb24gKHZhbHVlLCBpc0Rvd24sIHNpemUpIHtcbiAgICAgICAgICAgIHZhciBqID0gZ2V0Sih2YWx1ZSwgdGhpcy54UGN0KTtcbiAgICAgICAgICAgIC8vIFdoZW4gYXQgdGhlIHRvcCBvciBzdGVwcGluZyBkb3duLCBsb29rIGF0IHRoZSBwcmV2aW91cyBzdWItcmFuZ2VcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMTAwIHx8IChpc0Rvd24gJiYgdmFsdWUgPT09IHRoaXMueFBjdFtqIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgaiA9IE1hdGgubWF4KGogLSAxLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAodGhpcy54VmFsW2pdIC0gdGhpcy54VmFsW2ogLSAxXSkgLyBzaXplO1xuICAgICAgICB9O1xuICAgICAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0TmVhcmJ5U3RlcHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBqID0gZ2V0Sih2YWx1ZSwgdGhpcy54UGN0KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RlcEJlZm9yZToge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiB0aGlzLnhWYWxbaiAtIDJdLFxuICAgICAgICAgICAgICAgICAgICBzdGVwOiB0aGlzLnhOdW1TdGVwc1tqIC0gMl0sXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hlc3RTdGVwOiB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwW2ogLSAyXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpc1N0ZXA6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZTogdGhpcy54VmFsW2ogLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogdGhpcy54TnVtU3RlcHNbaiAtIDFdLFxuICAgICAgICAgICAgICAgICAgICBoaWdoZXN0U3RlcDogdGhpcy54SGlnaGVzdENvbXBsZXRlU3RlcFtqIC0gMV1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0ZXBBZnRlcjoge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiB0aGlzLnhWYWxbal0sXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IHRoaXMueE51bVN0ZXBzW2pdLFxuICAgICAgICAgICAgICAgICAgICBoaWdoZXN0U3RlcDogdGhpcy54SGlnaGVzdENvbXBsZXRlU3RlcFtqXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIFNwZWN0cnVtLnByb3RvdHlwZS5jb3VudFN0ZXBEZWNpbWFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGVwRGVjaW1hbHMgPSB0aGlzLnhOdW1TdGVwcy5tYXAoY291bnREZWNpbWFscyk7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgc3RlcERlY2ltYWxzKTtcbiAgICAgICAgfTtcbiAgICAgICAgU3BlY3RydW0ucHJvdG90eXBlLmhhc05vU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnhWYWxbMF0gPT09IHRoaXMueFZhbFt0aGlzLnhWYWwubGVuZ3RoIC0gMV07XG4gICAgICAgIH07XG4gICAgICAgIC8vIE91dHNpZGUgdGVzdGluZ1xuICAgICAgICBTcGVjdHJ1bS5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RlcCh0aGlzLnRvU3RlcHBpbmcodmFsdWUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgU3BlY3RydW0ucHJvdG90eXBlLmhhbmRsZUVudHJ5UG9pbnQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcGVyY2VudGFnZTtcbiAgICAgICAgICAgIC8vIENvdmVydCBtaW4vbWF4IHN5bnRheCB0byAwIGFuZCAxMDAuXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBwZXJjZW50YWdlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgcGVyY2VudGFnZSA9IDEwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlcmNlbnRhZ2UgPSBwYXJzZUZsb2F0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjb3JyZWN0IGlucHV0LlxuICAgICAgICAgICAgaWYgKCFpc051bWVyaWMocGVyY2VudGFnZSkgfHwgIWlzTnVtZXJpYyh2YWx1ZVswXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAncmFuZ2UnIHZhbHVlIGlzbid0IG51bWVyaWMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcmUgdmFsdWVzLlxuICAgICAgICAgICAgdGhpcy54UGN0LnB1c2gocGVyY2VudGFnZSk7XG4gICAgICAgICAgICB0aGlzLnhWYWwucHVzaCh2YWx1ZVswXSk7XG4gICAgICAgICAgICB2YXIgdmFsdWUxID0gTnVtYmVyKHZhbHVlWzFdKTtcbiAgICAgICAgICAgIC8vIE5hTiB3aWxsIGV2YWx1YXRlIHRvIGZhbHNlIHRvbywgYnV0IHRvIGtlZXBcbiAgICAgICAgICAgIC8vIGxvZ2dpbmcgY2xlYXIsIHNldCBzdGVwIGV4cGxpY2l0bHkuIE1ha2Ugc3VyZVxuICAgICAgICAgICAgLy8gbm90IHRvIG92ZXJyaWRlIHRoZSAnc3RlcCcgc2V0dGluZyB3aXRoIGZhbHNlLlxuICAgICAgICAgICAgaWYgKCFwZXJjZW50YWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTih2YWx1ZTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueFN0ZXBzWzBdID0gdmFsdWUxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMueFN0ZXBzLnB1c2goaXNOYU4odmFsdWUxKSA/IGZhbHNlIDogdmFsdWUxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXAucHVzaCgwKTtcbiAgICAgICAgfTtcbiAgICAgICAgU3BlY3RydW0ucHJvdG90eXBlLmhhbmRsZVN0ZXBQb2ludCA9IGZ1bmN0aW9uIChpLCBuKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgJ2ZhbHNlJyBzdGVwcGluZy5cbiAgICAgICAgICAgIGlmICghbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgb3ZlciB6ZXJvLWxlbmd0aCByYW5nZXMgKCM5NDgpO1xuICAgICAgICAgICAgaWYgKHRoaXMueFZhbFtpXSA9PT0gdGhpcy54VmFsW2kgKyAxXSkge1xuICAgICAgICAgICAgICAgIHRoaXMueFN0ZXBzW2ldID0gdGhpcy54SGlnaGVzdENvbXBsZXRlU3RlcFtpXSA9IHRoaXMueFZhbFtpXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGYWN0b3IgdG8gcmFuZ2UgcmF0aW9cbiAgICAgICAgICAgIHRoaXMueFN0ZXBzW2ldID1cbiAgICAgICAgICAgICAgICBmcm9tUGVyY2VudGFnZShbdGhpcy54VmFsW2ldLCB0aGlzLnhWYWxbaSArIDFdXSwgbiwgMCkgLyBzdWJSYW5nZVJhdGlvKHRoaXMueFBjdFtpXSwgdGhpcy54UGN0W2kgKyAxXSk7XG4gICAgICAgICAgICB2YXIgdG90YWxTdGVwcyA9ICh0aGlzLnhWYWxbaSArIDFdIC0gdGhpcy54VmFsW2ldKSAvIHRoaXMueE51bVN0ZXBzW2ldO1xuICAgICAgICAgICAgdmFyIGhpZ2hlc3RTdGVwID0gTWF0aC5jZWlsKE51bWJlcih0b3RhbFN0ZXBzLnRvRml4ZWQoMykpIC0gMSk7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IHRoaXMueFZhbFtpXSArIHRoaXMueE51bVN0ZXBzW2ldICogaGlnaGVzdFN0ZXA7XG4gICAgICAgICAgICB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwW2ldID0gc3RlcDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNwZWN0cnVtO1xuICAgIH0oKSk7XG4gICAgLy9lbmRyZWdpb25cbiAgICAvL3JlZ2lvbiBPcHRpb25zXG4gICAgLypcdEV2ZXJ5IGlucHV0IG9wdGlvbiBpcyB0ZXN0ZWQgYW5kIHBhcnNlZC4gVGhpcyB3aWxsIHByZXZlbnRcbiAgICAgICAgZW5kbGVzcyB2YWxpZGF0aW9uIGluIGludGVybmFsIG1ldGhvZHMuIFRoZXNlIHRlc3RzIGFyZVxuICAgICAgICBzdHJ1Y3R1cmVkIHdpdGggYW4gaXRlbSBmb3IgZXZlcnkgb3B0aW9uIGF2YWlsYWJsZS4gQW5cbiAgICAgICAgb3B0aW9uIGNhbiBiZSBtYXJrZWQgYXMgcmVxdWlyZWQgYnkgc2V0dGluZyB0aGUgJ3InIGZsYWcuXG4gICAgICAgIFRoZSB0ZXN0aW5nIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAgICAgICAgLSBUaGUgcHJvdmlkZWQgdmFsdWUgZm9yIHRoZSBvcHRpb247XG4gICAgICAgICAgICAtIEEgcmVmZXJlbmNlIHRvIHRoZSBvcHRpb25zIG9iamVjdDtcbiAgICAgICAgICAgIC0gVGhlIG5hbWUgZm9yIHRoZSBvcHRpb247XG5cbiAgICAgICAgVGhlIHRlc3RpbmcgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSB3aGVuIGFuIGVycm9yIGlzIGRldGVjdGVkLFxuICAgICAgICBvciB0cnVlIHdoZW4gZXZlcnl0aGluZyBpcyBPSy4gSXQgY2FuIGFsc28gbW9kaWZ5IHRoZSBvcHRpb25cbiAgICAgICAgb2JqZWN0LCB0byBtYWtlIHN1cmUgYWxsIHZhbHVlcyBjYW4gYmUgY29ycmVjdGx5IGxvb3BlZCBlbHNld2hlcmUuICovXG4gICAgLy9yZWdpb24gRGVmYXVsdHNcbiAgICB2YXIgZGVmYXVsdEZvcm1hdHRlciA9IHtcbiAgICAgICAgdG86IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBcIlwiIDogdmFsdWUudG9GaXhlZCgyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbTogTnVtYmVyXG4gICAgfTtcbiAgICB2YXIgY3NzQ2xhc3NlcyA9IHtcbiAgICAgICAgdGFyZ2V0OiBcInRhcmdldFwiLFxuICAgICAgICBiYXNlOiBcImJhc2VcIixcbiAgICAgICAgb3JpZ2luOiBcIm9yaWdpblwiLFxuICAgICAgICBoYW5kbGU6IFwiaGFuZGxlXCIsXG4gICAgICAgIGhhbmRsZUxvd2VyOiBcImhhbmRsZS1sb3dlclwiLFxuICAgICAgICBoYW5kbGVVcHBlcjogXCJoYW5kbGUtdXBwZXJcIixcbiAgICAgICAgdG91Y2hBcmVhOiBcInRvdWNoLWFyZWFcIixcbiAgICAgICAgaG9yaXpvbnRhbDogXCJob3Jpem9udGFsXCIsXG4gICAgICAgIHZlcnRpY2FsOiBcInZlcnRpY2FsXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiYmFja2dyb3VuZFwiLFxuICAgICAgICBjb25uZWN0OiBcImNvbm5lY3RcIixcbiAgICAgICAgY29ubmVjdHM6IFwiY29ubmVjdHNcIixcbiAgICAgICAgbHRyOiBcImx0clwiLFxuICAgICAgICBydGw6IFwicnRsXCIsXG4gICAgICAgIHRleHREaXJlY3Rpb25MdHI6IFwidHh0LWRpci1sdHJcIixcbiAgICAgICAgdGV4dERpcmVjdGlvblJ0bDogXCJ0eHQtZGlyLXJ0bFwiLFxuICAgICAgICBkcmFnZ2FibGU6IFwiZHJhZ2dhYmxlXCIsXG4gICAgICAgIGRyYWc6IFwic3RhdGUtZHJhZ1wiLFxuICAgICAgICB0YXA6IFwic3RhdGUtdGFwXCIsXG4gICAgICAgIGFjdGl2ZTogXCJhY3RpdmVcIixcbiAgICAgICAgdG9vbHRpcDogXCJ0b29sdGlwXCIsXG4gICAgICAgIHBpcHM6IFwicGlwc1wiLFxuICAgICAgICBwaXBzSG9yaXpvbnRhbDogXCJwaXBzLWhvcml6b250YWxcIixcbiAgICAgICAgcGlwc1ZlcnRpY2FsOiBcInBpcHMtdmVydGljYWxcIixcbiAgICAgICAgbWFya2VyOiBcIm1hcmtlclwiLFxuICAgICAgICBtYXJrZXJIb3Jpem9udGFsOiBcIm1hcmtlci1ob3Jpem9udGFsXCIsXG4gICAgICAgIG1hcmtlclZlcnRpY2FsOiBcIm1hcmtlci12ZXJ0aWNhbFwiLFxuICAgICAgICBtYXJrZXJOb3JtYWw6IFwibWFya2VyLW5vcm1hbFwiLFxuICAgICAgICBtYXJrZXJMYXJnZTogXCJtYXJrZXItbGFyZ2VcIixcbiAgICAgICAgbWFya2VyU3ViOiBcIm1hcmtlci1zdWJcIixcbiAgICAgICAgdmFsdWU6IFwidmFsdWVcIixcbiAgICAgICAgdmFsdWVIb3Jpem9udGFsOiBcInZhbHVlLWhvcml6b250YWxcIixcbiAgICAgICAgdmFsdWVWZXJ0aWNhbDogXCJ2YWx1ZS12ZXJ0aWNhbFwiLFxuICAgICAgICB2YWx1ZU5vcm1hbDogXCJ2YWx1ZS1ub3JtYWxcIixcbiAgICAgICAgdmFsdWVMYXJnZTogXCJ2YWx1ZS1sYXJnZVwiLFxuICAgICAgICB2YWx1ZVN1YjogXCJ2YWx1ZS1zdWJcIlxuICAgIH07XG4gICAgLy8gTmFtZXNwYWNlcyBvZiBpbnRlcm5hbCBldmVudCBsaXN0ZW5lcnNcbiAgICB2YXIgSU5URVJOQUxfRVZFTlRfTlMgPSB7XG4gICAgICAgIHRvb2x0aXBzOiBcIi5fX3Rvb2x0aXBzXCIsXG4gICAgICAgIGFyaWE6IFwiLl9fYXJpYVwiXG4gICAgfTtcbiAgICAvL2VuZHJlZ2lvblxuICAgIGZ1bmN0aW9uIHRlc3RTdGVwKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnc3RlcCcgaXMgbm90IG51bWVyaWMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBzdGVwIG9wdGlvbiBjYW4gc3RpbGwgYmUgdXNlZCB0byBzZXQgc3RlcHBpbmdcbiAgICAgICAgLy8gZm9yIGxpbmVhciBzbGlkZXJzLiBPdmVyd3JpdHRlbiBpZiBzZXQgaW4gJ3JhbmdlJy5cbiAgICAgICAgcGFyc2VkLnNpbmdsZVN0ZXAgPSBlbnRyeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdEtleWJvYXJkUGFnZU11bHRpcGxpZXIocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzTnVtZXJpYyhlbnRyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdrZXlib2FyZFBhZ2VNdWx0aXBsaWVyJyBpcyBub3QgbnVtZXJpYy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLmtleWJvYXJkUGFnZU11bHRpcGxpZXIgPSBlbnRyeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdEtleWJvYXJkTXVsdGlwbGllcihwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2tleWJvYXJkTXVsdGlwbGllcicgaXMgbm90IG51bWVyaWMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5rZXlib2FyZE11bHRpcGxpZXIgPSBlbnRyeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdEtleWJvYXJkRGVmYXVsdFN0ZXAocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzTnVtZXJpYyhlbnRyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdrZXlib2FyZERlZmF1bHRTdGVwJyBpcyBub3QgbnVtZXJpYy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLmtleWJvYXJkRGVmYXVsdFN0ZXAgPSBlbnRyeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFJhbmdlKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgLy8gRmlsdGVyIGluY29ycmVjdCBpbnB1dC5cbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3JhbmdlJyBpcyBub3QgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYXRjaCBtaXNzaW5nIHN0YXJ0IG9yIGVuZC5cbiAgICAgICAgaWYgKGVudHJ5Lm1pbiA9PT0gdW5kZWZpbmVkIHx8IGVudHJ5Lm1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiBNaXNzaW5nICdtaW4nIG9yICdtYXgnIGluICdyYW5nZScuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5zcGVjdHJ1bSA9IG5ldyBTcGVjdHJ1bShlbnRyeSwgcGFyc2VkLnNuYXAgfHwgZmFsc2UsIHBhcnNlZC5zaW5nbGVTdGVwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0YXJ0KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgZW50cnkgPSBhc0FycmF5KGVudHJ5KTtcbiAgICAgICAgLy8gVmFsaWRhdGUgaW5wdXQuIFZhbHVlcyBhcmVuJ3QgdGVzdGVkLCBhcyB0aGUgcHVibGljIC52YWwgbWV0aG9kXG4gICAgICAgIC8vIHdpbGwgYWx3YXlzIHByb3ZpZGUgYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGVudHJ5KSB8fCAhZW50cnkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnc3RhcnQnIG9wdGlvbiBpcyBpbmNvcnJlY3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlIHRoZSBudW1iZXIgb2YgaGFuZGxlcy5cbiAgICAgICAgcGFyc2VkLmhhbmRsZXMgPSBlbnRyeS5sZW5ndGg7XG4gICAgICAgIC8vIFdoZW4gdGhlIHNsaWRlciBpcyBpbml0aWFsaXplZCwgdGhlIC52YWwgbWV0aG9kIHdpbGxcbiAgICAgICAgLy8gYmUgY2FsbGVkIHdpdGggdGhlIHN0YXJ0IG9wdGlvbnMuXG4gICAgICAgIHBhcnNlZC5zdGFydCA9IGVudHJ5O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U25hcChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnc25hcCcgb3B0aW9uIG11c3QgYmUgYSBib29sZWFuLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbmZvcmNlIDEwMCUgc3RlcHBpbmcgd2l0aGluIHN1YnJhbmdlcy5cbiAgICAgICAgcGFyc2VkLnNuYXAgPSBlbnRyeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdEFuaW1hdGUocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2FuaW1hdGUnIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5mb3JjZSAxMDAlIHN0ZXBwaW5nIHdpdGhpbiBzdWJyYW5nZXMuXG4gICAgICAgIHBhcnNlZC5hbmltYXRlID0gZW50cnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RBbmltYXRpb25EdXJhdGlvbihwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdhbmltYXRpb25EdXJhdGlvbicgb3B0aW9uIG11c3QgYmUgYSBudW1iZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5hbmltYXRpb25EdXJhdGlvbiA9IGVudHJ5O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0Q29ubmVjdChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIHZhciBjb25uZWN0ID0gW2ZhbHNlXTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIC8vIE1hcCBsZWdhY3kgb3B0aW9uc1xuICAgICAgICBpZiAoZW50cnkgPT09IFwibG93ZXJcIikge1xuICAgICAgICAgICAgZW50cnkgPSBbdHJ1ZSwgZmFsc2VdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVudHJ5ID09PSBcInVwcGVyXCIpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gW2ZhbHNlLCB0cnVlXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYm9vbGVhbiBvcHRpb25zXG4gICAgICAgIGlmIChlbnRyeSA9PT0gdHJ1ZSB8fCBlbnRyeSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBwYXJzZWQuaGFuZGxlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdC5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3QucHVzaChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVqZWN0IGludmFsaWQgaW5wdXRcbiAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZW50cnkpIHx8ICFlbnRyeS5sZW5ndGggfHwgZW50cnkubGVuZ3RoICE9PSBwYXJzZWQuaGFuZGxlcyArIDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdjb25uZWN0JyBvcHRpb24gZG9lc24ndCBtYXRjaCBoYW5kbGUgY291bnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29ubmVjdCA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5jb25uZWN0ID0gY29ubmVjdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdE9yaWVudGF0aW9uKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgLy8gU2V0IG9yaWVudGF0aW9uIHRvIGFuIGEgbnVtZXJpY2FsIHZhbHVlIGZvciBlYXN5XG4gICAgICAgIC8vIGFycmF5IHNlbGVjdGlvbi5cbiAgICAgICAgc3dpdGNoIChlbnRyeSkge1xuICAgICAgICAgICAgY2FzZSBcImhvcml6b250YWxcIjpcbiAgICAgICAgICAgICAgICBwYXJzZWQub3J0ID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgICAgICAgICAgIHBhcnNlZC5vcnQgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnb3JpZW50YXRpb24nIG9wdGlvbiBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0TWFyZ2luKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnbWFyZ2luJyBvcHRpb24gbXVzdCBiZSBudW1lcmljLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJc3N1ZSAjNTgyXG4gICAgICAgIGlmIChlbnRyeSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5tYXJnaW4gPSBwYXJzZWQuc3BlY3RydW0uZ2V0RGlzdGFuY2UoZW50cnkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0TGltaXQocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzTnVtZXJpYyhlbnRyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdsaW1pdCcgb3B0aW9uIG11c3QgYmUgbnVtZXJpYy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLmxpbWl0ID0gcGFyc2VkLnNwZWN0cnVtLmdldERpc3RhbmNlKGVudHJ5KTtcbiAgICAgICAgaWYgKCFwYXJzZWQubGltaXQgfHwgcGFyc2VkLmhhbmRsZXMgPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnbGltaXQnIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBsaW5lYXIgc2xpZGVycyB3aXRoIDIgb3IgbW9yZSBoYW5kbGVzLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0UGFkZGluZyhwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpICYmICFBcnJheS5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IGJlIG51bWVyaWMgb3IgYXJyYXkgb2YgZXhhY3RseSAyIG51bWJlcnMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVudHJ5KSAmJiAhKGVudHJ5Lmxlbmd0aCA9PT0gMiB8fCBpc051bWVyaWMoZW50cnlbMF0pIHx8IGlzTnVtZXJpYyhlbnRyeVsxXSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAncGFkZGluZycgb3B0aW9uIG11c3QgYmUgbnVtZXJpYyBvciBhcnJheSBvZiBleGFjdGx5IDIgbnVtYmVycy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudHJ5ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICAgICAgZW50cnkgPSBbZW50cnksIGVudHJ5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyAnZ2V0RGlzdGFuY2UnIHJldHVybnMgZmFsc2UgZm9yIGludmFsaWQgdmFsdWVzLlxuICAgICAgICBwYXJzZWQucGFkZGluZyA9IFtwYXJzZWQuc3BlY3RydW0uZ2V0RGlzdGFuY2UoZW50cnlbMF0pLCBwYXJzZWQuc3BlY3RydW0uZ2V0RGlzdGFuY2UoZW50cnlbMV0pXTtcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcGFyc2VkLnNwZWN0cnVtLnhOdW1TdGVwcy5sZW5ndGggLSAxOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBsYXN0IFwicmFuZ2VcIiBjYW4ndCBjb250YWluIHN0ZXAgc2l6ZSBhcyBpdCBpcyBwdXJlbHkgYW4gZW5kcG9pbnQuXG4gICAgICAgICAgICBpZiAocGFyc2VkLnBhZGRpbmdbMF1baW5kZXhdIDwgMCB8fCBwYXJzZWQucGFkZGluZ1sxXVtpbmRleF0gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyKHMpLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdG90YWxQYWRkaW5nID0gZW50cnlbMF0gKyBlbnRyeVsxXTtcbiAgICAgICAgdmFyIGZpcnN0VmFsdWUgPSBwYXJzZWQuc3BlY3RydW0ueFZhbFswXTtcbiAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IHBhcnNlZC5zcGVjdHJ1bS54VmFsW3BhcnNlZC5zcGVjdHJ1bS54VmFsLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodG90YWxQYWRkaW5nIC8gKGxhc3RWYWx1ZSAtIGZpcnN0VmFsdWUpID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IG5vdCBleGNlZWQgMTAwJSBvZiB0aGUgcmFuZ2UuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3REaXJlY3Rpb24ocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICAvLyBTZXQgZGlyZWN0aW9uIGFzIGEgbnVtZXJpY2FsIHZhbHVlIGZvciBlYXN5IHBhcnNpbmcuXG4gICAgICAgIC8vIEludmVydCBjb25uZWN0aW9uIGZvciBSVEwgc2xpZGVycywgc28gdGhhdCB0aGUgcHJvcGVyXG4gICAgICAgIC8vIGhhbmRsZXMgZ2V0IHRoZSBjb25uZWN0L2JhY2tncm91bmQgY2xhc3Nlcy5cbiAgICAgICAgc3dpdGNoIChlbnRyeSkge1xuICAgICAgICAgICAgY2FzZSBcImx0clwiOlxuICAgICAgICAgICAgICAgIHBhcnNlZC5kaXIgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJ0bFwiOlxuICAgICAgICAgICAgICAgIHBhcnNlZC5kaXIgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnZGlyZWN0aW9uJyBvcHRpb24gd2FzIG5vdCByZWNvZ25pemVkLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0QmVoYXZpb3VyKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBpbnB1dCBpcyBhIHN0cmluZy5cbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2JlaGF2aW91cicgbXVzdCBiZSBhIHN0cmluZyBjb250YWluaW5nIG9wdGlvbnMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzdHJpbmcgY29udGFpbnMgYW55IGtleXdvcmRzLlxuICAgICAgICAvLyBOb25lIGFyZSByZXF1aXJlZC5cbiAgICAgICAgdmFyIHRhcCA9IGVudHJ5LmluZGV4T2YoXCJ0YXBcIikgPj0gMDtcbiAgICAgICAgdmFyIGRyYWcgPSBlbnRyeS5pbmRleE9mKFwiZHJhZ1wiKSA+PSAwO1xuICAgICAgICB2YXIgZml4ZWQgPSBlbnRyeS5pbmRleE9mKFwiZml4ZWRcIikgPj0gMDtcbiAgICAgICAgdmFyIHNuYXAgPSBlbnRyeS5pbmRleE9mKFwic25hcFwiKSA+PSAwO1xuICAgICAgICB2YXIgaG92ZXIgPSBlbnRyeS5pbmRleE9mKFwiaG92ZXJcIikgPj0gMDtcbiAgICAgICAgdmFyIHVuY29uc3RyYWluZWQgPSBlbnRyeS5pbmRleE9mKFwidW5jb25zdHJhaW5lZFwiKSA+PSAwO1xuICAgICAgICB2YXIgZHJhZ0FsbCA9IGVudHJ5LmluZGV4T2YoXCJkcmFnLWFsbFwiKSA+PSAwO1xuICAgICAgICBpZiAoZml4ZWQpIHtcbiAgICAgICAgICAgIGlmIChwYXJzZWQuaGFuZGxlcyAhPT0gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdmaXhlZCcgYmVoYXZpb3VyIG11c3QgYmUgdXNlZCB3aXRoIDIgaGFuZGxlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVzZSBtYXJnaW4gdG8gZW5mb3JjZSBmaXhlZCBzdGF0ZVxuICAgICAgICAgICAgdGVzdE1hcmdpbihwYXJzZWQsIHBhcnNlZC5zdGFydFsxXSAtIHBhcnNlZC5zdGFydFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuY29uc3RyYWluZWQgJiYgKHBhcnNlZC5tYXJnaW4gfHwgcGFyc2VkLmxpbWl0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3VuY29uc3RyYWluZWQnIGJlaGF2aW91ciBjYW5ub3QgYmUgdXNlZCB3aXRoIG1hcmdpbiBvciBsaW1pdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQuZXZlbnRzID0ge1xuICAgICAgICAgICAgdGFwOiB0YXAgfHwgc25hcCxcbiAgICAgICAgICAgIGRyYWc6IGRyYWcsXG4gICAgICAgICAgICBkcmFnQWxsOiBkcmFnQWxsLFxuICAgICAgICAgICAgZml4ZWQ6IGZpeGVkLFxuICAgICAgICAgICAgc25hcDogc25hcCxcbiAgICAgICAgICAgIGhvdmVyOiBob3ZlcixcbiAgICAgICAgICAgIHVuY29uc3RyYWluZWQ6IHVuY29uc3RyYWluZWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFRvb2x0aXBzKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnRyeSA9PT0gdHJ1ZSB8fCBpc1ZhbGlkUGFydGlhbEZvcm1hdHRlcihlbnRyeSkpIHtcbiAgICAgICAgICAgIHBhcnNlZC50b29sdGlwcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJzZWQuaGFuZGxlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnRvb2x0aXBzLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW50cnkgPSBhc0FycmF5KGVudHJ5KTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5sZW5ndGggIT09IHBhcnNlZC5oYW5kbGVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogbXVzdCBwYXNzIGEgZm9ybWF0dGVyIGZvciBhbGwgaGFuZGxlcy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRyeS5mb3JFYWNoKGZ1bmN0aW9uIChmb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciAhPT0gXCJib29sZWFuXCIgJiYgIWlzVmFsaWRQYXJ0aWFsRm9ybWF0dGVyKGZvcm1hdHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3Rvb2x0aXBzJyBtdXN0IGJlIHBhc3NlZCBhIGZvcm1hdHRlciBvciAnZmFsc2UnLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcnNlZC50b29sdGlwcyA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RIYW5kbGVBdHRyaWJ1dGVzKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5Lmxlbmd0aCAhPT0gcGFyc2VkLmhhbmRsZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6IG11c3QgcGFzcyBhIGF0dHJpYnV0ZXMgZm9yIGFsbCBoYW5kbGVzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQuaGFuZGxlQXR0cmlidXRlcyA9IGVudHJ5O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0QXJpYUZvcm1hdChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICghaXNWYWxpZFBhcnRpYWxGb3JtYXR0ZXIoZW50cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnYXJpYUZvcm1hdCcgcmVxdWlyZXMgJ3RvJyBtZXRob2QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5hcmlhRm9ybWF0ID0gZW50cnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RGb3JtYXQocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzVmFsaWRGb3JtYXR0ZXIoZW50cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnZm9ybWF0JyByZXF1aXJlcyAndG8nIGFuZCAnZnJvbScgbWV0aG9kcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLmZvcm1hdCA9IGVudHJ5O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0S2V5Ym9hcmRTdXBwb3J0KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdrZXlib2FyZFN1cHBvcnQnIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLmtleWJvYXJkU3VwcG9ydCA9IGVudHJ5O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0RG9jdW1lbnRFbGVtZW50KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBhZHZhbmNlZCBvcHRpb24uIFBhc3NlZCB2YWx1ZXMgYXJlIHVzZWQgd2l0aG91dCB2YWxpZGF0aW9uLlxuICAgICAgICBwYXJzZWQuZG9jdW1lbnRFbGVtZW50ID0gZW50cnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RDc3NQcmVmaXgocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcInN0cmluZ1wiICYmIGVudHJ5ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2Nzc1ByZWZpeCcgbXVzdCBiZSBhIHN0cmluZyBvciBgZmFsc2VgLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQuY3NzUHJlZml4ID0gZW50cnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RDc3NDbGFzc2VzKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2Nzc0NsYXNzZXMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcnNlZC5jc3NQcmVmaXggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHBhcnNlZC5jc3NDbGFzc2VzID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLmNzc0NsYXNzZXNba2V5XSA9IHBhcnNlZC5jc3NQcmVmaXggKyBlbnRyeVtrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJzZWQuY3NzQ2xhc3NlcyA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRlc3QgYWxsIGRldmVsb3BlciBzZXR0aW5ncyBhbmQgcGFyc2UgdG8gYXNzdW1wdGlvbi1zYWZlIHZhbHVlcy5cbiAgICBmdW5jdGlvbiB0ZXN0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIC8vIFRvIHByb3ZlIGEgZml4IGZvciAjNTM3LCBmcmVlemUgb3B0aW9ucyBoZXJlLlxuICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGlzIG1vZGlmaWVkLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICAgICAgLy8gT2JqZWN0LmZyZWV6ZShvcHRpb25zKTtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHtcbiAgICAgICAgICAgIG1hcmdpbjogbnVsbCxcbiAgICAgICAgICAgIGxpbWl0OiBudWxsLFxuICAgICAgICAgICAgcGFkZGluZzogbnVsbCxcbiAgICAgICAgICAgIGFuaW1hdGU6IHRydWUsXG4gICAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogMzAwLFxuICAgICAgICAgICAgYXJpYUZvcm1hdDogZGVmYXVsdEZvcm1hdHRlcixcbiAgICAgICAgICAgIGZvcm1hdDogZGVmYXVsdEZvcm1hdHRlclxuICAgICAgICB9O1xuICAgICAgICAvLyBUZXN0cyBhcmUgZXhlY3V0ZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIHByZXNlbnRlZCBoZXJlLlxuICAgICAgICB2YXIgdGVzdHMgPSB7XG4gICAgICAgICAgICBzdGVwOiB7IHI6IGZhbHNlLCB0OiB0ZXN0U3RlcCB9LFxuICAgICAgICAgICAga2V5Ym9hcmRQYWdlTXVsdGlwbGllcjogeyByOiBmYWxzZSwgdDogdGVzdEtleWJvYXJkUGFnZU11bHRpcGxpZXIgfSxcbiAgICAgICAgICAgIGtleWJvYXJkTXVsdGlwbGllcjogeyByOiBmYWxzZSwgdDogdGVzdEtleWJvYXJkTXVsdGlwbGllciB9LFxuICAgICAgICAgICAga2V5Ym9hcmREZWZhdWx0U3RlcDogeyByOiBmYWxzZSwgdDogdGVzdEtleWJvYXJkRGVmYXVsdFN0ZXAgfSxcbiAgICAgICAgICAgIHN0YXJ0OiB7IHI6IHRydWUsIHQ6IHRlc3RTdGFydCB9LFxuICAgICAgICAgICAgY29ubmVjdDogeyByOiB0cnVlLCB0OiB0ZXN0Q29ubmVjdCB9LFxuICAgICAgICAgICAgZGlyZWN0aW9uOiB7IHI6IHRydWUsIHQ6IHRlc3REaXJlY3Rpb24gfSxcbiAgICAgICAgICAgIHNuYXA6IHsgcjogZmFsc2UsIHQ6IHRlc3RTbmFwIH0sXG4gICAgICAgICAgICBhbmltYXRlOiB7IHI6IGZhbHNlLCB0OiB0ZXN0QW5pbWF0ZSB9LFxuICAgICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IHsgcjogZmFsc2UsIHQ6IHRlc3RBbmltYXRpb25EdXJhdGlvbiB9LFxuICAgICAgICAgICAgcmFuZ2U6IHsgcjogdHJ1ZSwgdDogdGVzdFJhbmdlIH0sXG4gICAgICAgICAgICBvcmllbnRhdGlvbjogeyByOiBmYWxzZSwgdDogdGVzdE9yaWVudGF0aW9uIH0sXG4gICAgICAgICAgICBtYXJnaW46IHsgcjogZmFsc2UsIHQ6IHRlc3RNYXJnaW4gfSxcbiAgICAgICAgICAgIGxpbWl0OiB7IHI6IGZhbHNlLCB0OiB0ZXN0TGltaXQgfSxcbiAgICAgICAgICAgIHBhZGRpbmc6IHsgcjogZmFsc2UsIHQ6IHRlc3RQYWRkaW5nIH0sXG4gICAgICAgICAgICBiZWhhdmlvdXI6IHsgcjogdHJ1ZSwgdDogdGVzdEJlaGF2aW91ciB9LFxuICAgICAgICAgICAgYXJpYUZvcm1hdDogeyByOiBmYWxzZSwgdDogdGVzdEFyaWFGb3JtYXQgfSxcbiAgICAgICAgICAgIGZvcm1hdDogeyByOiBmYWxzZSwgdDogdGVzdEZvcm1hdCB9LFxuICAgICAgICAgICAgdG9vbHRpcHM6IHsgcjogZmFsc2UsIHQ6IHRlc3RUb29sdGlwcyB9LFxuICAgICAgICAgICAga2V5Ym9hcmRTdXBwb3J0OiB7IHI6IHRydWUsIHQ6IHRlc3RLZXlib2FyZFN1cHBvcnQgfSxcbiAgICAgICAgICAgIGRvY3VtZW50RWxlbWVudDogeyByOiBmYWxzZSwgdDogdGVzdERvY3VtZW50RWxlbWVudCB9LFxuICAgICAgICAgICAgY3NzUHJlZml4OiB7IHI6IHRydWUsIHQ6IHRlc3RDc3NQcmVmaXggfSxcbiAgICAgICAgICAgIGNzc0NsYXNzZXM6IHsgcjogdHJ1ZSwgdDogdGVzdENzc0NsYXNzZXMgfSxcbiAgICAgICAgICAgIGhhbmRsZUF0dHJpYnV0ZXM6IHsgcjogZmFsc2UsIHQ6IHRlc3RIYW5kbGVBdHRyaWJ1dGVzIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgY29ubmVjdDogZmFsc2UsXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwibHRyXCIsXG4gICAgICAgICAgICBiZWhhdmlvdXI6IFwidGFwXCIsXG4gICAgICAgICAgICBvcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXG4gICAgICAgICAgICBrZXlib2FyZFN1cHBvcnQ6IHRydWUsXG4gICAgICAgICAgICBjc3NQcmVmaXg6IFwibm9VaS1cIixcbiAgICAgICAgICAgIGNzc0NsYXNzZXM6IGNzc0NsYXNzZXMsXG4gICAgICAgICAgICBrZXlib2FyZFBhZ2VNdWx0aXBsaWVyOiA1LFxuICAgICAgICAgICAga2V5Ym9hcmRNdWx0aXBsaWVyOiAxLFxuICAgICAgICAgICAga2V5Ym9hcmREZWZhdWx0U3RlcDogMTBcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXJpYUZvcm1hdCBkZWZhdWx0cyB0byByZWd1bGFyIGZvcm1hdCwgaWYgYW55LlxuICAgICAgICBpZiAob3B0aW9ucy5mb3JtYXQgJiYgIW9wdGlvbnMuYXJpYUZvcm1hdCkge1xuICAgICAgICAgICAgb3B0aW9ucy5hcmlhRm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUnVuIGFsbCBvcHRpb25zIHRocm91Z2ggYSB0ZXN0aW5nIG1lY2hhbmlzbSB0byBlbnN1cmUgY29ycmVjdFxuICAgICAgICAvLyBpbnB1dC4gSXQgc2hvdWxkIGJlIG5vdGVkIHRoYXQgb3B0aW9ucyBtaWdodCBnZXQgbW9kaWZpZWQgdG9cbiAgICAgICAgLy8gYmUgaGFuZGxlZCBwcm9wZXJseS4gRS5nLiB3cmFwcGluZyBpbnRlZ2VycyBpbiBhcnJheXMuXG4gICAgICAgIE9iamVjdC5rZXlzKHRlc3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgb3B0aW9uIGlzbid0IHNldCwgYnV0IGl0IGlzIHJlcXVpcmVkLCB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmICghaXNTZXQob3B0aW9uc1tuYW1lXSkgJiYgZGVmYXVsdHNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0c1tuYW1lXS5yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdcIiArIG5hbWUgKyBcIicgaXMgcmVxdWlyZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXN0c1tuYW1lXS50KHBhcnNlZCwgIWlzU2V0KG9wdGlvbnNbbmFtZV0pID8gZGVmYXVsdHNbbmFtZV0gOiBvcHRpb25zW25hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEZvcndhcmQgcGlwcyBvcHRpb25zXG4gICAgICAgIHBhcnNlZC5waXBzID0gb3B0aW9ucy5waXBzO1xuICAgICAgICAvLyBBbGwgcmVjZW50IGJyb3dzZXJzIGFjY2VwdCB1bnByZWZpeGVkIHRyYW5zZm9ybS5cbiAgICAgICAgLy8gV2UgbmVlZCAtbXMtIGZvciBJRTkgYW5kIC13ZWJraXQtIGZvciBvbGRlciBBbmRyb2lkO1xuICAgICAgICAvLyBBc3N1bWUgdXNlIG9mIC13ZWJraXQtIGlmIHVucHJlZml4ZWQgYW5kIC1tcy0gYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI2ZlYXQ9dHJhbnNmb3JtczJkXG4gICAgICAgIHZhciBkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIG1zUHJlZml4ID0gZC5zdHlsZS5tc1RyYW5zZm9ybSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgbm9QcmVmaXggPSBkLnN0eWxlLnRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJzZWQudHJhbnNmb3JtUnVsZSA9IG5vUHJlZml4ID8gXCJ0cmFuc2Zvcm1cIiA6IG1zUHJlZml4ID8gXCJtc1RyYW5zZm9ybVwiIDogXCJ3ZWJraXRUcmFuc2Zvcm1cIjtcbiAgICAgICAgLy8gUGlwcyBkb24ndCBtb3ZlLCBzbyB3ZSBjYW4gcGxhY2UgdGhlbSB1c2luZyBsZWZ0L3RvcC5cbiAgICAgICAgdmFyIHN0eWxlcyA9IFtcbiAgICAgICAgICAgIFtcImxlZnRcIiwgXCJ0b3BcIl0sXG4gICAgICAgICAgICBbXCJyaWdodFwiLCBcImJvdHRvbVwiXVxuICAgICAgICBdO1xuICAgICAgICBwYXJzZWQuc3R5bGUgPSBzdHlsZXNbcGFyc2VkLmRpcl1bcGFyc2VkLm9ydF07XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIC8vZW5kcmVnaW9uXG4gICAgZnVuY3Rpb24gc2NvcGUodGFyZ2V0LCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBnZXRBY3Rpb25zKCk7XG4gICAgICAgIHZhciBzdXBwb3J0c1RvdWNoQWN0aW9uTm9uZSA9IGdldFN1cHBvcnRzVG91Y2hBY3Rpb25Ob25lKCk7XG4gICAgICAgIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBzdXBwb3J0c1RvdWNoQWN0aW9uTm9uZSAmJiBnZXRTdXBwb3J0c1Bhc3NpdmUoKTtcbiAgICAgICAgLy8gQWxsIHZhcmlhYmxlcyBsb2NhbCB0byAnc2NvcGUnIGFyZSBwcmVmaXhlZCB3aXRoICdzY29wZV8nXG4gICAgICAgIC8vIFNsaWRlciBET00gTm9kZXNcbiAgICAgICAgdmFyIHNjb3BlX1RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdmFyIHNjb3BlX0Jhc2U7XG4gICAgICAgIHZhciBzY29wZV9IYW5kbGVzO1xuICAgICAgICB2YXIgc2NvcGVfQ29ubmVjdHM7XG4gICAgICAgIHZhciBzY29wZV9QaXBzO1xuICAgICAgICB2YXIgc2NvcGVfVG9vbHRpcHM7XG4gICAgICAgIC8vIFNsaWRlciBzdGF0ZSB2YWx1ZXNcbiAgICAgICAgdmFyIHNjb3BlX1NwZWN0cnVtID0gb3B0aW9ucy5zcGVjdHJ1bTtcbiAgICAgICAgdmFyIHNjb3BlX1ZhbHVlcyA9IFtdO1xuICAgICAgICB2YXIgc2NvcGVfTG9jYXRpb25zID0gW107XG4gICAgICAgIHZhciBzY29wZV9IYW5kbGVOdW1iZXJzID0gW107XG4gICAgICAgIHZhciBzY29wZV9BY3RpdmVIYW5kbGVzQ291bnQgPSAwO1xuICAgICAgICB2YXIgc2NvcGVfRXZlbnRzID0ge307XG4gICAgICAgIC8vIERvY3VtZW50IE5vZGVzXG4gICAgICAgIHZhciBzY29wZV9Eb2N1bWVudCA9IHRhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgICB2YXIgc2NvcGVfRG9jdW1lbnRFbGVtZW50ID0gb3B0aW9ucy5kb2N1bWVudEVsZW1lbnQgfHwgc2NvcGVfRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB2YXIgc2NvcGVfQm9keSA9IHNjb3BlX0RvY3VtZW50LmJvZHk7XG4gICAgICAgIC8vIEZvciBob3Jpem9udGFsIHNsaWRlcnMgaW4gc3RhbmRhcmQgbHRyIGRvY3VtZW50cyxcbiAgICAgICAgLy8gbWFrZSAubm9VaS1vcmlnaW4gb3ZlcmZsb3cgdG8gdGhlIGxlZnQgc28gdGhlIGRvY3VtZW50IGRvZXNuJ3Qgc2Nyb2xsLlxuICAgICAgICB2YXIgc2NvcGVfRGlyT2Zmc2V0ID0gc2NvcGVfRG9jdW1lbnQuZGlyID09PSBcInJ0bFwiIHx8IG9wdGlvbnMub3J0ID09PSAxID8gMCA6IDEwMDtcbiAgICAgICAgLy8gQ3JlYXRlcyBhIG5vZGUsIGFkZHMgaXQgdG8gdGFyZ2V0LCByZXR1cm5zIHRoZSBuZXcgbm9kZS5cbiAgICAgICAgZnVuY3Rpb24gYWRkTm9kZVRvKGFkZFRhcmdldCwgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICB2YXIgZGl2ID0gc2NvcGVfRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhkaXYsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRUYXJnZXQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgICAgIHJldHVybiBkaXY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwZW5kIGEgb3JpZ2luIHRvIHRoZSBiYXNlXG4gICAgICAgIGZ1bmN0aW9uIGFkZE9yaWdpbihiYXNlLCBoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBvcmlnaW4gPSBhZGROb2RlVG8oYmFzZSwgb3B0aW9ucy5jc3NDbGFzc2VzLm9yaWdpbik7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkTm9kZVRvKG9yaWdpbiwgb3B0aW9ucy5jc3NDbGFzc2VzLmhhbmRsZSk7XG4gICAgICAgICAgICBhZGROb2RlVG8oaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMudG91Y2hBcmVhKTtcbiAgICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWhhbmRsZVwiLCBTdHJpbmcoaGFuZGxlTnVtYmVyKSk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5rZXlib2FyZFN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0dsb2JhbF9hdHRyaWJ1dGVzL3RhYmluZGV4XG4gICAgICAgICAgICAgICAgLy8gMCA9IGZvY3VzYWJsZSBhbmQgcmVhY2hhYmxlXG4gICAgICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcbiAgICAgICAgICAgICAgICBoYW5kbGUuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudEtleWRvd24oZXZlbnQsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYW5kbGVBdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlc18xID0gb3B0aW9ucy5oYW5kbGVBdHRyaWJ1dGVzW2hhbmRsZU51bWJlcl07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGF0dHJpYnV0ZXNfMVthdHRyaWJ1dGVdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwic2xpZGVyXCIpO1xuICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcImFyaWEtb3JpZW50YXRpb25cIiwgb3B0aW9ucy5vcnQgPyBcInZlcnRpY2FsXCIgOiBcImhvcml6b250YWxcIik7XG4gICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlTG93ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFuZGxlTnVtYmVyID09PSBvcHRpb25zLmhhbmRsZXMgLSAxKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlVXBwZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnNlcnQgbm9kZXMgZm9yIGNvbm5lY3QgZWxlbWVudHNcbiAgICAgICAgZnVuY3Rpb24gYWRkQ29ubmVjdChiYXNlLCBhZGQpIHtcbiAgICAgICAgICAgIGlmICghYWRkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVUbyhiYXNlLCBvcHRpb25zLmNzc0NsYXNzZXMuY29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGhhbmRsZXMgdG8gdGhlIHNsaWRlciBiYXNlLlxuICAgICAgICBmdW5jdGlvbiBhZGRFbGVtZW50cyhjb25uZWN0T3B0aW9ucywgYmFzZSkge1xuICAgICAgICAgICAgdmFyIGNvbm5lY3RCYXNlID0gYWRkTm9kZVRvKGJhc2UsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5jb25uZWN0cyk7XG4gICAgICAgICAgICBzY29wZV9IYW5kbGVzID0gW107XG4gICAgICAgICAgICBzY29wZV9Db25uZWN0cyA9IFtdO1xuICAgICAgICAgICAgc2NvcGVfQ29ubmVjdHMucHVzaChhZGRDb25uZWN0KGNvbm5lY3RCYXNlLCBjb25uZWN0T3B0aW9uc1swXSkpO1xuICAgICAgICAgICAgLy8gWzo6OjpPPT09PU89PT09Tz09PT1dXG4gICAgICAgICAgICAvLyBjb25uZWN0T3B0aW9ucyA9IFswLCAxLCAxLCAxXVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmhhbmRsZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgYSBsaXN0IG9mIGFsbCBhZGRlZCBoYW5kbGVzLlxuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZXMucHVzaChhZGRPcmlnaW4oYmFzZSwgaSkpO1xuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnNbaV0gPSBpO1xuICAgICAgICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzLnB1c2goYWRkQ29ubmVjdChjb25uZWN0QmFzZSwgY29ubmVjdE9wdGlvbnNbaSArIDFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhIHNpbmdsZSBzbGlkZXIuXG4gICAgICAgIGZ1bmN0aW9uIGFkZFNsaWRlcihhZGRUYXJnZXQpIHtcbiAgICAgICAgICAgIC8vIEFwcGx5IGNsYXNzZXMgYW5kIGRhdGEgdG8gdGhlIHRhcmdldC5cbiAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRhcmdldCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kaXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5sdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMucnRsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9ydCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLmhvcml6b250YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudmVydGljYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRleHREaXJlY3Rpb24gPSBnZXRDb21wdXRlZFN0eWxlKGFkZFRhcmdldCkuZGlyZWN0aW9uO1xuICAgICAgICAgICAgaWYgKHRleHREaXJlY3Rpb24gPT09IFwicnRsXCIpIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50ZXh0RGlyZWN0aW9uUnRsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRleHREaXJlY3Rpb25MdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVUbyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5iYXNlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRUb29sdGlwKGhhbmRsZSwgaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMudG9vbHRpcHMgfHwgIW9wdGlvbnMudG9vbHRpcHNbaGFuZGxlTnVtYmVyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGROb2RlVG8oaGFuZGxlLmZpcnN0Q2hpbGQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50b29sdGlwKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc1NsaWRlckRpc2FibGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1RhcmdldC5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEaXNhYmxlIHRoZSBzbGlkZXIgZHJhZ2dpbmcgaWYgYW55IGhhbmRsZSBpcyBkaXNhYmxlZFxuICAgICAgICBmdW5jdGlvbiBpc0hhbmRsZURpc2FibGVkKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgdmFyIGhhbmRsZU9yaWdpbiA9IHNjb3BlX0hhbmRsZXNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVPcmlnaW4uaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlVG9vbHRpcHMoKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGVfVG9vbHRpcHMpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVFdmVudChcInVwZGF0ZVwiICsgSU5URVJOQUxfRVZFTlRfTlMudG9vbHRpcHMpO1xuICAgICAgICAgICAgICAgIHNjb3BlX1Rvb2x0aXBzLmZvckVhY2goZnVuY3Rpb24gKHRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQodG9vbHRpcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzY29wZV9Ub29sdGlwcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHRvb2x0aXBzIG9wdGlvbiBpcyBhIHNob3J0aGFuZCBmb3IgdXNpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuICAgICAgICBmdW5jdGlvbiB0b29sdGlwcygpIHtcbiAgICAgICAgICAgIHJlbW92ZVRvb2x0aXBzKCk7XG4gICAgICAgICAgICAvLyBUb29sdGlwcyBhcmUgYWRkZWQgd2l0aCBvcHRpb25zLnRvb2x0aXBzIGluIG9yaWdpbmFsIG9yZGVyLlxuICAgICAgICAgICAgc2NvcGVfVG9vbHRpcHMgPSBzY29wZV9IYW5kbGVzLm1hcChhZGRUb29sdGlwKTtcbiAgICAgICAgICAgIGJpbmRFdmVudChcInVwZGF0ZVwiICsgSU5URVJOQUxfRVZFTlRfTlMudG9vbHRpcHMsIGZ1bmN0aW9uICh2YWx1ZXMsIGhhbmRsZU51bWJlciwgdW5lbmNvZGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZV9Ub29sdGlwcyB8fCAhb3B0aW9ucy50b29sdGlwcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzY29wZV9Ub29sdGlwc1toYW5kbGVOdW1iZXJdID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IHZhbHVlc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXBzW2hhbmRsZU51bWJlcl0gIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUgPSBvcHRpb25zLnRvb2x0aXBzW2hhbmRsZU51bWJlcl0udG8odW5lbmNvZGVkW2hhbmRsZU51bWJlcl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzY29wZV9Ub29sdGlwc1toYW5kbGVOdW1iZXJdLmlubmVySFRNTCA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXJpYSgpIHtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50KFwidXBkYXRlXCIgKyBJTlRFUk5BTF9FVkVOVF9OUy5hcmlhKTtcbiAgICAgICAgICAgIGJpbmRFdmVudChcInVwZGF0ZVwiICsgSU5URVJOQUxfRVZFTlRfTlMuYXJpYSwgZnVuY3Rpb24gKHZhbHVlcywgaGFuZGxlTnVtYmVyLCB1bmVuY29kZWQsIHRhcCwgcG9zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIEFyaWEgVmFsdWVzIGZvciBhbGwgaGFuZGxlcywgYXMgYSBjaGFuZ2UgaW4gb25lIGNoYW5nZXMgbWluIGFuZCBtYXggdmFsdWVzIGZvciB0aGUgbmV4dC5cbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBzY29wZV9IYW5kbGVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbiA9IGNoZWNrSGFuZGxlUG9zaXRpb24oc2NvcGVfTG9jYXRpb25zLCBpbmRleCwgMCwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSBjaGVja0hhbmRsZVBvc2l0aW9uKHNjb3BlX0xvY2F0aW9ucywgaW5kZXgsIDEwMCwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3cgPSBwb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXR0ZWQgdmFsdWUgZm9yIGRpc3BsYXlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBTdHJpbmcob3B0aW9ucy5hcmlhRm9ybWF0LnRvKHVuZW5jb2RlZFtpbmRleF0pKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFwIHRvIHNsaWRlciByYW5nZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgbWluID0gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKG1pbikudG9GaXhlZCgxKTtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKG1heCkudG9GaXhlZCgxKTtcbiAgICAgICAgICAgICAgICAgICAgbm93ID0gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKG5vdykudG9GaXhlZCgxKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmNoaWxkcmVuWzBdLnNldEF0dHJpYnV0ZShcImFyaWEtdmFsdWVtaW5cIiwgbWluKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmNoaWxkcmVuWzBdLnNldEF0dHJpYnV0ZShcImFyaWEtdmFsdWVtYXhcIiwgbWF4KTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmNoaWxkcmVuWzBdLnNldEF0dHJpYnV0ZShcImFyaWEtdmFsdWVub3dcIiwgbm93KTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmNoaWxkcmVuWzBdLnNldEF0dHJpYnV0ZShcImFyaWEtdmFsdWV0ZXh0XCIsIHRleHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0R3JvdXAocGlwcykge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSByYW5nZS5cbiAgICAgICAgICAgIGlmIChwaXBzLm1vZGUgPT09IGV4cG9ydHMuUGlwc01vZGUuUmFuZ2UgfHwgcGlwcy5tb2RlID09PSBleHBvcnRzLlBpcHNNb2RlLlN0ZXBzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1NwZWN0cnVtLnhWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGlwcy5tb2RlID09PSBleHBvcnRzLlBpcHNNb2RlLkNvdW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBpcHMudmFsdWVzIDwgMikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAndmFsdWVzJyAoPj0gMikgcmVxdWlyZWQgZm9yIG1vZGUgJ2NvdW50Jy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERpdmlkZSAwIC0gMTAwIGluICdjb3VudCcgcGFydHMuXG4gICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gcGlwcy52YWx1ZXMgLSAxO1xuICAgICAgICAgICAgICAgIHZhciBzcHJlYWQgPSAxMDAgLyBpbnRlcnZhbDtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgLy8gTGlzdCB0aGVzZSBwYXJ0cyBhbmQgaGF2ZSB0aGVtIGhhbmRsZWQgYXMgJ3Bvc2l0aW9ucycuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGludGVydmFsLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2ludGVydmFsXSA9IGludGVydmFsICogc3ByZWFkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCgxMDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXBUb1JhbmdlKHZhbHVlcywgcGlwcy5zdGVwcGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwaXBzLm1vZGUgPT09IGV4cG9ydHMuUGlwc01vZGUuUG9zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gTWFwIGFsbCBwZXJjZW50YWdlcyB0byBvbi1yYW5nZSB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcFRvUmFuZ2UocGlwcy52YWx1ZXMsIHBpcHMuc3RlcHBlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGlwcy5tb2RlID09PSBleHBvcnRzLlBpcHNNb2RlLlZhbHVlcykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBtdXN0IGJlIHN0ZXBwZWQsIGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhIHBlcmNlbnRhZ2UgZmlyc3QuXG4gICAgICAgICAgICAgICAgaWYgKHBpcHMuc3RlcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGlwcy52YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBwZXJjZW50YWdlLCBhcHBseSBzdGVwLCByZXR1cm4gdG8gdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAoc2NvcGVfU3BlY3RydW0udG9TdGVwcGluZyh2YWx1ZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgY2FuIHNpbXBseSB1c2UgdGhlIHZhbHVlcy5cbiAgICAgICAgICAgICAgICByZXR1cm4gcGlwcy52YWx1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107IC8vIHBpcHMubW9kZSA9IG5ldmVyXG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFwVG9SYW5nZSh2YWx1ZXMsIHN0ZXBwZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcoc3RlcHBlZCA/IHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAodmFsdWUpIDogdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVTcHJlYWQocGlwcykge1xuICAgICAgICAgICAgZnVuY3Rpb24gc2FmZUluY3JlbWVudCh2YWx1ZSwgaW5jcmVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgZmxvYXRpbmcgcG9pbnQgdmFyaWFuY2UgYnkgZHJvcHBpbmcgdGhlIHNtYWxsZXN0IGRlY2ltYWwgcGxhY2VzLlxuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIoKHZhbHVlICsgaW5jcmVtZW50KS50b0ZpeGVkKDcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBncm91cCA9IGdldEdyb3VwKHBpcHMpO1xuICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSB7fTtcbiAgICAgICAgICAgIHZhciBmaXJzdEluUmFuZ2UgPSBzY29wZV9TcGVjdHJ1bS54VmFsWzBdO1xuICAgICAgICAgICAgdmFyIGxhc3RJblJhbmdlID0gc2NvcGVfU3BlY3RydW0ueFZhbFtzY29wZV9TcGVjdHJ1bS54VmFsLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdmFyIGlnbm9yZUZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaWdub3JlTGFzdCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHByZXZQY3QgPSAwO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgZ3JvdXAsIHNvcnQgaXQgYW5kIGZpbHRlciBhd2F5IGFsbCBkdXBsaWNhdGVzLlxuICAgICAgICAgICAgZ3JvdXAgPSB1bmlxdWUoZ3JvdXAuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSByYW5nZSBzdGFydHMgd2l0aCB0aGUgZmlyc3QgZWxlbWVudC5cbiAgICAgICAgICAgIGlmIChncm91cFswXSAhPT0gZmlyc3RJblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAudW5zaGlmdChmaXJzdEluUmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlnbm9yZUZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExpa2V3aXNlIGZvciB0aGUgbGFzdCBvbmUuXG4gICAgICAgICAgICBpZiAoZ3JvdXBbZ3JvdXAubGVuZ3RoIC0gMV0gIT09IGxhc3RJblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAucHVzaChsYXN0SW5SYW5nZSk7XG4gICAgICAgICAgICAgICAgaWdub3JlTGFzdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncm91cC5mb3JFYWNoKGZ1bmN0aW9uIChjdXJyZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBzdGVwIGFuZCB0aGUgbG93ZXIgKyB1cHBlciBwb3NpdGlvbnMuXG4gICAgICAgICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgdmFyIHE7XG4gICAgICAgICAgICAgICAgdmFyIGxvdyA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGhpZ2ggPSBncm91cFtpbmRleCArIDFdO1xuICAgICAgICAgICAgICAgIHZhciBuZXdQY3Q7XG4gICAgICAgICAgICAgICAgdmFyIHBjdERpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgdmFyIHBjdFBvcztcbiAgICAgICAgICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RlcHM7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWxTdGVwcztcbiAgICAgICAgICAgICAgICB2YXIgc3RlcFNpemU7XG4gICAgICAgICAgICAgICAgdmFyIGlzU3RlcHMgPSBwaXBzLm1vZGUgPT09IGV4cG9ydHMuUGlwc01vZGUuU3RlcHM7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB1c2luZyAnc3RlcHMnIG1vZGUsIHVzZSB0aGUgcHJvdmlkZWQgc3RlcHMuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSdsbCBzdGVwIG9uIHRvIHRoZSBuZXh0IHN1YnJhbmdlLlxuICAgICAgICAgICAgICAgIGlmIChpc1N0ZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXAgPSBzY29wZV9TcGVjdHJ1bS54TnVtU3RlcHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGEgJ2Z1bGwnIHN0ZXAuXG4gICAgICAgICAgICAgICAgaWYgKCFzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXAgPSBoaWdoIC0gbG93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBoaWdoIGlzIHVuZGVmaW5lZCB3ZSBhcmUgYXQgdGhlIGxhc3Qgc3VicmFuZ2UuIE1ha2Ugc3VyZSBpdCBpdGVyYXRlcyBvbmNlICgjMTA4OClcbiAgICAgICAgICAgICAgICBpZiAoaGlnaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2ggPSBsb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdGVwIGlzbid0IDAsIHdoaWNoIHdvdWxkIGNhdXNlIGFuIGluZmluaXRlIGxvb3AgKCM2NTQpXG4gICAgICAgICAgICAgICAgc3RlcCA9IE1hdGgubWF4KHN0ZXAsIDAuMDAwMDAwMSk7XG4gICAgICAgICAgICAgICAgLy8gRmluZCBhbGwgc3RlcHMgaW4gdGhlIHN1YnJhbmdlLlxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGxvdzsgaSA8PSBoaWdoOyBpID0gc2FmZUluY3JlbWVudChpLCBzdGVwKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHBlcmNlbnRhZ2UgdmFsdWUgZm9yIHRoZSBjdXJyZW50IHN0ZXAsXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgc2l6ZSBmb3IgdGhlIHN1YnJhbmdlLlxuICAgICAgICAgICAgICAgICAgICBuZXdQY3QgPSBzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKGkpO1xuICAgICAgICAgICAgICAgICAgICBwY3REaWZmZXJlbmNlID0gbmV3UGN0IC0gcHJldlBjdDtcbiAgICAgICAgICAgICAgICAgICAgc3RlcHMgPSBwY3REaWZmZXJlbmNlIC8gKHBpcHMuZGVuc2l0eSB8fCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhbFN0ZXBzID0gTWF0aC5yb3VuZChzdGVwcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcmF0aW8gcmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIHBlcmNlbnRhZ2Utc3BhY2UgYSBwb2ludCBpbmRpY2F0ZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBhIGRlbnNpdHkgMSB0aGUgcG9pbnRzL3BlcmNlbnRhZ2UgPSAxLiBGb3IgZGVuc2l0eSAyLCB0aGF0IHBlcmNlbnRhZ2UgbmVlZHMgdG8gYmUgcmUtZGl2aWRlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gUm91bmQgdGhlIHBlcmNlbnRhZ2Ugb2Zmc2V0IHRvIGFuIGV2ZW4gbnVtYmVyLCB0aGVuIGRpdmlkZSBieSB0d29cbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gc3ByZWFkIHRoZSBvZmZzZXQgb24gYm90aCBzaWRlcyBvZiB0aGUgcmFuZ2UuXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBTaXplID0gcGN0RGlmZmVyZW5jZSAvIHJlYWxTdGVwcztcbiAgICAgICAgICAgICAgICAgICAgLy8gRGl2aWRlIGFsbCBwb2ludHMgZXZlbmx5LCBhZGRpbmcgdGhlIGNvcnJlY3QgbnVtYmVyIHRvIHRoaXMgc3VicmFuZ2UuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1biB1cCB0byA8PSBzbyB0aGF0IDEwMCUgZ2V0cyBhIHBvaW50LCBldmVudCBpZiBpZ25vcmVMYXN0IGlzIHNldC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChxID0gMTsgcSA8PSByZWFsU3RlcHM7IHEgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJhdGlvIGJldHdlZW4gdGhlIHJvdW5kZWQgdmFsdWUgYW5kIHRoZSBhY3R1YWwgc2l6ZSBtaWdodCBiZSB+MSUgb2ZmLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29ycmVjdCB0aGUgcGVyY2VudGFnZSBvZmZzZXQgYnkgdGhlIG51bWJlciBvZiBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBlciBzdWJyYW5nZS4gZGVuc2l0eSA9IDEgd2lsbCByZXN1bHQgaW4gMTAwIHBvaW50cyBvbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ1bGwgcmFuZ2UsIDIgZm9yIDUwLCA0IGZvciAyNSwgZXRjLlxuICAgICAgICAgICAgICAgICAgICAgICAgcGN0UG9zID0gcHJldlBjdCArIHEgKiBzdGVwU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXNbcGN0UG9zLnRvRml4ZWQoNSldID0gW3Njb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyhwY3RQb3MpLCAwXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHBvaW50IHR5cGUuXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBncm91cC5pbmRleE9mKGkpID4gLTEgPyBleHBvcnRzLlBpcHNUeXBlLkxhcmdlVmFsdWUgOiBpc1N0ZXBzID8gZXhwb3J0cy5QaXBzVHlwZS5TbWFsbFZhbHVlIDogZXhwb3J0cy5QaXBzVHlwZS5Ob1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBFbmZvcmNlIHRoZSAnaWdub3JlRmlyc3QnIG9wdGlvbiBieSBvdmVyd3JpdGluZyB0aGUgdHlwZSBmb3IgMC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbmRleCAmJiBpZ25vcmVGaXJzdCAmJiBpICE9PSBoaWdoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShpID09PSBoaWdoICYmIGlnbm9yZUxhc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXJrIHRoZSAndHlwZScgb2YgdGhpcyBwb2ludC4gMCA9IHBsYWluLCAxID0gcmVhbCB2YWx1ZSwgMiA9IHN0ZXAgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleGVzW25ld1BjdC50b0ZpeGVkKDUpXSA9IFtpLCB0eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBlcmNlbnRhZ2UgY291bnQuXG4gICAgICAgICAgICAgICAgICAgIHByZXZQY3QgPSBuZXdQY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlcztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRNYXJraW5nKHNwcmVhZCwgZmlsdGVyRnVuYywgZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzY29wZV9Eb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdmFyIHZhbHVlU2l6ZUNsYXNzZXMgPSAoX2EgPSB7fSxcbiAgICAgICAgICAgICAgICBfYVtleHBvcnRzLlBpcHNUeXBlLk5vbmVdID0gXCJcIixcbiAgICAgICAgICAgICAgICBfYVtleHBvcnRzLlBpcHNUeXBlLk5vVmFsdWVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlTm9ybWFsLFxuICAgICAgICAgICAgICAgIF9hW2V4cG9ydHMuUGlwc1R5cGUuTGFyZ2VWYWx1ZV0gPSBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVMYXJnZSxcbiAgICAgICAgICAgICAgICBfYVtleHBvcnRzLlBpcHNUeXBlLlNtYWxsVmFsdWVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlU3ViLFxuICAgICAgICAgICAgICAgIF9hKTtcbiAgICAgICAgICAgIHZhciBtYXJrZXJTaXplQ2xhc3NlcyA9IChfYiA9IHt9LFxuICAgICAgICAgICAgICAgIF9iW2V4cG9ydHMuUGlwc1R5cGUuTm9uZV0gPSBcIlwiLFxuICAgICAgICAgICAgICAgIF9iW2V4cG9ydHMuUGlwc1R5cGUuTm9WYWx1ZV0gPSBvcHRpb25zLmNzc0NsYXNzZXMubWFya2VyTm9ybWFsLFxuICAgICAgICAgICAgICAgIF9iW2V4cG9ydHMuUGlwc1R5cGUuTGFyZ2VWYWx1ZV0gPSBvcHRpb25zLmNzc0NsYXNzZXMubWFya2VyTGFyZ2UsXG4gICAgICAgICAgICAgICAgX2JbZXhwb3J0cy5QaXBzVHlwZS5TbWFsbFZhbHVlXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJTdWIsXG4gICAgICAgICAgICAgICAgX2IpO1xuICAgICAgICAgICAgdmFyIHZhbHVlT3JpZW50YXRpb25DbGFzc2VzID0gW29wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZUhvcml6b250YWwsIG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZVZlcnRpY2FsXTtcbiAgICAgICAgICAgIHZhciBtYXJrZXJPcmllbnRhdGlvbkNsYXNzZXMgPSBbb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlckhvcml6b250YWwsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJWZXJ0aWNhbF07XG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBvcHRpb25zLmNzc0NsYXNzZXMucGlwcyk7XG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBvcHRpb25zLm9ydCA9PT0gMCA/IG9wdGlvbnMuY3NzQ2xhc3Nlcy5waXBzSG9yaXpvbnRhbCA6IG9wdGlvbnMuY3NzQ2xhc3Nlcy5waXBzVmVydGljYWwpO1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q2xhc3Nlcyh0eXBlLCBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHNvdXJjZSA9PT0gb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBvcmllbnRhdGlvbkNsYXNzZXMgPSBhID8gdmFsdWVPcmllbnRhdGlvbkNsYXNzZXMgOiBtYXJrZXJPcmllbnRhdGlvbkNsYXNzZXM7XG4gICAgICAgICAgICAgICAgdmFyIHNpemVDbGFzc2VzID0gYSA/IHZhbHVlU2l6ZUNsYXNzZXMgOiBtYXJrZXJTaXplQ2xhc3NlcztcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlICsgXCIgXCIgKyBvcmllbnRhdGlvbkNsYXNzZXNbb3B0aW9ucy5vcnRdICsgXCIgXCIgKyBzaXplQ2xhc3Nlc1t0eXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFNwcmVhZChvZmZzZXQsIHZhbHVlLCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGZpbHRlciBmdW5jdGlvbiwgaWYgaXQgaXMgc2V0LlxuICAgICAgICAgICAgICAgIHR5cGUgPSBmaWx0ZXJGdW5jID8gZmlsdGVyRnVuYyh2YWx1ZSwgdHlwZSkgOiB0eXBlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBleHBvcnRzLlBpcHNUeXBlLk5vbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBtYXJrZXIgZm9yIGV2ZXJ5IHBvaW50XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBhZGROb2RlVG8oZWxlbWVudCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NOYW1lID0gZ2V0Q2xhc3Nlcyh0eXBlLCBvcHRpb25zLmNzc0NsYXNzZXMubWFya2VyKTtcbiAgICAgICAgICAgICAgICBub2RlLnN0eWxlW29wdGlvbnMuc3R5bGVdID0gb2Zmc2V0ICsgXCIlXCI7XG4gICAgICAgICAgICAgICAgLy8gVmFsdWVzIGFyZSBvbmx5IGFwcGVuZGVkIGZvciBwb2ludHMgbWFya2VkICcxJyBvciAnMicuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPiBleHBvcnRzLlBpcHNUeXBlLk5vVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGFkZE5vZGVUbyhlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NOYW1lID0gZ2V0Q2xhc3Nlcyh0eXBlLCBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIiwgU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGVbb3B0aW9ucy5zdHlsZV0gPSBvZmZzZXQgKyBcIiVcIjtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBTdHJpbmcoZm9ybWF0dGVyLnRvKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXBwZW5kIGFsbCBwb2ludHMuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzcHJlYWQpLmZvckVhY2goZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGFkZFNwcmVhZChvZmZzZXQsIHNwcmVhZFtvZmZzZXRdWzBdLCBzcHJlYWRbb2Zmc2V0XVsxXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZVBpcHMoKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGVfUGlwcykge1xuICAgICAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQoc2NvcGVfUGlwcyk7XG4gICAgICAgICAgICAgICAgc2NvcGVfUGlwcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGlwcyhwaXBzKSB7XG4gICAgICAgICAgICAvLyBGaXggIzY2OVxuICAgICAgICAgICAgcmVtb3ZlUGlwcygpO1xuICAgICAgICAgICAgdmFyIHNwcmVhZCA9IGdlbmVyYXRlU3ByZWFkKHBpcHMpO1xuICAgICAgICAgICAgdmFyIGZpbHRlciA9IHBpcHMuZmlsdGVyO1xuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IHBpcHMuZm9ybWF0IHx8IHtcbiAgICAgICAgICAgICAgICB0bzogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcoTWF0aC5yb3VuZCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzY29wZV9QaXBzID0gc2NvcGVfVGFyZ2V0LmFwcGVuZENoaWxkKGFkZE1hcmtpbmcoc3ByZWFkLCBmaWx0ZXIsIGZvcm1hdCkpO1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1BpcHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hvcnRoYW5kIGZvciBiYXNlIGRpbWVuc2lvbnMuXG4gICAgICAgIGZ1bmN0aW9uIGJhc2VTaXplKCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBzY29wZV9CYXNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIGFsdCA9IChcIm9mZnNldFwiICsgW1wiV2lkdGhcIiwgXCJIZWlnaHRcIl1bb3B0aW9ucy5vcnRdKTtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLm9ydCA9PT0gMCA/IHJlY3Qud2lkdGggfHwgc2NvcGVfQmFzZVthbHRdIDogcmVjdC5oZWlnaHQgfHwgc2NvcGVfQmFzZVthbHRdO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZXIgZm9yIGF0dGFjaGluZyBldmVudHMgdHJvdWdoIGEgcHJveHkuXG4gICAgICAgIGZ1bmN0aW9uIGF0dGFjaEV2ZW50KGV2ZW50cywgZWxlbWVudCwgY2FsbGJhY2ssIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gJ2ZpbHRlcicgZXZlbnRzIHRvIHRoZSBzbGlkZXIuXG4gICAgICAgICAgICAvLyBlbGVtZW50IGlzIGEgbm9kZSwgbm90IGEgbm9kZUxpc3RcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGZpeEV2ZW50KGV2ZW50LCBkYXRhLnBhZ2VPZmZzZXQsIGRhdGEudGFyZ2V0IHx8IGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIC8vIGZpeEV2ZW50IHJldHVybnMgZmFsc2UgaWYgdGhpcyBldmVudCBoYXMgYSBkaWZmZXJlbnQgdGFyZ2V0XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBoYW5kbGluZyAobXVsdGktKSB0b3VjaCBldmVudHM7XG4gICAgICAgICAgICAgICAgaWYgKCFlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZG9Ob3RSZWplY3QgaXMgcGFzc2VkIGJ5IGFsbCBlbmQgZXZlbnRzIHRvIG1ha2Ugc3VyZSByZWxlYXNlZCB0b3VjaGVzXG4gICAgICAgICAgICAgICAgLy8gYXJlIG5vdCByZWplY3RlZCwgbGVhdmluZyB0aGUgc2xpZGVyIFwic3R1Y2tcIiB0byB0aGUgY3Vyc29yO1xuICAgICAgICAgICAgICAgIGlmIChpc1NsaWRlckRpc2FibGVkKCkgJiYgIWRhdGEuZG9Ob3RSZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTdG9wIGlmIGFuIGFjdGl2ZSAndGFwJyB0cmFuc2l0aW9uIGlzIHRha2luZyBwbGFjZS5cbiAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3Moc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGFwKSAmJiAhZGF0YS5kb05vdFJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSByaWdodCBvciBtaWRkbGUgY2xpY2tzIG9uIHN0YXJ0ICM0NTRcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzID09PSBhY3Rpb25zLnN0YXJ0ICYmIGUuYnV0dG9ucyAhPT0gdW5kZWZpbmVkICYmIGUuYnV0dG9ucyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcmlnaHQgb3IgbWlkZGxlIGNsaWNrcyBvbiBzdGFydCAjNDU0XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaG92ZXIgJiYgZS5idXR0b25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gJ3N1cHBvcnRzUGFzc2l2ZScgaXMgb25seSB0cnVlIGlmIGEgYnJvd3NlciBhbHNvIHN1cHBvcnRzIHRvdWNoLWFjdGlvbjogbm9uZSBpbiBDU1MuXG4gICAgICAgICAgICAgICAgLy8gaU9TIHNhZmFyaSBkb2VzIG5vdCwgc28gaXQgZG9lc24ndCBnZXQgdG8gYmVuZWZpdCBmcm9tIHBhc3NpdmUgc2Nyb2xsaW5nLiBpT1MgZG9lcyBzdXBwb3J0XG4gICAgICAgICAgICAgICAgLy8gdG91Y2gtYWN0aW9uOiBtYW5pcHVsYXRpb24sIGJ1dCB0aGF0IGFsbG93cyBwYW5uaW5nLCB3aGljaCBicmVha3NcbiAgICAgICAgICAgICAgICAvLyBzbGlkZXJzIGFmdGVyIHpvb21pbmcvb24gbm9uLXJlc3BvbnNpdmUgcGFnZXMuXG4gICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTMzMTEyXG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0c1Bhc3NpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLmNhbGNQb2ludCA9IGUucG9pbnRzW29wdGlvbnMub3J0XTtcbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBldmVudCBoYW5kbGVyIHdpdGggdGhlIGV2ZW50IFsgYW5kIGFkZGl0aW9uYWwgZGF0YSBdLlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUsIGRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbWV0aG9kcyA9IFtdO1xuICAgICAgICAgICAgLy8gQmluZCBhIGNsb3N1cmUgb24gdGhlIHRhcmdldCBmb3IgZXZlcnkgZXZlbnQgdHlwZS5cbiAgICAgICAgICAgIGV2ZW50cy5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbWV0aG9kLCBzdXBwb3J0c1Bhc3NpdmUgPyB7IHBhc3NpdmU6IHRydWUgfSA6IGZhbHNlKTtcbiAgICAgICAgICAgICAgICBtZXRob2RzLnB1c2goW2V2ZW50TmFtZSwgbWV0aG9kXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb3ZpZGUgYSBjbGVhbiBldmVudCB3aXRoIHN0YW5kYXJkaXplZCBvZmZzZXQgdmFsdWVzLlxuICAgICAgICBmdW5jdGlvbiBmaXhFdmVudChlLCBwYWdlT2Zmc2V0LCBldmVudFRhcmdldCkge1xuICAgICAgICAgICAgLy8gRmlsdGVyIHRoZSBldmVudCB0byByZWdpc3RlciB0aGUgdHlwZSwgd2hpY2ggY2FuIGJlXG4gICAgICAgICAgICAvLyB0b3VjaCwgbW91c2Ugb3IgcG9pbnRlci4gT2Zmc2V0IGNoYW5nZXMgbmVlZCB0byBiZVxuICAgICAgICAgICAgLy8gbWFkZSBvbiBhbiBldmVudCBzcGVjaWZpYyBiYXNpcy5cbiAgICAgICAgICAgIHZhciB0b3VjaCA9IGUudHlwZS5pbmRleE9mKFwidG91Y2hcIikgPT09IDA7XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLnR5cGUuaW5kZXhPZihcIm1vdXNlXCIpID09PSAwO1xuICAgICAgICAgICAgdmFyIHBvaW50ZXIgPSBlLnR5cGUuaW5kZXhPZihcInBvaW50ZXJcIikgPT09IDA7XG4gICAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgICB2YXIgeSA9IDA7XG4gICAgICAgICAgICAvLyBJRTEwIGltcGxlbWVudGVkIHBvaW50ZXIgZXZlbnRzIHdpdGggYSBwcmVmaXg7XG4gICAgICAgICAgICBpZiAoZS50eXBlLmluZGV4T2YoXCJNU1BvaW50ZXJcIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwb2ludGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVycm9uZW91cyBldmVudHMgc2VlbSB0byBiZSBwYXNzZWQgaW4gb2NjYXNpb25hbGx5IG9uIGlPUy9pUGFkT1MgYWZ0ZXIgdXNlciBmaW5pc2hlcyBpbnRlcmFjdGluZyB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgc2xpZGVyLiBUaGV5IGFwcGVhciB0byBiZSBvZiB0eXBlIE1vdXNlRXZlbnQsIHlldCB0aGV5IGRvbid0IGhhdmUgdXN1YWwgcHJvcGVydGllcyBzZXQuIElnbm9yZVxuICAgICAgICAgICAgLy8gZXZlbnRzIHRoYXQgaGF2ZSBubyB0b3VjaGVzIG9yIGJ1dHRvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZW0uICgjMTA1NywgIzEwNzksICMxMDk1KVxuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJtb3VzZWRvd25cIiAmJiAhZS5idXR0b25zICYmICFlLnRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgb25seSB0aGluZyBvbmUgaGFuZGxlIHNob3VsZCBiZSBjb25jZXJuZWQgYWJvdXQgaXMgdGhlIHRvdWNoZXMgdGhhdCBvcmlnaW5hdGVkIG9uIHRvcCBvZiBpdC5cbiAgICAgICAgICAgIGlmICh0b3VjaCkge1xuICAgICAgICAgICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBhIHRvdWNoIG9yaWdpbmF0ZWQgb24gdGhlIHRhcmdldC5cbiAgICAgICAgICAgICAgICB2YXIgaXNUb3VjaE9uVGFyZ2V0ID0gZnVuY3Rpb24gKGNoZWNrVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGNoZWNrVG91Y2gudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRhcmdldCA9PT0gZXZlbnRUYXJnZXQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmNvbnRhaW5zKHRhcmdldCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChlLmNvbXBvc2VkICYmIGUuY29tcG9zZWRQYXRoKCkuc2hpZnQoKSA9PT0gZXZlbnRUYXJnZXQpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIHRvdWNoc3RhcnQgZXZlbnRzLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGVyZSBpcyBzdGlsbCBubyBtb3JlIHRoYW4gb25lXG4gICAgICAgICAgICAgICAgLy8gdG91Y2ggb24gdGhlIHRhcmdldCBzbyB3ZSBsb29rIGFtb25nc3QgYWxsIHRvdWNoZXMuXG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldFRvdWNoZXMgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZS50b3VjaGVzLCBpc1RvdWNoT25UYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3Qgc3VwcG9ydCBtb3JlIHRoYW4gb25lIHRvdWNoIHBlciBoYW5kbGUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4ID0gdGFyZ2V0VG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHRhcmdldFRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgb3RoZXIgY2FzZXMsIGZpbmQgb24gY2hhbmdlZFRvdWNoZXMgaXMgZW5vdWdoLlxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VG91Y2ggPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKGUuY2hhbmdlZFRvdWNoZXMsIGlzVG91Y2hPblRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbmNlbCBpZiB0aGUgdGFyZ2V0IHRvdWNoIGhhcyBub3QgbW92ZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0VG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4ID0gdGFyZ2V0VG91Y2gucGFnZVg7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB0YXJnZXRUb3VjaC5wYWdlWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWdlT2Zmc2V0ID0gcGFnZU9mZnNldCB8fCBnZXRQYWdlT2Zmc2V0KHNjb3BlX0RvY3VtZW50KTtcbiAgICAgICAgICAgIGlmIChtb3VzZSB8fCBwb2ludGVyKSB7XG4gICAgICAgICAgICAgICAgeCA9IGUuY2xpZW50WCArIHBhZ2VPZmZzZXQueDtcbiAgICAgICAgICAgICAgICB5ID0gZS5jbGllbnRZICsgcGFnZU9mZnNldC55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5wYWdlT2Zmc2V0ID0gcGFnZU9mZnNldDtcbiAgICAgICAgICAgIGUucG9pbnRzID0gW3gsIHldO1xuICAgICAgICAgICAgZS5jdXJzb3IgPSBtb3VzZSB8fCBwb2ludGVyOyAvLyBGaXggIzQzNVxuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJhbnNsYXRlIGEgY29vcmRpbmF0ZSBpbiB0aGUgZG9jdW1lbnQgdG8gYSBwZXJjZW50YWdlIG9uIHRoZSBzbGlkZXJcbiAgICAgICAgZnVuY3Rpb24gY2FsY1BvaW50VG9QZXJjZW50YWdlKGNhbGNQb2ludCkge1xuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY2FsY1BvaW50IC0gb2Zmc2V0KHNjb3BlX0Jhc2UsIG9wdGlvbnMub3J0KTtcbiAgICAgICAgICAgIHZhciBwcm9wb3NhbCA9IChsb2NhdGlvbiAqIDEwMCkgLyBiYXNlU2l6ZSgpO1xuICAgICAgICAgICAgLy8gQ2xhbXAgcHJvcG9zYWwgYmV0d2VlbiAwJSBhbmQgMTAwJVxuICAgICAgICAgICAgLy8gT3V0LW9mLWJvdW5kIGNvb3JkaW5hdGVzIG1heSBvY2N1ciB3aGVuIC5ub1VpLWJhc2UgcHNldWRvLWVsZW1lbnRzXG4gICAgICAgICAgICAvLyBhcmUgdXNlZCAoZS5nLiBjb250YWluZWQgaGFuZGxlcyBmZWF0dXJlKVxuICAgICAgICAgICAgcHJvcG9zYWwgPSBsaW1pdChwcm9wb3NhbCk7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kaXIgPyAxMDAgLSBwcm9wb3NhbCA6IHByb3Bvc2FsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgaGFuZGxlIGNsb3Nlc3QgdG8gYSBjZXJ0YWluIHBlcmNlbnRhZ2Ugb24gdGhlIHNsaWRlclxuICAgICAgICBmdW5jdGlvbiBnZXRDbG9zZXN0SGFuZGxlKGNsaWNrZWRQb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIHNtYWxsZXN0RGlmZmVyZW5jZSA9IDEwMDtcbiAgICAgICAgICAgIHZhciBoYW5kbGVOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZXMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIERpc2FibGVkIGhhbmRsZXMgYXJlIGlnbm9yZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNIYW5kbGVEaXNhYmxlZChpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlUG9zaXRpb24gPSBzY29wZV9Mb2NhdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhciBkaWZmZXJlbmNlV2l0aFRoaXNIYW5kbGUgPSBNYXRoLmFicyhoYW5kbGVQb3NpdGlvbiAtIGNsaWNrZWRQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbCBzdGF0ZVxuICAgICAgICAgICAgICAgIHZhciBjbGlja0F0RWRnZSA9IGRpZmZlcmVuY2VXaXRoVGhpc0hhbmRsZSA9PT0gMTAwICYmIHNtYWxsZXN0RGlmZmVyZW5jZSA9PT0gMTAwO1xuICAgICAgICAgICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB0aGlzIGhhbmRsZSBpcyBzbWFsbGVyIHRoYW4gdGhlIHByZXZpb3VzbHkgY2hlY2tlZCBoYW5kbGVcbiAgICAgICAgICAgICAgICB2YXIgaXNDbG9zZXIgPSBkaWZmZXJlbmNlV2l0aFRoaXNIYW5kbGUgPCBzbWFsbGVzdERpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgdmFyIGlzQ2xvc2VyQWZ0ZXIgPSBkaWZmZXJlbmNlV2l0aFRoaXNIYW5kbGUgPD0gc21hbGxlc3REaWZmZXJlbmNlICYmIGNsaWNrZWRQb3NpdGlvbiA+IGhhbmRsZVBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChpc0Nsb3NlciB8fCBpc0Nsb3NlckFmdGVyIHx8IGNsaWNrQXRFZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlciA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBzbWFsbGVzdERpZmZlcmVuY2UgPSBkaWZmZXJlbmNlV2l0aFRoaXNIYW5kbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpcmUgJ2VuZCcgd2hlbiBhIG1vdXNlIG9yIHBlbiBsZWF2ZXMgdGhlIGRvY3VtZW50LlxuICAgICAgICBmdW5jdGlvbiBkb2N1bWVudExlYXZlKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJtb3VzZW91dFwiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lID09PSBcIkhUTUxcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LnJlbGF0ZWRUYXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBldmVudEVuZChldmVudCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIG1vdmVtZW50IG9uIGRvY3VtZW50IGZvciBoYW5kbGUgYW5kIHJhbmdlIGRyYWcuXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50TW92ZShldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgLy8gRml4ICM0OThcbiAgICAgICAgICAgIC8vIENoZWNrIHZhbHVlIG9mIC5idXR0b25zIGluICdzdGFydCcgdG8gd29yayBhcm91bmQgYSBidWcgaW4gSUUxMCBtb2JpbGUgKGRhdGEuYnV0dG9uc1Byb3BlcnR5KS5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvOTI3MDA1L21vYmlsZS1pZTEwLXdpbmRvd3MtcGhvbmUtYnV0dG9ucy1wcm9wZXJ0eS1vZi1wb2ludGVybW92ZS1ldmVudC1hbHdheXMtemVyb1xuICAgICAgICAgICAgLy8gSUU5IGhhcyAuYnV0dG9ucyBhbmQgLndoaWNoIHplcm8gb24gbW91c2Vtb3ZlLlxuICAgICAgICAgICAgLy8gRmlyZWZveCBicmVha3MgdGhlIHNwZWMgTUROIGRlZmluZXMuXG4gICAgICAgICAgICBpZiAobmF2aWdhdG9yLmFwcFZlcnNpb24uaW5kZXhPZihcIk1TSUUgOVwiKSA9PT0gLTEgJiYgZXZlbnQuYnV0dG9ucyA9PT0gMCAmJiBkYXRhLmJ1dHRvbnNQcm9wZXJ0eSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmVudEVuZChldmVudCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBhcmUgbW92aW5nIHVwIG9yIGRvd25cbiAgICAgICAgICAgIHZhciBtb3ZlbWVudCA9IChvcHRpb25zLmRpciA/IC0xIDogMSkgKiAoZXZlbnQuY2FsY1BvaW50IC0gZGF0YS5zdGFydENhbGNQb2ludCk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBtb3ZlbWVudCBpbnRvIGEgcGVyY2VudGFnZSBvZiB0aGUgc2xpZGVyIHdpZHRoL2hlaWdodFxuICAgICAgICAgICAgdmFyIHByb3Bvc2FsID0gKG1vdmVtZW50ICogMTAwKSAvIGRhdGEuYmFzZVNpemU7XG4gICAgICAgICAgICBtb3ZlSGFuZGxlcyhtb3ZlbWVudCA+IDAsIHByb3Bvc2FsLCBkYXRhLmxvY2F0aW9ucywgZGF0YS5oYW5kbGVOdW1iZXJzLCBkYXRhLmNvbm5lY3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVuYmluZCBtb3ZlIGV2ZW50cyBvbiBkb2N1bWVudCwgY2FsbCBjYWxsYmFja3MuXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50RW5kKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICAvLyBUaGUgaGFuZGxlIGlzIG5vIGxvbmdlciBhY3RpdmUsIHNvIHJlbW92ZSB0aGUgY2xhc3MuXG4gICAgICAgICAgICBpZiAoZGF0YS5oYW5kbGUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhkYXRhLmhhbmRsZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgc2NvcGVfQWN0aXZlSGFuZGxlc0NvdW50IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmJpbmQgdGhlIG1vdmUgYW5kIGVuZCBldmVudHMsIHdoaWNoIGFyZSBhZGRlZCBvbiAnc3RhcnQnLlxuICAgICAgICAgICAgZGF0YS5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIHNjb3BlX0RvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGNbMF0sIGNbMV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2NvcGVfQWN0aXZlSGFuZGxlc0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGRyYWdnaW5nIGNsYXNzLlxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLmRyYWcpO1xuICAgICAgICAgICAgICAgIHNldFppbmRleCgpO1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBjdXJzb3Igc3R5bGVzIGFuZCB0ZXh0LXNlbGVjdGlvbiBldmVudHMgYm91bmQgdG8gdGhlIGJvZHkuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICBzY29wZV9Cb2R5LnN0eWxlLmN1cnNvciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlX0JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdHN0YXJ0XCIsIHByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwiY2hhbmdlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwiZW5kXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCaW5kIG1vdmUgZXZlbnRzIG9uIGRvY3VtZW50LlxuICAgICAgICBmdW5jdGlvbiBldmVudFN0YXJ0KGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgZXZlbnQgaWYgYW55IGhhbmRsZSBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgaWYgKGRhdGEuaGFuZGxlTnVtYmVycy5zb21lKGlzSGFuZGxlRGlzYWJsZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhhbmRsZTtcbiAgICAgICAgICAgIGlmIChkYXRhLmhhbmRsZU51bWJlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZU9yaWdpbiA9IHNjb3BlX0hhbmRsZXNbZGF0YS5oYW5kbGVOdW1iZXJzWzBdXTtcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSBoYW5kbGVPcmlnaW4uY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgc2NvcGVfQWN0aXZlSGFuZGxlc0NvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgLy8gTWFyayB0aGUgaGFuZGxlIGFzICdhY3RpdmUnIHNvIGl0IGNhbiBiZSBzdHlsZWQuXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuYWN0aXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEEgZHJhZyBzaG91bGQgbmV2ZXIgcHJvcGFnYXRlIHVwIHRvIHRoZSAndGFwJyBldmVudC5cbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgLy8gUmVjb3JkIHRoZSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gW107XG4gICAgICAgICAgICAvLyBBdHRhY2ggdGhlIG1vdmUgYW5kIGVuZCBldmVudHMuXG4gICAgICAgICAgICB2YXIgbW92ZUV2ZW50ID0gYXR0YWNoRXZlbnQoYWN0aW9ucy5tb3ZlLCBzY29wZV9Eb2N1bWVudEVsZW1lbnQsIGV2ZW50TW92ZSwge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBldmVudCB0YXJnZXQgaGFzIGNoYW5nZWQgc28gd2UgbmVlZCB0byBwcm9wYWdhdGUgdGhlIG9yaWdpbmFsIG9uZSBzbyB0aGF0IHdlIGtlZXBcbiAgICAgICAgICAgICAgICAvLyByZWx5aW5nIG9uIGl0IHRvIGV4dHJhY3QgdGFyZ2V0IHRvdWNoZXMuXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgaGFuZGxlOiBoYW5kbGUsXG4gICAgICAgICAgICAgICAgY29ubmVjdDogZGF0YS5jb25uZWN0LFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgICAgICAgICAgIHN0YXJ0Q2FsY1BvaW50OiBldmVudC5jYWxjUG9pbnQsXG4gICAgICAgICAgICAgICAgYmFzZVNpemU6IGJhc2VTaXplKCksXG4gICAgICAgICAgICAgICAgcGFnZU9mZnNldDogZXZlbnQucGFnZU9mZnNldCxcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBkYXRhLmhhbmRsZU51bWJlcnMsXG4gICAgICAgICAgICAgICAgYnV0dG9uc1Byb3BlcnR5OiBldmVudC5idXR0b25zLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uczogc2NvcGVfTG9jYXRpb25zLnNsaWNlKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGVuZEV2ZW50ID0gYXR0YWNoRXZlbnQoYWN0aW9ucy5lbmQsIHNjb3BlX0RvY3VtZW50RWxlbWVudCwgZXZlbnRFbmQsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGhhbmRsZSxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVycyxcbiAgICAgICAgICAgICAgICBkb05vdFJlamVjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBkYXRhLmhhbmRsZU51bWJlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG91dEV2ZW50ID0gYXR0YWNoRXZlbnQoXCJtb3VzZW91dFwiLCBzY29wZV9Eb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50TGVhdmUsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGhhbmRsZSxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVycyxcbiAgICAgICAgICAgICAgICBkb05vdFJlamVjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBkYXRhLmhhbmRsZU51bWJlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgcHVzaGVkIHRoZSBsaXN0ZW5lcnMgaW4gdGhlIGxpc3RlbmVyIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRpbmdcbiAgICAgICAgICAgIC8vIGEgbmV3IG9uZSBhcyBpdCBoYXMgYWxyZWFkeSBiZWVuIHBhc3NlZCB0byB0aGUgZXZlbnQgaGFuZGxlcnMuXG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaC5hcHBseShsaXN0ZW5lcnMsIG1vdmVFdmVudC5jb25jYXQoZW5kRXZlbnQsIG91dEV2ZW50KSk7XG4gICAgICAgICAgICAvLyBUZXh0IHNlbGVjdGlvbiBpc24ndCBhbiBpc3N1ZSBvbiB0b3VjaCBkZXZpY2VzLFxuICAgICAgICAgICAgLy8gc28gYWRkaW5nIGN1cnNvciBzdHlsZXMgY2FuIGJlIHNraXBwZWQuXG4gICAgICAgICAgICBpZiAoZXZlbnQuY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCB0aGUgJ0knIGN1cnNvciBhbmQgZXh0ZW5kIHRoZSByYW5nZS1kcmFnIGN1cnNvci5cbiAgICAgICAgICAgICAgICBzY29wZV9Cb2R5LnN0eWxlLmN1cnNvciA9IGdldENvbXB1dGVkU3R5bGUoZXZlbnQudGFyZ2V0KS5jdXJzb3I7XG4gICAgICAgICAgICAgICAgLy8gTWFyayB0aGUgdGFyZ2V0IHdpdGggYSBkcmFnZ2luZyBzdGF0ZS5cbiAgICAgICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLmRyYWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHRleHQgc2VsZWN0aW9uIHdoZW4gZHJhZ2dpbmcgdGhlIGhhbmRsZXMuXG4gICAgICAgICAgICAgICAgLy8gSW4gbm9VaVNsaWRlciA8PSA5LjIuMCwgdGhpcyB3YXMgaGFuZGxlZCBieSBjYWxsaW5nIHByZXZlbnREZWZhdWx0IG9uIG1vdXNlL3RvdWNoIHN0YXJ0L21vdmUsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgc2Nyb2xsIGJsb2NraW5nLiBUaGUgc2VsZWN0c3RhcnQgZXZlbnQgaXMgc3VwcG9ydGVkIGJ5IEZpcmVGb3ggc3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDUyLFxuICAgICAgICAgICAgICAgIC8vIG1lYW5pbmcgdGhlIG9ubHkgaG9sZG91dCBpcyBpT1MgU2FmYXJpLiBUaGlzIGRvZXNuJ3QgbWF0dGVyOiB0ZXh0IHNlbGVjdGlvbiBpc24ndCB0cmlnZ2VyZWQgdGhlcmUuXG4gICAgICAgICAgICAgICAgLy8gVGhlICdjdXJzb3InIGZsYWcgaXMgZmFsc2UuXG4gICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1zZWxlY3RzdGFydFxuICAgICAgICAgICAgICAgIHNjb3BlX0JvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdHN0YXJ0XCIsIHByZXZlbnREZWZhdWx0LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwic3RhcnRcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1vdmUgY2xvc2VzdCBoYW5kbGUgdG8gdGFwcGVkIGxvY2F0aW9uLlxuICAgICAgICBmdW5jdGlvbiBldmVudFRhcChldmVudCkge1xuICAgICAgICAgICAgLy8gVGhlIHRhcCBldmVudCBzaG91bGRuJ3QgcHJvcGFnYXRlIHVwXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHZhciBwcm9wb3NhbCA9IGNhbGNQb2ludFRvUGVyY2VudGFnZShldmVudC5jYWxjUG9pbnQpO1xuICAgICAgICAgICAgdmFyIGhhbmRsZU51bWJlciA9IGdldENsb3Nlc3RIYW5kbGUocHJvcG9zYWwpO1xuICAgICAgICAgICAgLy8gVGFja2xlIHRoZSBjYXNlIHRoYXQgYWxsIGhhbmRsZXMgYXJlICdkaXNhYmxlZCcuXG4gICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZsYWcgdGhlIHNsaWRlciBhcyBpdCBpcyBub3cgaW4gYSB0cmFuc2l0aW9uYWwgc3RhdGUuXG4gICAgICAgICAgICAvLyBUcmFuc2l0aW9uIHRha2VzIGEgY29uZmlndXJhYmxlIGFtb3VudCBvZiBtcyAoZGVmYXVsdCAzMDApLiBSZS1lbmFibGUgdGhlIHNsaWRlciBhZnRlciB0aGF0LlxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmV2ZW50cy5zbmFwKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3NGb3Ioc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGFwLCBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHByb3Bvc2FsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIHNldFppbmRleCgpO1xuICAgICAgICAgICAgZmlyZUV2ZW50KFwic2xpZGVcIiwgaGFuZGxlTnVtYmVyLCB0cnVlKTtcbiAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBoYW5kbGVOdW1iZXIsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmV2ZW50cy5zbmFwKSB7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwiY2hhbmdlXCIsIGhhbmRsZU51bWJlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlciwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmVudFN0YXJ0KGV2ZW50LCB7IGhhbmRsZU51bWJlcnM6IFtoYW5kbGVOdW1iZXJdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZpcmVzIGEgJ2hvdmVyJyBldmVudCBmb3IgYSBob3ZlcmVkIG1vdXNlL3BlbiBwb3NpdGlvbi5cbiAgICAgICAgZnVuY3Rpb24gZXZlbnRIb3ZlcihldmVudCkge1xuICAgICAgICAgICAgdmFyIHByb3Bvc2FsID0gY2FsY1BvaW50VG9QZXJjZW50YWdlKGV2ZW50LmNhbGNQb2ludCk7XG4gICAgICAgICAgICB2YXIgdG8gPSBzY29wZV9TcGVjdHJ1bS5nZXRTdGVwKHByb3Bvc2FsKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyh0byk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzY29wZV9FdmVudHMpLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiaG92ZXJcIiA9PT0gdGFyZ2V0RXZlbnQuc3BsaXQoXCIuXCIpWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlX0V2ZW50c1t0YXJnZXRFdmVudF0uZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc2NvcGVfU2VsZiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGVzIGtleWRvd24gb24gZm9jdXNlZCBoYW5kbGVzXG4gICAgICAgIC8vIERvbid0IG1vdmUgdGhlIGRvY3VtZW50IHdoZW4gcHJlc3NpbmcgYXJyb3cga2V5cyBvbiBmb2N1c2VkIGhhbmRsZXNcbiAgICAgICAgZnVuY3Rpb24gZXZlbnRLZXlkb3duKGV2ZW50LCBoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChpc1NsaWRlckRpc2FibGVkKCkgfHwgaXNIYW5kbGVEaXNhYmxlZChoYW5kbGVOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhvcml6b250YWxLZXlzID0gW1wiTGVmdFwiLCBcIlJpZ2h0XCJdO1xuICAgICAgICAgICAgdmFyIHZlcnRpY2FsS2V5cyA9IFtcIkRvd25cIiwgXCJVcFwiXTtcbiAgICAgICAgICAgIHZhciBsYXJnZVN0ZXBLZXlzID0gW1wiUGFnZURvd25cIiwgXCJQYWdlVXBcIl07XG4gICAgICAgICAgICB2YXIgZWRnZUtleXMgPSBbXCJIb21lXCIsIFwiRW5kXCJdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlyICYmICFvcHRpb25zLm9ydCkge1xuICAgICAgICAgICAgICAgIC8vIE9uIGFuIHJpZ2h0LXRvLWxlZnQgc2xpZGVyLCB0aGUgbGVmdCBhbmQgcmlnaHQga2V5cyBhY3QgaW52ZXJ0ZWRcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsS2V5cy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9ydCAmJiAhb3B0aW9ucy5kaXIpIHtcbiAgICAgICAgICAgICAgICAvLyBPbiBhIHRvcC10by1ib3R0b20gc2xpZGVyLCB0aGUgdXAgYW5kIGRvd24ga2V5cyBhY3QgaW52ZXJ0ZWRcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEtleXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIGxhcmdlU3RlcEtleXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RyaXAgXCJBcnJvd1wiIGZvciBJRSBjb21wYXRpYmlsaXR5LiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXlcbiAgICAgICAgICAgIHZhciBrZXkgPSBldmVudC5rZXkucmVwbGFjZShcIkFycm93XCIsIFwiXCIpO1xuICAgICAgICAgICAgdmFyIGlzTGFyZ2VEb3duID0ga2V5ID09PSBsYXJnZVN0ZXBLZXlzWzBdO1xuICAgICAgICAgICAgdmFyIGlzTGFyZ2VVcCA9IGtleSA9PT0gbGFyZ2VTdGVwS2V5c1sxXTtcbiAgICAgICAgICAgIHZhciBpc0Rvd24gPSBrZXkgPT09IHZlcnRpY2FsS2V5c1swXSB8fCBrZXkgPT09IGhvcml6b250YWxLZXlzWzBdIHx8IGlzTGFyZ2VEb3duO1xuICAgICAgICAgICAgdmFyIGlzVXAgPSBrZXkgPT09IHZlcnRpY2FsS2V5c1sxXSB8fCBrZXkgPT09IGhvcml6b250YWxLZXlzWzFdIHx8IGlzTGFyZ2VVcDtcbiAgICAgICAgICAgIHZhciBpc01pbiA9IGtleSA9PT0gZWRnZUtleXNbMF07XG4gICAgICAgICAgICB2YXIgaXNNYXggPSBrZXkgPT09IGVkZ2VLZXlzWzFdO1xuICAgICAgICAgICAgaWYgKCFpc0Rvd24gJiYgIWlzVXAgJiYgIWlzTWluICYmICFpc01heCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciB0bztcbiAgICAgICAgICAgIGlmIChpc1VwIHx8IGlzRG93bikge1xuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBpc0Rvd24gPyAwIDogMTtcbiAgICAgICAgICAgICAgICB2YXIgc3RlcHMgPSBnZXROZXh0U3RlcHNGb3JIYW5kbGUoaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RlcCA9IHN0ZXBzW2RpcmVjdGlvbl07XG4gICAgICAgICAgICAgICAgLy8gQXQgdGhlIGVkZ2Ugb2YgYSBzbGlkZXIsIGRvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5vIHN0ZXAgc2V0LCB1c2UgdGhlIGRlZmF1bHQgb2YgMTAlIG9mIHRoZSBzdWItcmFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcCA9IHNjb3BlX1NwZWN0cnVtLmdldERlZmF1bHRTdGVwKHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdLCBpc0Rvd24sIG9wdGlvbnMua2V5Ym9hcmREZWZhdWx0U3RlcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0xhcmdlVXAgfHwgaXNMYXJnZURvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcCAqPSBvcHRpb25zLmtleWJvYXJkUGFnZU11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGVwICo9IG9wdGlvbnMua2V5Ym9hcmRNdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTdGVwIG92ZXIgemVyby1sZW5ndGggcmFuZ2VzICgjOTQ4KTtcbiAgICAgICAgICAgICAgICBzdGVwID0gTWF0aC5tYXgoc3RlcCwgMC4wMDAwMDAxKTtcbiAgICAgICAgICAgICAgICAvLyBEZWNyZW1lbnQgZm9yIGRvd24gc3RlcHNcbiAgICAgICAgICAgICAgICBzdGVwID0gKGlzRG93biA/IC0xIDogMSkgKiBzdGVwO1xuICAgICAgICAgICAgICAgIHRvID0gc2NvcGVfVmFsdWVzW2hhbmRsZU51bWJlcl0gKyBzdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNNYXgpIHtcbiAgICAgICAgICAgICAgICAvLyBFbmQga2V5XG4gICAgICAgICAgICAgICAgdG8gPSBvcHRpb25zLnNwZWN0cnVtLnhWYWxbb3B0aW9ucy5zcGVjdHJ1bS54VmFsLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSG9tZSBrZXlcbiAgICAgICAgICAgICAgICB0byA9IG9wdGlvbnMuc3BlY3RydW0ueFZhbFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcodG8pLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIGZpcmVFdmVudChcInNsaWRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIGZpcmVFdmVudChcImNoYW5nZVwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXR0YWNoIGV2ZW50cyB0byBzZXZlcmFsIHNsaWRlciBwYXJ0cy5cbiAgICAgICAgZnVuY3Rpb24gYmluZFNsaWRlckV2ZW50cyhiZWhhdmlvdXIpIHtcbiAgICAgICAgICAgIC8vIEF0dGFjaCB0aGUgc3RhbmRhcmQgZHJhZyBldmVudCB0byB0aGUgaGFuZGxlcy5cbiAgICAgICAgICAgIGlmICghYmVoYXZpb3VyLmZpeGVkKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVfSGFuZGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGV2ZW50cyBhcmUgb25seSBib3VuZCB0byB0aGUgdmlzdWFsIGhhbmRsZVxuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50LCBub3QgdGhlICdyZWFsJyBvcmlnaW4gZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgYXR0YWNoRXZlbnQoYWN0aW9ucy5zdGFydCwgaGFuZGxlLmNoaWxkcmVuWzBdLCBldmVudFN0YXJ0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBbaW5kZXhdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXR0YWNoIHRoZSB0YXAgZXZlbnQgdG8gdGhlIHNsaWRlciBiYXNlLlxuICAgICAgICAgICAgaWYgKGJlaGF2aW91ci50YXApIHtcbiAgICAgICAgICAgICAgICBhdHRhY2hFdmVudChhY3Rpb25zLnN0YXJ0LCBzY29wZV9CYXNlLCBldmVudFRhcCwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmlyZSBob3ZlciBldmVudHNcbiAgICAgICAgICAgIGlmIChiZWhhdmlvdXIuaG92ZXIpIHtcbiAgICAgICAgICAgICAgICBhdHRhY2hFdmVudChhY3Rpb25zLm1vdmUsIHNjb3BlX0Jhc2UsIGV2ZW50SG92ZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgaG92ZXI6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ha2UgdGhlIHJhbmdlIGRyYWdnYWJsZS5cbiAgICAgICAgICAgIGlmIChiZWhhdmlvdXIuZHJhZykge1xuICAgICAgICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzLmZvckVhY2goZnVuY3Rpb24gKGNvbm5lY3QsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0ID09PSBmYWxzZSB8fCBpbmRleCA9PT0gMCB8fCBpbmRleCA9PT0gc2NvcGVfQ29ubmVjdHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVCZWZvcmUgPSBzY29wZV9IYW5kbGVzW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVBZnRlciA9IHNjb3BlX0hhbmRsZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRIb2xkZXJzID0gW2Nvbm5lY3RdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlc1RvRHJhZyA9IFtoYW5kbGVCZWZvcmUsIGhhbmRsZUFmdGVyXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZU51bWJlcnNUb0RyYWcgPSBbaW5kZXggLSAxLCBpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKGNvbm5lY3QsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5kcmFnZ2FibGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSByYW5nZSBpcyBmaXhlZCwgdGhlIGVudGlyZSByYW5nZSBjYW5cbiAgICAgICAgICAgICAgICAgICAgLy8gYmUgZHJhZ2dlZCBieSB0aGUgaGFuZGxlcy4gVGhlIGhhbmRsZSBpbiB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgLy8gb3JpZ2luIHdpbGwgcHJvcGFnYXRlIHRoZSBzdGFydCBldmVudCB1cHdhcmQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpdCBuZWVkcyB0byBiZSBib3VuZCBtYW51YWxseSBvbiB0aGUgb3RoZXIuXG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWhhdmlvdXIuZml4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVycy5wdXNoKGhhbmRsZUJlZm9yZS5jaGlsZHJlblswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEhvbGRlcnMucHVzaChoYW5kbGVBZnRlci5jaGlsZHJlblswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlaGF2aW91ci5kcmFnQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVzVG9EcmFnID0gc2NvcGVfSGFuZGxlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnNUb0RyYWcgPSBzY29wZV9IYW5kbGVOdW1iZXJzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudEhvbGRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoRXZlbnQoYWN0aW9ucy5zdGFydCwgZXZlbnRIb2xkZXIsIGV2ZW50U3RhcnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVzOiBoYW5kbGVzVG9EcmFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IGhhbmRsZU51bWJlcnNUb0RyYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdDogY29ubmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEF0dGFjaCBhbiBldmVudCB0byB0aGlzIHNsaWRlciwgcG9zc2libHkgaW5jbHVkaW5nIGEgbmFtZXNwYWNlXG4gICAgICAgIGZ1bmN0aW9uIGJpbmRFdmVudChuYW1lc3BhY2VkRXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzY29wZV9FdmVudHNbbmFtZXNwYWNlZEV2ZW50XSA9IHNjb3BlX0V2ZW50c1tuYW1lc3BhY2VkRXZlbnRdIHx8IFtdO1xuICAgICAgICAgICAgc2NvcGVfRXZlbnRzW25hbWVzcGFjZWRFdmVudF0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZXZlbnQgYm91bmQgaXMgJ3VwZGF0ZSwnIGZpcmUgaXQgaW1tZWRpYXRlbHkgZm9yIGFsbCBoYW5kbGVzLlxuICAgICAgICAgICAgaWYgKG5hbWVzcGFjZWRFdmVudC5zcGxpdChcIi5cIilbMF0gPT09IFwidXBkYXRlXCIpIHtcbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVzLmZvckVhY2goZnVuY3Rpb24gKGEsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNJbnRlcm5hbE5hbWVzcGFjZShuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lc3BhY2UgPT09IElOVEVSTkFMX0VWRU5UX05TLmFyaWEgfHwgbmFtZXNwYWNlID09PSBJTlRFUk5BTF9FVkVOVF9OUy50b29sdGlwcztcbiAgICAgICAgfVxuICAgICAgICAvLyBVbmRvIGF0dGFjaG1lbnQgb2YgZXZlbnRcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRXZlbnQobmFtZXNwYWNlZEV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuYW1lc3BhY2VkRXZlbnQgJiYgbmFtZXNwYWNlZEV2ZW50LnNwbGl0KFwiLlwiKVswXTtcbiAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBldmVudCA/IG5hbWVzcGFjZWRFdmVudC5zdWJzdHJpbmcoZXZlbnQubGVuZ3RoKSA6IG5hbWVzcGFjZWRFdmVudDtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNjb3BlX0V2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoYmluZCkge1xuICAgICAgICAgICAgICAgIHZhciB0RXZlbnQgPSBiaW5kLnNwbGl0KFwiLlwiKVswXTtcbiAgICAgICAgICAgICAgICB2YXIgdE5hbWVzcGFjZSA9IGJpbmQuc3Vic3RyaW5nKHRFdmVudC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICgoIWV2ZW50IHx8IGV2ZW50ID09PSB0RXZlbnQpICYmICghbmFtZXNwYWNlIHx8IG5hbWVzcGFjZSA9PT0gdE5hbWVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBkZWxldGUgcHJvdGVjdGVkIGludGVybmFsIGV2ZW50IGlmIGludGVudGlvbmFsXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNJbnRlcm5hbE5hbWVzcGFjZSh0TmFtZXNwYWNlKSB8fCBuYW1lc3BhY2UgPT09IHROYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY29wZV9FdmVudHNbYmluZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRlcm5hbCBldmVudCBoYW5kbGluZ1xuICAgICAgICBmdW5jdGlvbiBmaXJlRXZlbnQoZXZlbnROYW1lLCBoYW5kbGVOdW1iZXIsIHRhcCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2NvcGVfRXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXRFdmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudFR5cGUgPSB0YXJnZXRFdmVudC5zcGxpdChcIi5cIilbMF07XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlX0V2ZW50c1t0YXJnZXRFdmVudF0uZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHNsaWRlciBwdWJsaWMgQVBJIGFzIHRoZSBzY29wZSAoJ3RoaXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfU2VsZiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdmFsdWVzIGFzIGFycmF5LCBzbyBhcmdfMVthcmdfMl0gaXMgYWx3YXlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfVmFsdWVzLm1hcChvcHRpb25zLmZvcm1hdC50byksIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGluZGV4LCAwIG9yIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlciwgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbi1mb3JtYXR0ZWQgc2xpZGVyIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfVmFsdWVzLnNsaWNlKCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXZlbnQgaXMgZmlyZWQgYnkgdGFwLCB0cnVlIG9yIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXAgfHwgZmFsc2UsIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVmdCBvZmZzZXQgb2YgdGhlIGhhbmRsZSwgaW4gcmVsYXRpb24gdG8gdGhlIHNsaWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfTG9jYXRpb25zLnNsaWNlKCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBzbGlkZXIgcHVibGljIEFQSSB0byBhbiBhY2Nlc3NpYmxlIHBhcmFtZXRlciB3aGVuIHRoaXMgaXMgdW5hdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlX1NlbGYpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGxpdCBvdXQgdGhlIGhhbmRsZSBwb3NpdGlvbmluZyBsb2dpYyBzbyB0aGUgTW92ZSBldmVudCBjYW4gdXNlIGl0LCB0b29cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tIYW5kbGVQb3NpdGlvbihyZWZlcmVuY2UsIGhhbmRsZU51bWJlciwgdG8sIGxvb2tCYWNrd2FyZCwgbG9va0ZvcndhcmQsIGdldFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2U7XG4gICAgICAgICAgICAvLyBGb3Igc2xpZGVycyB3aXRoIG11bHRpcGxlIGhhbmRsZXMsIGxpbWl0IG1vdmVtZW50IHRvIHRoZSBvdGhlciBoYW5kbGUuXG4gICAgICAgICAgICAvLyBBcHBseSB0aGUgbWFyZ2luIG9wdGlvbiBieSBhZGRpbmcgaXQgdG8gdGhlIGhhbmRsZSBwb3NpdGlvbnMuXG4gICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxICYmICFvcHRpb25zLmV2ZW50cy51bmNvbnN0cmFpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvb2tCYWNrd2FyZCAmJiBoYW5kbGVOdW1iZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gc2NvcGVfU3BlY3RydW0uZ2V0QWJzb2x1dGVEaXN0YW5jZShyZWZlcmVuY2VbaGFuZGxlTnVtYmVyIC0gMV0sIG9wdGlvbnMubWFyZ2luLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gTWF0aC5tYXgodG8sIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxvb2tGb3J3YXJkICYmIGhhbmRsZU51bWJlciA8IHNjb3BlX0hhbmRsZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IHNjb3BlX1NwZWN0cnVtLmdldEFic29sdXRlRGlzdGFuY2UocmVmZXJlbmNlW2hhbmRsZU51bWJlciArIDFdLCBvcHRpb25zLm1hcmdpbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gTWF0aC5taW4odG8sIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgbGltaXQgb3B0aW9uIGhhcyB0aGUgb3Bwb3NpdGUgZWZmZWN0LCBsaW1pdGluZyBoYW5kbGVzIHRvIGFcbiAgICAgICAgICAgIC8vIG1heGltdW0gZGlzdGFuY2UgZnJvbSBhbm90aGVyLiBMaW1pdCBtdXN0IGJlID4gMCwgYXMgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBoYW5kbGVzIHdvdWxkIGJlIHVubW92YWJsZS5cbiAgICAgICAgICAgIGlmIChzY29wZV9IYW5kbGVzLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5saW1pdCkge1xuICAgICAgICAgICAgICAgIGlmIChsb29rQmFja3dhcmQgJiYgaGFuZGxlTnVtYmVyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IHNjb3BlX1NwZWN0cnVtLmdldEFic29sdXRlRGlzdGFuY2UocmVmZXJlbmNlW2hhbmRsZU51bWJlciAtIDFdLCBvcHRpb25zLmxpbWl0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gTWF0aC5taW4odG8sIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxvb2tGb3J3YXJkICYmIGhhbmRsZU51bWJlciA8IHNjb3BlX0hhbmRsZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IHNjb3BlX1NwZWN0cnVtLmdldEFic29sdXRlRGlzdGFuY2UocmVmZXJlbmNlW2hhbmRsZU51bWJlciArIDFdLCBvcHRpb25zLmxpbWl0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBwYWRkaW5nIG9wdGlvbiBrZWVwcyB0aGUgaGFuZGxlcyBhIGNlcnRhaW4gZGlzdGFuY2UgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIGVkZ2VzIG9mIHRoZSBzbGlkZXIuIFBhZGRpbmcgbXVzdCBiZSA+IDAuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZU51bWJlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IHNjb3BlX1NwZWN0cnVtLmdldEFic29sdXRlRGlzdGFuY2UoMCwgb3B0aW9ucy5wYWRkaW5nWzBdLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gTWF0aC5tYXgodG8sIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZU51bWJlciA9PT0gc2NvcGVfSGFuZGxlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gc2NvcGVfU3BlY3RydW0uZ2V0QWJzb2x1dGVEaXN0YW5jZSgxMDAsIG9wdGlvbnMucGFkZGluZ1sxXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gTWF0aC5taW4odG8sIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0byA9IHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAodG8pO1xuICAgICAgICAgICAgLy8gTGltaXQgcGVyY2VudGFnZSB0byB0aGUgMCAtIDEwMCByYW5nZVxuICAgICAgICAgICAgdG8gPSBsaW1pdCh0byk7XG4gICAgICAgICAgICAvLyBSZXR1cm4gZmFsc2UgaWYgaGFuZGxlIGNhbid0IG1vdmVcbiAgICAgICAgICAgIGlmICh0byA9PT0gcmVmZXJlbmNlW2hhbmRsZU51bWJlcl0gJiYgIWdldFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZXMgc2xpZGVyIG9yaWVudGF0aW9uIHRvIGNyZWF0ZSBDU1MgcnVsZXMuIGEgPSBiYXNlIHZhbHVlO1xuICAgICAgICBmdW5jdGlvbiBpblJ1bGVPcmRlcih2LCBhKSB7XG4gICAgICAgICAgICB2YXIgbyA9IG9wdGlvbnMub3J0O1xuICAgICAgICAgICAgcmV0dXJuIChvID8gYSA6IHYpICsgXCIsIFwiICsgKG8gPyB2IDogYSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTW92ZXMgaGFuZGxlKHMpIGJ5IGEgcGVyY2VudGFnZVxuICAgICAgICAvLyAoYm9vbCwgJSB0byBtb3ZlLCBbJSB3aGVyZSBoYW5kbGUgc3RhcnRlZCwgLi4uXSwgW2luZGV4IGluIHNjb3BlX0hhbmRsZXMsIC4uLl0pXG4gICAgICAgIGZ1bmN0aW9uIG1vdmVIYW5kbGVzKHVwd2FyZCwgcHJvcG9zYWwsIGxvY2F0aW9ucywgaGFuZGxlTnVtYmVycywgY29ubmVjdCkge1xuICAgICAgICAgICAgdmFyIHByb3Bvc2FscyA9IGxvY2F0aW9ucy5zbGljZSgpO1xuICAgICAgICAgICAgLy8gU3RvcmUgZmlyc3QgaGFuZGxlIG5vdywgc28gd2Ugc3RpbGwgaGF2ZSBpdCBpbiBjYXNlIGhhbmRsZU51bWJlcnMgaXMgcmV2ZXJzZWRcbiAgICAgICAgICAgIHZhciBmaXJzdEhhbmRsZSA9IGhhbmRsZU51bWJlcnNbMF07XG4gICAgICAgICAgICB2YXIgYiA9IFshdXB3YXJkLCB1cHdhcmRdO1xuICAgICAgICAgICAgdmFyIGYgPSBbdXB3YXJkLCAhdXB3YXJkXTtcbiAgICAgICAgICAgIC8vIENvcHkgaGFuZGxlTnVtYmVycyBzbyB3ZSBkb24ndCBjaGFuZ2UgdGhlIGRhdGFzZXRcbiAgICAgICAgICAgIGhhbmRsZU51bWJlcnMgPSBoYW5kbGVOdW1iZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgd2hpY2ggaGFuZGxlIGlzICdsZWFkaW5nJy5cbiAgICAgICAgICAgIC8vIElmIHRoYXQgb25lIGNhbid0IG1vdmUgdGhlIHNlY29uZCBjYW4ndCBlaXRoZXIuXG4gICAgICAgICAgICBpZiAodXB3YXJkKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVycy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGVwIDE6IGdldCB0aGUgbWF4aW11bSBwZXJjZW50YWdlIHRoYXQgYW55IG9mIHRoZSBoYW5kbGVzIGNhbiBtb3ZlXG4gICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVOdW1iZXIsIG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvID0gY2hlY2tIYW5kbGVQb3NpdGlvbihwcm9wb3NhbHMsIGhhbmRsZU51bWJlciwgcHJvcG9zYWxzW2hhbmRsZU51bWJlcl0gKyBwcm9wb3NhbCwgYltvXSwgZltvXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIGlmIG9uZSBvZiB0aGUgaGFuZGxlcyBjYW4ndCBtb3ZlLlxuICAgICAgICAgICAgICAgICAgICBpZiAodG8gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbCA9IHRvIC0gcHJvcG9zYWxzW2hhbmRsZU51bWJlcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbHNbaGFuZGxlTnVtYmVyXSA9IHRvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB1c2luZyBvbmUgaGFuZGxlLCBjaGVjayBiYWNrd2FyZCBBTkQgZm9yd2FyZFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYiA9IGYgPSBbdHJ1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFN0ZXAgMjogVHJ5IHRvIHNldCB0aGUgaGFuZGxlcyB3aXRoIHRoZSBmb3VuZCBwZXJjZW50YWdlXG4gICAgICAgICAgICBoYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZU51bWJlciwgbykge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gc2V0SGFuZGxlKGhhbmRsZU51bWJlciwgbG9jYXRpb25zW2hhbmRsZU51bWJlcl0gKyBwcm9wb3NhbCwgYltvXSwgZltvXSkgfHwgc3RhdGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFN0ZXAgMzogSWYgYSBoYW5kbGUgbW92ZWQsIGZpcmUgZXZlbnRzXG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwic2xpZGVcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0YXJnZXQgaXMgYSBjb25uZWN0LCB0aGVuIGZpcmUgZHJhZyBldmVudFxuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJkcmFnXCIsIGZpcnN0SGFuZGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGFrZXMgYSBiYXNlIHZhbHVlIGFuZCBhbiBvZmZzZXQuIFRoaXMgb2Zmc2V0IGlzIHVzZWQgZm9yIHRoZSBjb25uZWN0IGJhciBzaXplLlxuICAgICAgICAvLyBJbiB0aGUgaW5pdGlhbCBkZXNpZ24gZm9yIHRoaXMgZmVhdHVyZSwgdGhlIG9yaWdpbiBlbGVtZW50IHdhcyAxJSB3aWRlLlxuICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCBhIHJvdW5kaW5nIGJ1ZyBpbiBDaHJvbWUgbWFrZXMgaXQgaW1wb3NzaWJsZSB0byBpbXBsZW1lbnQgdGhpcyBmZWF0dXJlXG4gICAgICAgIC8vIGluIHRoaXMgbWFubmVyOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD03OTgyMjNcbiAgICAgICAgZnVuY3Rpb24gdHJhbnNmb3JtRGlyZWN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRpciA/IDEwMCAtIGEgLSBiIDogYTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGVzIHNjb3BlX0xvY2F0aW9ucyBhbmQgc2NvcGVfVmFsdWVzLCB1cGRhdGVzIHZpc3VhbCBzdGF0ZVxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVIYW5kbGVQb3NpdGlvbihoYW5kbGVOdW1iZXIsIHRvKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgbG9jYXRpb25zLlxuICAgICAgICAgICAgc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl0gPSB0bztcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIHRoZSBzbGlkZXIgc3RlcHBpbmcvcmFuZ2UuXG4gICAgICAgICAgICBzY29wZV9WYWx1ZXNbaGFuZGxlTnVtYmVyXSA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyh0byk7XG4gICAgICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24odG8sIDApIC0gc2NvcGVfRGlyT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZVJ1bGUgPSBcInRyYW5zbGF0ZShcIiArIGluUnVsZU9yZGVyKHRyYW5zbGF0aW9uICsgXCIlXCIsIFwiMFwiKSArIFwiKVwiO1xuICAgICAgICAgICAgc2NvcGVfSGFuZGxlc1toYW5kbGVOdW1iZXJdLnN0eWxlW29wdGlvbnMudHJhbnNmb3JtUnVsZV0gPSB0cmFuc2xhdGVSdWxlO1xuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdChoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdChoYW5kbGVOdW1iZXIgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGVzIGJlZm9yZSB0aGUgc2xpZGVyIG1pZGRsZSBhcmUgc3RhY2tlZCBsYXRlciA9IGhpZ2hlcixcbiAgICAgICAgLy8gSGFuZGxlcyBhZnRlciB0aGUgbWlkZGxlIGxhdGVyIGlzIGxvd2VyXG4gICAgICAgIC8vIFtbN10gWzhdIC4uLi4uLi4uLi4gfCAuLi4uLi4uLi4uIFs1XSBbNF1cbiAgICAgICAgZnVuY3Rpb24gc2V0WmluZGV4KCkge1xuICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlyID0gc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl0gPiA1MCA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICB2YXIgekluZGV4ID0gMyArIChzY29wZV9IYW5kbGVzLmxlbmd0aCArIGRpciAqIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgc2NvcGVfSGFuZGxlc1toYW5kbGVOdW1iZXJdLnN0eWxlLnpJbmRleCA9IFN0cmluZyh6SW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBzdWdnZXN0ZWQgdmFsdWVzIGFuZCBhcHBseSBtYXJnaW4sIHN0ZXAuXG4gICAgICAgIC8vIGlmIGV4YWN0SW5wdXQgaXMgdHJ1ZSwgZG9uJ3QgcnVuIGNoZWNrSGFuZGxlUG9zaXRpb24sIHRoZW4gdGhlIGhhbmRsZSBjYW4gYmUgcGxhY2VkIGluIGJldHdlZW4gc3RlcHMgKCM0MzYpXG4gICAgICAgIGZ1bmN0aW9uIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHRvLCBsb29rQmFja3dhcmQsIGxvb2tGb3J3YXJkLCBleGFjdElucHV0KSB7XG4gICAgICAgICAgICBpZiAoIWV4YWN0SW5wdXQpIHtcbiAgICAgICAgICAgICAgICB0byA9IGNoZWNrSGFuZGxlUG9zaXRpb24oc2NvcGVfTG9jYXRpb25zLCBoYW5kbGVOdW1iZXIsIHRvLCBsb29rQmFja3dhcmQsIGxvb2tGb3J3YXJkLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG8gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlSGFuZGxlUG9zaXRpb24oaGFuZGxlTnVtYmVyLCB0byk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGVzIHN0eWxlIGF0dHJpYnV0ZSBmb3IgY29ubmVjdCBub2Rlc1xuICAgICAgICBmdW5jdGlvbiB1cGRhdGVDb25uZWN0KGluZGV4KSB7XG4gICAgICAgICAgICAvLyBTa2lwIGNvbm5lY3RzIHNldCB0byBmYWxzZVxuICAgICAgICAgICAgaWYgKCFzY29wZV9Db25uZWN0c1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbCA9IDA7XG4gICAgICAgICAgICB2YXIgaCA9IDEwMDtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGwgPSBzY29wZV9Mb2NhdGlvbnNbaW5kZXggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gc2NvcGVfQ29ubmVjdHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGggPSBzY29wZV9Mb2NhdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgdXNlIHR3byBydWxlczpcbiAgICAgICAgICAgIC8vICd0cmFuc2xhdGUnIHRvIGNoYW5nZSB0aGUgbGVmdC90b3Agb2Zmc2V0O1xuICAgICAgICAgICAgLy8gJ3NjYWxlJyB0byBjaGFuZ2UgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50O1xuICAgICAgICAgICAgLy8gQXMgdGhlIGVsZW1lbnQgaGFzIGEgd2lkdGggb2YgMTAwJSwgYSB0cmFuc2xhdGlvbiBvZiAxMDAlIGlzIGVxdWFsIHRvIDEwMCUgb2YgdGhlIHBhcmVudCAoLm5vVWktYmFzZSlcbiAgICAgICAgICAgIHZhciBjb25uZWN0V2lkdGggPSBoIC0gbDtcbiAgICAgICAgICAgIHZhciB0cmFuc2xhdGVSdWxlID0gXCJ0cmFuc2xhdGUoXCIgKyBpblJ1bGVPcmRlcih0cmFuc2Zvcm1EaXJlY3Rpb24obCwgY29ubmVjdFdpZHRoKSArIFwiJVwiLCBcIjBcIikgKyBcIilcIjtcbiAgICAgICAgICAgIHZhciBzY2FsZVJ1bGUgPSBcInNjYWxlKFwiICsgaW5SdWxlT3JkZXIoY29ubmVjdFdpZHRoIC8gMTAwLCBcIjFcIikgKyBcIilcIjtcbiAgICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzW2luZGV4XS5zdHlsZVtvcHRpb25zLnRyYW5zZm9ybVJ1bGVdID1cbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVSdWxlICsgXCIgXCIgKyBzY2FsZVJ1bGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2VzIHZhbHVlIHBhc3NlZCB0byAuc2V0IG1ldGhvZC4gUmV0dXJucyBjdXJyZW50IHZhbHVlIGlmIG5vdCBwYXJzZS1hYmxlLlxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlVG9WYWx1ZSh0bywgaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAvLyBTZXR0aW5nIHdpdGggbnVsbCBpbmRpY2F0ZXMgYW4gJ2lnbm9yZScuXG4gICAgICAgICAgICAvLyBJbnB1dHRpbmcgJ2ZhbHNlJyBpcyBpbnZhbGlkLlxuICAgICAgICAgICAgaWYgKHRvID09PSBudWxsIHx8IHRvID09PSBmYWxzZSB8fCB0byA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYSBmb3JtYXR0ZWQgbnVtYmVyIHdhcyBwYXNzZWQsIGF0dGVtcHQgdG8gZGVjb2RlIGl0LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRvID0gU3RyaW5nKHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvID0gb3B0aW9ucy5mb3JtYXQuZnJvbSh0byk7XG4gICAgICAgICAgICBpZiAodG8gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdG8gPSBzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHBhcnNpbmcgdGhlIG51bWJlciBmYWlsZWQsIHVzZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgICAgICAgIGlmICh0byA9PT0gZmFsc2UgfHwgaXNOYU4odG8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0aGUgc2xpZGVyIHZhbHVlLlxuICAgICAgICBmdW5jdGlvbiB2YWx1ZVNldChpbnB1dCwgZmlyZVNldEV2ZW50LCBleGFjdElucHV0KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gYXNBcnJheShpbnB1dCk7XG4gICAgICAgICAgICB2YXIgaXNJbml0ID0gc2NvcGVfTG9jYXRpb25zWzBdID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBFdmVudCBmaXJlcyBieSBkZWZhdWx0XG4gICAgICAgICAgICBmaXJlU2V0RXZlbnQgPSBmaXJlU2V0RXZlbnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmaXJlU2V0RXZlbnQ7XG4gICAgICAgICAgICAvLyBBbmltYXRpb24gaXMgb3B0aW9uYWwuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGluaXRpYWwgdmFsdWVzIHdlcmUgc2V0IGJlZm9yZSB1c2luZyBhbmltYXRlZCBwbGFjZW1lbnQuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRlICYmICFpc0luaXQpIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzc0ZvcihzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXAsIG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmlyc3QgcGFzcywgd2l0aG91dCBsb29rQWhlYWQgYnV0IHdpdGggbG9va0JhY2t3YXJkLiBWYWx1ZXMgYXJlIHNldCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHJlc29sdmVUb1ZhbHVlKHZhbHVlc1toYW5kbGVOdW1iZXJdLCBoYW5kbGVOdW1iZXIpLCB0cnVlLCBmYWxzZSwgZXhhY3RJbnB1dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBpID0gc2NvcGVfSGFuZGxlTnVtYmVycy5sZW5ndGggPT09IDEgPyAwIDogMTtcbiAgICAgICAgICAgIC8vIFNwcmVhZCBoYW5kbGVzIGV2ZW5seSBhY3Jvc3MgdGhlIHNsaWRlciBpZiB0aGUgcmFuZ2UgaGFzIG5vIHNpemUgKG1pbj1tYXgpXG4gICAgICAgICAgICBpZiAoaXNJbml0ICYmIHNjb3BlX1NwZWN0cnVtLmhhc05vU2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgZXhhY3RJbnB1dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2NvcGVfTG9jYXRpb25zWzBdID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlTnVtYmVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZV8xID0gMTAwIC8gKHNjb3BlX0hhbmRsZU51bWJlcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSA9IGhhbmRsZU51bWJlciAqIHNwYWNlXzE7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNlY29uZGFyeSBwYXNzZXMuIE5vdyB0aGF0IGFsbCBiYXNlIHZhbHVlcyBhcmUgc2V0LCBhcHBseSBjb25zdHJhaW50cy5cbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgYWxsIGhhbmRsZXMgdG8gZW5zdXJlIGNvbnN0cmFpbnRzIGFyZSBhcHBsaWVkIGZvciB0aGUgZW50aXJlIHNsaWRlciAoSXNzdWUgIzEwMDkpXG4gICAgICAgICAgICBmb3IgKDsgaSA8IHNjb3BlX0hhbmRsZU51bWJlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSwgdHJ1ZSwgdHJ1ZSwgZXhhY3RJbnB1dCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRaaW5kZXgoKTtcbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgLy8gRmlyZSB0aGUgZXZlbnQgb25seSBmb3IgaGFuZGxlcyB0aGF0IHJlY2VpdmVkIGEgbmV3IHZhbHVlLCBhcyBwZXIgIzU3OVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbaGFuZGxlTnVtYmVyXSAhPT0gbnVsbCAmJiBmaXJlU2V0RXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgc2xpZGVyIHRvIGluaXRpYWwgdmFsdWVzXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlUmVzZXQoZmlyZVNldEV2ZW50KSB7XG4gICAgICAgICAgICB2YWx1ZVNldChvcHRpb25zLnN0YXJ0LCBmaXJlU2V0RXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB2YWx1ZSBmb3IgYSBzaW5nbGUgaGFuZGxlXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlU2V0SGFuZGxlKGhhbmRsZU51bWJlciwgdmFsdWUsIGZpcmVTZXRFdmVudCwgZXhhY3RJbnB1dCkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIG51bWVyaWMgaW5wdXRcbiAgICAgICAgICAgIGhhbmRsZU51bWJlciA9IE51bWJlcihoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgaWYgKCEoaGFuZGxlTnVtYmVyID49IDAgJiYgaGFuZGxlTnVtYmVyIDwgc2NvcGVfSGFuZGxlTnVtYmVycy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogaW52YWxpZCBoYW5kbGUgbnVtYmVyLCBnb3Q6IFwiICsgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExvb2sgYm90aCBiYWNrd2FyZCBhbmQgZm9yd2FyZCwgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0aGlzIGhhbmRsZSB0byBcInB1c2hcIiBvdGhlciBoYW5kbGVzICgjOTYwKTtcbiAgICAgICAgICAgIC8vIFRoZSBleGFjdElucHV0IGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvIGlnbm9yZSBzbGlkZXIgc3RlcHBpbmcgKCM0MzYpXG4gICAgICAgICAgICBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCByZXNvbHZlVG9WYWx1ZSh2YWx1ZSwgaGFuZGxlTnVtYmVyKSwgdHJ1ZSwgdHJ1ZSwgZXhhY3RJbnB1dCk7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIGlmIChmaXJlU2V0RXZlbnQpIHtcbiAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJzZXRcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIHNsaWRlciB2YWx1ZS5cbiAgICAgICAgZnVuY3Rpb24gdmFsdWVHZXQodW5lbmNvZGVkKSB7XG4gICAgICAgICAgICBpZiAodW5lbmNvZGVkID09PSB2b2lkIDApIHsgdW5lbmNvZGVkID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmICh1bmVuY29kZWQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gYSBjb3B5IG9mIHRoZSByYXcgdmFsdWVzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1ZhbHVlcy5sZW5ndGggPT09IDEgPyBzY29wZV9WYWx1ZXNbMF0gOiBzY29wZV9WYWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gc2NvcGVfVmFsdWVzLm1hcChvcHRpb25zLmZvcm1hdC50byk7XG4gICAgICAgICAgICAvLyBJZiBvbmx5IG9uZSBoYW5kbGUgaXMgdXNlZCwgcmV0dXJuIGEgc2luZ2xlIHZhbHVlLlxuICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmVzIGNsYXNzZXMgZnJvbSB0aGUgcm9vdCBhbmQgZW1wdGllcyBpdC5cbiAgICAgICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBwcm90ZWN0ZWQgaW50ZXJuYWwgbGlzdGVuZXJzXG4gICAgICAgICAgICByZW1vdmVFdmVudChJTlRFUk5BTF9FVkVOVF9OUy5hcmlhKTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50KElOVEVSTkFMX0VWRU5UX05TLnRvb2x0aXBzKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMuY3NzQ2xhc3NlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXNba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdoaWxlIChzY29wZV9UYXJnZXQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHNjb3BlX1RhcmdldC5yZW1vdmVDaGlsZChzY29wZV9UYXJnZXQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgc2NvcGVfVGFyZ2V0Lm5vVWlTbGlkZXI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0TmV4dFN0ZXBzRm9ySGFuZGxlKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl07XG4gICAgICAgICAgICB2YXIgbmVhcmJ5U3RlcHMgPSBzY29wZV9TcGVjdHJ1bS5nZXROZWFyYnlTdGVwcyhsb2NhdGlvbik7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzY29wZV9WYWx1ZXNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICAgIHZhciBpbmNyZW1lbnQgPSBuZWFyYnlTdGVwcy50aGlzU3RlcC5zdGVwO1xuICAgICAgICAgICAgdmFyIGRlY3JlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAvLyBJZiBzbmFwcGVkLCBkaXJlY3RseSB1c2UgZGVmaW5lZCBzdGVwIHZhbHVlXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zbmFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgLSBuZWFyYnlTdGVwcy5zdGVwQmVmb3JlLnN0YXJ0VmFsdWUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbmVhcmJ5U3RlcHMuc3RlcEFmdGVyLnN0YXJ0VmFsdWUgLSB2YWx1ZSB8fCBudWxsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IHZhbHVlIGluIHRoaXMgc3RlcCBtb3ZlcyBpbnRvIHRoZSBuZXh0IHN0ZXAsXG4gICAgICAgICAgICAvLyB0aGUgaW5jcmVtZW50IGlzIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBzdGVwIC0gdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICsgaW5jcmVtZW50ID4gbmVhcmJ5U3RlcHMuc3RlcEFmdGVyLnN0YXJ0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50ID0gbmVhcmJ5U3RlcHMuc3RlcEFmdGVyLnN0YXJ0VmFsdWUgLSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYmV5b25kIHRoZSBzdGFydGluZyBwb2ludFxuICAgICAgICAgICAgaWYgKHZhbHVlID4gbmVhcmJ5U3RlcHMudGhpc1N0ZXAuc3RhcnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGRlY3JlbWVudCA9IG5lYXJieVN0ZXBzLnRoaXNTdGVwLnN0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZWFyYnlTdGVwcy5zdGVwQmVmb3JlLnN0ZXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBhIGhhbmRsZSBpcyBhdCB0aGUgc3RhcnQgb2YgYSBzdGVwLCBpdCBhbHdheXMgc3RlcHMgYmFjayBpbnRvIHRoZSBwcmV2aW91cyBzdGVwIGZpcnN0XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnQgPSB2YWx1ZSAtIG5lYXJieVN0ZXBzLnN0ZXBCZWZvcmUuaGlnaGVzdFN0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3csIGlmIGF0IHRoZSBzbGlkZXIgZWRnZXMsIHRoZXJlIGlzIG5vIGluL2RlY3JlbWVudFxuICAgICAgICAgICAgaWYgKGxvY2F0aW9uID09PSAxMDApIHtcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobG9jYXRpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXMgcGVyICMzOTEsIHRoZSBjb21wYXJpc29uIGZvciB0aGUgZGVjcmVtZW50IHN0ZXAgY2FuIGhhdmUgc29tZSByb3VuZGluZyBpc3N1ZXMuXG4gICAgICAgICAgICB2YXIgc3RlcERlY2ltYWxzID0gc2NvcGVfU3BlY3RydW0uY291bnRTdGVwRGVjaW1hbHMoKTtcbiAgICAgICAgICAgIC8vIFJvdW5kIHBlciAjMzkxXG4gICAgICAgICAgICBpZiAoaW5jcmVtZW50ICE9PSBudWxsICYmIGluY3JlbWVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnQgPSBOdW1iZXIoaW5jcmVtZW50LnRvRml4ZWQoc3RlcERlY2ltYWxzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVjcmVtZW50ICE9PSBudWxsICYmIGRlY3JlbWVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnQgPSBOdW1iZXIoZGVjcmVtZW50LnRvRml4ZWQoc3RlcERlY2ltYWxzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2RlY3JlbWVudCwgaW5jcmVtZW50XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgc3RlcCBzaXplIGZvciB0aGUgc2xpZGVyLlxuICAgICAgICBmdW5jdGlvbiBnZXROZXh0U3RlcHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVfSGFuZGxlTnVtYmVycy5tYXAoZ2V0TmV4dFN0ZXBzRm9ySGFuZGxlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGFibGU6IG1hcmdpbiwgbGltaXQsIHBhZGRpbmcsIHN0ZXAsIHJhbmdlLCBhbmltYXRlLCBzbmFwXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMob3B0aW9uc1RvVXBkYXRlLCBmaXJlU2V0RXZlbnQpIHtcbiAgICAgICAgICAgIC8vIFNwZWN0cnVtIGlzIGNyZWF0ZWQgdXNpbmcgdGhlIHJhbmdlLCBzbmFwLCBkaXJlY3Rpb24gYW5kIHN0ZXAgb3B0aW9ucy5cbiAgICAgICAgICAgIC8vICdzbmFwJyBhbmQgJ3N0ZXAnIGNhbiBiZSB1cGRhdGVkLlxuICAgICAgICAgICAgLy8gSWYgJ3NuYXAnIGFuZCAnc3RlcCcgYXJlIG5vdCBwYXNzZWQsIHRoZXkgc2hvdWxkIHJlbWFpbiB1bmNoYW5nZWQuXG4gICAgICAgICAgICB2YXIgdiA9IHZhbHVlR2V0KCk7XG4gICAgICAgICAgICB2YXIgdXBkYXRlQWJsZSA9IFtcbiAgICAgICAgICAgICAgICBcIm1hcmdpblwiLFxuICAgICAgICAgICAgICAgIFwibGltaXRcIixcbiAgICAgICAgICAgICAgICBcInBhZGRpbmdcIixcbiAgICAgICAgICAgICAgICBcInJhbmdlXCIsXG4gICAgICAgICAgICAgICAgXCJhbmltYXRlXCIsXG4gICAgICAgICAgICAgICAgXCJzbmFwXCIsXG4gICAgICAgICAgICAgICAgXCJzdGVwXCIsXG4gICAgICAgICAgICAgICAgXCJmb3JtYXRcIixcbiAgICAgICAgICAgICAgICBcInBpcHNcIixcbiAgICAgICAgICAgICAgICBcInRvb2x0aXBzXCJcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICAvLyBPbmx5IGNoYW5nZSBvcHRpb25zIHRoYXQgd2UncmUgYWN0dWFsbHkgcGFzc2VkIHRvIHVwZGF0ZS5cbiAgICAgICAgICAgIHVwZGF0ZUFibGUuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciB1bmRlZmluZWQuIG51bGwgcmVtb3ZlcyB0aGUgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNUb1VwZGF0ZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsT3B0aW9uc1tuYW1lXSA9IG9wdGlvbnNUb1VwZGF0ZVtuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBuZXdPcHRpb25zID0gdGVzdE9wdGlvbnMob3JpZ2luYWxPcHRpb25zKTtcbiAgICAgICAgICAgIC8vIExvYWQgbmV3IG9wdGlvbnMgaW50byB0aGUgc2xpZGVyIHN0YXRlXG4gICAgICAgICAgICB1cGRhdGVBYmxlLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc1RvVXBkYXRlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tuYW1lXSA9IG5ld09wdGlvbnNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzY29wZV9TcGVjdHJ1bSA9IG5ld09wdGlvbnMuc3BlY3RydW07XG4gICAgICAgICAgICAvLyBMaW1pdCwgbWFyZ2luIGFuZCBwYWRkaW5nIGRlcGVuZCBvbiB0aGUgc3BlY3RydW0gYnV0IGFyZSBzdG9yZWQgb3V0c2lkZSBvZiBpdC4gKCM2NzcpXG4gICAgICAgICAgICBvcHRpb25zLm1hcmdpbiA9IG5ld09wdGlvbnMubWFyZ2luO1xuICAgICAgICAgICAgb3B0aW9ucy5saW1pdCA9IG5ld09wdGlvbnMubGltaXQ7XG4gICAgICAgICAgICBvcHRpb25zLnBhZGRpbmcgPSBuZXdPcHRpb25zLnBhZGRpbmc7XG4gICAgICAgICAgICAvLyBVcGRhdGUgcGlwcywgcmVtb3ZlcyBleGlzdGluZy5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBpcHMpIHtcbiAgICAgICAgICAgICAgICBwaXBzKG9wdGlvbnMucGlwcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmVQaXBzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgdG9vbHRpcHMsIHJlbW92ZXMgZXhpc3RpbmcuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwcykge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmVUb29sdGlwcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSB0aGUgY3VycmVudCBwb3NpdGlvbmluZyBzbyB2YWx1ZVNldCBmb3JjZXMgYW4gdXBkYXRlLlxuICAgICAgICAgICAgc2NvcGVfTG9jYXRpb25zID0gW107XG4gICAgICAgICAgICB2YWx1ZVNldChpc1NldChvcHRpb25zVG9VcGRhdGUuc3RhcnQpID8gb3B0aW9uc1RvVXBkYXRlLnN0YXJ0IDogdiwgZmlyZVNldEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbml0aWFsaXphdGlvbiBzdGVwc1xuICAgICAgICBmdW5jdGlvbiBzZXR1cFNsaWRlcigpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgYmFzZSBlbGVtZW50LCBpbml0aWFsaXplIEhUTUwgYW5kIHNldCBjbGFzc2VzLlxuICAgICAgICAgICAgLy8gQWRkIGhhbmRsZXMgYW5kIGNvbm5lY3QgZWxlbWVudHMuXG4gICAgICAgICAgICBzY29wZV9CYXNlID0gYWRkU2xpZGVyKHNjb3BlX1RhcmdldCk7XG4gICAgICAgICAgICBhZGRFbGVtZW50cyhvcHRpb25zLmNvbm5lY3QsIHNjb3BlX0Jhc2UpO1xuICAgICAgICAgICAgLy8gQXR0YWNoIHVzZXIgZXZlbnRzLlxuICAgICAgICAgICAgYmluZFNsaWRlckV2ZW50cyhvcHRpb25zLmV2ZW50cyk7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIHB1YmxpYyB2YWx1ZSBtZXRob2QgdG8gc2V0IHRoZSBzdGFydCB2YWx1ZXMuXG4gICAgICAgICAgICB2YWx1ZVNldChvcHRpb25zLnN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBpcHMpIHtcbiAgICAgICAgICAgICAgICBwaXBzKG9wdGlvbnMucGlwcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwcykge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmlhKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0dXBTbGlkZXIoKTtcbiAgICAgICAgdmFyIHNjb3BlX1NlbGYgPSB7XG4gICAgICAgICAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgICAgICAgICAgc3RlcHM6IGdldE5leHRTdGVwcyxcbiAgICAgICAgICAgIG9uOiBiaW5kRXZlbnQsXG4gICAgICAgICAgICBvZmY6IHJlbW92ZUV2ZW50LFxuICAgICAgICAgICAgZ2V0OiB2YWx1ZUdldCxcbiAgICAgICAgICAgIHNldDogdmFsdWVTZXQsXG4gICAgICAgICAgICBzZXRIYW5kbGU6IHZhbHVlU2V0SGFuZGxlLFxuICAgICAgICAgICAgcmVzZXQ6IHZhbHVlUmVzZXQsXG4gICAgICAgICAgICAvLyBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcsIGRvbid0IHVzZSB0aGlzIGluIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICAgICAgICBfX21vdmVIYW5kbGVzOiBmdW5jdGlvbiAodXB3YXJkLCBwcm9wb3NhbCwgaGFuZGxlTnVtYmVycykge1xuICAgICAgICAgICAgICAgIG1vdmVIYW5kbGVzKHVwd2FyZCwgcHJvcG9zYWwsIHNjb3BlX0xvY2F0aW9ucywgaGFuZGxlTnVtYmVycyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9uczogb3JpZ2luYWxPcHRpb25zLFxuICAgICAgICAgICAgdXBkYXRlT3B0aW9uczogdXBkYXRlT3B0aW9ucyxcbiAgICAgICAgICAgIHRhcmdldDogc2NvcGVfVGFyZ2V0LFxuICAgICAgICAgICAgcmVtb3ZlUGlwczogcmVtb3ZlUGlwcyxcbiAgICAgICAgICAgIHJlbW92ZVRvb2x0aXBzOiByZW1vdmVUb29sdGlwcyxcbiAgICAgICAgICAgIGdldFBvc2l0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZV9Mb2NhdGlvbnMuc2xpY2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRUb29sdGlwczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZV9Ub29sdGlwcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRPcmlnaW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX0hhbmRsZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGlwczogcGlwcyAvLyBJc3N1ZSAjNTk0XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzY29wZV9TZWxmO1xuICAgIH1cbiAgICAvLyBSdW4gdGhlIHN0YW5kYXJkIGluaXRpYWxpemVyXG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZSh0YXJnZXQsIG9yaWdpbmFsT3B0aW9ucykge1xuICAgICAgICBpZiAoIXRhcmdldCB8fCAhdGFyZ2V0Lm5vZGVOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiBjcmVhdGUgcmVxdWlyZXMgYSBzaW5nbGUgZWxlbWVudCwgZ290OiBcIiArIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgdGhlIHNsaWRlciB3YXMgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgICAgICAgaWYgKHRhcmdldC5ub1VpU2xpZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiBTbGlkZXIgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3QgdGhlIG9wdGlvbnMgYW5kIGNyZWF0ZSB0aGUgc2xpZGVyIGVudmlyb25tZW50O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRlc3RPcHRpb25zKG9yaWdpbmFsT3B0aW9ucyk7XG4gICAgICAgIHZhciBhcGkgPSBzY29wZSh0YXJnZXQsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucyk7XG4gICAgICAgIHRhcmdldC5ub1VpU2xpZGVyID0gYXBpO1xuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH1cbiAgICB2YXIgbm91aXNsaWRlciA9IHtcbiAgICAgICAgLy8gRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLCBkb24ndCB1c2UgdGhpcyBpbiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAgICBfX3NwZWN0cnVtOiBTcGVjdHJ1bSxcbiAgICAgICAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGRlZmF1bHQgY2xhc3NlcywgYWxsb3dzIGdsb2JhbCBjaGFuZ2VzLlxuICAgICAgICAvLyBVc2UgdGhlIGNzc0NsYXNzZXMgb3B0aW9uIGZvciBjaGFuZ2VzIHRvIG9uZSBzbGlkZXIuXG4gICAgICAgIGNzc0NsYXNzZXM6IGNzc0NsYXNzZXMsXG4gICAgICAgIGNyZWF0ZTogaW5pdGlhbGl6ZVxuICAgIH07XG5cbiAgICBleHBvcnRzLmNyZWF0ZSA9IGluaXRpYWxpemU7XG4gICAgZXhwb3J0cy5jc3NDbGFzc2VzID0gY3NzQ2xhc3NlcztcbiAgICBleHBvcnRzWydkZWZhdWx0J10gPSBub3Vpc2xpZGVyO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsICJpbXBvcnQgeyBQYXJzZXIsIHRyYW5zZm9ybXMgfSBmcm9tIFwianNvbjJjc3ZcIjtcclxuaW1wb3J0IHsgRGF0ZVRpbWUgfSBmcm9tIFwibHV4b25cIjtcclxuaW1wb3J0IHsgbm9ybWFsaXplUGF0aCwgTm90aWNlLCBQbHVnaW4gfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHsgb3BlblZpZXcgfSBmcm9tIFwib2JzaWRpYW4tY29tbXVuaXR5LWxpYlwiO1xyXG5pbXBvcnQgeyBDaGFydE1vZGFsIH0gZnJvbSBcIi4vQ2hhcnRNb2RhbFwiO1xyXG5pbXBvcnQge1xyXG5cdENPUlJFTEFUSU9OX1JFUE9SVF9WSUVXLFxyXG5cdENPUlJFTEFUSU9OX1ZJRVcsXHJcblx0REVGQVVMVF9TRVRUSU5HUyxcclxuXHRkcm9wSGVhZGVyT3JBbGlhcyxcclxuXHRzcGxpdExpbmtzUmVnZXgsXHJcbn0gZnJvbSBcIi4vY29uc3RcIjtcclxuaW1wb3J0IENvcnJlbGF0aW9uc1JlcG9ydFZpZXcgZnJvbSBcIi4vQ29ycmVsYXRpb25zUmVwb3J0Vmlld1wiO1xyXG5pbXBvcnQge1xyXG5cdGJ1aWxkQWxsQ29ycmVsYXRpb25zLFxyXG5cdHByb2Nlc3NQYWdlcyxcclxuXHR1bnByb3h5LFxyXG59IGZyb20gXCIuL2NvcnJlbGF0aW9uVXRpbHNcIjtcclxuaW1wb3J0IENvcnJlbGF0aW9uVmlldyBmcm9tIFwiLi9Db3JyZWxhdGlvblZpZXdcIjtcclxuaW1wb3J0IHtcclxuXHRDb3JyZWxhdGlvbnMsXHJcblx0RGF0YVR5cGUsXHJcblx0UHJlc2V0RmllbGQsXHJcblx0Um93LFxyXG5cdFNldHRpbmdzLFxyXG5cdFN1cGVyY2hhcmdlZEZpZWxkLFxyXG59IGZyb20gXCIuL2ludGVyZmFjZXNcIjtcclxuaW1wb3J0IHsgU2V0dGluZ1RhYiB9IGZyb20gXCIuL1NldHRpbmdUYWJcIjtcclxuaW1wb3J0IHsgU3RhdHNNb2RhbCB9IGZyb20gXCIuL1N0YXRzTW9kYWxcIjtcclxuaW1wb3J0IHtcclxuXHRkcm9wV2lraSxcclxuXHRtYWtlQXJyLFxyXG5cdG1ha2VTdWIsXHJcblx0c3BsaXRBbmRUcmltLFxyXG5cdHN0cmluZ1RvTnVsbE9yVW5kZWZpbmVkLFxyXG59IGZyb20gXCIuL3V0aWxzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhQW5hbHlzaXNQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xyXG5cdHNldHRpbmdzOiBTZXR0aW5ncztcclxuXHRpbmRleDoge1xyXG5cdFx0ZGF0YTogeyBbZmllbGQ6IHN0cmluZ106IERhdGFUeXBlIH1bXTtcclxuXHRcdGRhdGFNYXA6IHsgW2ZpZWxkOiBzdHJpbmddOiBEYXRhVHlwZVtdIH07XHJcblx0XHRjb3JyczogQ29ycmVsYXRpb25zO1xyXG5cdFx0bWluRGF0ZTogRGF0ZVRpbWU7XHJcblx0XHRtYXhEYXRlOiBEYXRlVGltZTtcclxuXHR9ID0ge1xyXG5cdFx0ZGF0YTogdW5kZWZpbmVkLFxyXG5cdFx0ZGF0YU1hcDogdW5kZWZpbmVkLFxyXG5cdFx0Y29ycnM6IHVuZGVmaW5lZCxcclxuXHRcdG1pbkRhdGU6IHVuZGVmaW5lZCxcclxuXHRcdG1heERhdGU6IHVuZGVmaW5lZCxcclxuXHR9O1xyXG5cclxuXHR1bndyYXBwZWRGaWVsZHM6IHsgW2ZpZWxkOiBzdHJpbmddOiBzdHJpbmdbXSB9ID0ge307XHJcblxyXG5cdGFzeW5jIG9ubG9hZCgpIHtcclxuXHRcdGNvbnNvbGUubG9nKFwiTG9hZGluZyBkYXRhLWFuYWx5c2lzIHBsdWdpblwiKTtcclxuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XHJcblxyXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XHJcblxyXG5cdFx0Y29uc3Qgb25BUElSZWFkeSA9IGFzeW5jICgpID0+IHtcclxuXHRcdFx0dGhpcy5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkoYXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRcdGF3YWl0IHRoaXMucmVmcmVzaEluZGV4KCk7XHJcblx0XHRcdFx0dGhpcy5pbmRleC5jb3JycyA9IGJ1aWxkQWxsQ29ycmVsYXRpb25zKFxyXG5cdFx0XHRcdFx0dGhpcy5pbmRleC5kYXRhLFxyXG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5maWVsZHNUb0NoZWNrLFxyXG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5maWVsZHNUb0lnbm9yZUZvckNvcnJzLFxyXG5cdFx0XHRcdFx0dHJ1ZVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGhpcy5hcHAucGx1Z2lucy5lbmFibGVkUGx1Z2lucy5oYXMoXCJkYXRhdmlld1wiKSkge1xyXG5cdFx0XHRjb25zdCBhcGkgPSB0aGlzLmFwcC5wbHVnaW5zLnBsdWdpbnMuZGF0YXZpZXc/LmFwaTtcclxuXHRcdFx0aWYgKGFwaSkgYXdhaXQgb25BUElSZWFkeSgpO1xyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR0aGlzLnJlZ2lzdGVyRXZlbnQoXHJcblx0XHRcdFx0XHR0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLm9uKFxyXG5cdFx0XHRcdFx0XHRcImRhdGF2aWV3OmFwaS1yZWFkeVwiLFxyXG5cdFx0XHRcdFx0XHRhc3luYyAoYXBpKSA9PiB7XHJcblx0XHRcdFx0XHRcdFx0YXdhaXQgb25BUElSZWFkeSgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHQpXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmV3IE5vdGljZShcclxuXHRcdFx0XHRcIkRhdGF2aWV3IG11c3QgYmUgZW5hYmxlZCBmb3IgdGhlIERhdGEgQW5hbHlzaXMgcGx1Z2luIHRvIHdvcmtcIlxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XHJcblx0XHRcdGlkOiBcInJlZnJlc2gtaW5kZXhcIixcclxuXHRcdFx0bmFtZTogXCJSZWZyZXNoIEluZGV4XCIsXHJcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLnJlZnJlc2hJbmRleCgpLFxyXG5cdFx0fSk7XHJcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xyXG5cdFx0XHRpZDogXCJjaGFydC12aWV3XCIsXHJcblx0XHRcdG5hbWU6IFwiT3BlbiBDaGFydCBNb2RhbFwiLFxyXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4gbmV3IENoYXJ0TW9kYWwodGhpcy5hcHAsIHRoaXMpLm9wZW4oKSxcclxuXHRcdH0pO1xyXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcclxuXHRcdFx0aWQ6IFwic3RhdHMtdmlld1wiLFxyXG5cdFx0XHRuYW1lOiBcIk9wZW4gU3RhdHMgTW9kYWxcIixcclxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IG5ldyBTdGF0c01vZGFsKHRoaXMuYXBwLCB0aGlzKS5vcGVuKCksXHJcblx0XHR9KTtcclxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XHJcblx0XHRcdGlkOiBcImJ1aWxkcy1jb3Jyc1wiLFxyXG5cdFx0XHRuYW1lOiBcIkJ1aWxkIENvcnJlbGF0aW9uc1wiLFxyXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGNvcnJzID0gYnVpbGRBbGxDb3JyZWxhdGlvbnMoXHJcblx0XHRcdFx0XHR0aGlzLmluZGV4LmRhdGEsXHJcblx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmZpZWxkc1RvQ2hlY2ssXHJcblx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmZpZWxkc1RvSWdub3JlRm9yQ29ycnMsXHJcblx0XHRcdFx0XHR0cnVlXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHQvLyBUT0RPOiBkb24ndCB3ZSB3YW50IHRvIHNldCB0aGUgaW5kZXguY29ycnMgdG8gdGhlIHZhbHVlIGhlcmU/XHJcblx0XHRcdFx0Y29uc29sZS5sb2coY29ycnMpO1xyXG5cdFx0XHR9LFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcclxuXHRcdFx0aWQ6IFwiZXhwb3J0LWRhdGFcIixcclxuXHRcdFx0bmFtZTogXCJFeHBvcnQgRGF0YVwiLFxyXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRjb25zdCBqc0RGID0gYXdhaXQgdGhpcy5jcmVhdGVKU0RGKCk7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhqc0RGKTtcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMud3JpdGVNZXRhZGF0YWZyYW1lKGpzREYpO1xyXG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XHJcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiQW4gZXJyb3Igb2NjdXJlZC4gUGxlYXNlIGNoZWNrIHRoZSBjb25zb2xlLlwiKTtcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGVycm9yKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xyXG5cdFx0XHRpZDogXCJvcGVuLWNvcnJlbGF0aW9uLXZpZXdcIixcclxuXHRcdFx0bmFtZTogXCJPcGVuIEZpbGUgQ29ycmVsYXRpb25zIFZpZXdcIixcclxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+XHJcblx0XHRcdFx0YXdhaXQgb3BlblZpZXcodGhpcy5hcHAsIENPUlJFTEFUSU9OX1ZJRVcsIENvcnJlbGF0aW9uVmlldyksXHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xyXG5cdFx0XHRpZDogXCJvcGVuLWNvcnJlbGF0aW9uLXJlcG9ydFwiLFxyXG5cdFx0XHRuYW1lOiBcIk9wZW4gQ29ycmVsYXRpb25zIFN1bW1hcnkgUmVwb3J0XCIsXHJcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PlxyXG5cdFx0XHRcdGF3YWl0IG9wZW5WaWV3KFxyXG5cdFx0XHRcdFx0dGhpcy5hcHAsXHJcblx0XHRcdFx0XHRDT1JSRUxBVElPTl9SRVBPUlRfVklFVyxcclxuXHRcdFx0XHRcdENvcnJlbGF0aW9uc1JlcG9ydFZpZXdcclxuXHRcdFx0XHQpLFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5yZWdpc3RlclZpZXcoXHJcblx0XHRcdENPUlJFTEFUSU9OX1ZJRVcsXHJcblx0XHRcdChsZWFmKSA9PiBuZXcgQ29ycmVsYXRpb25WaWV3KGxlYWYsIHRoaXMpXHJcblx0XHQpO1xyXG5cclxuXHRcdHRoaXMucmVnaXN0ZXJWaWV3KFxyXG5cdFx0XHRDT1JSRUxBVElPTl9SRVBPUlRfVklFVyxcclxuXHRcdFx0KGxlYWYpID0+IG5ldyBDb3JyZWxhdGlvbnNSZXBvcnRWaWV3KGxlYWYsIHRoaXMpXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0b251bmxvYWQoKSB7XHJcblx0XHR0aGlzLmFwcC53b3Jrc3BhY2VcclxuXHRcdFx0LmdldExlYXZlc09mVHlwZShDT1JSRUxBVElPTl9WSUVXKVxyXG5cdFx0XHQuZm9yRWFjaCgobGVhZikgPT4gbGVhZi5kZXRhY2goKSk7XHJcblx0fVxyXG5cclxuXHRnZXREVkFQSSA9ICgpID0+IHRoaXMuYXBwLnBsdWdpbnMucGx1Z2lucy5kYXRhdmlldz8uYXBpO1xyXG5cclxuXHR1bnByb3h5KGl0ZW06IGFueSk6IERhdGFUeXBlW10ge1xyXG5cdFx0Y29uc3QgdW5wcm94aWVkID0gW107XHJcblxyXG5cdFx0Y29uc3QgcXVldWUgPSBbaXRlbV07XHJcblx0XHR3aGlsZSAocXVldWUubGVuZ3RoKSB7XHJcblx0XHRcdGNvbnN0IGN1cnJJdGVtID0gcXVldWUuc2hpZnQoKTtcclxuXHRcdFx0Ly8gXCJQcm94eVwiIGZvciBjaGVja2luZyBpZiBgY3Vyckl0ZW1gIGlzIGEgcHJveHlcclxuXHRcdFx0aWYgKHR5cGVvZiBjdXJySXRlbS5kZWZhdWx0Q29tcGFyYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRcdFx0Y29uc3QgcG9zc2libGVVbnByb3hpZWQgPSBPYmplY3QuYXNzaWduKHt9LCBjdXJySXRlbSk7XHJcblx0XHRcdFx0Y29uc3QgeyB2YWx1ZXMgfSA9IHBvc3NpYmxlVW5wcm94aWVkO1xyXG5cdFx0XHRcdGlmICh2YWx1ZXMpIHF1ZXVlLnB1c2goLi4udmFsdWVzKTtcclxuXHRcdFx0XHRlbHNlIHVucHJveGllZC5wdXNoKHBvc3NpYmxlVW5wcm94aWVkKTtcclxuXHRcdFx0fSBlbHNlIHVucHJveGllZC5wdXNoKGN1cnJJdGVtKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB1bnByb3hpZWQ7XHJcblx0fVxyXG5cclxuXHRnZXRJbm5lclZhbHVlKHZhbHVlOiBhbnkpIHtcclxuXHRcdGNvbnN0IHVucHJveGllZCA9IHRoaXMudW5wcm94eSh2YWx1ZSk7XHJcblx0XHRpZiAodW5wcm94aWVkLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHRpZiAodHlwZW9mIHVucHJveGllZFswXSA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRcdGxldCBsaXN0ID0gdW5wcm94aWVkWzBdO1xyXG5cdFx0XHRcdGlmIChsaXN0LnN0YXJ0c1dpdGgoXCJbXCIpICYmIGxpc3QuZW5kc1dpdGgoXCJdXCIpKSB7XHJcblx0XHRcdFx0XHRsaXN0ID0gbGlzdC5zbGljZSgxLCAtMSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNvbnN0IHNwbGl0cyA9IHNwbGl0QW5kVHJpbShsaXN0KS5tYXAoKGl0ZW0pID0+IHtcclxuXHRcdFx0XHRcdGlmIChpdGVtLnN0YXJ0c1dpdGgoYFwiYCkgJiYgaXRlbS5lbmRzV2l0aChgXCJgKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gaXRlbS5zbGljZSgxLCAtMSk7XHJcblx0XHRcdFx0XHR9IGVsc2UgcmV0dXJuIGl0ZW07XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0aWYgKHNwbGl0cy5sZW5ndGggPT09IDEpIHJldHVybiBzcGxpdHNbMF07XHJcblx0XHRcdFx0ZWxzZSByZXR1cm4gc3BsaXRzO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmICh1bnByb3hpZWRbMF0udHlwZSA9PT0gXCJmaWxlXCIpIHtcclxuXHRcdFx0XHRcdHJldHVybiB1bnByb3hpZWRbMF0ucGF0aDtcclxuXHRcdFx0XHR9IGVsc2UgcmV0dXJuIHVucHJveGllZFswXTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKHVucHJveGllZFswXS50eXBlID09PSBcImZpbGVcIikge1xyXG5cdFx0XHRcdHJldHVybiB1bnByb3hpZWQubWFwKChsaW5rKSA9PiBsaW5rLnBhdGgpO1xyXG5cdFx0XHR9IGVsc2UgcmV0dXJuIHVucHJveGllZDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGFzeW5jIGdldFN1cGVyY2hhcmdlZEZpZWxkcygpOiBQcm9taXNlPFN1cGVyY2hhcmdlZEZpZWxkW10+IHtcclxuXHRcdGNvbnN0IHsgYXBwLCBzZXR0aW5ncyB9ID0gdGhpcztcclxuXHJcblx0XHRjb25zdCBwcmVzZXRGaWVsZHM6IFByZXNldEZpZWxkW10gPVxyXG5cdFx0XHRhcHAucGx1Z2lucy5wbHVnaW5zW1wic3VwZXJjaGFyZ2VkLWxpbmtzLW9ic2lkaWFuXCJdPy5zZXR0aW5nc1xyXG5cdFx0XHRcdC5wcmVzZXRGaWVsZHM7XHJcblxyXG5cdFx0aWYgKCFwcmVzZXRGaWVsZHMpIHJldHVybiBudWxsO1xyXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKFxyXG5cdFx0XHRwcmVzZXRGaWVsZHMubWFwKGFzeW5jIChmaWVsZCkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHsgdmFsdWVzTGlzdE5vdGVQYXRoLCB2YWx1ZXMsIG5hbWUgfSA9IGZpZWxkO1xyXG5cdFx0XHRcdGNvbnN0IG5ld1ZhbHVlczogc3RyaW5nW10gPSBPYmplY3QudmFsdWVzKHZhbHVlcyk7XHJcblxyXG5cdFx0XHRcdGlmICh2YWx1ZXNMaXN0Tm90ZVBhdGgpIHtcclxuXHRcdFx0XHRcdGNvbnN0IGZpbGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KFxyXG5cdFx0XHRcdFx0XHR2YWx1ZXNMaXN0Tm90ZVBhdGgsXHJcblx0XHRcdFx0XHRcdFwiXCJcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRpZiAoIWZpbGUpIHJldHVybjtcclxuXHRcdFx0XHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5jYWNoZWRSZWFkKGZpbGUpO1xyXG5cdFx0XHRcdFx0Y29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KFwiXFxuXCIpO1xyXG5cclxuXHRcdFx0XHRcdGxpbmVzLmZvckVhY2goKGxpbmUpID0+IG5ld1ZhbHVlcy5wdXNoKGxpbmUpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB7IG5hbWUsIHZhbHVlczogbmV3VmFsdWVzIH07XHJcblx0XHRcdH0pXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0Ly8gSXQgbmVlZHMgdG8gdGFrZSBpbiBkYXRhIGFzIGFuIGFyZ3VtZW50LCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJlZm9yZSBkYXRhIGlzIGZpbmlzaGVkIGluaXRpYWxpc2luZ1xyXG5cdGFzeW5jIHVud3JhcFN0ckxpc3RzKGRhdGE6IHsgW2ZpZWxkOiBzdHJpbmddOiBhbnkgfVtdKSB7XHJcblx0XHRjb25zdCB7IHVud3JhcHBlZEZpZWxkcyB9ID0gdGhpcztcclxuXHRcdGNvbnN0IHsgZmllbGRzVG9DaGVjayB9ID0gdGhpcy5zZXR0aW5ncztcclxuXHJcblx0XHRjb25zdCBzY0ZpZWxkcyA9IGF3YWl0IHRoaXMuZ2V0U3VwZXJjaGFyZ2VkRmllbGRzKCk7XHJcblxyXG5cdFx0aWYgKHNjRmllbGRzKSB7XHJcblx0XHRcdGZvciAoY29uc3Qgc2NGaWVsZCBvZiBzY0ZpZWxkcykge1xyXG5cdFx0XHRcdGNvbnN0IHsgbmFtZSwgdmFsdWVzIH0gPSBzY0ZpZWxkO1xyXG5cdFx0XHRcdHVud3JhcHBlZEZpZWxkc1tuYW1lXSA9IFtdO1xyXG5cdFx0XHRcdGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XHJcblx0XHRcdFx0XHRpZiAodmFsdWUudHJpbSgpID09PSBcIlwiKSBjb250aW51ZTtcclxuXHRcdFx0XHRcdHVud3JhcHBlZEZpZWxkc1tuYW1lXS5wdXNoKGRyb3BXaWtpKHZhbHVlKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkc1RvQ2hlY2spIHtcclxuXHRcdFx0XHR1bndyYXBwZWRGaWVsZHNbZmllbGRdID0gW107XHJcblx0XHRcdFx0ZGF0YS5mb3JFYWNoKChkKSA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBjZWxsID0gZFtmaWVsZF07XHJcblxyXG5cdFx0XHRcdFx0Ly8gQlVHOiBEb24ndCBkbyB0aGlzIGZvciBfZXZlcnlfIHN0cmluZ1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBjZWxsID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdFx0XHRcdGRbY2VsbF0gPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRpZiAoIXVud3JhcHBlZEZpZWxkc1tmaWVsZF0uaW5jbHVkZXMoY2VsbCkpXHJcblx0XHRcdFx0XHRcdFx0dW53cmFwcGVkRmllbGRzW2ZpZWxkXS5wdXNoKGNlbGwpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChcclxuXHRcdFx0XHRcdFx0Y2VsbD8uZXZlcnkgJiZcclxuXHRcdFx0XHRcdFx0Y2VsbC5ldmVyeSgoeDogYW55KSA9PiB0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIilcclxuXHRcdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0XHRjZWxsLmZvckVhY2goKHN0cjogc3RyaW5nKSA9PiB7XHJcblx0XHRcdFx0XHRcdFx0ZFtzdHJdID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoIXVud3JhcHBlZEZpZWxkc1tmaWVsZF0uaW5jbHVkZXMoc3RyKSlcclxuXHRcdFx0XHRcdFx0XHRcdHVud3JhcHBlZEZpZWxkc1tmaWVsZF0ucHVzaChzdHIpO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRhc3luYyByZWZyZXNoSW5kZXgoKSB7XHJcblx0XHRjb25zdCBub3RpY2UgPSBuZXcgTm90aWNlKFwiSW5kZXggcmVmcmVzaGluZy4uLlwiKTtcclxuXHRcdGNvbnN0IGR2QXBpID0gdGhpcy5nZXREVkFQSSgpO1xyXG5cdFx0aWYgKCFkdkFwaSkge1xyXG5cdFx0XHRub3RpY2Uuc2V0TWVzc2FnZShcIkRhdGF2aWV3IG11c3QgYmUgZW5hYmxlZFwiKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0Y29uc3QgeyBhcHAsIHNldHRpbmdzIH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IHsgZmllbGRzVG9DaGVjaywgZmllbGRMaXN0cyB9ID0gc2V0dGluZ3M7XHJcblx0XHRmb3IgKGNvbnN0IHBhdGggb2YgZmllbGRMaXN0cykge1xyXG5cdFx0XHRjb25zdCBmaWxlID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QocGF0aCwgXCJcIik7XHJcblx0XHRcdGlmICghZmlsZSkgY29udGludWU7XHJcblxyXG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgYXBwLnZhdWx0LmNhY2hlZFJlYWQoZmlsZSk7XHJcblx0XHRcdGNvbnRlbnQuc3BsaXQoXCJcXG5cIikuZm9yRWFjaCgobGluZSkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGZpZWxkID0gZHJvcFdpa2kobGluZSk7XHJcblx0XHRcdFx0aWYgKCFmaWVsZHNUb0NoZWNrLmluY2x1ZGVzKGZpZWxkKSkgZmllbGRzVG9DaGVjay5wdXNoKGZpZWxkKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHNldHRpbmdzLmZpZWxkc1RvQ2hlY2sgPSBmaWVsZHNUb0NoZWNrO1xyXG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBwYWdlczogeyBbZmllbGQ6IHN0cmluZ106IGFueSB9W10gPSBkdkFwaS5wYWdlcygpLnZhbHVlcztcclxuXHRcdGNvbnN0IHJlc3VsdCA9IHByb2Nlc3NQYWdlcyhwYWdlcywgZmllbGRzVG9DaGVjayk7XHJcblxyXG5cdFx0YXdhaXQgdGhpcy51bndyYXBTdHJMaXN0cyhyZXN1bHQucGFnZXMpO1xyXG5cclxuXHRcdHRoaXMuaW5kZXguZGF0YSA9IHJlc3VsdC5wYWdlcztcclxuXHRcdHRoaXMuaW5kZXgubWluRGF0ZSA9IERhdGVUaW1lLm1pbiguLi5yZXN1bHQuZGF0ZXMpO1xyXG5cdFx0dGhpcy5pbmRleC5tYXhEYXRlID0gRGF0ZVRpbWUubWF4KC4uLnJlc3VsdC5kYXRlcyk7XHJcblxyXG5cdFx0Y29uc29sZS5sb2codGhpcy5pbmRleCk7XHJcblx0XHRub3RpY2Uuc2V0TWVzc2FnZShcIkluZGV4IHJlZnJlc2hlZCBcdTI3MDVcIik7XHJcblx0fVxyXG5cclxuXHRhbGxVbmlxdWVWYWx1ZXNGb3JGaWVsZChmaWVsZDogc3RyaW5nKSB7XHJcblx0XHRjb25zdCB2YWx1ZXM6IGFueVtdID0gW107XHJcblx0XHR0aGlzLmluZGV4LmRhdGEuZm9yRWFjaCgocGFnZSkgPT4ge1xyXG5cdFx0XHRpZiAocGFnZVtmaWVsZF0pIHtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHVucHJveHkocGFnZVtmaWVsZF0pO1xyXG5cdFx0XHRcdG1ha2VBcnIodmFsdWUpLmZvckVhY2goKHYpID0+IHtcclxuXHRcdFx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHZhbHVlcy5wdXNoKHYpO1xyXG5cdFx0XHRcdFx0ZWxzZSBpZiAodi5wYXRoKSB2YWx1ZXMucHVzaCh2LnBhdGgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gWy4uLm5ldyBTZXQoWy4uLnZhbHVlc10pXTtcclxuXHR9XHJcblxyXG5cdGluZmVyVHlwZShcclxuXHRcdHhzOiAoc3RyaW5nIHwgbnVtYmVyKVtdXHJcblx0KTogXCJzdHJpbmdcIiB8IFwibnVtYmVyXCIgfCBcIm9iamVjdFwiIHwgXCJ1bmRlZmluZWRcIiB7XHJcblx0XHRjb25zdCBkZWZpbmVkcyA9IHhzLmZpbHRlcigoeCkgPT4geCk7XHJcblx0XHRjb25zdCB0eXBlcyA9IGRlZmluZWRzLm1hcCgoeCkgPT4gdHlwZW9mIHgpO1xyXG5cdFx0aWYgKCFkZWZpbmVkcy5sZW5ndGgpIHJldHVybiBcInVuZGVmaW5lZFwiO1xyXG5cdFx0Y29uc3QgdGhyZXNoID0gZGVmaW5lZHMubGVuZ3RoIC8gMjtcclxuXHJcblx0XHRpZiAodHlwZXMuZmlsdGVyKCh4KSA9PiB4ID09PSBcIm51bWJlclwiKS5sZW5ndGggPj0gdGhyZXNoKVxyXG5cdFx0XHRyZXR1cm4gXCJudW1iZXJcIjtcclxuXHRcdGVsc2UgaWYgKHR5cGVzLmZpbHRlcigoeCkgPT4geCA9PT0gXCJzdHJpbmdcIikubGVuZ3RoID49IHRocmVzaClcclxuXHRcdFx0cmV0dXJuIFwic3RyaW5nXCI7XHJcblx0XHRlbHNlIHJldHVybiBcIm9iamVjdFwiO1xyXG5cdH1cclxuXHJcblx0cmVwbGFjZU1pc3NpbmcoeHM6IChzdHJpbmcgfCBudW1iZXIpW10pIHtcclxuXHRcdGNvbnN0IHR5cGUgPSB0aGlzLmluZmVyVHlwZSh4cyk7XHJcblx0XHRyZXR1cm4geHMubWFwKCh4KSA9PiB4ID8/ICh0eXBlID09PSBcIm51bWJlclwiID8gMCA6IFwiTi9BXCIpKTtcclxuXHR9XHJcblxyXG5cdC8vIFRlc3QgY29tbWVudFxyXG5cclxuXHRhc3luYyBjcmVhdGVKU0RGKCkge1xyXG5cdFx0Y29uc3QgeyBzZXR0aW5ncyB9ID0gdGhpcztcclxuXHRcdGNvbnN0IHtcclxuXHRcdFx0YWRkTm90ZUNvbnRlbnQsXHJcblx0XHRcdGFkZEZpbGVEYXRhLFxyXG5cdFx0XHRudWxsVmFsdWUsXHJcblx0XHRcdHVuZGVmaW5lZFZhbHVlLFxyXG5cdFx0XHRmaWVsZHNUb0NoZWNrLFxyXG5cdFx0fSA9IHNldHRpbmdzO1xyXG5cclxuXHRcdGNvbnN0IHRhYmxlOiBSb3dbXSA9IFtdO1xyXG5cdFx0Y29uc3QgdW5pcXVlS2V5czogc3RyaW5nW10gPSBbXTtcclxuXHJcblx0XHRsZXQgYWN0dWFsTnVsbFZhbHVlID0gc3RyaW5nVG9OdWxsT3JVbmRlZmluZWQobnVsbFZhbHVlKTtcclxuXHJcblx0XHRmb3IgKGNvbnN0IHBhZ2Ugb2YgdGhpcy5pbmRleC5kYXRhKSB7XHJcblx0XHRcdGNvbnN0IHsgZmlsZSB9ID0gcGFnZTtcclxuXHJcblx0XHRcdGNvbnN0IGN1cnJSb3c6IFJvdyA9IHsgZmlsZTogeyBwYXRoOiBmaWxlLnBhdGggfSwgY29udGVudDogXCJcIiB9O1xyXG5cclxuXHRcdFx0aWYgKGFkZE5vdGVDb250ZW50KSB7XHJcblx0XHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNhY2hlZFJlYWQoZmlsZSk7XHJcblx0XHRcdFx0Y3VyclJvd1tcImNvbnRlbnRcIl0gPSBjb250ZW50O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmdW5jdGlvbiB1cGRhdGVDZWxsKGNvbDogc3RyaW5nLCBjdXJyUm93OiBSb3cpIHtcclxuXHRcdFx0XHRpZiAoY29sICE9PSBcInBvc2l0aW9uXCIgJiYgKGNvbCAhPT0gXCJmaWxlXCIgfHwgYWRkRmlsZURhdGEpKSB7XHJcblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IHBhZ2VbY29sXTtcclxuXHRcdFx0XHRcdGNvbnN0IGFyclZhbHVlcyA9IFt2YWx1ZV0uZmxhdCg0KTtcclxuXHJcblx0XHRcdFx0XHQvLyBDb2xsZWN0IHVuaXF1ZSBrZXlzIGZvciBsYXRlclxyXG5cdFx0XHRcdFx0aWYgKCF1bmlxdWVLZXlzLmluY2x1ZGVzKGNvbCkpIHVuaXF1ZUtleXMucHVzaChjb2wpO1xyXG5cclxuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdFx0Ly8gTnVsbCB2YWx1ZXNcclxuXHRcdFx0XHRcdFx0Y3VyclJvd1tjb2xdID0gYWN0dWFsTnVsbFZhbHVlO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0XHRcdFx0Ly8gU3RyaW5nIHZhbHVlc1xyXG5cdFx0XHRcdFx0XHRjb25zdCBzcGxpdHMgPSB2YWx1ZS5tYXRjaChzcGxpdExpbmtzUmVnZXgpO1xyXG5cdFx0XHRcdFx0XHRpZiAoc3BsaXRzICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gV2lraWxpbmstc3RyaW5nc1xyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGxpbmtzID0gc3BsaXRzXHJcblx0XHRcdFx0XHRcdFx0XHQubWFwKChsaW5rKSA9PiB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGRyb3BwZWQgPVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxpbmsubWF0Y2goZHJvcEhlYWRlck9yQWxpYXMpPy5bMV07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZHJvcHBlZCA/IGBbWyR7ZHJvcHBlZH1dXWAgOiBsaW5rO1xyXG5cdFx0XHRcdFx0XHRcdFx0fSlcclxuXHRcdFx0XHRcdFx0XHRcdC5qb2luKFwiLCBcIik7XHJcblx0XHRcdFx0XHRcdFx0Y3VyclJvd1tjb2xdID0gbGlua3M7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gTm9uLWxpbmsgU3RyaW5nXHJcblx0XHRcdFx0XHRcdFx0Y3VyclJvd1tjb2xdID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYXJyVmFsdWVzPy5bMF0/LnRzKSB7XHJcblx0XHRcdFx0XHRcdC8vIERhdGVzXHJcblx0XHRcdFx0XHRcdGN1cnJSb3dbY29sXSA9IGFyclZhbHVlc1xyXG5cdFx0XHRcdFx0XHRcdC5tYXAoKHZhbCkgPT4gdmFsPy50cylcclxuXHRcdFx0XHRcdFx0XHQuam9pbihcIiwgXCIpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChhcnJWYWx1ZXM/LlswXT8ucGF0aCkge1xyXG5cdFx0XHRcdFx0XHQvLyBMaW5rIG9iamVjdHNcclxuXHRcdFx0XHRcdFx0Y3VyclJvd1tjb2xdID0gYXJyVmFsdWVzXHJcblx0XHRcdFx0XHRcdFx0Lm1hcCgodmFsKSA9PiBgW1ske3ZhbD8ucGF0aH1dXWApXHJcblx0XHRcdFx0XHRcdFx0LmpvaW4oXCIsIFwiKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoXHJcblx0XHRcdFx0XHRcdE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09XHJcblx0XHRcdFx0XHRcdFwiW29iamVjdCBPYmplY3RdXCJcclxuXHRcdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0XHRjdXJyUm93W2NvbF0gPSB2YWx1ZTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdC8vIE1pc2NlbGxhbmVvdXMgYXJyYXlzIGFyZSBqb2luZWQgaW50byBzdHJpbmdzXHJcblx0XHRcdFx0XHRcdGN1cnJSb3dbY29sXSA9IGFyclZhbHVlcy5qb2luKFwiLCBcIik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKGNvbnN0IGtleSBvZiBmaWVsZHNUb0NoZWNrKSB1cGRhdGVDZWxsKGtleSwgY3VyclJvdyk7XHJcblxyXG5cdFx0XHRjb25zdCB7IHVud3JhcHBlZEZpZWxkcyB9ID0gdGhpcztcclxuXHRcdFx0Zm9yIChjb25zdCBmaWVsZCBpbiB1bndyYXBwZWRGaWVsZHMpIHtcclxuXHRcdFx0XHRjb25zdCBhbGxWYWxzID0gdGhpcy5hbGxVbmlxdWVWYWx1ZXNGb3JGaWVsZChmaWVsZCk7XHJcblx0XHRcdFx0Y29uc3QgY2VsbCA9IHBhZ2VbZmllbGRdO1xyXG5cclxuXHRcdFx0XHRpZiAoY2VsbCAhPT0gbnVsbCAmJiBjZWxsICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHVucHJveGllZHMgPSB1bnByb3h5KGNlbGwpO1xyXG5cclxuXHRcdFx0XHRcdGFsbFZhbHMuZm9yRWFjaCgoc3ViKSA9PiB7XHJcblx0XHRcdFx0XHRcdGN1cnJSb3dbbWFrZVN1YihmaWVsZCwgc3ViKV0gPSAwO1xyXG5cclxuXHRcdFx0XHRcdFx0W3VucHJveGllZHNdLmZsYXQoKS5mb3JFYWNoKCh1bnByb3hpZWQpID0+IHtcclxuXHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mIHVucHJveGllZCA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRcdFx0XHRcdFx0c3BsaXRBbmRUcmltKHVucHJveGllZCkuZm9yRWFjaChcclxuXHRcdFx0XHRcdFx0XHRcdFx0KHNwbGl0KSA9PlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdChjdXJyUm93W21ha2VTdWIoZmllbGQsIHNwbGl0KV0gPSAxKVxyXG5cdFx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB1bnByb3hpZWQucGF0aCA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3VyclJvd1ttYWtlU3ViKGZpZWxkLCB1bnByb3hpZWQucGF0aCldID0gMTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0YWJsZS5wdXNoKGN1cnJSb3cpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgT2JqZWN0LmtleXModGFibGUpLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHVuaXF1ZUtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XHJcblx0XHRcdFx0aWYgKHRhYmxlW2ldW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0dGFibGVbaV1ba2V5XSA9IHN0cmluZ1RvTnVsbE9yVW5kZWZpbmVkKHVuZGVmaW5lZFZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRhYmxlO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgd3JpdGVNZXRhZGF0YWZyYW1lKGpzREY6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIH1bXSkge1xyXG5cdFx0Y29uc3QgeyBudWxsVmFsdWUsIGRlZmF1bHRTYXZlUGF0aCB9ID0gdGhpcy5zZXR0aW5ncztcclxuXHRcdGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG51bGxWYWx1ZTtcclxuXHJcblx0XHRjb25zdCBvcHRzID0geyBkZWZhdWx0VmFsdWUsIHRyYW5zZm9ybXM6IFt0cmFuc2Zvcm1zLmZsYXR0ZW4oKV0gfTtcclxuXHJcblx0XHRsZXQgY3N2ID0gXCJcIjtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIob3B0cyk7XHJcblx0XHRcdGNzdiA9IHBhcnNlci5wYXJzZShqc0RGKTtcclxuXHJcblx0XHRcdGlmIChkZWZhdWx0U2F2ZVBhdGggPT09IFwiXCIgJiYgY3N2ICE9PSBcIlwiKSB7XHJcblx0XHRcdFx0bmV3IE5vdGljZShcIlBsZWFzZSBjaG9vc2UgYSBwYXRoIHRvIHNhdmUgdG8gaW4gc2V0dGluZ3NcIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGNvbnN0IHNhdmVQYXRoID0gbm9ybWFsaXplUGF0aChkZWZhdWx0U2F2ZVBhdGgpO1xyXG5cdFx0XHRcdFx0Y29uc3Qgbm93ID0gd2luZG93Lm1vbWVudCgpLmZvcm1hdChcIllZWVktTU0tREQgSEhtbXNzXCIpO1xyXG5cclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShgJHtzYXZlUGF0aH0gJHtub3d9LmNzdmAsIGNzdik7XHJcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiV3JpdGUgTWV0YWRhdGFmcmFtZSBjb21wbGV0ZVwiKTtcclxuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIkZpbGUgYWxyZWFkeSBleGlzdHNcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcihlcnIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xyXG5cdFx0dGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oXHJcblx0XHRcdHt9LFxyXG5cdFx0XHRERUZBVUxUX1NFVFRJTkdTLFxyXG5cdFx0XHRhd2FpdCB0aGlzLmxvYWREYXRhKClcclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XHJcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xyXG5cdH1cclxufVxyXG4iLCAiLyoqXHJcbiAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIHZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgY29tbW9ubHkgdXNlZCBpbiBPYnNpZGlhbiBwbHVnaW5zLlxyXG4gKiBAbW9kdWxlIG9ic2lkaWFuLWNvbW11bml0eS1saWJcclxuICovXHJcbmltcG9ydCAqIGFzIGZlYXRoZXIgZnJvbSBcImZlYXRoZXItaWNvbnNcIjtcclxuaW1wb3J0IHsgYWRkSWNvbiwgTWFya2Rvd25SZW5kZXJlciwgTWFya2Rvd25WaWV3LCBNb2RhbCwgbm9ybWFsaXplUGF0aCwgTm90aWNlLCByZXF1ZXN0LCBURmlsZSwgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuLyoqXHJcbiAqIFlvdSBjYW4gYXdhaXQgdGhpcyBGdW5jdGlvbiB0byBkZWxheSBleGVjdXRpb25cclxuICpcclxuICogQHBhcmFtIGRlbGF5IFRoZSBkZWxheSBpbiBtc1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXQoZGVsYXkpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIGFsbCBvZmZpY2lhbCBGZWF0aGVyIEljb25zIHRvIE9ic2lkaWFuLlxyXG4gKiBodHRwczovL2ZlYXRoZXJpY29ucy5jb20vXHJcbiAqXHJcbiAqIEBwYXJhbSBhdHRyIFNWRyBBdHRyaWJ1dGVzIGZvciB0aGUgSWNvbi4gVGhlIGRlZmF1bHQgc2hvdWxkIHdvcmsgZm9yIG1vc3QgdXNlY2FzZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkQWxsRmVhdGhlckljb25zKGF0dHIgPSB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIHdpZHRoOiBcIjEwMFwiLCBoZWlnaHQ6IFwiMTAwXCIgfSkge1xyXG4gICAgT2JqZWN0LnZhbHVlcyhmZWF0aGVyLmljb25zKS5mb3JFYWNoKChpKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3ZnID0gaS50b1N2ZyhhdHRyKTtcclxuICAgICAgICBhZGRJY29uKGBmZWF0aGVyLSR7aS5uYW1lfWAsIHN2Zyk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogQWRkcyBhIHNwZWNpZmljIEZlYXRoZXIgSWNvbiB0byBPYnNpZGlhbi5cclxuICpcclxuICogQHBhcmFtIG5hbWUgb2ZmaWNpYWwgTmFtZSBvZiB0aGUgSWNvbiAoaHR0cHM6Ly9mZWF0aGVyaWNvbnMuY29tLylcclxuICogQHBhcmFtIGF0dHIgU1ZHIEF0dHJpYnV0ZXMgZm9yIHRoZSBJY29uLiBUaGUgZGVmYXVsdCBzaG91bGQgd29yayBmb3IgbW9zdCB1c2VjYXNlcy5cclxuICogQHJldHVybnMge3N0cmluZ30gSWNvbiBuYW1lXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkRmVhdGhlckljb24obmFtZSwgYXR0ciA9IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgd2lkdGg6IFwiMTAwXCIsIGhlaWdodDogXCIxMDBcIiB9KSB7XHJcbiAgICBpZiAoZmVhdGhlci5pY29uc1tuYW1lXSkge1xyXG4gICAgICAgIGNvbnN0IGljb25OYW1lID0gYGZlYXRoZXItJHtuYW1lfWA7XHJcbiAgICAgICAgYWRkSWNvbihpY29uTmFtZSwgZmVhdGhlci5pY29uc1tuYW1lXS50b1N2ZyhhdHRyKSk7XHJcbiAgICAgICAgcmV0dXJuIGljb25OYW1lO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoYFRoaXMgSWNvbiAoJHtuYW1lfSkgZG9lc24ndCBleGlzdCBpbiB0aGUgRmVhdGhlciBMaWJyYXJ5LmApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgYmFzZTY0IFN0cmluZyB0byBhbiBBcnJheUJ1ZmZlci5cclxuICogWW91IGNhbiB0aGVuIHVzZSB0aGUgQXJyYXlCdWZmZXIgdG8gc2F2ZSB0aGUgYXNzZXQgdG8gZGlzay5cclxuICpcclxuICogQHBhcmFtIGJhc2U2NCBiYXNlNjQgc3RyaW5nIHRvIGJlIGNvbnZlcnRlZC5cclxuICogQHJldHVybnMgQXJyYXlCdWZmZXJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRUb0FycmF5QnVmZmVyKGJhc2U2NCkge1xyXG4gICAgY29uc3QgYmluYXJ5X3N0cmluZyA9IHdpbmRvdy5hdG9iKGJhc2U2NCk7XHJcbiAgICBjb25zdCBsZW4gPSBiaW5hcnlfc3RyaW5nLmxlbmd0aDtcclxuICAgIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbik7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgYnl0ZXNbaV0gPSBiaW5hcnlfc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYnl0ZXMuYnVmZmVyO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGlzIGEgaGVscGVyIG1ldGhvZCBmb3IgYW4gdW5kb2N1bWVudGVkIEFQSSBvZiBPYnNpZGlhbi5cclxuICpcclxuICogQHBhcmFtIHZhdWx0IFlvdSBjYW4gZ2V0IHRoaXMgdmlhIGB0aGlzLmFwcC52YXVsdGBcclxuICogQHBhcmFtIGZpbGVOYW1lIFRoZSBGaWxlbmFtZSBmb3IgeW91ciBBdHRhY2htZW50XHJcbiAqIEBwYXJhbSBmb3JtYXQgVGhlIEZpbGVmb3JtYXQgb2YgeW91ciBBdHRhY2htZW50XHJcbiAqIEBwYXJhbSBzb3VyY2VGaWxlIFRoZSBTb3VyY2VmaWxlIGZyb20gd2hlcmUgdGhlIEF0dGFjaG1lbnQgZ2V0cyBhZGRlZCwgdGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgQXR0YWNobWVudCBGb2xkZXIgbWlnaHQgYmUgZGlmZmVyZW50IGJhc2VkIG9uIHdoZXJlIGl0IGdldHMgaW5zZXJ0ZWQuXHJcbiAqIEByZXR1cm5zIFRoZSBBdHRhY2htZW50IFBhdGhcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBdmFpbGFibGVQYXRoRm9yQXR0YWNobWVudHModmF1bHQsIGZpbGVOYW1lLCBmb3JtYXQsIHNvdXJjZUZpbGUpIHtcclxuICAgIC8vQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgcmV0dXJuIHZhdWx0LmdldEF2YWlsYWJsZVBhdGhGb3JBdHRhY2htZW50cyhmaWxlTmFtZSwgZm9ybWF0LCBzb3VyY2VGaWxlKTtcclxufVxyXG4vKipcclxuICogQ29weSBgY29udGVudGAgdG8gdGhlIHVzZXJzIGNsaXBib2FyZC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgVGhlIGNvbnRlbnQgdG8gYmUgY29waWVkIHRvIGNsaXBib2FyZC5cclxuICogQHBhcmFtIHsoKSA9PiBhbnl9IHN1Y2Nlc3MgVGhlIGNhbGxiYWNrIHRvIHJ1biB3aGVuIHRleHQgaXMgc3VjY2Vzc2Z1bGx5IGNvcGllZC4gRGVmYXVsdCB0aHJvd3MgYSBuZXcgYE5vdGljZWBcclxuICogQHBhcmFtIHsocmVhc29uPykgPT4gYW55fSBmYWlsdXJlIFRoZSBjYWxsYmFjayB0byBydW4gd2hlbiB0ZXh0IHdhcyBub3QgYWJsZSB0byBiZSBjb3BpZWQuIERlZmF1bHQgdGhyb3dzIGEgbmV3IGBOb3RpY2VgLCBhbmQgY29uc29sZSBsb2dzIHRoZSBlcnJvci5gXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29weShjb250ZW50LCBzdWNjZXNzID0gKCkgPT4gbmV3IE5vdGljZShcIkNvcGllZCB0byBjbGlwYm9hcmRcIiksIGZhaWx1cmUgPSAocmVhc29uKSA9PiB7XHJcbiAgICBuZXcgTm90aWNlKFwiQ291bGQgbm90IGNvcHkgdG8gY2xpcGJvYXJkXCIpO1xyXG4gICAgY29uc29sZS5sb2coeyByZWFzb24gfSk7XHJcbn0pIHtcclxuICAgIGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KGNvbnRlbnQpLnRoZW4oc3VjY2VzcywgZmFpbHVyZSk7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGFuIGVkaXRvciwgY2hlY2sgaWYgc29tZXRoaW5nIGlzIHNlbGVjdGVkIGFuZCByZXR1cm4gdGhhdCBzZWxlY3Rpb24sIG90aGVyd2lzZSByZXR1cm4gdGhlIGVudGlyZSBjb250ZW50IG9mIHRoZSBlZGl0b3JcclxuICogQHBhcmFtICB7RWRpdG9yfSBlZGl0b3JcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3Rpb25Gcm9tRWRpdG9yKGVkaXRvcikge1xyXG4gICAgaWYgKGVkaXRvci5zb21ldGhpbmdTZWxlY3RlZCgpKVxyXG4gICAgICAgIHJldHVybiBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGVkaXRvci5nZXRWYWx1ZSgpO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVjayBpZiBzb21ldGhpbmcgaXMgc2VsZWN0ZWQgaW4gdGhlIGN1cnJlbnQgZmlsZSBhbmQgcmV0dXJuIHRoYXQgc2VsZWN0aW9uLCBvdGhlcndpc2UgcmV0dXJuIHRoZSBlbnRpcmUgY29udGVudCBvZiB0aGUgY3VycmVudCBmaWxlLlxyXG4gKiBAcGFyYW0gIHtBcHB9IGFwcFxyXG4gKiBAcGFyYW0gIHtib29sZWFufSBbY2FjaGVkPXRydWVdIFVzZSBgY2FjaGVkUmVhZGAgb3IgYHJlYWRgLiBgY2FjaGVkUmVhZGAgYnkgZGVmYXVsdC5cclxuICogQHJldHVybnMge3N0cmluZyB8IG51bGx9IGBudWxsYCBpZiBub3QgZm9jdXNzZWQgb24gYSBtYXJrZG93biBmaWxlXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2VsZWN0aW9uRnJvbUN1cnJGaWxlKGFwcCwgY2FjaGVkID0gdHJ1ZSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgdGV4dCA9IChfYSA9IHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvU3RyaW5nKCk7XHJcbiAgICBpZiAodGV4dClcclxuICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gYXdhaXQgZ2V0QWN0aXZlRmlsZUNvbnRlbnQoYXBwLCBjYWNoZWQpO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVjayBpZiBgbm90ZU5hbWVgIGlzIHRoZSBuYW1lIG9mIGEgbm90ZSB0aGF0IGV4aXN0cyBpbiB0aGUgdmF1bHQuXHJcbiAqIEBwYXJhbSAge0FwcH0gYXBwXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gbm90ZU5hbWUgQmFzZW5hbWUgb2YgdGhlIG5vdGUgdG8gc2VhcmNoIGZvci5cclxuICogQHBhcmFtICB7c3RyaW5nfSBbc291cmNlUGF0aD1cIlwiXSBPcHRpb25hbCBmaWxlIHBhdGggdG8gc3RhcnQgc2VhcmNoaW5nIGZyb20uIERlZmF1bHQgaXMgdGhlIGN1cnJlbnQgZmlsZS5cclxuICogQHJldHVybnMgYm9vbGVhblxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGlzSW5WYXVsdCA9IChhcHAsIG5vdGVOYW1lLCBzb3VyY2VQYXRoID0gXCJcIikgPT4gISFhcHAubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChub3RlTmFtZSwgc291cmNlUGF0aCk7XHJcbi8qKlxyXG4gKiBXaGVuIGhvdmVyaW5nIGEgbGluayBnb2luZyB0byBgdG9gLCBzaG93IHRoZSBPYnNpZGlhbiBob3Zlci1wcmV2aWV3IG9mIHRoYXQgbm90ZS5cclxuICpcclxuICogWW91IHByb2JhYmx5IGhhdmUgdG8gaG9sZCBkb3duIGBDdHJsYCB3aGVuIGhvdmVyaW5nIHRoZSBsaW5rIGZvciB0aGUgcHJldmlldyB0byBhcHBlYXIhXHJcbiAqIEBwYXJhbSAge01vdXNlRXZlbnR9IGV2ZW50XHJcbiAqIEBwYXJhbSAge1lvdXJWaWV3fSB2aWV3IFRoZSB2aWV3IHdpdGggdGhlIGxpbmsgYmVpbmcgaG92ZXJlZFxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRvIFRoZSBiYXNlbmFtZSBvZiB0aGUgbm90ZSB0byBwcmV2aWV3LlxyXG4gKiBAdGVtcGxhdGUgWW91clZpZXcgVGhlIFZpZXdUeXBlIG9mIHlvdXIgdmlld1xyXG4gKiBAcmV0dXJucyB2b2lkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaG92ZXJQcmV2aWV3KGV2ZW50LCB2aWV3LCB0bykge1xyXG4gICAgY29uc3QgdGFyZ2V0RWwgPSBldmVudC50YXJnZXQ7XHJcbiAgICB2aWV3LmFwcC53b3Jrc3BhY2UudHJpZ2dlcihcImhvdmVyLWxpbmtcIiwge1xyXG4gICAgICAgIGV2ZW50LFxyXG4gICAgICAgIHNvdXJjZTogdmlldy5nZXRWaWV3VHlwZSgpLFxyXG4gICAgICAgIGhvdmVyUGFyZW50OiB2aWV3LFxyXG4gICAgICAgIHRhcmdldEVsLFxyXG4gICAgICAgIGxpbmt0ZXh0OiB0byxcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWFya2Rvd24gbm90ZSBuYW1lZCBgbmV3TmFtZWAgaW4gdGhlIHVzZXIncyBwcmVmZmVyZWQgbmV3LW5vdGUtZm9sZGVyLlxyXG4gKiBAcGFyYW0gIHtBcHB9IGFwcFxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5ld05hbWUgTmFtZSBvZiBuZXcgbm90ZSAod2l0aCBvciB3aXRob3V0ICcubWQnKVxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IFtjdXJyRmlsZVBhdGg9XCJcIl0gRmlsZSBwYXRoIG9mIHRoZSBjdXJyZW50IG5vdGUuIFVzZSBhbiBlbXB0eSBzdHJpbmcgaWYgdGhlcmUgaXMgbm8gYWN0aXZlIGZpbGUuXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPFRGaWxlPn0gbmV3IFRGaWxlXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlTmV3TUROb3RlKGFwcCwgbmV3TmFtZSwgY3VyckZpbGVQYXRoID0gXCJcIikge1xyXG4gICAgY29uc3QgbmV3RmlsZUZvbGRlciA9IGFwcC5maWxlTWFuYWdlci5nZXROZXdGaWxlUGFyZW50KGN1cnJGaWxlUGF0aCkucGF0aDtcclxuICAgIGNvbnN0IG5ld0ZpbGVQYXRoID0gbm9ybWFsaXplUGF0aChgJHtuZXdGaWxlRm9sZGVyfSR7bmV3RmlsZUZvbGRlciA9PT0gXCIvXCIgPyBcIlwiIDogXCIvXCJ9JHthZGRNRChuZXdOYW1lKX1gKTtcclxuICAgIHJldHVybiBhd2FpdCBhcHAudmF1bHQuY3JlYXRlKG5ld0ZpbGVQYXRoLCBcIlwiKTtcclxufVxyXG4vKipcclxuICogQWRkICcubWQnIHRvIGBub3RlTmFtZWAgaWYgaXQgaXNuJ3QgYWxyZWFkeSB0aGVyZS5cclxuICogQHBhcmFtICB7c3RyaW5nfSBub3RlTmFtZSB3aXRoIG9yIHdpdGhvdXQgJy5tZCcgb24gdGhlIGVuZC5cclxuICogQHJldHVybnMge3N0cmluZ30gbm90ZU5hbWUgd2l0aCAnLm1kJyBvbiB0aGUgZW5kLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGFkZE1EID0gKG5vdGVOYW1lKSA9PiB7XHJcbiAgICByZXR1cm4gbm90ZU5hbWUuZW5kc1dpdGgoXCIubWRcIikgPyBub3RlTmFtZSA6IG5vdGVOYW1lICsgXCIubWRcIjtcclxufTtcclxuLyoqXHJcbiAqIFN0cmlwICcubWQnIG9mZiB0aGUgZW5kIG9mIGEgbm90ZSBuYW1lIHRvIGdldCBpdHMgYmFzZW5hbWUuXHJcbiAqXHJcbiAqIFdvcmtzIHdpdGggdGhlIGVkZ2VjYXNlIHdoZXJlIGEgbm90ZSBoYXMgJy5tZCcgaW4gaXRzIGJhc2VuYW1lOiBgT2JzaWRpYW4ubWQubWRgLCBmb3IgZXhhbXBsZS5cclxuICogQHBhcmFtICB7c3RyaW5nfSBub3RlTmFtZSB3aXRoIG9yIHdpdGhvdXQgJy5tZCcgb24gdGhlIGVuZC5cclxuICogQHJldHVybnMge3N0cmluZ30gbm90ZU5hbWUgd2l0aG91dCAnLm1kJ1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHN0cmlwTUQgPSAobm90ZU5hbWUpID0+IHtcclxuICAgIGlmIChub3RlTmFtZS5lbmRzV2l0aChcIi5tZFwiKSkge1xyXG4gICAgICAgIHJldHVybiBub3RlTmFtZS5zcGxpdChcIi5tZFwiKS5zbGljZSgwLCAtMSkuam9pbihcIi5tZFwiKTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gbm90ZU5hbWU7XHJcbn07XHJcbi8qKlxyXG4gKiBXaGVuIGNsaWNraW5nIGEgbGluaywgY2hlY2sgaWYgdGhhdCBub3RlIGlzIGFscmVhZHkgb3BlbiBpbiBhbm90aGVyIGxlYWYsIGFuZCBzd2l0Y2ggdG8gdGhhdCBsZWFmLCBpZiBzby4gT3RoZXJ3aXNlLCBvcGVuIHRoZSBub3RlIGluIGEgbmV3IHBhbmUuXHJcbiAqIEBwYXJhbSAge0FwcH0gYXBwXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gZGVzdCBOYW1lIG9mIG5vdGUgdG8gb3Blbi4gSWYgeW91IHdhbnQgdG8gb3BlbiBhIG5vbi1tZCBub3RlLCBiZSBzdXJlIHRvIGFkZCB0aGUgZmlsZSBleHRlbnNpb24uXHJcbiAqIEBwYXJhbSAge01vdXNlRXZlbnR9IGV2ZW50XHJcbiAqIEBwYXJhbSAge3tjcmVhdGVOZXdGaWxlOmJvb2xlYW59fSBbb3B0aW9ucz17Y3JlYXRlTmV3RmlsZTp0cnVlfV0gV2hldGhlciBvciBub3QgdG8gY3JlYXRlIGBkZXN0YCBmaWxlIGlmIGl0IGRvZXNuJ3QgZXhpc3QuIElmIGBmYWxzZWAsIHNpbXBseSByZXR1cm4gZnJvbSB0aGUgZnVuY3Rpb24uXHJcbiAqIEByZXR1cm5zIFByb21pc2VcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBvcGVuT3JTd2l0Y2goYXBwLCBkZXN0LCBldmVudCwgb3B0aW9ucyA9IHsgY3JlYXRlTmV3RmlsZTogdHJ1ZSB9KSB7XHJcbiAgICBjb25zdCB7IHdvcmtzcGFjZSB9ID0gYXBwO1xyXG4gICAgbGV0IGRlc3RGaWxlID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QoZGVzdCwgXCJcIik7XHJcbiAgICAvLyBJZiBkZXN0IGRvZXNuJ3QgZXhpc3QsIG1ha2UgaXRcclxuICAgIGlmICghZGVzdEZpbGUgJiYgb3B0aW9ucy5jcmVhdGVOZXdGaWxlKSB7XHJcbiAgICAgICAgZGVzdEZpbGUgPSBhd2FpdCBjcmVhdGVOZXdNRE5vdGUoYXBwLCBkZXN0KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFkZXN0RmlsZSAmJiAhb3B0aW9ucy5jcmVhdGVOZXdGaWxlKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIC8vIENoZWNrIGlmIGl0J3MgYWxyZWFkeSBvcGVuXHJcbiAgICBjb25zdCBsZWF2ZXNXaXRoRGVzdEFscmVhZHlPcGVuID0gW107XHJcbiAgICAvLyBGb3IgYWxsIG9wZW4gbGVhdmVzLCBpZiB0aGUgbGVhdmUncyBiYXNlbmFtZSBpcyBlcXVhbCB0byB0aGUgbGluayBkZXN0aW5hdGlvbiwgcmF0aGVyIGFjdGl2YXRlIHRoYXQgbGVhZiBpbnN0ZWFkIG9mIG9wZW5pbmcgaXQgaW4gdHdvIHBhbmVzXHJcbiAgICB3b3Jrc3BhY2UuaXRlcmF0ZUFsbExlYXZlcygobGVhZikgPT4ge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAobGVhZi52aWV3IGluc3RhbmNlb2YgTWFya2Rvd25WaWV3KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSAoX2EgPSBsZWFmLnZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWxlO1xyXG4gICAgICAgICAgICBpZiAoZmlsZSAmJiBmaWxlLmJhc2VuYW1lICsgXCIuXCIgKyBmaWxlLmV4dGVuc2lvbiA9PT0gZGVzdCkge1xyXG4gICAgICAgICAgICAgICAgbGVhdmVzV2l0aERlc3RBbHJlYWR5T3Blbi5wdXNoKGxlYWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyBSYXRoZXIgc3dpdGNoIHRvIGl0IGlmIGl0IGlzIG9wZW5cclxuICAgIGlmIChsZWF2ZXNXaXRoRGVzdEFscmVhZHlPcGVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB3b3Jrc3BhY2Uuc2V0QWN0aXZlTGVhZihsZWF2ZXNXaXRoRGVzdEFscmVhZHlPcGVuWzBdKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBjb25zdCBtb2RlID0gYXBwLnZhdWx0LmdldENvbmZpZyhcImRlZmF1bHRWaWV3TW9kZVwiKTtcclxuICAgICAgICBjb25zdCBsZWFmID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5nZXRNb2RpZmllclN0YXRlKFwiTWV0YVwiKVxyXG4gICAgICAgICAgICA/IHdvcmtzcGFjZS5zcGxpdEFjdGl2ZUxlYWYoKVxyXG4gICAgICAgICAgICA6IHdvcmtzcGFjZS5nZXRVbnBpbm5lZExlYWYoKTtcclxuICAgICAgICBhd2FpdCBsZWFmLm9wZW5GaWxlKGRlc3RGaWxlLCB7IGFjdGl2ZTogdHJ1ZSwgbW9kZSB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2l2ZW4gYSBsaXN0IG9mIHJlc29sdmVkIGxpbmtzIGZyb20gYXBwLm1ldGFkYXRhQ2FjaGUsIGNoZWNrIGlmIGBmcm9tYCBoYXMgYSBsaW5rIHRvIGB0b2BcclxuICogQHBhcmFtICB7UmVzb2x2ZWRMaW5rc30gcmVzb2x2ZWRMaW5rc1xyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZyb20gTm90ZSBuYW1lIHdpdGggbGluayBsZWF2aW5nIChXaXRoIG9yIHdpdGhvdXQgJy5tZCcpXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gdG8gTm90ZSBuYW1lIHdpdGggbGluayBhcnJpdmluZyAoV2l0aCBvciB3aXRob3V0ICcubWQnKVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkaXJlY3RlZD10cnVlXSBPbmx5IGNoZWNrIGlmIGBmcm9tYCBoYXMgYSBsaW5rIHRvIGB0b2AuIElmIG5vdCBkaXJlY3RlZCwgY2hlY2sgaW4gYm90aCBkaXJlY3Rpb25zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNMaW5rZWQocmVzb2x2ZWRMaW5rcywgZnJvbSwgdG8sIGRpcmVjdGVkID0gdHJ1ZSkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIGlmICghZnJvbS5lbmRzV2l0aChcIi5tZFwiKSkge1xyXG4gICAgICAgIGZyb20gKz0gXCIubWRcIjtcclxuICAgIH1cclxuICAgIGlmICghdG8uZW5kc1dpdGgoXCIubWRcIikpIHtcclxuICAgICAgICB0byArPSBcIi5tZFwiO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZnJvbVRvID0gKF9hID0gcmVzb2x2ZWRMaW5rc1tmcm9tXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhc093blByb3BlcnR5KHRvKTtcclxuICAgIGlmICghZnJvbVRvICYmICFkaXJlY3RlZCkge1xyXG4gICAgICAgIGNvbnN0IHRvRnJvbSA9IChfYiA9IHJlc29sdmVkTGlua3NbdG9dKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGFzT3duUHJvcGVydHkoZnJvbSk7XHJcbiAgICAgICAgcmV0dXJuIHRvRnJvbTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gZnJvbVRvO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgbGluayBgZnJvbWAgXHUyMTkyIGB0b2AgaXMgcmVzb2x2ZWQgb3Igbm90LlxyXG4gKiBAcGFyYW0gIHtBcHB9IGFwcFxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRvXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gZnJvbVxyXG4gKiBAcmV0dXJucyBib29sZWFuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNSZXNvbHZlZChhcHAsIHRvLCBmcm9tKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCB7IHJlc29sdmVkTGlua3MgfSA9IGFwcC5tZXRhZGF0YUNhY2hlO1xyXG4gICAgcmV0dXJuICgoX2EgPSByZXNvbHZlZExpbmtzID09PSBudWxsIHx8IHJlc29sdmVkTGlua3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc29sdmVkTGlua3NbYWRkTUQoZnJvbSldKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYWRkTUQodG8pXSkgPiAwO1xyXG59XHJcbi8qKlxyXG4gKiBPcGVuIHlvdXIgdmlldyBvbiB0aGUgY2hvc2VuIGBzaWRlYCBpZiBpdCBpc24ndCBhbHJlYWR5IG9wZW5cclxuICogQHBhcmFtICB7QXBwfSBhcHBcclxuICogQHBhcmFtICB7c3RyaW5nfSB2aWV3VHlwZVxyXG4gKiBAcGFyYW0gIHtDb25zdHJ1Y3RvcjxZb3VyVmlldz59IHZpZXdDbGFzcyBUaGUgY2xhc3MgY29uc3RydWN0b3Igb2YgeW91ciB2aWV3XHJcbiAqIEBwYXJhbSAge1wibGVmdFwifFwicmlnaHRcIn0gW3NpZGU9XCJyaWdodFwiXVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxZb3VyVmlldz59IFRoZSBvcGVuZWQgdmlld1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG9wZW5WaWV3KGFwcCwgdmlld1R5cGUsIHZpZXdDbGFzcywgc2lkZSA9IFwicmlnaHRcIikge1xyXG4gICAgbGV0IGxlYWYgPSBudWxsO1xyXG4gICAgZm9yIChsZWFmIG9mIGFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKHZpZXdUeXBlKSkge1xyXG4gICAgICAgIGlmIChsZWFmLnZpZXcgaW5zdGFuY2VvZiB2aWV3Q2xhc3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlYWYudmlldztcclxuICAgICAgICB9XHJcbiAgICAgICAgYXdhaXQgbGVhZi5zZXRWaWV3U3RhdGUoeyB0eXBlOiBcImVtcHR5XCIgfSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBsZWFmID1cclxuICAgICAgICAobGVhZiAhPT0gbnVsbCAmJiBsZWFmICE9PSB2b2lkIDAgPyBsZWFmIDogc2lkZSA9PT0gXCJyaWdodFwiKVxyXG4gICAgICAgICAgICA/IGFwcC53b3Jrc3BhY2UuZ2V0UmlnaHRMZWFmKGZhbHNlKVxyXG4gICAgICAgICAgICA6IGFwcC53b3Jrc3BhY2UuZ2V0TGVmdExlYWYoZmFsc2UpO1xyXG4gICAgYXdhaXQgbGVhZi5zZXRWaWV3U3RhdGUoe1xyXG4gICAgICAgIHR5cGU6IHZpZXdUeXBlLFxyXG4gICAgICAgIGFjdGl2ZTogdHJ1ZSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGxlYWYudmlldztcclxufVxyXG4vKipcclxuICogQ2hlY2sgd2hpY2ggc2lkZSBvZiB0aGUgd29ya3NwYWNlIHlvdXIgYHZpZXdUeXBlYCBpcyBvbiwgYW5kIHNhdmUgaXQgaW50byBgcGx1Z2luLnNldHRpbmdzW3NldHRpbmdOYW1lXWAuXHJcbiAqXHJcbiAqICoqVGlwKio6IFJ1biB0aGlzIGZ1bmN0aW9uIG9uIGBwbHVnaW4udW5sb2FkYCB0byBzYXZlIHRoZSBsYXN0IHNpZGUgeW91ciB2aWV3IHdhcyBvbiB3aGVuIGNsb3NpbmcsIHRoZW4ge0BsaW5rIG9wZW5WaWV3fSBvbiB0aGUgc2FtZSBzaWRlIGl0IHdhcyBsYXN0LlxyXG4gKiBAcGFyYW0gIHtBcHB9IGFwcFxyXG4gKiBAcGFyYW0gIHtZb3VyUGx1Z2lufSBwbHVnaW5cclxuICogQHBhcmFtICB7c3RyaW5nfSB2aWV3VHlwZVxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNldHRpbmdOYW1lXHJcbiAqIEByZXR1cm5zIHtcImxlZnRcIiB8IFwicmlnaHRcIn0gYHNpZGVgXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZVZpZXdTaWRlKGFwcCwgcGx1Z2luLCB2aWV3VHlwZSwgc2V0dGluZ05hbWUpIHtcclxuICAgIGNvbnN0IGxlYWYgPSBhcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZSh2aWV3VHlwZSlbMF07XHJcbiAgICBpZiAoIWxlYWYpIHtcclxuICAgICAgICBjb25zb2xlLmluZm8oYE9ic2lkaWFuLUNvbW11bml0eS1MaWI6IE5vIGluc3RhbmNlIG9mICcke3ZpZXdUeXBlfScgb3BlbiwgY2Fubm90IHNhdmUgc2lkZWApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgY29uc3Qgc2lkZSA9IGxlYWYuZ2V0Um9vdCgpLnNpZGU7XHJcbiAgICAvL0B0cy1pZ25vcmVcclxuICAgIHBsdWdpbi5zZXR0aW5nc1tzZXR0aW5nTmFtZV0gPSBzaWRlO1xyXG4gICAgLy9AdHMtaWdub3JlXHJcbiAgICBhd2FpdCBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICByZXR1cm4gc2lkZTtcclxufVxyXG4vKipcclxuICogQSBNb2RhbCB1c2VkIGluIHtAbGluayBhZGRSZW5kZXJlZE1hcmtkb3duQnV0dG9ufSB0byBkaXNwbGF5IHJlbmRlcmVkIG1hcmtkb3duIGZyb20gYSByYXcgc3RyaW5nLCBvciBmZXRjaGVkIGZyb20gYSBwcm92aWRlZCB1cmwuXHJcbiAqXHJcbiAqICFbXShodHRwczovL2kuaW1ndXIuY29tL05Nd001MEUucG5nKVxyXG4gKiBAcGFyYW0gIHtBcHB9IGFwcFxyXG4gKiBAcGFyYW0gIHtZb3VyUGx1Z2lufSBwbHVnaW5cclxuICogQHBhcmFtICB7c3RyaW5nfSBzb3VyY2UgUmF3IG1hcmtkb3duIGNvbnRlbnQgb3IgdXJsIHRvIGZpbmQgcmF3IG1hcmtkb3duLlxyXG4gKiBAcGFyYW0gIHtib29sZWFufSBmZXRjaCBUcnVlIFx1MjE5MiBmZXRjaCBtYXJrZG93biBmcm9tIGBzb3VyY2VgIGFzIHVybC4gRmFsc2UgXHUyMTkyIGBzb3VyY2VgIGlzIGFscmVhZHkgYSBtYXJrZG93biBzdHJpbmcuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUmVuZGVyZWRNYXJrZG93bk1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG4gICAgY29uc3RydWN0b3IoYXBwLCBwbHVnaW4sIHNvdXJjZSwgZmV0Y2gpIHtcclxuICAgICAgICBzdXBlcihhcHApO1xyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMuZmV0Y2ggPSBmZXRjaDtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uT3BlbigpIHtcclxuICAgICAgICBsZXQgeyBjb250ZW50RWwsIHNvdXJjZSwgcGx1Z2luLCBmZXRjaCB9ID0gdGhpcztcclxuICAgICAgICBsZXQgY29udGVudCA9IHNvdXJjZTtcclxuICAgICAgICBpZiAoZmV0Y2gpIHtcclxuICAgICAgICAgICAgY29udGVudEVsLmNyZWF0ZURpdih7IHRleHQ6IGBXYWl0aW5nIGZvciBjb250ZW50IGZyb206ICcke3NvdXJjZX0nYCB9KTtcclxuICAgICAgICAgICAgY29udGVudCA9IGF3YWl0IHJlcXVlc3QoeyB1cmw6IHNvdXJjZSB9KTtcclxuICAgICAgICAgICAgY29udGVudEVsLmVtcHR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxvZ0RpdiA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoeyBjbHM6IFwiT0NMLVJlbmRlcmVkTWFya2Rvd25Nb2RhbFwiIH0pO1xyXG4gICAgICAgIE1hcmtkb3duUmVuZGVyZXIucmVuZGVyTWFya2Rvd24oY29udGVudCwgbG9nRGl2LCBcIlwiLCBwbHVnaW4pO1xyXG4gICAgfVxyXG4gICAgb25DbG9zZSgpIHtcclxuICAgICAgICB0aGlzLmNvbnRlbnRFbC5lbXB0eSgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBZGQgYSBidXR0b24gdG8gYW4gSFRNTEVMZW1lbnQsIHdoaWNoLCB3aGVuIGNsaWNrZWQsIHBvcHMgdXAgYSB7QGxpbmsgUmVuZGVyZWRNYXJrZG93bk1vZGFsfSBzaG93aW5nIHJlbmRlcmVkIG1hcmtkb3duLlxyXG4gKlxyXG4gKiBVc2UgYGZldGNoYCB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoZSBtYXJrZG93biBzdHJpbmcgbmVlZHMgdG8gYmUgZmV0Y2hlZCwgb3IgaWYgaXQgaGFzIGJlZW4gcHJvdmlkZWQgYXMgYSBzdHJpbmcgYWxyZWFkeS5cclxuICpcclxuICogIVtdKGh0dHBzOi8vaS5pbWd1ci5jb20vSGk0Z3l5di5wbmcpXHJcbiAqIEBwYXJhbSAge0FwcH0gYXBwXHJcbiAqIEBwYXJhbSAge1lvdXJQbHVnaW59IHBsdWdpblxyXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gY29udGFpbmVyRWwgSFRNTEVsZW1lbnQgdG8gYWRkIHRoZSBidXR0b24gdG9cclxuICogQHBhcmFtICB7c3RyaW5nfSBzb3VyY2UgUmF3IG1hcmtkb3duIGNvbnRlbnQgb3IgdXJsIHRvIGZpbmQgcmF3IG1hcmtkb3duLlxyXG4gKiBAcGFyYW0gIHtib29sZWFufSBmZXRjaCBUcnVlIFx1MjE5MiBmZXRjaCBtYXJrZG93biBmcm9tIGBzb3VyY2VgIGFzIHVybC4gRmFsc2UgXHUyMTkyIGBzb3VyY2VgIGlzIGFscmVhZHkgYSBtYXJrZG93biBzdHJpbmcuXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gZGlzcGxheVRleHQgVGV4dCB0byBkaXNwbGF5IGluIHRoZSBidXR0b24uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkUmVuZGVyZWRNYXJrZG93bkJ1dHRvbihhcHAsIHBsdWdpbiwgY29udGFpbmVyRWwsIHNvdXJjZSwgZmV0Y2gsIGRpc3BsYXlUZXh0KSB7XHJcbiAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImJ1dHRvblwiLCB7IHRleHQ6IGRpc3BsYXlUZXh0IH0sIChidXQpID0+IGJ1dC5vbkNsaWNrRXZlbnQoKCkgPT4ge1xyXG4gICAgICAgIG5ldyBSZW5kZXJlZE1hcmtkb3duTW9kYWwoYXBwLCBwbHVnaW4sIHNvdXJjZSwgZmV0Y2gpLm9wZW4oKTtcclxuICAgIH0pKTtcclxufVxyXG4vKipcclxuICogQ2hlY2sgaWYgYGFwcC5tZXRhZGF0YUNhY2hlLlJlc29sdmVkTGlua3NgIGhhdmUgZnVsbHkgaW5pdGFsaXNlZC5cclxuICpcclxuICogVXNlZCB3aXRoIHtAbGluayB3YWl0Rm9yUmVzb2x2ZWRMaW5rc30uXHJcbiAqIEBwYXJhbSB7QXBwfSBhcHBcclxuICogQHBhcmFtICB7bnVtYmVyfSBub0ZpbGVzIE51bWJlciBvZiBmaWxlcyBpbiB5b3VyIHZhdWx0LlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlZExpbmtzQ29tcGxldGUoYXBwLCBub0ZpbGVzKSB7XHJcbiAgICBjb25zdCB7IHJlc29sdmVkTGlua3MgfSA9IGFwcC5tZXRhZGF0YUNhY2hlO1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc29sdmVkTGlua3MpLmxlbmd0aCA9PT0gbm9GaWxlcztcclxufVxyXG4vKipcclxuICogV2FpdCBmb3IgYGFwcC5tZXRhZGF0YUNhY2hlLlJlc29sdmVkTGlua3NgIHRvIGhhdmUgZnVsbHkgaW5pdGlhbGlzZWQuXHJcbiAqIEBwYXJhbSB7QXBwfSBhcHBcclxuICogQHBhcmFtICB7bnVtYmVyfSBbZGVsYXk9MTAwMF0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJldHdlZW4gZWFjaCBjaGVjay5cclxuICogQHBhcmFtIHtudW1iZXJ9IFttYXg9NTBdIE1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gY2hlY2sgYmVmb3JlIHRocm93aW5nIGFuIGVycm9yIGFuZCBicmVha2luZyBvdXQgb2YgdGhlIGxvb3AuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FpdEZvclJlc29sdmVkTGlua3MoYXBwLCBkZWxheSA9IDEwMDAsIG1heCA9IDUwKSB7XHJcbiAgICBjb25zdCBub0ZpbGVzID0gYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKS5sZW5ndGg7XHJcbiAgICBsZXQgaSA9IDA7XHJcbiAgICB3aGlsZSAoIXJlc29sdmVkTGlua3NDb21wbGV0ZShhcHAsIG5vRmlsZXMpICYmIGkgPCBtYXgpIHtcclxuICAgICAgICBhd2FpdCB3YWl0KGRlbGF5KTtcclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcbiAgICBpZiAoaSA9PT0gbWF4KSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJPYnNpZGlhbi1Db21tdW5pdHktTGliOiBSZXNvbHZlZExpbmtzIGRpZCBub3QgZmluaXNoIGluaXRpYWxpc2luZy4gYG1heGAgaXRlcmF0aW9ucyB3YXMgcmVhY2hlZCBmaXJzdC5cIik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBjb250ZW50IG9mIGEgbm90ZSBoYXMgWUFNTC4gSWYgc28sIHJldHVybiBhbiBhcnJheSBvZiB0aGUgWUFNTCBhbmQgdGhlIHJlc3Qgb2YgdGhlIG5vdGUuIElmIG5vdCwgcmV0dXJuIGBbJycsIGNvbnRlbnRdYFxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRlbnRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzcGxpdEF0WWFtbChjb250ZW50KSB7XHJcbiAgICBpZiAoIS9eLS0tXFxuLy50ZXN0KGNvbnRlbnQpKVxyXG4gICAgICAgIHJldHVybiBbXCJcIiwgY29udGVudF07XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBzcGxpdHMgPSBjb250ZW50LnNwbGl0KFwiLS0tXCIpO1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHNwbGl0cy5zbGljZSgwLCAyKS5qb2luKFwiLS0tXCIpICsgXCItLS1cIixcclxuICAgICAgICAgICAgc3BsaXRzLnNsaWNlKDIpLmpvaW4oXCItLS1cIiksXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWN0aXZlRmlsZUNvbnRlbnQoYXBwLCBjYWNoZWQgPSB0cnVlKSB7XHJcbiAgICBjb25zdCBjdXJyRmlsZSA9IGFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xyXG4gICAgaWYgKCEoY3VyckZpbGUgaW5zdGFuY2VvZiBURmlsZSkpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBpZiAoY2FjaGVkKVxyXG4gICAgICAgIHJldHVybiBhd2FpdCBhcHAudmF1bHQuY2FjaGVkUmVhZChjdXJyRmlsZSk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwcC52YXVsdC5yZWFkKGN1cnJGaWxlKTtcclxufVxyXG4iLCAiaW1wb3J0IHsgQXBwLCBNb2RhbCB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4vQ29tcG9uZW50cy9DaGFydC5zdmVsdGVcIjtcclxuaW1wb3J0IHR5cGUgRGF0YUFuYWx5c2lzUGx1Z2luIGZyb20gXCIuL21haW5cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBDaGFydE1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG5cdHBsdWdpbjogRGF0YUFuYWx5c2lzUGx1Z2luO1xyXG5cdG1vZGFsOiBDaGFydE1vZGFsO1xyXG5cdGYxOiBzdHJpbmc7XHJcblx0ZjI6IHN0cmluZztcclxuXHJcblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogRGF0YUFuYWx5c2lzUGx1Z2luLCBmMSA9IFwiXCIsIGYyID0gXCJcIikge1xyXG5cdFx0c3VwZXIoYXBwKTtcclxuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG5cdFx0dGhpcy5tb2RhbCA9IHRoaXM7XHJcblx0XHR0aGlzLmYxID0gZjE7XHJcblx0XHR0aGlzLmYyID0gZjI7XHJcblx0fVxyXG5cclxuXHRvbk9wZW4oKSB7XHJcblx0XHRjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuXHRcdGNvbnRlbnRFbC5lbXB0eSgpO1xyXG5cclxuXHRcdG5ldyBDaGFydCh7XHJcblx0XHRcdHRhcmdldDogY29udGVudEVsLFxyXG5cdFx0XHRwcm9wczoge1xyXG5cdFx0XHRcdG1vZGFsOiB0aGlzLFxyXG5cdFx0XHR9LFxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRvbkNsb3NlKCkge1xyXG5cdFx0dGhpcy5jb250ZW50RWwuZW1wdHkoKTtcclxuXHR9XHJcbn1cclxuIiwgImZ1bmN0aW9uIG5vb3AoKSB7IH1cbmNvbnN0IGlkZW50aXR5ID0geCA9PiB4O1xuZnVuY3Rpb24gYXNzaWduKHRhciwgc3JjKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGZvciAoY29uc3QgayBpbiBzcmMpXG4gICAgICAgIHRhcltrXSA9IHNyY1trXTtcbiAgICByZXR1cm4gdGFyO1xufVxuZnVuY3Rpb24gaXNfcHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gYWRkX2xvY2F0aW9uKGVsZW1lbnQsIGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhcikge1xuICAgIGVsZW1lbnQuX19zdmVsdGVfbWV0YSA9IHtcbiAgICAgICAgbG9jOiB7IGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhciB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJ1bihmbikge1xuICAgIHJldHVybiBmbigpO1xufVxuZnVuY3Rpb24gYmxhbmtfb2JqZWN0KCkge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuZnVuY3Rpb24gcnVuX2FsbChmbnMpIHtcbiAgICBmbnMuZm9yRWFjaChydW4pO1xufVxuZnVuY3Rpb24gaXNfZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gc2FmZV9ub3RfZXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiIHx8ICgoYSAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHx8IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nKTtcbn1cbmxldCBzcmNfdXJsX2VxdWFsX2FuY2hvcjtcbmZ1bmN0aW9uIHNyY191cmxfZXF1YWwoZWxlbWVudF9zcmMsIHVybCkge1xuICAgIGlmICghc3JjX3VybF9lcXVhbF9hbmNob3IpIHtcbiAgICAgICAgc3JjX3VybF9lcXVhbF9hbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgfVxuICAgIHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWYgPSB1cmw7XG4gICAgcmV0dXJuIGVsZW1lbnRfc3JjID09PSBzcmNfdXJsX2VxdWFsX2FuY2hvci5ocmVmO1xufVxuZnVuY3Rpb24gbm90X2VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYjtcbn1cbmZ1bmN0aW9uIGlzX2VtcHR5KG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3N0b3JlKHN0b3JlLCBuYW1lKSB7XG4gICAgaWYgKHN0b3JlICE9IG51bGwgJiYgdHlwZW9mIHN0b3JlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCcke25hbWV9JyBpcyBub3QgYSBzdG9yZSB3aXRoIGEgJ3N1YnNjcmliZScgbWV0aG9kYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3Vic2NyaWJlKHN0b3JlLCAuLi5jYWxsYmFja3MpIHtcbiAgICBpZiAoc3RvcmUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgY29uc3QgdW5zdWIgPSBzdG9yZS5zdWJzY3JpYmUoLi4uY2FsbGJhY2tzKTtcbiAgICByZXR1cm4gdW5zdWIudW5zdWJzY3JpYmUgPyAoKSA9PiB1bnN1Yi51bnN1YnNjcmliZSgpIDogdW5zdWI7XG59XG5mdW5jdGlvbiBnZXRfc3RvcmVfdmFsdWUoc3RvcmUpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgc3Vic2NyaWJlKHN0b3JlLCBfID0+IHZhbHVlID0gXykoKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjb21wb25lbnRfc3Vic2NyaWJlKGNvbXBvbmVudCwgc3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaChzdWJzY3JpYmUoc3RvcmUsIGNhbGxiYWNrKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVfc2xvdChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG4gICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgICAgY29uc3Qgc2xvdF9jdHggPSBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblswXShzbG90X2N0eCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG4gICAgcmV0dXJuIGRlZmluaXRpb25bMV0gJiYgZm5cbiAgICAgICAgPyBhc3NpZ24oJCRzY29wZS5jdHguc2xpY2UoKSwgZGVmaW5pdGlvblsxXShmbihjdHgpKSlcbiAgICAgICAgOiAkJHNjb3BlLmN0eDtcbn1cbmZ1bmN0aW9uIGdldF9zbG90X2NoYW5nZXMoZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGZuKSB7XG4gICAgaWYgKGRlZmluaXRpb25bMl0gJiYgZm4pIHtcbiAgICAgICAgY29uc3QgbGV0cyA9IGRlZmluaXRpb25bMl0oZm4oZGlydHkpKTtcbiAgICAgICAgaWYgKCQkc2NvcGUuZGlydHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxldHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsZXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gW107XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBNYXRoLm1heCgkJHNjb3BlLmRpcnR5Lmxlbmd0aCwgbGV0cy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZFtpXSA9ICQkc2NvcGUuZGlydHlbaV0gfCBsZXRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJCRzY29wZS5kaXJ0eSB8IGxldHM7XG4gICAgfVxuICAgIHJldHVybiAkJHNjb3BlLmRpcnR5O1xufVxuZnVuY3Rpb24gdXBkYXRlX3Nsb3RfYmFzZShzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgc2xvdF9jaGFuZ2VzLCBnZXRfc2xvdF9jb250ZXh0X2ZuKSB7XG4gICAgaWYgKHNsb3RfY2hhbmdlcykge1xuICAgICAgICBjb25zdCBzbG90X2NvbnRleHQgPSBnZXRfc2xvdF9jb250ZXh0KHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbiAgICAgICAgc2xvdC5wKHNsb3RfY29udGV4dCwgc2xvdF9jaGFuZ2VzKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVfc2xvdChzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4sIGdldF9zbG90X2NvbnRleHRfZm4pIHtcbiAgICBjb25zdCBzbG90X2NoYW5nZXMgPSBnZXRfc2xvdF9jaGFuZ2VzKHNsb3RfZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4pO1xuICAgIHVwZGF0ZV9zbG90X2Jhc2Uoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIHNsb3RfY2hhbmdlcywgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG59XG5mdW5jdGlvbiBnZXRfYWxsX2RpcnR5X2Zyb21fc2NvcGUoJCRzY29wZSkge1xuICAgIGlmICgkJHNjb3BlLmN0eC5sZW5ndGggPiAzMikge1xuICAgICAgICBjb25zdCBkaXJ0eSA9IFtdO1xuICAgICAgICBjb25zdCBsZW5ndGggPSAkJHNjb3BlLmN0eC5sZW5ndGggLyAzMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGlydHlbaV0gPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlydHk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMocHJvcHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gcHJvcHMpXG4gICAgICAgIGlmIChrWzBdICE9PSAnJCcpXG4gICAgICAgICAgICByZXN1bHRba10gPSBwcm9wc1trXTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29tcHV0ZV9yZXN0X3Byb3BzKHByb3BzLCBrZXlzKSB7XG4gICAgY29uc3QgcmVzdCA9IHt9O1xuICAgIGtleXMgPSBuZXcgU2V0KGtleXMpO1xuICAgIGZvciAoY29uc3QgayBpbiBwcm9wcylcbiAgICAgICAgaWYgKCFrZXlzLmhhcyhrKSAmJiBrWzBdICE9PSAnJCcpXG4gICAgICAgICAgICByZXN0W2tdID0gcHJvcHNba107XG4gICAgcmV0dXJuIHJlc3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlX3Nsb3RzKHNsb3RzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gb25jZShmbikge1xuICAgIGxldCByYW4gPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHJhbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgICAgZm4uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbnVsbF90b19lbXB0eSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldF9zdG9yZV92YWx1ZShzdG9yZSwgcmV0LCB2YWx1ZSkge1xuICAgIHN0b3JlLnNldCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGhhc19wcm9wID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG5mdW5jdGlvbiBhY3Rpb25fZGVzdHJveWVyKGFjdGlvbl9yZXN1bHQpIHtcbiAgICByZXR1cm4gYWN0aW9uX3Jlc3VsdCAmJiBpc19mdW5jdGlvbihhY3Rpb25fcmVzdWx0LmRlc3Ryb3kpID8gYWN0aW9uX3Jlc3VsdC5kZXN0cm95IDogbm9vcDtcbn1cblxuY29uc3QgaXNfY2xpZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5sZXQgbm93ID0gaXNfY2xpZW50XG4gICAgPyAoKSA9PiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcbiAgICA6ICgpID0+IERhdGUubm93KCk7XG5sZXQgcmFmID0gaXNfY2xpZW50ID8gY2IgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKSA6IG5vb3A7XG4vLyB1c2VkIGludGVybmFsbHkgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIHNldF9ub3coZm4pIHtcbiAgICBub3cgPSBmbjtcbn1cbmZ1bmN0aW9uIHNldF9yYWYoZm4pIHtcbiAgICByYWYgPSBmbjtcbn1cblxuY29uc3QgdGFza3MgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBydW5fdGFza3Mobm93KSB7XG4gICAgdGFza3MuZm9yRWFjaCh0YXNrID0+IHtcbiAgICAgICAgaWYgKCF0YXNrLmMobm93KSkge1xuICAgICAgICAgICAgdGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgICAgICAgdGFzay5mKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodGFza3Muc2l6ZSAhPT0gMClcbiAgICAgICAgcmFmKHJ1bl90YXNrcyk7XG59XG4vKipcbiAqIEZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkhXG4gKi9cbmZ1bmN0aW9uIGNsZWFyX2xvb3BzKCkge1xuICAgIHRhc2tzLmNsZWFyKCk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdGFzayB0aGF0IHJ1bnMgb24gZWFjaCByYWYgZnJhbWVcbiAqIHVudGlsIGl0IHJldHVybnMgYSBmYWxzeSB2YWx1ZSBvciBpcyBhYm9ydGVkXG4gKi9cbmZ1bmN0aW9uIGxvb3AoY2FsbGJhY2spIHtcbiAgICBsZXQgdGFzaztcbiAgICBpZiAodGFza3Muc2l6ZSA9PT0gMClcbiAgICAgICAgcmFmKHJ1bl90YXNrcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvbWlzZTogbmV3IFByb21pc2UoZnVsZmlsbCA9PiB7XG4gICAgICAgICAgICB0YXNrcy5hZGQodGFzayA9IHsgYzogY2FsbGJhY2ssIGY6IGZ1bGZpbGwgfSk7XG4gICAgICAgIH0pLFxuICAgICAgICBhYm9ydCgpIHtcbiAgICAgICAgICAgIHRhc2tzLmRlbGV0ZSh0YXNrKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8vIFRyYWNrIHdoaWNoIG5vZGVzIGFyZSBjbGFpbWVkIGR1cmluZyBoeWRyYXRpb24uIFVuY2xhaW1lZCBub2RlcyBjYW4gdGhlbiBiZSByZW1vdmVkIGZyb20gdGhlIERPTVxuLy8gYXQgdGhlIGVuZCBvZiBoeWRyYXRpb24gd2l0aG91dCB0b3VjaGluZyB0aGUgcmVtYWluaW5nIG5vZGVzLlxubGV0IGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xuZnVuY3Rpb24gc3RhcnRfaHlkcmF0aW5nKCkge1xuICAgIGlzX2h5ZHJhdGluZyA9IHRydWU7XG59XG5mdW5jdGlvbiBlbmRfaHlkcmF0aW5nKCkge1xuICAgIGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gdXBwZXJfYm91bmQobG93LCBoaWdoLCBrZXksIHZhbHVlKSB7XG4gICAgLy8gUmV0dXJuIGZpcnN0IGluZGV4IG9mIHZhbHVlIGxhcmdlciB0aGFuIGlucHV0IHZhbHVlIGluIHRoZSByYW5nZSBbbG93LCBoaWdoKVxuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIGNvbnN0IG1pZCA9IGxvdyArICgoaGlnaCAtIGxvdykgPj4gMSk7XG4gICAgICAgIGlmIChrZXkobWlkKSA8PSB2YWx1ZSkge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbn1cbmZ1bmN0aW9uIGluaXRfaHlkcmF0ZSh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0Lmh5ZHJhdGVfaW5pdClcbiAgICAgICAgcmV0dXJuO1xuICAgIHRhcmdldC5oeWRyYXRlX2luaXQgPSB0cnVlO1xuICAgIC8vIFdlIGtub3cgdGhhdCBhbGwgY2hpbGRyZW4gaGF2ZSBjbGFpbV9vcmRlciB2YWx1ZXMgc2luY2UgdGhlIHVuY2xhaW1lZCBoYXZlIGJlZW4gZGV0YWNoZWQgaWYgdGFyZ2V0IGlzIG5vdCA8aGVhZD5cbiAgICBsZXQgY2hpbGRyZW4gPSB0YXJnZXQuY2hpbGROb2RlcztcbiAgICAvLyBJZiB0YXJnZXQgaXMgPGhlYWQ+LCB0aGVyZSBtYXkgYmUgY2hpbGRyZW4gd2l0aG91dCBjbGFpbV9vcmRlclxuICAgIGlmICh0YXJnZXQubm9kZU5hbWUgPT09ICdIRUFEJykge1xuICAgICAgICBjb25zdCBteUNoaWxkcmVuID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBteUNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4gPSBteUNoaWxkcmVuO1xuICAgIH1cbiAgICAvKlxuICAgICogUmVvcmRlciBjbGFpbWVkIGNoaWxkcmVuIG9wdGltYWxseS5cbiAgICAqIFdlIGNhbiByZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5IGJ5IGZpbmRpbmcgdGhlIGxvbmdlc3Qgc3Vic2VxdWVuY2Ugb2ZcbiAgICAqIG5vZGVzIHRoYXQgYXJlIGFscmVhZHkgY2xhaW1lZCBpbiBvcmRlciBhbmQgb25seSBtb3ZpbmcgdGhlIHJlc3QuIFRoZSBsb25nZXN0XG4gICAgKiBzdWJzZXF1ZW5jZSBzdWJzZXF1ZW5jZSBvZiBub2RlcyB0aGF0IGFyZSBjbGFpbWVkIGluIG9yZGVyIGNhbiBiZSBmb3VuZCBieVxuICAgICogY29tcHV0aW5nIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgLmNsYWltX29yZGVyIHZhbHVlcy5cbiAgICAqXG4gICAgKiBUaGlzIGFsZ29yaXRobSBpcyBvcHRpbWFsIGluIGdlbmVyYXRpbmcgdGhlIGxlYXN0IGFtb3VudCBvZiByZW9yZGVyIG9wZXJhdGlvbnNcbiAgICAqIHBvc3NpYmxlLlxuICAgICpcbiAgICAqIFByb29mOlxuICAgICogV2Uga25vdyB0aGF0LCBnaXZlbiBhIHNldCBvZiByZW9yZGVyaW5nIG9wZXJhdGlvbnMsIHRoZSBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlXG4gICAgKiBhbHdheXMgZm9ybSBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLCBzaW5jZSB0aGV5IGRvIG5vdCBtb3ZlIGFtb25nIGVhY2ggb3RoZXJcbiAgICAqIG1lYW5pbmcgdGhhdCB0aGV5IG11c3QgYmUgYWxyZWFkeSBvcmRlcmVkIGFtb25nIGVhY2ggb3RoZXIuIFRodXMsIHRoZSBtYXhpbWFsXG4gICAgKiBzZXQgb2Ygbm9kZXMgdGhhdCBkbyBub3QgbW92ZSBmb3JtIGEgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLlxuICAgICovXG4gICAgLy8gQ29tcHV0ZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2VcbiAgICAvLyBtOiBzdWJzZXF1ZW5jZSBsZW5ndGggaiA9PiBpbmRleCBrIG9mIHNtYWxsZXN0IHZhbHVlIHRoYXQgZW5kcyBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIGxlbmd0aCBqXG4gICAgY29uc3QgbSA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCArIDEpO1xuICAgIC8vIFByZWRlY2Vzc29yIGluZGljZXMgKyAxXG4gICAgY29uc3QgcCA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgbVswXSA9IC0xO1xuICAgIGxldCBsb25nZXN0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBjaGlsZHJlbltpXS5jbGFpbV9vcmRlcjtcbiAgICAgICAgLy8gRmluZCB0aGUgbGFyZ2VzdCBzdWJzZXF1ZW5jZSBsZW5ndGggc3VjaCB0aGF0IGl0IGVuZHMgaW4gYSB2YWx1ZSBsZXNzIHRoYW4gb3VyIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgLy8gdXBwZXJfYm91bmQgcmV0dXJucyBmaXJzdCBncmVhdGVyIHZhbHVlLCBzbyB3ZSBzdWJ0cmFjdCBvbmVcbiAgICAgICAgLy8gd2l0aCBmYXN0IHBhdGggZm9yIHdoZW4gd2UgYXJlIG9uIHRoZSBjdXJyZW50IGxvbmdlc3Qgc3Vic2VxdWVuY2VcbiAgICAgICAgY29uc3Qgc2VxTGVuID0gKChsb25nZXN0ID4gMCAmJiBjaGlsZHJlblttW2xvbmdlc3RdXS5jbGFpbV9vcmRlciA8PSBjdXJyZW50KSA/IGxvbmdlc3QgKyAxIDogdXBwZXJfYm91bmQoMSwgbG9uZ2VzdCwgaWR4ID0+IGNoaWxkcmVuW21baWR4XV0uY2xhaW1fb3JkZXIsIGN1cnJlbnQpKSAtIDE7XG4gICAgICAgIHBbaV0gPSBtW3NlcUxlbl0gKyAxO1xuICAgICAgICBjb25zdCBuZXdMZW4gPSBzZXFMZW4gKyAxO1xuICAgICAgICAvLyBXZSBjYW4gZ3VhcmFudGVlIHRoYXQgY3VycmVudCBpcyB0aGUgc21hbGxlc3QgdmFsdWUuIE90aGVyd2lzZSwgd2Ugd291bGQgaGF2ZSBnZW5lcmF0ZWQgYSBsb25nZXIgc2VxdWVuY2UuXG4gICAgICAgIG1bbmV3TGVuXSA9IGk7XG4gICAgICAgIGxvbmdlc3QgPSBNYXRoLm1heChuZXdMZW4sIGxvbmdlc3QpO1xuICAgIH1cbiAgICAvLyBUaGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIG5vZGVzIChpbml0aWFsbHkgcmV2ZXJzZWQpXG4gICAgY29uc3QgbGlzID0gW107XG4gICAgLy8gVGhlIHJlc3Qgb2YgdGhlIG5vZGVzLCBub2RlcyB0aGF0IHdpbGwgYmUgbW92ZWRcbiAgICBjb25zdCB0b01vdmUgPSBbXTtcbiAgICBsZXQgbGFzdCA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgZm9yIChsZXQgY3VyID0gbVtsb25nZXN0XSArIDE7IGN1ciAhPSAwOyBjdXIgPSBwW2N1ciAtIDFdKSB7XG4gICAgICAgIGxpcy5wdXNoKGNoaWxkcmVuW2N1ciAtIDFdKTtcbiAgICAgICAgZm9yICg7IGxhc3QgPj0gY3VyOyBsYXN0LS0pIHtcbiAgICAgICAgICAgIHRvTW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0LS07XG4gICAgfVxuICAgIGZvciAoOyBsYXN0ID49IDA7IGxhc3QtLSkge1xuICAgICAgICB0b01vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG4gICAgfVxuICAgIGxpcy5yZXZlcnNlKCk7XG4gICAgLy8gV2Ugc29ydCB0aGUgbm9kZXMgYmVpbmcgbW92ZWQgdG8gZ3VhcmFudGVlIHRoYXQgdGhlaXIgaW5zZXJ0aW9uIG9yZGVyIG1hdGNoZXMgdGhlIGNsYWltIG9yZGVyXG4gICAgdG9Nb3ZlLnNvcnQoKGEsIGIpID0+IGEuY2xhaW1fb3JkZXIgLSBiLmNsYWltX29yZGVyKTtcbiAgICAvLyBGaW5hbGx5LCB3ZSBtb3ZlIHRoZSBub2Rlc1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHRvTW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB3aGlsZSAoaiA8IGxpcy5sZW5ndGggJiYgdG9Nb3ZlW2ldLmNsYWltX29yZGVyID49IGxpc1tqXS5jbGFpbV9vcmRlcikge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IGogPCBsaXMubGVuZ3RoID8gbGlzW2pdIDogbnVsbDtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZSh0b01vdmVbaV0sIGFuY2hvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kKHRhcmdldCwgbm9kZSkge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9zdHlsZXModGFyZ2V0LCBzdHlsZV9zaGVldF9pZCwgc3R5bGVzKSB7XG4gICAgY29uc3QgYXBwZW5kX3N0eWxlc190byA9IGdldF9yb290X2Zvcl9zdHlsZSh0YXJnZXQpO1xuICAgIGlmICghYXBwZW5kX3N0eWxlc190by5nZXRFbGVtZW50QnlJZChzdHlsZV9zaGVldF9pZCkpIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBlbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZS5pZCA9IHN0eWxlX3NoZWV0X2lkO1xuICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHN0eWxlcztcbiAgICAgICAgYXBwZW5kX3N0eWxlc2hlZXQoYXBwZW5kX3N0eWxlc190bywgc3R5bGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldF9yb290X2Zvcl9zdHlsZShub2RlKSB7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgY29uc3Qgcm9vdCA9IG5vZGUuZ2V0Um9vdE5vZGUgPyBub2RlLmdldFJvb3ROb2RlKCkgOiBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgaWYgKHJvb3QgJiYgcm9vdC5ob3N0KSB7XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50O1xufVxuZnVuY3Rpb24gYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQobm9kZSkge1xuICAgIGNvbnN0IHN0eWxlX2VsZW1lbnQgPSBlbGVtZW50KCdzdHlsZScpO1xuICAgIGFwcGVuZF9zdHlsZXNoZWV0KGdldF9yb290X2Zvcl9zdHlsZShub2RlKSwgc3R5bGVfZWxlbWVudCk7XG4gICAgcmV0dXJuIHN0eWxlX2VsZW1lbnQ7XG59XG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzaGVldChub2RlLCBzdHlsZSkge1xuICAgIGFwcGVuZChub2RlLmhlYWQgfHwgbm9kZSwgc3R5bGUpO1xufVxuZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpIHtcbiAgICBpZiAoaXNfaHlkcmF0aW5nKSB7XG4gICAgICAgIGluaXRfaHlkcmF0ZSh0YXJnZXQpO1xuICAgICAgICBpZiAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID09PSB1bmRlZmluZWQpIHx8ICgodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgIT09IG51bGwpICYmICh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5wYXJlbnRFbGVtZW50ICE9PSB0YXJnZXQpKSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTa2lwIG5vZGVzIG9mIHVuZGVmaW5lZCBvcmRlcmluZ1xuICAgICAgICB3aGlsZSAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsKSAmJiAodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQuY2xhaW1fb3JkZXIgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgIT09IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKSB7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IGluc2VydCBpZiB0aGUgb3JkZXJpbmcgb2YgdGhpcyBub2RlIHNob3VsZCBiZSBtb2RpZmllZCBvciB0aGUgcGFyZW50IG5vZGUgaXMgbm90IHRhcmdldFxuICAgICAgICAgICAgaWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCB8fCBub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGlmIChpc19oeWRyYXRpbmcgJiYgIWFuY2hvcikge1xuICAgICAgICBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT0gYW5jaG9yKSB7XG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaChub2RlKSB7XG4gICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuZnVuY3Rpb24gZGVzdHJveV9lYWNoKGl0ZXJhdGlvbnMsIGRldGFjaGluZykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoaXRlcmF0aW9uc1tpXSlcbiAgICAgICAgICAgIGl0ZXJhdGlvbnNbaV0uZChkZXRhY2hpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVsZW1lbnQobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xufVxuZnVuY3Rpb24gZWxlbWVudF9pcyhuYW1lLCBpcykge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUsIHsgaXMgfSk7XG59XG5mdW5jdGlvbiBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzKG9iaiwgZXhjbHVkZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc19wcm9wKG9iaiwgaylcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICYmIGV4Y2x1ZGUuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRhcmdldFtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gc3ZnX2VsZW1lbnQobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG59XG5mdW5jdGlvbiB0ZXh0KGRhdGEpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSk7XG59XG5mdW5jdGlvbiBzcGFjZSgpIHtcbiAgICByZXR1cm4gdGV4dCgnICcpO1xufVxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRleHQoJycpO1xufVxuZnVuY3Rpb24gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHByZXZlbnRfZGVmYXVsdChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN0b3BfcHJvcGFnYXRpb24oZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc2VsZihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzKVxuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRydXN0ZWQoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGV2ZW50LmlzVHJ1c3RlZClcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICBlbHNlIGlmIChub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpICE9PSB2YWx1ZSlcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobm9kZS5fX3Byb3RvX18pO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5jc3NUZXh0ID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ19fdmFsdWUnKSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gbm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlc2NyaXB0b3JzW2tleV0gJiYgZGVzY3JpcHRvcnNba2V5XS5zZXQpIHtcbiAgICAgICAgICAgIG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X3N2Z19hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKHByb3AgaW4gbm9kZSkge1xuICAgICAgICBub2RlW3Byb3BdID0gdHlwZW9mIG5vZGVbcHJvcF0gPT09ICdib29sZWFuJyAmJiB2YWx1ZSA9PT0gJycgPyB0cnVlIDogdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhdHRyKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB4bGlua19hdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cF92YWx1ZShncm91cCwgX192YWx1ZSwgY2hlY2tlZCkge1xuICAgIGNvbnN0IHZhbHVlID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGdyb3VwW2ldLmNoZWNrZWQpXG4gICAgICAgICAgICB2YWx1ZS5hZGQoZ3JvdXBbaV0uX192YWx1ZSk7XG4gICAgfVxuICAgIGlmICghY2hlY2tlZCkge1xuICAgICAgICB2YWx1ZS5kZWxldGUoX192YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gJycgPyBudWxsIDogK3ZhbHVlO1xufVxuZnVuY3Rpb24gdGltZV9yYW5nZXNfdG9fYXJyYXkocmFuZ2VzKSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBhcnJheS5wdXNoKHsgc3RhcnQ6IHJhbmdlcy5zdGFydChpKSwgZW5kOiByYW5nZXMuZW5kKGkpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBjaGlsZHJlbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5jaGlsZE5vZGVzKTtcbn1cbmZ1bmN0aW9uIGluaXRfY2xhaW1faW5mbyhub2Rlcykge1xuICAgIGlmIChub2Rlcy5jbGFpbV9pbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZXMuY2xhaW1faW5mbyA9IHsgbGFzdF9pbmRleDogMCwgdG90YWxfY2xhaW1lZDogMCB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsYWltX25vZGUobm9kZXMsIHByZWRpY2F0ZSwgcHJvY2Vzc05vZGUsIGNyZWF0ZU5vZGUsIGRvbnRVcGRhdGVMYXN0SW5kZXggPSBmYWxzZSkge1xuICAgIC8vIFRyeSB0byBmaW5kIG5vZGVzIGluIGFuIG9yZGVyIHN1Y2ggdGhhdCB3ZSBsZW5ndGhlbiB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlXG4gICAgaW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcbiAgICBjb25zdCByZXN1bHROb2RlID0gKCgpID0+IHtcbiAgICAgICAgLy8gV2UgZmlyc3QgdHJ5IHRvIGZpbmQgYW4gZWxlbWVudCBhZnRlciB0aGUgcHJldmlvdXMgb25lXG4gICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXg7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc05vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkb250VXBkYXRlTGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgdHJ5IHRvIGZpbmQgb25lIGJlZm9yZVxuICAgICAgICAvLyBXZSBpdGVyYXRlIGluIHJldmVyc2Ugc28gdGhhdCB3ZSBkb24ndCBnbyB0b28gZmFyIGJhY2tcbiAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRvbnRVcGRhdGVMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSBzcGxpY2VkIGJlZm9yZSB0aGUgbGFzdF9pbmRleCwgd2UgZGVjcmVhc2UgaXRcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGNhbid0IGZpbmQgYW55IG1hdGNoaW5nIG5vZGUsIHdlIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU5vZGUoKTtcbiAgICB9KSgpO1xuICAgIHJlc3VsdE5vZGUuY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG4gICAgbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG4gICAgcmV0dXJuIHJlc3VsdE5vZGU7XG59XG5mdW5jdGlvbiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGNyZWF0ZV9lbGVtZW50KSB7XG4gICAgcmV0dXJuIGNsYWltX25vZGUobm9kZXMsIChub2RlKSA9PiBub2RlLm5vZGVOYW1lID09PSBuYW1lLCAobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCByZW1vdmUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlc1tqXTtcbiAgICAgICAgICAgIGlmICghYXR0cmlidXRlc1thdHRyaWJ1dGUubmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZW1vdmUucHVzaChhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlLmZvckVhY2godiA9PiBub2RlLnJlbW92ZUF0dHJpYnV0ZSh2KSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSwgKCkgPT4gY3JlYXRlX2VsZW1lbnQobmFtZSkpO1xufVxuZnVuY3Rpb24gY2xhaW1fZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gY2xhaW1fc3ZnX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBzdmdfZWxlbWVudCk7XG59XG5mdW5jdGlvbiBjbGFpbV90ZXh0KG5vZGVzLCBkYXRhKSB7XG4gICAgcmV0dXJuIGNsYWltX25vZGUobm9kZXMsIChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSAzLCAobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhU3RyID0gJycgKyBkYXRhO1xuICAgICAgICBpZiAobm9kZS5kYXRhLnN0YXJ0c1dpdGgoZGF0YVN0cikpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmRhdGEubGVuZ3RoICE9PSBkYXRhU3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnNwbGl0VGV4dChkYXRhU3RyLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSBkYXRhU3RyO1xuICAgICAgICB9XG4gICAgfSwgKCkgPT4gdGV4dChkYXRhKSwgdHJ1ZSAvLyBUZXh0IG5vZGVzIHNob3VsZCBub3QgdXBkYXRlIGxhc3QgaW5kZXggc2luY2UgaXQgaXMgbGlrZWx5IG5vdCB3b3J0aCBpdCB0byBlbGltaW5hdGUgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBhY3R1YWwgZWxlbWVudHNcbiAgICApO1xufVxuZnVuY3Rpb24gY2xhaW1fc3BhY2Uobm9kZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fdGV4dChub2RlcywgJyAnKTtcbn1cbmZ1bmN0aW9uIGZpbmRfY29tbWVudChub2RlcywgdGV4dCwgc3RhcnQpIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIGNvbW1lbnQgbm9kZSAqLyAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSA9PT0gdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNsYWltX2h0bWxfdGFnKG5vZGVzKSB7XG4gICAgLy8gZmluZCBodG1sIG9wZW5pbmcgdGFnXG4gICAgY29uc3Qgc3RhcnRfaW5kZXggPSBmaW5kX2NvbW1lbnQobm9kZXMsICdIVE1MX1RBR19TVEFSVCcsIDApO1xuICAgIGNvbnN0IGVuZF9pbmRleCA9IGZpbmRfY29tbWVudChub2RlcywgJ0hUTUxfVEFHX0VORCcsIHN0YXJ0X2luZGV4KTtcbiAgICBpZiAoc3RhcnRfaW5kZXggPT09IGVuZF9pbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24oKTtcbiAgICB9XG4gICAgaW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcbiAgICBjb25zdCBodG1sX3RhZ19ub2RlcyA9IG5vZGVzLnNwbGljZShzdGFydF9pbmRleCwgZW5kX2luZGV4ICsgMSk7XG4gICAgZGV0YWNoKGh0bWxfdGFnX25vZGVzWzBdKTtcbiAgICBkZXRhY2goaHRtbF90YWdfbm9kZXNbaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMV0pO1xuICAgIGNvbnN0IGNsYWltZWRfbm9kZXMgPSBodG1sX3RhZ19ub2Rlcy5zbGljZSgxLCBodG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxKTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgY2xhaW1lZF9ub2Rlcykge1xuICAgICAgICBuLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKGNsYWltZWRfbm9kZXMpO1xufVxuZnVuY3Rpb24gc2V0X2RhdGEodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQud2hvbGVUZXh0ICE9PSBkYXRhKVxuICAgICAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gc2V0X2lucHV0X3ZhbHVlKGlucHV0LCB2YWx1ZSkge1xuICAgIGlucHV0LnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRfaW5wdXRfdHlwZShpbnB1dCwgdHlwZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlucHV0LnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X3N0eWxlKG5vZGUsIGtleSwgdmFsdWUsIGltcG9ydGFudCkge1xuICAgIG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSwgaW1wb3J0YW50ID8gJ2ltcG9ydGFudCcgOiAnJyk7XG59XG5mdW5jdGlvbiBzZWxlY3Rfb3B0aW9uKHNlbGVjdCwgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuICAgICAgICBpZiAob3B0aW9uLl9fdmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdC5zZWxlY3RlZEluZGV4ID0gLTE7IC8vIG5vIG9wdGlvbiBzaG91bGQgYmUgc2VsZWN0ZWRcbn1cbmZ1bmN0aW9uIHNlbGVjdF9vcHRpb25zKHNlbGVjdCwgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB+dmFsdWUuaW5kZXhPZihvcHRpb24uX192YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0X3ZhbHVlKHNlbGVjdCkge1xuICAgIGNvbnN0IHNlbGVjdGVkX29wdGlvbiA9IHNlbGVjdC5xdWVyeVNlbGVjdG9yKCc6Y2hlY2tlZCcpIHx8IHNlbGVjdC5vcHRpb25zWzBdO1xuICAgIHJldHVybiBzZWxlY3RlZF9vcHRpb24gJiYgc2VsZWN0ZWRfb3B0aW9uLl9fdmFsdWU7XG59XG5mdW5jdGlvbiBzZWxlY3RfbXVsdGlwbGVfdmFsdWUoc2VsZWN0KSB7XG4gICAgcmV0dXJuIFtdLm1hcC5jYWxsKHNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKCc6Y2hlY2tlZCcpLCBvcHRpb24gPT4gb3B0aW9uLl9fdmFsdWUpO1xufVxuLy8gdW5mb3J0dW5hdGVseSB0aGlzIGNhbid0IGJlIGEgY29uc3RhbnQgYXMgdGhhdCB3b3VsZG4ndCBiZSB0cmVlLXNoYWtlYWJsZVxuLy8gc28gd2UgY2FjaGUgdGhlIHJlc3VsdCBpbnN0ZWFkXG5sZXQgY3Jvc3NvcmlnaW47XG5mdW5jdGlvbiBpc19jcm9zc29yaWdpbigpIHtcbiAgICBpZiAoY3Jvc3NvcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjcm9zc29yaWdpbiA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB2b2lkIHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjcm9zc29yaWdpbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyb3Nzb3JpZ2luO1xufVxuZnVuY3Rpb24gYWRkX3Jlc2l6ZV9saXN0ZW5lcihub2RlLCBmbikge1xuICAgIGNvbnN0IGNvbXB1dGVkX3N0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBpZiAoY29tcHV0ZWRfc3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIH1cbiAgICBjb25zdCBpZnJhbWUgPSBlbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBibG9jazsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7ICcgK1xuICAgICAgICAnb3ZlcmZsb3c6IGhpZGRlbjsgYm9yZGVyOiAwOyBvcGFjaXR5OiAwOyBwb2ludGVyLWV2ZW50czogbm9uZTsgei1pbmRleDogLTE7Jyk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIGlmcmFtZS50YWJJbmRleCA9IC0xO1xuICAgIGNvbnN0IGNyb3Nzb3JpZ2luID0gaXNfY3Jvc3NvcmlnaW4oKTtcbiAgICBsZXQgdW5zdWJzY3JpYmU7XG4gICAgaWYgKGNyb3Nzb3JpZ2luKSB7XG4gICAgICAgIGlmcmFtZS5zcmMgPSBcImRhdGE6dGV4dC9odG1sLDxzY3JpcHQ+b25yZXNpemU9ZnVuY3Rpb24oKXtwYXJlbnQucG9zdE1lc3NhZ2UoMCwnKicpfTwvc2NyaXB0PlwiO1xuICAgICAgICB1bnN1YnNjcmliZSA9IGxpc3Rlbih3aW5kb3csICdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBpZnJhbWUuY29udGVudFdpbmRvdylcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmcmFtZS5zcmMgPSAnYWJvdXQ6YmxhbmsnO1xuICAgICAgICBpZnJhbWUub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBsaXN0ZW4oaWZyYW1lLmNvbnRlbnRXaW5kb3csICdyZXNpemUnLCBmbik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGVuZChub2RlLCBpZnJhbWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChjcm9zc29yaWdpbikge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1bnN1YnNjcmliZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBkZXRhY2goaWZyYW1lKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9nZ2xlX2NsYXNzKGVsZW1lbnQsIG5hbWUsIHRvZ2dsZSkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0W3RvZ2dsZSA/ICdhZGQnIDogJ3JlbW92ZSddKG5hbWUpO1xufVxuZnVuY3Rpb24gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgYnViYmxlcyA9IGZhbHNlKSB7XG4gICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgIGUuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIGJ1YmJsZXMsIGZhbHNlLCBkZXRhaWwpO1xuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcXVlcnlfc2VsZWN0b3JfYWxsKHNlbGVjdG9yLCBwYXJlbnQgPSBkb2N1bWVudC5ib2R5KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbn1cbmNsYXNzIEh0bWxUYWcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuICAgIH1cbiAgICBjKGh0bWwpIHtcbiAgICAgICAgdGhpcy5oKGh0bWwpO1xuICAgIH1cbiAgICBtKGh0bWwsIHRhcmdldCwgYW5jaG9yID0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMuZSkge1xuICAgICAgICAgICAgdGhpcy5lID0gZWxlbWVudCh0YXJnZXQubm9kZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy50ID0gdGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5jKGh0bWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaShhbmNob3IpO1xuICAgIH1cbiAgICBoKGh0bWwpIHtcbiAgICAgICAgdGhpcy5lLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHRoaXMubiA9IEFycmF5LmZyb20odGhpcy5lLmNoaWxkTm9kZXMpO1xuICAgIH1cbiAgICBpKGFuY2hvcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5zZXJ0KHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHAoaHRtbCkge1xuICAgICAgICB0aGlzLmQoKTtcbiAgICAgICAgdGhpcy5oKGh0bWwpO1xuICAgICAgICB0aGlzLmkodGhpcy5hKTtcbiAgICB9XG4gICAgZCgpIHtcbiAgICAgICAgdGhpcy5uLmZvckVhY2goZGV0YWNoKTtcbiAgICB9XG59XG5jbGFzcyBIdG1sVGFnSHlkcmF0aW9uIGV4dGVuZHMgSHRtbFRhZyB7XG4gICAgY29uc3RydWN0b3IoY2xhaW1lZF9ub2Rlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuICAgICAgICB0aGlzLmwgPSBjbGFpbWVkX25vZGVzO1xuICAgIH1cbiAgICBjKGh0bWwpIHtcbiAgICAgICAgaWYgKHRoaXMubCkge1xuICAgICAgICAgICAgdGhpcy5uID0gdGhpcy5sO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIuYyhodG1sKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpKGFuY2hvcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5zZXJ0X2h5ZHJhdGlvbih0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGF0dHJpYnV0ZV90b19vYmplY3QoYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmVzdWx0W2F0dHJpYnV0ZS5uYW1lXSA9IGF0dHJpYnV0ZS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMoZWxlbWVudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGVsZW1lbnQuY2hpbGROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIHJlc3VsdFtub2RlLnNsb3QgfHwgJ2RlZmF1bHQnXSA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgYWN0aXZlX2RvY3MgPSBuZXcgU2V0KCk7XG5sZXQgYWN0aXZlID0gMDtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJrc2t5YXBwL3N0cmluZy1oYXNoL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICAgIGxldCBoYXNoID0gNTM4MTtcbiAgICBsZXQgaSA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpIF4gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGhhc2ggPj4+IDA7XG59XG5mdW5jdGlvbiBjcmVhdGVfcnVsZShub2RlLCBhLCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2UsIGZuLCB1aWQgPSAwKSB7XG4gICAgY29uc3Qgc3RlcCA9IDE2LjY2NiAvIGR1cmF0aW9uO1xuICAgIGxldCBrZXlmcmFtZXMgPSAne1xcbic7XG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPD0gMTsgcCArPSBzdGVwKSB7XG4gICAgICAgIGNvbnN0IHQgPSBhICsgKGIgLSBhKSAqIGVhc2UocCk7XG4gICAgICAgIGtleWZyYW1lcyArPSBwICogMTAwICsgYCV7JHtmbih0LCAxIC0gdCl9fVxcbmA7XG4gICAgfVxuICAgIGNvbnN0IHJ1bGUgPSBrZXlmcmFtZXMgKyBgMTAwJSB7JHtmbihiLCAxIC0gYil9fVxcbn1gO1xuICAgIGNvbnN0IG5hbWUgPSBgX19zdmVsdGVfJHtoYXNoKHJ1bGUpfV8ke3VpZH1gO1xuICAgIGNvbnN0IGRvYyA9IGdldF9yb290X2Zvcl9zdHlsZShub2RlKTtcbiAgICBhY3RpdmVfZG9jcy5hZGQoZG9jKTtcbiAgICBjb25zdCBzdHlsZXNoZWV0ID0gZG9jLl9fc3ZlbHRlX3N0eWxlc2hlZXQgfHwgKGRvYy5fX3N2ZWx0ZV9zdHlsZXNoZWV0ID0gYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQobm9kZSkuc2hlZXQpO1xuICAgIGNvbnN0IGN1cnJlbnRfcnVsZXMgPSBkb2MuX19zdmVsdGVfcnVsZXMgfHwgKGRvYy5fX3N2ZWx0ZV9ydWxlcyA9IHt9KTtcbiAgICBpZiAoIWN1cnJlbnRfcnVsZXNbbmFtZV0pIHtcbiAgICAgICAgY3VycmVudF9ydWxlc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHN0eWxlc2hlZXQuaW5zZXJ0UnVsZShgQGtleWZyYW1lcyAke25hbWV9ICR7cnVsZX1gLCBzdHlsZXNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbiA9IG5vZGUuc3R5bGUuYW5pbWF0aW9uIHx8ICcnO1xuICAgIG5vZGUuc3R5bGUuYW5pbWF0aW9uID0gYCR7YW5pbWF0aW9uID8gYCR7YW5pbWF0aW9ufSwgYCA6ICcnfSR7bmFtZX0gJHtkdXJhdGlvbn1tcyBsaW5lYXIgJHtkZWxheX1tcyAxIGJvdGhgO1xuICAgIGFjdGl2ZSArPSAxO1xuICAgIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gZGVsZXRlX3J1bGUobm9kZSwgbmFtZSkge1xuICAgIGNvbnN0IHByZXZpb3VzID0gKG5vZGUuc3R5bGUuYW5pbWF0aW9uIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICBjb25zdCBuZXh0ID0gcHJldmlvdXMuZmlsdGVyKG5hbWVcbiAgICAgICAgPyBhbmltID0+IGFuaW0uaW5kZXhPZihuYW1lKSA8IDAgLy8gcmVtb3ZlIHNwZWNpZmljIGFuaW1hdGlvblxuICAgICAgICA6IGFuaW0gPT4gYW5pbS5pbmRleE9mKCdfX3N2ZWx0ZScpID09PSAtMSAvLyByZW1vdmUgYWxsIFN2ZWx0ZSBhbmltYXRpb25zXG4gICAgKTtcbiAgICBjb25zdCBkZWxldGVkID0gcHJldmlvdXMubGVuZ3RoIC0gbmV4dC5sZW5ndGg7XG4gICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBuZXh0LmpvaW4oJywgJyk7XG4gICAgICAgIGFjdGl2ZSAtPSBkZWxldGVkO1xuICAgICAgICBpZiAoIWFjdGl2ZSlcbiAgICAgICAgICAgIGNsZWFyX3J1bGVzKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xlYXJfcnVsZXMoKSB7XG4gICAgcmFmKCgpID0+IHtcbiAgICAgICAgaWYgKGFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgYWN0aXZlX2RvY3MuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVzaGVldCA9IGRvYy5fX3N2ZWx0ZV9zdHlsZXNoZWV0O1xuICAgICAgICAgICAgbGV0IGkgPSBzdHlsZXNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgc3R5bGVzaGVldC5kZWxldGVSdWxlKGkpO1xuICAgICAgICAgICAgZG9jLl9fc3ZlbHRlX3J1bGVzID0ge307XG4gICAgICAgIH0pO1xuICAgICAgICBhY3RpdmVfZG9jcy5jbGVhcigpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVfYW5pbWF0aW9uKG5vZGUsIGZyb20sIGZuLCBwYXJhbXMpIHtcbiAgICBpZiAoIWZyb20pXG4gICAgICAgIHJldHVybiBub29wO1xuICAgIGNvbnN0IHRvID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoZnJvbS5sZWZ0ID09PSB0by5sZWZ0ICYmIGZyb20ucmlnaHQgPT09IHRvLnJpZ2h0ICYmIGZyb20udG9wID09PSB0by50b3AgJiYgZnJvbS5ib3R0b20gPT09IHRvLmJvdHRvbSlcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgXG4gICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBzaG91bGQgdGhpcyBiZSBzZXBhcmF0ZWQgZnJvbSBkZXN0cnVjdHVyaW5nPyBPciBzdGFydC9lbmQgYWRkZWQgdG8gcHVibGljIGFwaSBhbmQgZG9jdW1lbnRhdGlvbj9cbiAgICBzdGFydDogc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXksIFxuICAgIC8vIEB0cy1pZ25vcmUgdG9kbzpcbiAgICBlbmQgPSBzdGFydF90aW1lICsgZHVyYXRpb24sIHRpY2sgPSBub29wLCBjc3MgfSA9IGZuKG5vZGUsIHsgZnJvbSwgdG8gfSwgcGFyYW1zKTtcbiAgICBsZXQgcnVubmluZyA9IHRydWU7XG4gICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBsZXQgbmFtZTtcbiAgICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVsYXkpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBuYW1lKTtcbiAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgIGlmICghc3RhcnRlZCAmJiBub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ZWQgJiYgbm93ID49IGVuZCkge1xuICAgICAgICAgICAgdGljaygxLCAwKTtcbiAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgICAgICAgY29uc3QgcCA9IG5vdyAtIHN0YXJ0X3RpbWU7XG4gICAgICAgICAgICBjb25zdCB0ID0gMCArIDEgKiBlYXNpbmcocCAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIHN0YXJ0KCk7XG4gICAgdGljaygwLCAxKTtcbiAgICByZXR1cm4gc3RvcDtcbn1cbmZ1bmN0aW9uIGZpeF9wb3NpdGlvbihub2RlKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGlmIChzdHlsZS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBzdHlsZS5wb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHN0eWxlO1xuICAgICAgICBjb25zdCBhID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIG5vZGUuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGFkZF90cmFuc2Zvcm0obm9kZSwgYSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkX3RyYW5zZm9ybShub2RlLCBhKSB7XG4gICAgY29uc3QgYiA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGEubGVmdCAhPT0gYi5sZWZ0IHx8IGEudG9wICE9PSBiLnRvcCkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gYCR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHthLmxlZnQgLSBiLmxlZnR9cHgsICR7YS50b3AgLSBiLnRvcH1weClgO1xuICAgIH1cbn1cblxubGV0IGN1cnJlbnRfY29tcG9uZW50O1xuZnVuY3Rpb24gc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIGN1cnJlbnRfY29tcG9uZW50ID0gY29tcG9uZW50O1xufVxuZnVuY3Rpb24gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkge1xuICAgIGlmICghY3VycmVudF9jb21wb25lbnQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY2FsbGVkIG91dHNpZGUgY29tcG9uZW50IGluaXRpYWxpemF0aW9uJyk7XG4gICAgcmV0dXJuIGN1cnJlbnRfY29tcG9uZW50O1xufVxuZnVuY3Rpb24gYmVmb3JlVXBkYXRlKGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYmVmb3JlX3VwZGF0ZS5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIG9uTW91bnQoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9tb3VudC5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIGFmdGVyVXBkYXRlKGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYWZ0ZXJfdXBkYXRlLnB1c2goZm4pO1xufVxuZnVuY3Rpb24gb25EZXN0cm95KGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fZGVzdHJveS5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcbiAgICByZXR1cm4gKHR5cGUsIGRldGFpbCkgPT4ge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW3R5cGVdO1xuICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGFyZSB0aGVyZSBzaXR1YXRpb25zIHdoZXJlIGV2ZW50cyBjb3VsZCBiZSBkaXNwYXRjaGVkXG4gICAgICAgICAgICAvLyBpbiBhIHNlcnZlciAobm9uLURPTSkgZW52aXJvbm1lbnQ/XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwpO1xuICAgICAgICAgICAgY2FsbGJhY2tzLnNsaWNlKCkuZm9yRWFjaChmbiA9PiB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChjb21wb25lbnQsIGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNldENvbnRleHQoa2V5LCBjb250ZXh0KSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5zZXQoa2V5LCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGdldENvbnRleHQoa2V5KSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuZ2V0KGtleSk7XG59XG5mdW5jdGlvbiBnZXRBbGxDb250ZXh0cygpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dDtcbn1cbmZ1bmN0aW9uIGhhc0NvbnRleHQoa2V5KSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuaGFzKGtleSk7XG59XG4vLyBUT0RPIGZpZ3VyZSBvdXQgaWYgd2Ugc3RpbGwgd2FudCB0byBzdXBwb3J0XG4vLyBzaG9ydGhhbmQgZXZlbnRzLCBvciBpZiB3ZSB3YW50IHRvIGltcGxlbWVudFxuLy8gYSByZWFsIGJ1YmJsaW5nIG1lY2hhbmlzbVxuZnVuY3Rpb24gYnViYmxlKGNvbXBvbmVudCwgZXZlbnQpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW2V2ZW50LnR5cGVdO1xuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKGZuID0+IGZuLmNhbGwodGhpcywgZXZlbnQpKTtcbiAgICB9XG59XG5cbmNvbnN0IGRpcnR5X2NvbXBvbmVudHMgPSBbXTtcbmNvbnN0IGludHJvcyA9IHsgZW5hYmxlZDogZmFsc2UgfTtcbmNvbnN0IGJpbmRpbmdfY2FsbGJhY2tzID0gW107XG5jb25zdCByZW5kZXJfY2FsbGJhY2tzID0gW107XG5jb25zdCBmbHVzaF9jYWxsYmFja3MgPSBbXTtcbmNvbnN0IHJlc29sdmVkX3Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbmxldCB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG5mdW5jdGlvbiBzY2hlZHVsZV91cGRhdGUoKSB7XG4gICAgaWYgKCF1cGRhdGVfc2NoZWR1bGVkKSB7XG4gICAgICAgIHVwZGF0ZV9zY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlZF9wcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRpY2soKSB7XG4gICAgc2NoZWR1bGVfdXBkYXRlKCk7XG4gICAgcmV0dXJuIHJlc29sdmVkX3Byb21pc2U7XG59XG5mdW5jdGlvbiBhZGRfcmVuZGVyX2NhbGxiYWNrKGZuKSB7XG4gICAgcmVuZGVyX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIGFkZF9mbHVzaF9jYWxsYmFjayhmbikge1xuICAgIGZsdXNoX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cbi8vIGZsdXNoKCkgY2FsbHMgY2FsbGJhY2tzIGluIHRoaXMgb3JkZXI6XG4vLyAxLiBBbGwgYmVmb3JlVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuXG4vLyAyLiBBbGwgYmluZDp0aGlzIGNhbGxiYWNrcywgaW4gcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyAzLiBBbGwgYWZ0ZXJVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW4uIEVYQ0VQVFxuLy8gICAgZm9yIGFmdGVyVXBkYXRlcyBjYWxsZWQgZHVyaW5nIHRoZSBpbml0aWFsIG9uTW91bnQsIHdoaWNoIGFyZSBjYWxsZWQgaW5cbi8vICAgIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gU2luY2UgY2FsbGJhY2tzIG1pZ2h0IHVwZGF0ZSBjb21wb25lbnQgdmFsdWVzLCB3aGljaCBjb3VsZCB0cmlnZ2VyIGFub3RoZXJcbi8vIGNhbGwgdG8gZmx1c2goKSwgdGhlIGZvbGxvd2luZyBzdGVwcyBndWFyZCBhZ2FpbnN0IHRoaXM6XG4vLyAxLiBEdXJpbmcgYmVmb3JlVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4vLyAgICBkaXJ0eV9jb21wb25lbnRzIGFycmF5IGFuZCB3aWxsIGNhdXNlIGEgcmVlbnRyYW50IGNhbGwgdG8gZmx1c2goKS4gQmVjYXVzZVxuLy8gICAgdGhlIGZsdXNoIGluZGV4IGlzIGtlcHQgb3V0c2lkZSB0aGUgZnVuY3Rpb24sIHRoZSByZWVudHJhbnQgY2FsbCB3aWxsIHBpY2tcbi8vICAgIHVwIHdoZXJlIHRoZSBlYXJsaWVyIGNhbGwgbGVmdCBvZmYgYW5kIGdvIHRocm91Z2ggYWxsIGRpcnR5IGNvbXBvbmVudHMuIFRoZVxuLy8gICAgY3VycmVudF9jb21wb25lbnQgdmFsdWUgaXMgc2F2ZWQgYW5kIHJlc3RvcmVkIHNvIHRoYXQgdGhlIHJlZW50cmFudCBjYWxsIHdpbGxcbi8vICAgIG5vdCBpbnRlcmZlcmUgd2l0aCB0aGUgXCJwYXJlbnRcIiBmbHVzaCgpIGNhbGwuXG4vLyAyLiBiaW5kOnRoaXMgY2FsbGJhY2tzIGNhbm5vdCB0cmlnZ2VyIG5ldyBmbHVzaCgpIGNhbGxzLlxuLy8gMy4gRHVyaW5nIGFmdGVyVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgTk9UIGhhdmUgdGhlaXIgYWZ0ZXJVcGRhdGVcbi8vICAgIGNhbGxiYWNrIGNhbGxlZCBhIHNlY29uZCB0aW1lOyB0aGUgc2Vlbl9jYWxsYmFja3Mgc2V0LCBvdXRzaWRlIHRoZSBmbHVzaCgpXG4vLyAgICBmdW5jdGlvbiwgZ3VhcmFudGVlcyB0aGlzIGJlaGF2aW9yLlxuY29uc3Qgc2Vlbl9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5sZXQgZmx1c2hpZHggPSAwOyAvLyBEbyAqbm90KiBtb3ZlIHRoaXMgaW5zaWRlIHRoZSBmbHVzaCgpIGZ1bmN0aW9uXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgICBjb25zdCBzYXZlZF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICBkbyB7XG4gICAgICAgIC8vIGZpcnN0LCBjYWxsIGJlZm9yZVVwZGF0ZSBmdW5jdGlvbnNcbiAgICAgICAgLy8gYW5kIHVwZGF0ZSBjb21wb25lbnRzXG4gICAgICAgIHdoaWxlIChmbHVzaGlkeCA8IGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBkaXJ0eV9jb21wb25lbnRzW2ZsdXNoaWR4XTtcbiAgICAgICAgICAgIGZsdXNoaWR4Kys7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShjb21wb25lbnQuJCQpO1xuICAgICAgICB9XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgZGlydHlfY29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgICAgICBmbHVzaGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChiaW5kaW5nX2NhbGxiYWNrcy5sZW5ndGgpXG4gICAgICAgICAgICBiaW5kaW5nX2NhbGxiYWNrcy5wb3AoKSgpO1xuICAgICAgICAvLyB0aGVuLCBvbmNlIGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGNhbGxcbiAgICAgICAgLy8gYWZ0ZXJVcGRhdGUgZnVuY3Rpb25zLiBUaGlzIG1heSBjYXVzZVxuICAgICAgICAvLyBzdWJzZXF1ZW50IHVwZGF0ZXMuLi5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHJlbmRlcl9jYWxsYmFja3NbaV07XG4gICAgICAgICAgICBpZiAoIXNlZW5fY2FsbGJhY2tzLmhhcyhjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5zbyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGxvb3BzXG4gICAgICAgICAgICAgICAgc2Vlbl9jYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICB9IHdoaWxlIChkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCk7XG4gICAgd2hpbGUgKGZsdXNoX2NhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgZmx1c2hfY2FsbGJhY2tzLnBvcCgpKCk7XG4gICAgfVxuICAgIHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBzZWVuX2NhbGxiYWNrcy5jbGVhcigpO1xuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChzYXZlZF9jb21wb25lbnQpO1xufVxuZnVuY3Rpb24gdXBkYXRlKCQkKSB7XG4gICAgaWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICQkLnVwZGF0ZSgpO1xuICAgICAgICBydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuICAgICAgICBjb25zdCBkaXJ0eSA9ICQkLmRpcnR5O1xuICAgICAgICAkJC5kaXJ0eSA9IFstMV07XG4gICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LnAoJCQuY3R4LCBkaXJ0eSk7XG4gICAgICAgICQkLmFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xuICAgIH1cbn1cblxubGV0IHByb21pc2U7XG5mdW5jdGlvbiB3YWl0KCkge1xuICAgIGlmICghcHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2gobm9kZSwgZGlyZWN0aW9uLCBraW5kKSB7XG4gICAgbm9kZS5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudChgJHtkaXJlY3Rpb24gPyAnaW50cm8nIDogJ291dHJvJ30ke2tpbmR9YCkpO1xufVxuY29uc3Qgb3V0cm9pbmcgPSBuZXcgU2V0KCk7XG5sZXQgb3V0cm9zO1xuZnVuY3Rpb24gZ3JvdXBfb3V0cm9zKCkge1xuICAgIG91dHJvcyA9IHtcbiAgICAgICAgcjogMCxcbiAgICAgICAgYzogW10sXG4gICAgICAgIHA6IG91dHJvcyAvLyBwYXJlbnQgZ3JvdXBcbiAgICB9O1xufVxuZnVuY3Rpb24gY2hlY2tfb3V0cm9zKCkge1xuICAgIGlmICghb3V0cm9zLnIpIHtcbiAgICAgICAgcnVuX2FsbChvdXRyb3MuYyk7XG4gICAgfVxuICAgIG91dHJvcyA9IG91dHJvcy5wO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbl9pbihibG9jaywgbG9jYWwpIHtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2suaSkge1xuICAgICAgICBvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuICAgICAgICBibG9jay5pKGxvY2FsKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uX291dChibG9jaywgbG9jYWwsIGRldGFjaCwgY2FsbGJhY2spIHtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2subykge1xuICAgICAgICBpZiAob3V0cm9pbmcuaGFzKGJsb2NrKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb3V0cm9pbmcuYWRkKGJsb2NrKTtcbiAgICAgICAgb3V0cm9zLmMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suZCgxKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYmxvY2subyhsb2NhbCk7XG4gICAgfVxufVxuY29uc3QgbnVsbF90cmFuc2l0aW9uID0geyBkdXJhdGlvbjogMCB9O1xuZnVuY3Rpb24gY3JlYXRlX2luX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gZmFsc2U7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lO1xuICAgIGxldCB0YXNrO1xuICAgIGxldCB1aWQgPSAwO1xuICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MsIHVpZCsrKTtcbiAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgICAgIGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuICAgICAgICBpZiAodGFzaylcbiAgICAgICAgICAgIHRhc2suYWJvcnQoKTtcbiAgICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ3N0YXJ0JykpO1xuICAgICAgICB0YXNrID0gbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobm93ID49IGVuZF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHRydWUsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydW5uaW5nO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICAgIGlmIChzdGFydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSk7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZygpO1xuICAgICAgICAgICAgICAgIHdhaXQoKS50aGVuKGdvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgICAgICBzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVuZCgpIHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVfb3V0X3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWU7XG4gICAgY29uc3QgZ3JvdXAgPSBvdXRyb3M7XG4gICAgZ3JvdXAuciArPSAxO1xuICAgIGZ1bmN0aW9uIGdvKCkge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAxLCAwLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgICAgIGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnc3RhcnQnKSk7XG4gICAgICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBlbmRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBmYWxzZSwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tZ3JvdXAucikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHJlc3VsdCBpbiBgZW5kKClgIGJlaW5nIGNhbGxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gY2xlYW4gdXAgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVuX2FsbChncm91cC5jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGljaygxIC0gdCwgdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICB3YWl0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcoKTtcbiAgICAgICAgICAgIGdvKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ28oKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5kKHJlc2V0KSB7XG4gICAgICAgICAgICBpZiAocmVzZXQgJiYgY29uZmlnLnRpY2spIHtcbiAgICAgICAgICAgICAgICBjb25maWcudGljaygxLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcywgaW50cm8pIHtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zKTtcbiAgICBsZXQgdCA9IGludHJvID8gMCA6IDE7XG4gICAgbGV0IHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgbGV0IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lID0gbnVsbDtcbiAgICBmdW5jdGlvbiBjbGVhcl9hbmltYXRpb24oKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdChwcm9ncmFtLCBkdXJhdGlvbikge1xuICAgICAgICBjb25zdCBkID0gKHByb2dyYW0uYiAtIHQpO1xuICAgICAgICBkdXJhdGlvbiAqPSBNYXRoLmFicyhkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGE6IHQsXG4gICAgICAgICAgICBiOiBwcm9ncmFtLmIsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICBzdGFydDogcHJvZ3JhbS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogcHJvZ3JhbS5zdGFydCArIGR1cmF0aW9uLFxuICAgICAgICAgICAgZ3JvdXA6IHByb2dyYW0uZ3JvdXBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ28oYikge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBjb25zdCBwcm9ncmFtID0ge1xuICAgICAgICAgICAgc3RhcnQ6IG5vdygpICsgZGVsYXksXG4gICAgICAgICAgICBiXG4gICAgICAgIH07XG4gICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgIHByb2dyYW0uZ3JvdXAgPSBvdXRyb3M7XG4gICAgICAgICAgICBvdXRyb3MuciArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICBwZW5kaW5nX3Byb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBpbnRybywgYW5kIHRoZXJlJ3MgYSBkZWxheSwgd2UgbmVlZCB0byBkb1xuICAgICAgICAgICAgLy8gYW4gaW5pdGlhbCB0aWNrIGFuZC9vciBhcHBseSBDU1MgYW5pbWF0aW9uIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCB0LCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiKVxuICAgICAgICAgICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBpbml0KHByb2dyYW0sIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgYiwgJ3N0YXJ0JykpO1xuICAgICAgICAgICAgbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nX3Byb2dyYW0gJiYgbm93ID4gcGVuZGluZ19wcm9ncmFtLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocGVuZGluZ19wcm9ncmFtLCBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnc3RhcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIHJ1bm5pbmdfcHJvZ3JhbS5iLCBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24sIDAsIGVhc2luZywgY29uZmlnLmNzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2sodCA9IHJ1bm5pbmdfcHJvZ3JhbS5iLCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwZW5kaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSBkb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbS5iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludHJvIFx1MjAxNCB3ZSBjYW4gdGlkeSB1cCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG91dHJvIFx1MjAxNCBuZWVkcyB0byBiZSBjb29yZGluYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIS0tcnVubmluZ19wcm9ncmFtLmdyb3VwLnIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5fYWxsKHJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBub3cgLSBydW5uaW5nX3Byb2dyYW0uc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gcnVubmluZ19wcm9ncmFtLmEgKyBydW5uaW5nX3Byb2dyYW0uZCAqIGVhc2luZyhwIC8gcnVubmluZ19wcm9ncmFtLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhIShydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJ1bihiKSB7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHdhaXQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcoKTtcbiAgICAgICAgICAgICAgICAgICAgZ28oYik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbyhiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlX3Byb21pc2UocHJvbWlzZSwgaW5mbykge1xuICAgIGNvbnN0IHRva2VuID0gaW5mby50b2tlbiA9IHt9O1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSh0eXBlLCBpbmRleCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaW5mby50b2tlbiAhPT0gdG9rZW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGluZm8ucmVzb2x2ZWQgPSB2YWx1ZTtcbiAgICAgICAgbGV0IGNoaWxkX2N0eCA9IGluZm8uY3R4O1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoaWxkX2N0eCA9IGNoaWxkX2N0eC5zbGljZSgpO1xuICAgICAgICAgICAgY2hpbGRfY3R4W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9jayA9IHR5cGUgJiYgKGluZm8uY3VycmVudCA9IHR5cGUpKGNoaWxkX2N0eCk7XG4gICAgICAgIGxldCBuZWVkc19mbHVzaCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5mby5ibG9jaykge1xuICAgICAgICAgICAgaWYgKGluZm8uYmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgaW5mby5ibG9ja3MuZm9yRWFjaCgoYmxvY2ssIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGluZGV4ICYmIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8uYmxvY2tzW2ldID09PSBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLmJsb2Nrc1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja19vdXRyb3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5mby5ibG9jay5kKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2suYygpO1xuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG4gICAgICAgICAgICBibG9jay5tKGluZm8ubW91bnQoKSwgaW5mby5hbmNob3IpO1xuICAgICAgICAgICAgbmVlZHNfZmx1c2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluZm8uYmxvY2sgPSBibG9jaztcbiAgICAgICAgaWYgKGluZm8uYmxvY2tzKVxuICAgICAgICAgICAgaW5mby5ibG9ja3NbaW5kZXhdID0gYmxvY2s7XG4gICAgICAgIGlmIChuZWVkc19mbHVzaCkge1xuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNfcHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICBjb25zdCBjdXJyZW50X2NvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuICAgICAgICBwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGN1cnJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnRoZW4sIDEsIGluZm8udmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGN1cnJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLmNhdGNoLCAyLCBpbmZvLmVycm9yLCBlcnJvcik7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgICAgICBpZiAoIWluZm8uaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGlmIHdlIHByZXZpb3VzbHkgaGFkIGEgdGhlbi9jYXRjaCBibG9jaywgZGVzdHJveSBpdFxuICAgICAgICBpZiAoaW5mby5jdXJyZW50ICE9PSBpbmZvLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnBlbmRpbmcsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8udGhlbikge1xuICAgICAgICAgICAgdXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLnJlc29sdmVkID0gcHJvbWlzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVfYXdhaXRfYmxvY2tfYnJhbmNoKGluZm8sIGN0eCwgZGlydHkpIHtcbiAgICBjb25zdCBjaGlsZF9jdHggPSBjdHguc2xpY2UoKTtcbiAgICBjb25zdCB7IHJlc29sdmVkIH0gPSBpbmZvO1xuICAgIGlmIChpbmZvLmN1cnJlbnQgPT09IGluZm8udGhlbikge1xuICAgICAgICBjaGlsZF9jdHhbaW5mby52YWx1ZV0gPSByZXNvbHZlZDtcbiAgICB9XG4gICAgaWYgKGluZm8uY3VycmVudCA9PT0gaW5mby5jYXRjaCkge1xuICAgICAgICBjaGlsZF9jdHhbaW5mby5lcnJvcl0gPSByZXNvbHZlZDtcbiAgICB9XG4gICAgaW5mby5ibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpO1xufVxuXG5jb25zdCBnbG9iYWxzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgPyB3aW5kb3dcbiAgICA6IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGdsb2JhbFRoaXNcbiAgICAgICAgOiBnbG9iYWwpO1xuXG5mdW5jdGlvbiBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5kKDEpO1xuICAgIGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbn1cbmZ1bmN0aW9uIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICB0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuICAgICAgICBsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmYoKTtcbiAgICBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuZnVuY3Rpb24gZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZigpO1xuICAgIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuZnVuY3Rpb24gdXBkYXRlX2tleWVkX2VhY2gob2xkX2Jsb2NrcywgZGlydHksIGdldF9rZXksIGR5bmFtaWMsIGN0eCwgbGlzdCwgbG9va3VwLCBub2RlLCBkZXN0cm95LCBjcmVhdGVfZWFjaF9ibG9jaywgbmV4dCwgZ2V0X2NvbnRleHQpIHtcbiAgICBsZXQgbyA9IG9sZF9ibG9ja3MubGVuZ3RoO1xuICAgIGxldCBuID0gbGlzdC5sZW5ndGg7XG4gICAgbGV0IGkgPSBvO1xuICAgIGNvbnN0IG9sZF9pbmRleGVzID0ge307XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgb2xkX2luZGV4ZXNbb2xkX2Jsb2Nrc1tpXS5rZXldID0gaTtcbiAgICBjb25zdCBuZXdfYmxvY2tzID0gW107XG4gICAgY29uc3QgbmV3X2xvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkZWx0YXMgPSBuZXcgTWFwKCk7XG4gICAgaSA9IG47XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBjaGlsZF9jdHggPSBnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpO1xuICAgICAgICBjb25zdCBrZXkgPSBnZXRfa2V5KGNoaWxkX2N0eCk7XG4gICAgICAgIGxldCBibG9jayA9IGxvb2t1cC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICAgICAgYmxvY2sgPSBjcmVhdGVfZWFjaF9ibG9jayhrZXksIGNoaWxkX2N0eCk7XG4gICAgICAgICAgICBibG9jay5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHluYW1pYykge1xuICAgICAgICAgICAgYmxvY2sucChjaGlsZF9jdHgsIGRpcnR5KTtcbiAgICAgICAgfVxuICAgICAgICBuZXdfbG9va3VwLnNldChrZXksIG5ld19ibG9ja3NbaV0gPSBibG9jayk7XG4gICAgICAgIGlmIChrZXkgaW4gb2xkX2luZGV4ZXMpXG4gICAgICAgICAgICBkZWx0YXMuc2V0KGtleSwgTWF0aC5hYnMoaSAtIG9sZF9pbmRleGVzW2tleV0pKTtcbiAgICB9XG4gICAgY29uc3Qgd2lsbF9tb3ZlID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGRpZF9tb3ZlID0gbmV3IFNldCgpO1xuICAgIGZ1bmN0aW9uIGluc2VydChibG9jaykge1xuICAgICAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICAgICAgYmxvY2subShub2RlLCBuZXh0KTtcbiAgICAgICAgbG9va3VwLnNldChibG9jay5rZXksIGJsb2NrKTtcbiAgICAgICAgbmV4dCA9IGJsb2NrLmZpcnN0O1xuICAgICAgICBuLS07XG4gICAgfVxuICAgIHdoaWxlIChvICYmIG4pIHtcbiAgICAgICAgY29uc3QgbmV3X2Jsb2NrID0gbmV3X2Jsb2Nrc1tuIC0gMV07XG4gICAgICAgIGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3NbbyAtIDFdO1xuICAgICAgICBjb25zdCBuZXdfa2V5ID0gbmV3X2Jsb2NrLmtleTtcbiAgICAgICAgY29uc3Qgb2xkX2tleSA9IG9sZF9ibG9jay5rZXk7XG4gICAgICAgIGlmIChuZXdfYmxvY2sgPT09IG9sZF9ibG9jaykge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgbmV4dCA9IG5ld19ibG9jay5maXJzdDtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2tleSkpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvbGQgYmxvY2tcbiAgICAgICAgICAgIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFsb29rdXAuaGFzKG5ld19rZXkpIHx8IHdpbGxfbW92ZS5oYXMobmV3X2tleSkpIHtcbiAgICAgICAgICAgIGluc2VydChuZXdfYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpZF9tb3ZlLmhhcyhvbGRfa2V5KSkge1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhcy5nZXQobmV3X2tleSkgPiBkZWx0YXMuZ2V0KG9sZF9rZXkpKSB7XG4gICAgICAgICAgICBkaWRfbW92ZS5hZGQobmV3X2tleSk7XG4gICAgICAgICAgICBpbnNlcnQobmV3X2Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbGxfbW92ZS5hZGQob2xkX2tleSk7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKG8tLSkge1xuICAgICAgICBjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW29dO1xuICAgICAgICBpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9ibG9jay5rZXkpKVxuICAgICAgICAgICAgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG4gICAgfVxuICAgIHdoaWxlIChuKVxuICAgICAgICBpbnNlcnQobmV3X2Jsb2Nrc1tuIC0gMV0pO1xuICAgIHJldHVybiBuZXdfYmxvY2tzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9rZXlzKGN0eCwgbGlzdCwgZ2V0X2NvbnRleHQsIGdldF9rZXkpIHtcbiAgICBjb25zdCBrZXlzID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBnZXRfa2V5KGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSkpO1xuICAgICAgICBpZiAoa2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaGF2ZSBkdXBsaWNhdGUga2V5cyBpbiBhIGtleWVkIGVhY2gnKTtcbiAgICAgICAgfVxuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0X3NwcmVhZF91cGRhdGUobGV2ZWxzLCB1cGRhdGVzKSB7XG4gICAgY29uc3QgdXBkYXRlID0ge307XG4gICAgY29uc3QgdG9fbnVsbF9vdXQgPSB7fTtcbiAgICBjb25zdCBhY2NvdW50ZWRfZm9yID0geyAkJHNjb3BlOiAxIH07XG4gICAgbGV0IGkgPSBsZXZlbHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3QgbyA9IGxldmVsc1tpXTtcbiAgICAgICAgY29uc3QgbiA9IHVwZGF0ZXNbaV07XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG4pKVxuICAgICAgICAgICAgICAgICAgICB0b19udWxsX291dFtrZXldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY291bnRlZF9mb3Jba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVba2V5XSA9IG5ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudGVkX2ZvcltrZXldID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXZlbHNbaV0gPSBuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbykge1xuICAgICAgICAgICAgICAgIGFjY291bnRlZF9mb3Jba2V5XSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdG9fbnVsbF9vdXQpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHVwZGF0ZSkpXG4gICAgICAgICAgICB1cGRhdGVba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZTtcbn1cbmZ1bmN0aW9uIGdldF9zcHJlYWRfb2JqZWN0KHNwcmVhZF9wcm9wcykge1xuICAgIHJldHVybiB0eXBlb2Ygc3ByZWFkX3Byb3BzID09PSAnb2JqZWN0JyAmJiBzcHJlYWRfcHJvcHMgIT09IG51bGwgPyBzcHJlYWRfcHJvcHMgOiB7fTtcbn1cblxuLy8gc291cmNlOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWxcbmNvbnN0IGJvb2xlYW5fYXR0cmlidXRlcyA9IG5ldyBTZXQoW1xuICAgICdhbGxvd2Z1bGxzY3JlZW4nLFxuICAgICdhbGxvd3BheW1lbnRyZXF1ZXN0JyxcbiAgICAnYXN5bmMnLFxuICAgICdhdXRvZm9jdXMnLFxuICAgICdhdXRvcGxheScsXG4gICAgJ2NoZWNrZWQnLFxuICAgICdjb250cm9scycsXG4gICAgJ2RlZmF1bHQnLFxuICAgICdkZWZlcicsXG4gICAgJ2Rpc2FibGVkJyxcbiAgICAnZm9ybW5vdmFsaWRhdGUnLFxuICAgICdoaWRkZW4nLFxuICAgICdpc21hcCcsXG4gICAgJ2xvb3AnLFxuICAgICdtdWx0aXBsZScsXG4gICAgJ211dGVkJyxcbiAgICAnbm9tb2R1bGUnLFxuICAgICdub3ZhbGlkYXRlJyxcbiAgICAnb3BlbicsXG4gICAgJ3BsYXlzaW5saW5lJyxcbiAgICAncmVhZG9ubHknLFxuICAgICdyZXF1aXJlZCcsXG4gICAgJ3JldmVyc2VkJyxcbiAgICAnc2VsZWN0ZWQnXG5dKTtcblxuY29uc3QgaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIgPSAvW1xccydcIj4vPVxcdXtGREQwfS1cXHV7RkRFRn1cXHV7RkZGRX1cXHV7RkZGRn1cXHV7MUZGRkV9XFx1ezFGRkZGfVxcdXsyRkZGRX1cXHV7MkZGRkZ9XFx1ezNGRkZFfVxcdXszRkZGRn1cXHV7NEZGRkV9XFx1ezRGRkZGfVxcdXs1RkZGRX1cXHV7NUZGRkZ9XFx1ezZGRkZFfVxcdXs2RkZGRn1cXHV7N0ZGRkV9XFx1ezdGRkZGfVxcdXs4RkZGRX1cXHV7OEZGRkZ9XFx1ezlGRkZFfVxcdXs5RkZGRn1cXHV7QUZGRkV9XFx1e0FGRkZGfVxcdXtCRkZGRX1cXHV7QkZGRkZ9XFx1e0NGRkZFfVxcdXtDRkZGRn1cXHV7REZGRkV9XFx1e0RGRkZGfVxcdXtFRkZGRX1cXHV7RUZGRkZ9XFx1e0ZGRkZFfVxcdXtGRkZGRn1cXHV7MTBGRkZFfVxcdXsxMEZGRkZ9XS91O1xuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jbm9uY2hhcmFjdGVyXG5mdW5jdGlvbiBzcHJlYWQoYXJncywgY2xhc3Nlc190b19hZGQpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uYXJncyk7XG4gICAgaWYgKGNsYXNzZXNfdG9fYWRkKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLmNsYXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgPSBjbGFzc2VzX3RvX2FkZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgKz0gJyAnICsgY2xhc3Nlc190b19hZGQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGlmIChpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3Rlci50ZXN0KG5hbWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHN0ciArPSAnICcgKyBuYW1lO1xuICAgICAgICBlbHNlIGlmIChib29sZWFuX2F0dHJpYnV0ZXMuaGFzKG5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICBzdHIgKz0gJyAnICsgbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgKz0gYCAke25hbWV9PVwiJHt2YWx1ZX1cImA7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3RyO1xufVxuY29uc3QgZXNjYXBlZCA9IHtcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7JyxcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0Oydcbn07XG5mdW5jdGlvbiBlc2NhcGUoaHRtbCkge1xuICAgIHJldHVybiBTdHJpbmcoaHRtbCkucmVwbGFjZSgvW1wiJyY8Pl0vZywgbWF0Y2ggPT4gZXNjYXBlZFttYXRjaF0pO1xufVxuZnVuY3Rpb24gZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gZXNjYXBlKHZhbHVlKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZXNjYXBlX29iamVjdChvYmopIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBlc2NhcGVfYXR0cmlidXRlX3ZhbHVlKG9ialtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGVhY2goaXRlbXMsIGZuKSB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IGZuKGl0ZW1zW2ldLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmNvbnN0IG1pc3NpbmdfY29tcG9uZW50ID0ge1xuICAgICQkcmVuZGVyOiAoKSA9PiAnJ1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlX2NvbXBvbmVudChjb21wb25lbnQsIG5hbWUpIHtcbiAgICBpZiAoIWNvbXBvbmVudCB8fCAhY29tcG9uZW50LiQkcmVuZGVyKSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnc3ZlbHRlOmNvbXBvbmVudCcpXG4gICAgICAgICAgICBuYW1lICs9ICcgdGhpcz17Li4ufSc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgPCR7bmFtZX0+IGlzIG5vdCBhIHZhbGlkIFNTUiBjb21wb25lbnQuIFlvdSBtYXkgbmVlZCB0byByZXZpZXcgeW91ciBidWlsZCBjb25maWcgdG8gZW5zdXJlIHRoYXQgZGVwZW5kZW5jaWVzIGFyZSBjb21waWxlZCwgcmF0aGVyIHRoYW4gaW1wb3J0ZWQgYXMgcHJlLWNvbXBpbGVkIG1vZHVsZXNgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGRlYnVnKGZpbGUsIGxpbmUsIGNvbHVtbiwgdmFsdWVzKSB7XG4gICAgY29uc29sZS5sb2coYHtAZGVidWd9ICR7ZmlsZSA/IGZpbGUgKyAnICcgOiAnJ30oJHtsaW5lfToke2NvbHVtbn0pYCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKHZhbHVlcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIHJldHVybiAnJztcbn1cbmxldCBvbl9kZXN0cm95O1xuZnVuY3Rpb24gY3JlYXRlX3Nzcl9jb21wb25lbnQoZm4pIHtcbiAgICBmdW5jdGlvbiAkJHJlbmRlcihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgICAgICBjb25zdCAkJCA9IHtcbiAgICAgICAgICAgIG9uX2Rlc3Ryb3ksXG4gICAgICAgICAgICBjb250ZXh0OiBuZXcgTWFwKGNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuICAgICAgICAgICAgLy8gdGhlc2Ugd2lsbCBiZSBpbW1lZGlhdGVseSBkaXNjYXJkZWRcbiAgICAgICAgICAgIG9uX21vdW50OiBbXSxcbiAgICAgICAgICAgIGJlZm9yZV91cGRhdGU6IFtdLFxuICAgICAgICAgICAgYWZ0ZXJfdXBkYXRlOiBbXSxcbiAgICAgICAgICAgIGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KClcbiAgICAgICAgfTtcbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHsgJCQgfSk7XG4gICAgICAgIGNvbnN0IGh0bWwgPSBmbihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMpO1xuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQocGFyZW50X2NvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXI6IChwcm9wcyA9IHt9LCB7ICQkc2xvdHMgPSB7fSwgY29udGV4dCA9IG5ldyBNYXAoKSB9ID0ge30pID0+IHtcbiAgICAgICAgICAgIG9uX2Rlc3Ryb3kgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdGl0bGU6ICcnLCBoZWFkOiAnJywgY3NzOiBuZXcgU2V0KCkgfTtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAkJHJlbmRlcihyZXN1bHQsIHByb3BzLCB7fSwgJCRzbG90cywgY29udGV4dCk7XG4gICAgICAgICAgICBydW5fYWxsKG9uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBodG1sLFxuICAgICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBBcnJheS5mcm9tKHJlc3VsdC5jc3MpLm1hcChjc3MgPT4gY3NzLmNvZGUpLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgICAgICAgICBtYXA6IG51bGwgLy8gVE9ET1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGVhZDogcmVzdWx0LnRpdGxlICsgcmVzdWx0LmhlYWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgICQkcmVuZGVyXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFkZF9hdHRyaWJ1dGUobmFtZSwgdmFsdWUsIGJvb2xlYW4pIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCAoYm9vbGVhbiAmJiAhdmFsdWUpKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgcmV0dXJuIGAgJHtuYW1lfSR7dmFsdWUgPT09IHRydWUgJiYgYm9vbGVhbl9hdHRyaWJ1dGVzLmhhcyhuYW1lKSA/ICcnIDogYD0ke3R5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeShlc2NhcGUodmFsdWUpKSA6IGBcIiR7dmFsdWV9XCJgfWB9YDtcbn1cbmZ1bmN0aW9uIGFkZF9jbGFzc2VzKGNsYXNzZXMpIHtcbiAgICByZXR1cm4gY2xhc3NlcyA/IGAgY2xhc3M9XCIke2NsYXNzZXN9XCJgIDogJyc7XG59XG5cbmZ1bmN0aW9uIGJpbmQoY29tcG9uZW50LCBuYW1lLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGluZGV4ID0gY29tcG9uZW50LiQkLnByb3BzW25hbWVdO1xuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXBvbmVudC4kJC5ib3VuZFtpbmRleF0gPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2soY29tcG9uZW50LiQkLmN0eFtpbmRleF0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZV9jb21wb25lbnQoYmxvY2spIHtcbiAgICBibG9jayAmJiBibG9jay5jKCk7XG59XG5mdW5jdGlvbiBjbGFpbV9jb21wb25lbnQoYmxvY2ssIHBhcmVudF9ub2Rlcykge1xuICAgIGJsb2NrICYmIGJsb2NrLmwocGFyZW50X25vZGVzKTtcbn1cbmZ1bmN0aW9uIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIHRhcmdldCwgYW5jaG9yLCBjdXN0b21FbGVtZW50KSB7XG4gICAgY29uc3QgeyBmcmFnbWVudCwgb25fbW91bnQsIG9uX2Rlc3Ryb3ksIGFmdGVyX3VwZGF0ZSB9ID0gY29tcG9uZW50LiQkO1xuICAgIGZyYWdtZW50ICYmIGZyYWdtZW50Lm0odGFyZ2V0LCBhbmNob3IpO1xuICAgIGlmICghY3VzdG9tRWxlbWVudCkge1xuICAgICAgICAvLyBvbk1vdW50IGhhcHBlbnMgYmVmb3JlIHRoZSBpbml0aWFsIGFmdGVyVXBkYXRlXG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3X29uX2Rlc3Ryb3kgPSBvbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICAgICAgaWYgKG9uX2Rlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBvbl9kZXN0cm95LnB1c2goLi4ubmV3X29uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRWRnZSBjYXNlIC0gY29tcG9uZW50IHdhcyBkZXN0cm95ZWQgaW1tZWRpYXRlbHksXG4gICAgICAgICAgICAgICAgLy8gbW9zdCBsaWtlbHkgYXMgYSByZXN1bHQgb2YgYSBiaW5kaW5nIGluaXRpYWxpc2luZ1xuICAgICAgICAgICAgICAgIHJ1bl9hbGwobmV3X29uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50LiQkLm9uX21vdW50ID0gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lfY29tcG9uZW50KGNvbXBvbmVudCwgZGV0YWNoaW5nKSB7XG4gICAgY29uc3QgJCQgPSBjb21wb25lbnQuJCQ7XG4gICAgaWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHJ1bl9hbGwoJCQub25fZGVzdHJveSk7XG4gICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmQoZGV0YWNoaW5nKTtcbiAgICAgICAgLy8gVE9ETyBudWxsIG91dCBvdGhlciByZWZzLCBpbmNsdWRpbmcgY29tcG9uZW50LiQkIChidXQgbmVlZCB0b1xuICAgICAgICAvLyBwcmVzZXJ2ZSBmaW5hbCBzdGF0ZT8pXG4gICAgICAgICQkLm9uX2Rlc3Ryb3kgPSAkJC5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgICQkLmN0eCA9IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKSB7XG4gICAgaWYgKGNvbXBvbmVudC4kJC5kaXJ0eVswXSA9PT0gLTEpIHtcbiAgICAgICAgZGlydHlfY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgIHNjaGVkdWxlX3VwZGF0ZSgpO1xuICAgICAgICBjb21wb25lbnQuJCQuZGlydHkuZmlsbCgwKTtcbiAgICB9XG4gICAgY29tcG9uZW50LiQkLmRpcnR5WyhpIC8gMzEpIHwgMF0gfD0gKDEgPDwgKGkgJSAzMSkpO1xufVxuZnVuY3Rpb24gaW5pdChjb21wb25lbnQsIG9wdGlvbnMsIGluc3RhbmNlLCBjcmVhdGVfZnJhZ21lbnQsIG5vdF9lcXVhbCwgcHJvcHMsIGFwcGVuZF9zdHlsZXMsIGRpcnR5ID0gWy0xXSkge1xuICAgIGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcbiAgICBjb25zdCAkJCA9IGNvbXBvbmVudC4kJCA9IHtcbiAgICAgICAgZnJhZ21lbnQ6IG51bGwsXG4gICAgICAgIGN0eDogbnVsbCxcbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHVwZGF0ZTogbm9vcCxcbiAgICAgICAgbm90X2VxdWFsLFxuICAgICAgICBib3VuZDogYmxhbmtfb2JqZWN0KCksXG4gICAgICAgIC8vIGxpZmVjeWNsZVxuICAgICAgICBvbl9tb3VudDogW10sXG4gICAgICAgIG9uX2Rlc3Ryb3k6IFtdLFxuICAgICAgICBvbl9kaXNjb25uZWN0OiBbXSxcbiAgICAgICAgYmVmb3JlX3VwZGF0ZTogW10sXG4gICAgICAgIGFmdGVyX3VwZGF0ZTogW10sXG4gICAgICAgIGNvbnRleHQ6IG5ldyBNYXAob3B0aW9ucy5jb250ZXh0IHx8IChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogW10pKSxcbiAgICAgICAgLy8gZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KCksXG4gICAgICAgIGRpcnR5LFxuICAgICAgICBza2lwX2JvdW5kOiBmYWxzZSxcbiAgICAgICAgcm9vdDogb3B0aW9ucy50YXJnZXQgfHwgcGFyZW50X2NvbXBvbmVudC4kJC5yb290XG4gICAgfTtcbiAgICBhcHBlbmRfc3R5bGVzICYmIGFwcGVuZF9zdHlsZXMoJCQucm9vdCk7XG4gICAgbGV0IHJlYWR5ID0gZmFsc2U7XG4gICAgJCQuY3R4ID0gaW5zdGFuY2VcbiAgICAgICAgPyBpbnN0YW5jZShjb21wb25lbnQsIG9wdGlvbnMucHJvcHMgfHwge30sIChpLCByZXQsIC4uLnJlc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdC5sZW5ndGggPyByZXN0WzBdIDogcmV0O1xuICAgICAgICAgICAgaWYgKCQkLmN0eCAmJiBub3RfZXF1YWwoJCQuY3R4W2ldLCAkJC5jdHhbaV0gPSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoISQkLnNraXBfYm91bmQgJiYgJCQuYm91bmRbaV0pXG4gICAgICAgICAgICAgICAgICAgICQkLmJvdW5kW2ldKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVhZHkpXG4gICAgICAgICAgICAgICAgICAgIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0pXG4gICAgICAgIDogW107XG4gICAgJCQudXBkYXRlKCk7XG4gICAgcmVhZHkgPSB0cnVlO1xuICAgIHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG4gICAgLy8gYGZhbHNlYCBhcyBhIHNwZWNpYWwgY2FzZSBvZiBubyBET00gY29tcG9uZW50XG4gICAgJCQuZnJhZ21lbnQgPSBjcmVhdGVfZnJhZ21lbnQgPyBjcmVhdGVfZnJhZ21lbnQoJCQuY3R4KSA6IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLnRhcmdldCkge1xuICAgICAgICBpZiAob3B0aW9ucy5oeWRyYXRlKSB7XG4gICAgICAgICAgICBzdGFydF9oeWRyYXRpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gY2hpbGRyZW4ob3B0aW9ucy50YXJnZXQpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50Lmwobm9kZXMpO1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChkZXRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbnRybylcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oY29tcG9uZW50LiQkLmZyYWdtZW50KTtcbiAgICAgICAgbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgb3B0aW9ucy50YXJnZXQsIG9wdGlvbnMuYW5jaG9yLCBvcHRpb25zLmN1c3RvbUVsZW1lbnQpO1xuICAgICAgICBlbmRfaHlkcmF0aW5nKCk7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgfVxuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbn1cbmxldCBTdmVsdGVFbGVtZW50O1xuaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFN2ZWx0ZUVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9uX21vdW50IH0gPSB0aGlzLiQkO1xuICAgICAgICAgICAgdGhpcy4kJC5vbl9kaXNjb25uZWN0ID0gb25fbW91bnQubWFwKHJ1bikuZmlsdGVyKGlzX2Z1bmN0aW9uKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLiQkLnNsb3R0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy4kJC5zbG90dGVkW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzW2F0dHJdID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBydW5fYWxsKHRoaXMuJCQub25fZGlzY29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgJGRlc3Ryb3koKSB7XG4gICAgICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgICAgIHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gVE9ETyBzaG91bGQgdGhpcyBkZWxlZ2F0ZSB0byBhZGRFdmVudExpc3RlbmVyP1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKSk7XG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAkc2V0KCQkcHJvcHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eSgkJHByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy4kJHNldCgkJHByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzLiBVc2VkIHdoZW4gZGV2PWZhbHNlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnQge1xuICAgICRkZXN0cm95KCkge1xuICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgfVxuICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pKTtcbiAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAkc2V0KCQkcHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KCQkcHJvcHMpKSB7XG4gICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kJHNldCgkJHByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaF9kZXYodHlwZSwgZGV0YWlsKSB7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQodHlwZSwgT2JqZWN0LmFzc2lnbih7IHZlcnNpb246ICczLjQ1LjAnIH0sIGRldGFpbCksIHRydWUpKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9kZXYodGFyZ2V0LCBub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSB9KTtcbiAgICBhcHBlbmQodGFyZ2V0LCBub2RlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb25fZGV2KHRhcmdldCwgbm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUgfSk7XG4gICAgYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2Rldih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcbiAgICBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbl9kZXYodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlLCBhbmNob3IgfSk7XG4gICAgaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG59XG5mdW5jdGlvbiBkZXRhY2hfZGV2KG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZScsIHsgbm9kZSB9KTtcbiAgICBkZXRhY2gobm9kZSk7XG59XG5mdW5jdGlvbiBkZXRhY2hfYmV0d2Vlbl9kZXYoYmVmb3JlLCBhZnRlcikge1xuICAgIHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcgJiYgYmVmb3JlLm5leHRTaWJsaW5nICE9PSBhZnRlcikge1xuICAgICAgICBkZXRhY2hfZGV2KGJlZm9yZS5uZXh0U2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoX2JlZm9yZV9kZXYoYWZ0ZXIpIHtcbiAgICB3aGlsZSAoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2hfYWZ0ZXJfZGV2KGJlZm9yZSkge1xuICAgIHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgZGV0YWNoX2RldihiZWZvcmUubmV4dFNpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpc3Rlbl9kZXYobm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMsIGhhc19wcmV2ZW50X2RlZmF1bHQsIGhhc19zdG9wX3Byb3BhZ2F0aW9uKSB7XG4gICAgY29uc3QgbW9kaWZpZXJzID0gb3B0aW9ucyA9PT0gdHJ1ZSA/IFsnY2FwdHVyZSddIDogb3B0aW9ucyA/IEFycmF5LmZyb20oT2JqZWN0LmtleXMob3B0aW9ucykpIDogW107XG4gICAgaWYgKGhhc19wcmV2ZW50X2RlZmF1bHQpXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdwcmV2ZW50RGVmYXVsdCcpO1xuICAgIGlmIChoYXNfc3RvcF9wcm9wYWdhdGlvbilcbiAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3N0b3BQcm9wYWdhdGlvbicpO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NQWRkRXZlbnRMaXN0ZW5lcicsIHsgbm9kZSwgZXZlbnQsIGhhbmRsZXIsIG1vZGlmaWVycyB9KTtcbiAgICBjb25zdCBkaXNwb3NlID0gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZUV2ZW50TGlzdGVuZXInLCB7IG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBtb2RpZmllcnMgfSk7XG4gICAgICAgIGRpc3Bvc2UoKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYXR0cl9kZXYobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlQXR0cmlidXRlJywgeyBub2RlLCBhdHRyaWJ1dGUgfSk7XG4gICAgZWxzZVxuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldEF0dHJpYnV0ZScsIHsgbm9kZSwgYXR0cmlidXRlLCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIHByb3BfZGV2KG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIG5vZGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXRQcm9wZXJ0eScsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gZGF0YXNldF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbm9kZS5kYXRhc2V0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YXNldCcsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gc2V0X2RhdGFfZGV2KHRleHQsIGRhdGEpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgIGlmICh0ZXh0Lndob2xlVGV4dCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YScsIHsgbm9kZTogdGV4dCwgZGF0YSB9KTtcbiAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9hcmd1bWVudChhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ3N0cmluZycgJiYgIShhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gYXJnKSkge1xuICAgICAgICBsZXQgbXNnID0gJ3sjZWFjaH0gb25seSBpdGVyYXRlcyBvdmVyIGFycmF5LWxpa2Ugb2JqZWN0cy4nO1xuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIGFyZykge1xuICAgICAgICAgICAgbXNnICs9ICcgWW91IGNhbiB1c2UgYSBzcHJlYWQgdG8gY29udmVydCB0aGlzIGl0ZXJhYmxlIGludG8gYW4gYXJyYXkuJztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9zbG90cyhuYW1lLCBzbG90LCBrZXlzKSB7XG4gICAgZm9yIChjb25zdCBzbG90X2tleSBvZiBPYmplY3Qua2V5cyhzbG90KSkge1xuICAgICAgICBpZiAoIX5rZXlzLmluZGV4T2Yoc2xvdF9rZXkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYDwke25hbWV9PiByZWNlaXZlZCBhbiB1bmV4cGVjdGVkIHNsb3QgXCIke3Nsb3Rfa2V5fVwiLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cyB3aXRoIHNvbWUgbWlub3IgZGV2LWVuaGFuY2VtZW50cy4gVXNlZCB3aGVuIGRldj10cnVlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnREZXYgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8ICghb3B0aW9ucy50YXJnZXQgJiYgIW9wdGlvbnMuJCRpbmxpbmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIndGFyZ2V0JyBpcyBhIHJlcXVpcmVkIG9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuJGRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ29tcG9uZW50IHdhcyBhbHJlYWR5IGRlc3Ryb3llZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgJGNhcHR1cmVfc3RhdGUoKSB7IH1cbiAgICAkaW5qZWN0X3N0YXRlKCkgeyB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgdG8gY3JlYXRlIHN0cm9uZ2x5IHR5cGVkIFN2ZWx0ZSBjb21wb25lbnRzLlxuICogVGhpcyBvbmx5IGV4aXN0cyBmb3IgdHlwaW5nIHB1cnBvc2VzIGFuZCBzaG91bGQgYmUgdXNlZCBpbiBgLmQudHNgIGZpbGVzLlxuICpcbiAqICMjIyBFeGFtcGxlOlxuICpcbiAqIFlvdSBoYXZlIGNvbXBvbmVudCBsaWJyYXJ5IG9uIG5wbSBjYWxsZWQgYGNvbXBvbmVudC1saWJyYXJ5YCwgZnJvbSB3aGljaFxuICogeW91IGV4cG9ydCBhIGNvbXBvbmVudCBjYWxsZWQgYE15Q29tcG9uZW50YC4gRm9yIFN2ZWx0ZStUeXBlU2NyaXB0IHVzZXJzLFxuICogeW91IHdhbnQgdG8gcHJvdmlkZSB0eXBpbmdzLiBUaGVyZWZvcmUgeW91IGNyZWF0ZSBhIGBpbmRleC5kLnRzYDpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBTdmVsdGVDb21wb25lbnRUeXBlZCB9IGZyb20gXCJzdmVsdGVcIjtcbiAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudFR5cGVkPHtmb286IHN0cmluZ30+IHt9XG4gKiBgYGBcbiAqIFR5cGluZyB0aGlzIG1ha2VzIGl0IHBvc3NpYmxlIGZvciBJREVzIGxpa2UgVlMgQ29kZSB3aXRoIHRoZSBTdmVsdGUgZXh0ZW5zaW9uXG4gKiB0byBwcm92aWRlIGludGVsbGlzZW5zZSBhbmQgdG8gdXNlIHRoZSBjb21wb25lbnQgbGlrZSB0aGlzIGluIGEgU3ZlbHRlIGZpbGVcbiAqIHdpdGggVHlwZVNjcmlwdDpcbiAqIGBgYHN2ZWx0ZVxuICogPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAqIFx0aW1wb3J0IHsgTXlDb21wb25lbnQgfSBmcm9tIFwiY29tcG9uZW50LWxpYnJhcnlcIjtcbiAqIDwvc2NyaXB0PlxuICogPE15Q29tcG9uZW50IGZvbz17J2Jhcid9IC8+XG4gKiBgYGBcbiAqXG4gKiAjIyMjIFdoeSBub3QgbWFrZSB0aGlzIHBhcnQgb2YgYFN2ZWx0ZUNvbXBvbmVudChEZXYpYD9cbiAqIEJlY2F1c2VcbiAqIGBgYHRzXG4gKiBjbGFzcyBBU3ViY2xhc3NPZlN2ZWx0ZUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudDx7Zm9vOiBzdHJpbmd9PiB7fVxuICogY29uc3QgY29tcG9uZW50OiB0eXBlb2YgU3ZlbHRlQ29tcG9uZW50ID0gQVN1YmNsYXNzT2ZTdmVsdGVDb21wb25lbnQ7XG4gKiBgYGBcbiAqIHdpbGwgdGhyb3cgYSB0eXBlIGVycm9yLCBzbyB3ZSBuZWVkIHRvIHNlcGFyYXRlIHRoZSBtb3JlIHN0cmljdGx5IHR5cGVkIGNsYXNzLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnRUeXBlZCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudERldiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsb29wX2d1YXJkKHRpbWVvdXQpIHtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydCA+IHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCBkZXRlY3RlZCcpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgSHRtbFRhZywgSHRtbFRhZ0h5ZHJhdGlvbiwgU3ZlbHRlQ29tcG9uZW50LCBTdmVsdGVDb21wb25lbnREZXYsIFN2ZWx0ZUNvbXBvbmVudFR5cGVkLCBTdmVsdGVFbGVtZW50LCBhY3Rpb25fZGVzdHJveWVyLCBhZGRfYXR0cmlidXRlLCBhZGRfY2xhc3NlcywgYWRkX2ZsdXNoX2NhbGxiYWNrLCBhZGRfbG9jYXRpb24sIGFkZF9yZW5kZXJfY2FsbGJhY2ssIGFkZF9yZXNpemVfbGlzdGVuZXIsIGFkZF90cmFuc2Zvcm0sIGFmdGVyVXBkYXRlLCBhcHBlbmQsIGFwcGVuZF9kZXYsIGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0LCBhcHBlbmRfaHlkcmF0aW9uLCBhcHBlbmRfaHlkcmF0aW9uX2RldiwgYXBwZW5kX3N0eWxlcywgYXNzaWduLCBhdHRyLCBhdHRyX2RldiwgYXR0cmlidXRlX3RvX29iamVjdCwgYmVmb3JlVXBkYXRlLCBiaW5kLCBiaW5kaW5nX2NhbGxiYWNrcywgYmxhbmtfb2JqZWN0LCBidWJibGUsIGNoZWNrX291dHJvcywgY2hpbGRyZW4sIGNsYWltX2NvbXBvbmVudCwgY2xhaW1fZWxlbWVudCwgY2xhaW1faHRtbF90YWcsIGNsYWltX3NwYWNlLCBjbGFpbV9zdmdfZWxlbWVudCwgY2xhaW1fdGV4dCwgY2xlYXJfbG9vcHMsIGNvbXBvbmVudF9zdWJzY3JpYmUsIGNvbXB1dGVfcmVzdF9wcm9wcywgY29tcHV0ZV9zbG90cywgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBjcmVhdGVfYW5pbWF0aW9uLCBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uLCBjcmVhdGVfY29tcG9uZW50LCBjcmVhdGVfaW5fdHJhbnNpdGlvbiwgY3JlYXRlX291dF90cmFuc2l0aW9uLCBjcmVhdGVfc2xvdCwgY3JlYXRlX3Nzcl9jb21wb25lbnQsIGN1cnJlbnRfY29tcG9uZW50LCBjdXN0b21fZXZlbnQsIGRhdGFzZXRfZGV2LCBkZWJ1ZywgZGVzdHJveV9ibG9jaywgZGVzdHJveV9jb21wb25lbnQsIGRlc3Ryb3lfZWFjaCwgZGV0YWNoLCBkZXRhY2hfYWZ0ZXJfZGV2LCBkZXRhY2hfYmVmb3JlX2RldiwgZGV0YWNoX2JldHdlZW5fZGV2LCBkZXRhY2hfZGV2LCBkaXJ0eV9jb21wb25lbnRzLCBkaXNwYXRjaF9kZXYsIGVhY2gsIGVsZW1lbnQsIGVsZW1lbnRfaXMsIGVtcHR5LCBlbmRfaHlkcmF0aW5nLCBlc2NhcGUsIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUsIGVzY2FwZV9vYmplY3QsIGVzY2FwZWQsIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMsIGZpeF9hbmRfZGVzdHJveV9ibG9jaywgZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jaywgZml4X3Bvc2l0aW9uLCBmbHVzaCwgZ2V0QWxsQ29udGV4dHMsIGdldENvbnRleHQsIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSwgZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUsIGdldF9jdXJyZW50X2NvbXBvbmVudCwgZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cywgZ2V0X3Jvb3RfZm9yX3N0eWxlLCBnZXRfc2xvdF9jaGFuZ2VzLCBnZXRfc3ByZWFkX29iamVjdCwgZ2V0X3NwcmVhZF91cGRhdGUsIGdldF9zdG9yZV92YWx1ZSwgZ2xvYmFscywgZ3JvdXBfb3V0cm9zLCBoYW5kbGVfcHJvbWlzZSwgaGFzQ29udGV4dCwgaGFzX3Byb3AsIGlkZW50aXR5LCBpbml0LCBpbnNlcnQsIGluc2VydF9kZXYsIGluc2VydF9oeWRyYXRpb24sIGluc2VydF9oeWRyYXRpb25fZGV2LCBpbnRyb3MsIGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLCBpc19jbGllbnQsIGlzX2Nyb3Nzb3JpZ2luLCBpc19lbXB0eSwgaXNfZnVuY3Rpb24sIGlzX3Byb21pc2UsIGxpc3RlbiwgbGlzdGVuX2RldiwgbG9vcCwgbG9vcF9ndWFyZCwgbWlzc2luZ19jb21wb25lbnQsIG1vdW50X2NvbXBvbmVudCwgbm9vcCwgbm90X2VxdWFsLCBub3csIG51bGxfdG9fZW1wdHksIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMsIG9uRGVzdHJveSwgb25Nb3VudCwgb25jZSwgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIHByZXZlbnRfZGVmYXVsdCwgcHJvcF9kZXYsIHF1ZXJ5X3NlbGVjdG9yX2FsbCwgcmFmLCBydW4sIHJ1bl9hbGwsIHNhZmVfbm90X2VxdWFsLCBzY2hlZHVsZV91cGRhdGUsIHNlbGVjdF9tdWx0aXBsZV92YWx1ZSwgc2VsZWN0X29wdGlvbiwgc2VsZWN0X29wdGlvbnMsIHNlbGVjdF92YWx1ZSwgc2VsZiwgc2V0Q29udGV4dCwgc2V0X2F0dHJpYnV0ZXMsIHNldF9jdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEsIHNldF9kYXRhLCBzZXRfZGF0YV9kZXYsIHNldF9pbnB1dF90eXBlLCBzZXRfaW5wdXRfdmFsdWUsIHNldF9ub3csIHNldF9yYWYsIHNldF9zdG9yZV92YWx1ZSwgc2V0X3N0eWxlLCBzZXRfc3ZnX2F0dHJpYnV0ZXMsIHNwYWNlLCBzcHJlYWQsIHNyY191cmxfZXF1YWwsIHN0YXJ0X2h5ZHJhdGluZywgc3RvcF9wcm9wYWdhdGlvbiwgc3Vic2NyaWJlLCBzdmdfZWxlbWVudCwgdGV4dCwgdGljaywgdGltZV9yYW5nZXNfdG9fYXJyYXksIHRvX251bWJlciwgdG9nZ2xlX2NsYXNzLCB0cmFuc2l0aW9uX2luLCB0cmFuc2l0aW9uX291dCwgdHJ1c3RlZCwgdXBkYXRlX2F3YWl0X2Jsb2NrX2JyYW5jaCwgdXBkYXRlX2tleWVkX2VhY2gsIHVwZGF0ZV9zbG90LCB1cGRhdGVfc2xvdF9iYXNlLCB2YWxpZGF0ZV9jb21wb25lbnQsIHZhbGlkYXRlX2VhY2hfYXJndW1lbnQsIHZhbGlkYXRlX2VhY2hfa2V5cywgdmFsaWRhdGVfc2xvdHMsIHZhbGlkYXRlX3N0b3JlLCB4bGlua19hdHRyIH07XG4iLCAiPHNjcmlwdCBsYW5nPVwidHNcIj5cclxuXHRpbXBvcnQgeyBEYXRlVGltZSB9IGZyb20gXCJvYnNpZGlhbi1kYXRhdmlld1wiO1xyXG5cdGltcG9ydCB7IGdldFBlYXJzb25Db3JyZWxhdGlvbiwgaXNRdWFudCB9IGZyb20gXCJzcmMvYW5hbHlzZXNcIjtcclxuXHRpbXBvcnQgeyBDaGFydE1vZGFsIH0gZnJvbSBcInNyYy9DaGFydE1vZGFsXCI7XHJcblx0aW1wb3J0IFNjYXR0ZXIgZnJvbSBcInN2ZWx0ZS1jaGFydGpzL3NyYy9TY2F0dGVyLnN2ZWx0ZVwiO1xyXG5cdGltcG9ydCBDaGFydE9wdGlvbnMgZnJvbSBcIi4vQ2hhcnRPcHRpb25zLnN2ZWx0ZVwiO1xyXG5cclxuXHRleHBvcnQgbGV0IG1vZGFsOiBDaGFydE1vZGFsO1xyXG5cdGxldCB7IGYxLCBmMiB9ID0gbW9kYWw7XHJcblxyXG5cdGNvbnN0IHsgYXBwLCBwbHVnaW4gfSA9IG1vZGFsO1xyXG5cdGNvbnN0IHsgaW5kZXgsIHNldHRpbmdzIH0gPSBwbHVnaW47XHJcblx0Y29uc3QgeyBmaWVsZHNUb0NoZWNrIH0gPSBzZXR0aW5ncztcclxuXHJcblx0bGV0IGFsbEZpZWxkcyA9IGZpZWxkc1RvQ2hlY2s7XHJcblx0bGV0IFtuMSwgbjJdID0gWzAsIDBdO1xyXG5cclxuXHRsZXQgY29sb3VyID0gXCIjMTVhMjUyXCI7XHJcblx0bGV0IHN0YXJ0RGF0ZSA9IGluZGV4Lm1pbkRhdGU7XHJcblx0bGV0IGVuZERhdGUgPSBpbmRleC5tYXhEYXRlO1xyXG5cdGxldCBkbk9ubHkgPSBmYWxzZTtcclxuXHRsZXQgZXJyb3JNZXNzYWdlID0gXCJcIjtcclxuXHJcblx0aW50ZXJmYWNlIERhdHVtMmQge1xyXG5cdFx0eDogbnVtYmVyO1xyXG5cdFx0eTogbnVtYmVyO1xyXG5cdFx0bmFtZTogc3RyaW5nO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaXNWYWxpZFNlbGVjdGlvbihmMTogc3RyaW5nLCBmMjogc3RyaW5nKSB7XHJcblx0XHRyZXR1cm4gZjEgJiYgZjI7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoSW5uZXJEYXRhKFxyXG5cdFx0ZjE6IHN0cmluZyxcclxuXHRcdGYyOiBzdHJpbmcsXHJcblx0XHRkbk9ubHk6IGJvb2xlYW4sXHJcblx0XHRzdGFydERhdGU6IERhdGVUaW1lLFxyXG5cdFx0ZW5kRGF0ZTogRGF0ZVRpbWVcclxuXHQpOiBEYXR1bTJkW10ge1xyXG5cdFx0Y29uc3QgZmlsZVJhbmdlID0gZG5Pbmx5XHJcblx0XHRcdD8gaW5kZXguZGF0YS5maWx0ZXIoKGl0ZW0pID0+IHtcclxuXHRcdFx0XHRcdC8vIERhdGF2aWV3IGFscmVhZHkgcGFyc2VzIHRoZSBub3RlIHRpdGxlIGZvciBhIGRhdGVcdUQ4M0VcdURENzNcclxuXHRcdFx0XHRcdGNvbnN0IHsgZGF5IH06IHsgZGF5OiBEYXRlVGltZSB9ID0gaXRlbS5maWxlO1xyXG5cdFx0XHRcdFx0cmV0dXJuIChcclxuXHRcdFx0XHRcdFx0ZGF5ICYmIHN0YXJ0RGF0ZS50cyA8PSBkYXkudHMgJiYgZGF5LnRzIDw9IGVuZERhdGUudHNcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdCAgfSlcclxuXHRcdFx0OiBpbmRleC5kYXRhO1xyXG5cclxuXHRcdGNvbnN0IGlubmVyRGF0YSA9IGZpbGVSYW5nZVxyXG5cdFx0XHQubWFwKChwYWdlKSA9PiB7XHJcblx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdHg6IHBhZ2VbZjFdIGFzIG51bWJlcixcclxuXHRcdFx0XHRcdHk6IHBhZ2VbZjJdIGFzIG51bWJlcixcclxuXHRcdFx0XHRcdG5hbWU6IHBhZ2UuZmlsZS5uYW1lLFxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH0pXHJcblx0XHRcdC5maWx0ZXIoKHBvaW50KSA9PiB7XHJcblx0XHRcdFx0cmV0dXJuIHBvaW50LnggIT09IHVuZGVmaW5lZCAmJiBwb2ludC55ICE9PSB1bmRlZmluZWQ7XHJcblx0XHRcdH0pO1xyXG5cdFx0cmV0dXJuIGlubmVyRGF0YTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hDb3JyZWxhdGlvbihmMTogc3RyaW5nLCBmMjogc3RyaW5nLCBpbm5lckRhdGE6IERhdHVtMmRbXSkge1xyXG5cdFx0Y29uc3QgeHMgPSBpbm5lckRhdGEubWFwKChwKSA9PiBwLngpO1xyXG5cdFx0Y29uc3QgeXMgPSBpbm5lckRhdGEubWFwKChwKSA9PiBwLnkpO1xyXG5cclxuXHRcdGlmIChpc1ZhbGlkU2VsZWN0aW9uKGYxLCBmMikpIHtcclxuXHRcdFx0Y29uc3QgeFZhbGlkID0gaXNRdWFudCh4cyk7XHJcblx0XHRcdGNvbnN0IHlWYWxpZCA9IGlzUXVhbnQoeXMpO1xyXG5cdFx0XHRpZiAoIXhWYWxpZCAmJiAheVZhbGlkKSB7XHJcblx0XHRcdFx0ZXJyb3JNZXNzYWdlID0gXCJCb3RoIGZpZWxkcyBoYXZlIG5vbi1udW1lcmljIHZhbHVlcy5cIjtcclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0fSBlbHNlIGlmICgheFZhbGlkKSB7XHJcblx0XHRcdFx0ZXJyb3JNZXNzYWdlID0gXCJGaXJzdCBmaWVsZCBoYXMgbm9uLW51bWVyaWMgdmFsdWVzLlwiO1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCF5VmFsaWQpIHtcclxuXHRcdFx0XHRlcnJvck1lc3NhZ2UgPSBcIlNlY29uZCBmaWVsZCBoYXMgbm9uLW51bWVyaWMgdmFsdWVzLlwiO1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVycm9yTWVzc2FnZSA9IFwiXCI7XHJcblx0XHRcdHJldHVybiBnZXRQZWFyc29uQ29ycmVsYXRpb24oeHMsIHlzLCB0cnVlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaENoYXJ0RGF0YShjb2xvdXI6IHN0cmluZywgaW5uZXJEYXRhOiBEYXR1bTJkW10pIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGxhYmVsczogW1wiU2NhdHRlclwiXSxcclxuXHRcdFx0ZGF0YXNldHM6IFtcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRib3JkZXJDb2xvcjogY29sb3VyLFxyXG5cdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiBjb2xvdXIsXHJcblx0XHRcdFx0XHRsYWJlbDogXCJEYXRhXCIsXHJcblx0XHRcdFx0XHRkYXRhOiBpbm5lckRhdGEsXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XSxcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoQ2hhcnRPcHRpb25zKGYxOiBzdHJpbmcsIGYyOiBzdHJpbmcpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHRpdGxlOiB7XHJcblx0XHRcdFx0ZGlzcGxheTogdHJ1ZSxcclxuXHRcdFx0XHR0ZXh0OiBcIlNjYXR0ZXIgQ2hhcnQgLSBMb2dhcml0aG1pYyBYLUF4aXNcIixcclxuXHRcdFx0fSxcclxuXHRcdFx0c2NhbGVzOiB7XHJcblx0XHRcdFx0eEF4ZXM6IHtcclxuXHRcdFx0XHRcdHRpdGxlOiB7XHJcblx0XHRcdFx0XHRcdGRpc3BsYXk6IGlzVmFsaWRTZWxlY3Rpb24oZjEsIGYyKSxcclxuXHRcdFx0XHRcdFx0dGV4dDogZjEgPz8gXCJcIixcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHR0eXBlOiBcImxpbmVhclwiLFxyXG5cdFx0XHRcdFx0cG9zaXRpb246IFwiYm90dG9tXCIsXHJcblx0XHRcdFx0XHRzY2FsZUxhYmVsOiB7XHJcblx0XHRcdFx0XHRcdGxhYmVsU3RyaW5nOiBcIkZyZXF1ZW5jeVwiLFxyXG5cdFx0XHRcdFx0XHRkaXNwbGF5OiB0cnVlLFxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHR5QXhlczoge1xyXG5cdFx0XHRcdFx0dHlwZTogXCJsaW5lYXJcIixcclxuXHRcdFx0XHRcdHNjYWxlTGFiZWw6IHtcclxuXHRcdFx0XHRcdFx0bGFiZWxTdHJpbmc6IFwiVm9sdGFnZVwiLFxyXG5cdFx0XHRcdFx0XHRkaXNwbGF5OiB0cnVlLFxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdHRpdGxlOiB7XHJcblx0XHRcdFx0XHRcdGRpc3BsYXk6IGlzVmFsaWRTZWxlY3Rpb24oZjEsIGYyKSxcclxuXHRcdFx0XHRcdFx0dGV4dDogZjIgPz8gXCJcIixcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0fSxcclxuXHRcdFx0cGx1Z2luczoge1xyXG5cdFx0XHRcdHRvb2x0aXA6IHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrczoge1xyXG5cdFx0XHRcdFx0XHRsYWJlbDogZnVuY3Rpb24gKHRvb2x0aXBJdGVtOiBEYXR1bTJkKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29uc3QgeyByYXcgfSA9IHRvb2x0aXBJdGVtO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBgJHtyYXcubmFtZX06XFxuKCR7cmF3Lnh9LCAke3Jhdy55fSlgO1xyXG5cdFx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHR9LFxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdCQ6IGlubmVyRGF0YSA9IHJlZnJlc2hJbm5lckRhdGEoZjEsIGYyLCBkbk9ubHksIHN0YXJ0RGF0ZSwgZW5kRGF0ZSk7XHJcblx0JDogY29ycmVsYXRpb24gPSByZWZyZXNoQ29ycmVsYXRpb24oZjEsIGYyLCBpbm5lckRhdGEpO1xyXG5cdCQ6IGRhdGEgPSByZWZyZXNoQ2hhcnREYXRhKGNvbG91ciwgaW5uZXJEYXRhKTtcclxuXHQkOiBjaGFydE9wdGlvbnMgPSByZWZyZXNoQ2hhcnRPcHRpb25zKGYxLCBmMik7XHJcbjwvc2NyaXB0PlxyXG5cclxuPGRpdiBjbGFzcz1cImNoZWNrYm94ZXNcIj5cclxuXHQ8ZGF0YWxpc3QgaWQ9XCJmaWVsZHNcIj5cclxuXHRcdHsjZWFjaCBhbGxGaWVsZHMgYXMgZmllbGR9XHJcblx0XHRcdDxvcHRpb24gdmFsdWU9e2ZpZWxkfSAvPlxyXG5cdFx0ey9lYWNofVxyXG5cdDwvZGF0YWxpc3Q+XHJcblx0PGxhYmVsPlxyXG5cdFx0RmllbGQgMTpcclxuXHRcdDxpbnB1dCBiaW5kOnZhbHVlPXtmMX0gbGlzdD1cImZpZWxkc1wiIC8+XHJcblx0PC9sYWJlbD5cclxuXHQ8bGFiZWw+XHJcblx0XHRGaWVsZCAyOlxyXG5cdFx0PGlucHV0IGJpbmQ6dmFsdWU9e2YyfSBsaXN0PVwiZmllbGRzXCIgLz5cclxuXHQ8L2xhYmVsPlxyXG48L2Rpdj5cclxuXHJcbjxDaGFydE9wdGlvbnMgYmluZDpjb2xvdXIgYmluZDpzdGFydERhdGUgYmluZDplbmREYXRlIGJpbmQ6ZG5Pbmx5IC8+XHJcbjxTY2F0dGVyIHtkYXRhfSBvcHRpb25zPXtjaGFydE9wdGlvbnN9IC8+XHJcblxyXG48ZGl2IGNsYXNzPVwibWVhc3VyZXNcIj5cclxuXHR7I2lmIGVycm9yTWVzc2FnZSAhPSBcIlwifVxyXG5cdFx0PHNwYW4+RXJyb3I6IHtlcnJvck1lc3NhZ2V9PC9zcGFuPlxyXG5cdHs6ZWxzZSBpZiBpc1ZhbGlkU2VsZWN0aW9uKGYxLCBmMil9XHJcblx0XHQ8c3Bhbj5cclxuXHRcdFx0PHNwYW4gY2xhc3M9XCJtZWFzdXJlLW5hbWVcIj5uOjwvc3Bhbj5cclxuXHRcdFx0PHNwYW4gY2xhc3M9XCJtZWFzdXJlLXZhbHVlXCI+e2lubmVyRGF0YS5sZW5ndGh9PC9zcGFuPlxyXG5cdFx0PC9zcGFuPlxyXG5cdFx0PHNwYW4+XHJcblx0XHRcdDxzcGFuIGNsYXNzPVwibWVhc3VyZS1uYW1lXCI+Q29ycmVsYXRpb246PC9zcGFuPlxyXG5cdFx0XHQ8c3BhbiBjbGFzcz1cIm1lYXN1cmUtdmFsdWVcIj57Y29ycmVsYXRpb24/LnRvRml4ZWQoNCl9PC9zcGFuPlxyXG5cdFx0PC9zcGFuPlxyXG5cdHs6ZWxzZX1cclxuXHRcdDxzcGFuPlNlbGVjdCAyIGZpZWxkczwvc3Bhbj5cclxuXHR7L2lmfVxyXG48L2Rpdj5cclxuXHJcbjxzdHlsZT5cclxuXHRkaXYuY2hlY2tib3hlcyB7XHJcblx0XHRib3JkZXItcmFkaXVzOiA1cHg7XHJcblx0XHRib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlcik7XHJcblx0XHRwYWRkaW5nOiAzcHg7XHJcblx0fVxyXG5cclxuXHRkaXYubWVhc3VyZXMge1xyXG5cdFx0ZGlzcGxheTogZmxleDtcclxuXHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcclxuXHR9XHJcblxyXG5cdHNwYW4ubWVhc3VyZS1uYW1lIHtcclxuXHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLWJhY2tncm91bmQtc2Vjb25kYXJ5LWFsdCk7XHJcblx0XHRwYWRkaW5nOiAycHggNHB4O1xyXG5cdFx0Ym9yZGVyLXJhZGl1czogM3B4O1xyXG5cdFx0Zm9udC1zaXplOiAxMnB4O1xyXG5cdFx0bGluZS1oZWlnaHQ6IDEycHg7XHJcblx0fVxyXG5cdHNwYW4ubWVhc3VyZS1uYW1lOmhvdmVyIHtcclxuXHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLWludGVyYWN0aXZlLWFjY2VudCk7XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iLCAiLyoqXHJcbiAqIENvbXB1dGUgdGhlIFBlYXJzb24gY29ycmVsYXRpb24gY29lZmZpY2llbnQgYmV0d2VlbiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXHJcbiAqIEBwYXJhbSB7YXJyYXl0eXBlfSB4cyAtIHRoZSBmaXJzdCBhcnJheSBvZiBudW1iZXJzXHJcbiAqIEBwYXJhbSB7YXJyYXl0eXBlfSB5cyAtIHRoZSBhcnJheSBvZiB5IHZhbHVlc1xyXG4gKiBAcmV0dXJucyBUaGUgY29ycmVsYXRpb24gY29lZmZpY2llbnQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGVhcnNvbkNvcnJlbGF0aW9uKFxyXG5cdHhzOiBudW1iZXJbXSxcclxuXHR5czogbnVtYmVyW10sXHJcblx0c2tpcFF1YW50Q2hlY2sgPSBmYWxzZVxyXG4pIHtcclxuXHRpZiAoeHMubGVuZ3RoIDw9IDEgfHwgeXMubGVuZ3RoIDw9IDEpIHJldHVybiBudWxsO1xyXG5cclxuXHRpZiAoIXNraXBRdWFudENoZWNrICYmICghaXNRdWFudCh4cykgfHwgIWlzUXVhbnQoeXMpKSkgcmV0dXJuIG51bGw7XHJcblxyXG5cdGNvbnN0IG4gPSB4cy5sZW5ndGg7XHJcblx0aWYgKG4gIT09IHlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIG11c3QgYmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xyXG5cclxuXHRsZXQgc3VtX3ggPSAwO1xyXG5cdGxldCBzdW1feSA9IDA7XHJcblx0bGV0IHN1bV94eSA9IDA7XHJcblx0bGV0IHN1bV94eCA9IDA7XHJcblx0bGV0IHN1bV95eSA9IDA7XHJcblxyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjb25zdCB4ID0geHNbaV07XHJcblx0XHRjb25zdCB5ID0geXNbaV07XHJcblx0XHRzdW1feCArPSB4O1xyXG5cdFx0c3VtX3kgKz0geTtcclxuXHRcdHN1bV94eCArPSB4ICogeDtcclxuXHRcdHN1bV95eSArPSB5ICogeTtcclxuXHRcdHN1bV94eSArPSB4ICogeTtcclxuXHR9XHJcblxyXG5cdGNvbnN0IGNvcnIgPVxyXG5cdFx0KG4gKiBzdW1feHkgLSBzdW1feCAqIHN1bV95KSAvXHJcblx0XHRNYXRoLnNxcnQoKG4gKiBzdW1feHggLSBzdW1feCAqIHN1bV94KSAqIChuICogc3VtX3l5IC0gc3VtX3kgKiBzdW1feSkpO1xyXG5cclxuXHQvLyBjb25zdCBuID0geHMubGVuZ3RoO1xyXG5cdC8vIGNvbnN0IHhfYmFyID0gZ2V0TWVhbih4cyk7XHJcblx0Ly8gY29uc3QgeV9iYXIgPSBnZXRNZWFuKHlzKTtcclxuXHJcblx0Ly8gbGV0IHN1bV94X21pbnVzX211ID0gMDtcclxuXHQvLyBsZXQgc3VtX3lfbWludXNfbXUgPSAwO1xyXG5cclxuXHQvLyBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdC8vIFx0Y29uc3QgeCA9IHhzW2ldO1xyXG5cdC8vIFx0Y29uc3QgeSA9IHlzW2ldO1xyXG5cclxuXHQvLyBcdHN1bV94X21pbnVzX211ICs9IHggLSB4X2JhcjtcclxuXHQvLyBcdHN1bV95X21pbnVzX211ICs9IHkgLSB5X2JhcjtcclxuXHQvLyB9XHJcblxyXG5cdC8vIGNvbnN0IGNvcnIgPVxyXG5cdC8vIFx0KHN1bV94X21pbnVzX211ICogc3VtX3lfbWludXNfbXUpIC9cclxuXHQvLyBcdE1hdGguc3FydChcclxuXHQvLyBcdFx0c3VtX3hfbWludXNfbXUgKiBzdW1feF9taW51c19tdSAqIHN1bV95X21pbnVzX211ICogc3VtX3lfbWludXNfbXVcclxuXHQvLyBcdCk7XHJcblxyXG5cdHJldHVybiBjb3JyO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBzZXQgb2YgYmluYXJ5IHZhbHVlcyBhbmQgYSBzZXQgb2YgcXVhbnRpdGF0aXZlIHZhbHVlcywgcmV0dXJuIHRoZSBwb2ludC1iaXNlcmlhbFxyXG5jb3JyZWxhdGlvbiBjb2VmZmljaWVudC5cclxuICogQHBhcmFtIHsobnVtYmVyIHwgYm9vbGVhbilbXX0geHMgLSBUaGUgYXJyYXkgb2YgYmluYXJ5IHZhbHVlcy5cclxuICogQHBhcmFtIHtudW1iZXJbXX0geXMgLSB0aGUgZGVwZW5kZW50IHZhcmlhYmxlXHJcbiAqIEByZXR1cm5zIFRoZSBwb2ludCBiaXNlcmlhbCBjb3JyZWxhdGlvbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2ludEJpc2VyaWFsQ29ycmVsYXRpb24oXHJcblx0eHM6IChudW1iZXIgfCBib29sZWFuKVtdLFxyXG5cdHlzOiBudW1iZXJbXVxyXG4pIHtcclxuXHRpZiAoeHMubGVuZ3RoIDw9IDEgfHwgeXMubGVuZ3RoIDw9IDEgfHwgIWlzQmluYXJ5KHhzKSB8fCAhaXNRdWFudCh5cykpXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0Y29uc3QgbTA6IG51bWJlcltdID0gW10sXHJcblx0XHRtMTogbnVtYmVyW10gPSBbXTtcclxuXHR4cy5mb3JFYWNoKCh4LCBpKSA9PiB7XHJcblx0XHRjb25zdCB5ID0geXNbaV07XHJcblx0XHRpZiAoIXgpIG0wLnB1c2goeSk7XHJcblx0XHRlbHNlIG0xLnB1c2goeSk7XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiAoXHJcblx0XHQoKG0xLmxlbmd0aCAtIG0wLmxlbmd0aCkgLyBnZXRTdGREZXYoeXMpKSAqXHJcblx0XHRNYXRoLnNxcnQoKG0xLmxlbmd0aCAqIG0wLmxlbmd0aCkgLyB4cy5sZW5ndGgpXHJcblx0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhbGwgdmFsdWVzIGluIGB4c2AgYXJlIG51bWJlcnNcclxuICogQHBhcmFtIHtudW1iZXJbXX0geHMgLSBUaGUgYXJyYXkgb2YgbnVtYmVycyB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNRdWFudCh4czogbnVtYmVyW10pOiBib29sZWFuIHtcclxuXHRyZXR1cm4geHMubGVuZ3RoICYmIHhzLmV2ZXJ5KCh4KSA9PiB0eXBlb2YgeCA9PT0gXCJudW1iZXJcIik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFycmF5IG9ubHkgY29udGFpbnMgYDBgJ3MgYW5kIGAxYCdzLCBvciBgdHJ1ZWAncyBhbmQgYGZhbHNlYCdzLlxyXG4gKiBAcGFyYW0geyhudW1iZXIgfCBib29sZWFuKVtdfSB4cyAtIFRoZSBhcnJheSBvZiB2YWx1ZXMgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQmluYXJ5KHhzOiAobnVtYmVyIHwgYm9vbGVhbilbXSk6IGJvb2xlYW4ge1xyXG5cdHJldHVybiAoXHJcblx0XHR4cy5sZW5ndGggJiZcclxuXHRcdHhzLmV2ZXJ5KCh4KSA9PiB4ID09PSAwIHx8IHggPT09IDEgfHwgeCA9PT0gZmFsc2UgfHwgeCA9PT0gdHJ1ZSlcclxuXHQpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29tcHV0ZSB0aGUgbWVhbiBvZiBhIGxpc3Qgb2YgbnVtYmVycy5cclxuICpcclxuICogQ2hlY2tzIGlmIHtAbGluayBpc1F1YW50fS5cclxuICogQHBhcmFtIHtudW1iZXJbXX0geHMgLSBUaGUgYXJyYXkgb2YgbnVtYmVycyB0byBjb21wdXRlIHRoZSBtZWFuIG9mLlxyXG4gKiBAcmV0dXJucyBUaGUgbWVhbiBvZiBgeHNgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1lYW4oeHM6IG51bWJlcltdKSB7XHJcblx0aWYgKCFpc1F1YW50KHhzKSkgcmV0dXJuIG51bGw7XHJcblx0cmV0dXJuIHhzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8geHMubGVuZ3RoO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBsaXN0IG9mIG51bWJlcnMsIHJldHVybiB0aGUgbWVkaWFuIG9mIHRoZSBsaXN0LlxyXG4gKlxyXG4gKiBDaGVja3MgaWYge0BsaW5rIGlzUXVhbnR9LlxyXG4gKiBAcGFyYW0ge251bWJlcltdfSB4cyAtIFRoZSBhcnJheSBvZiBudW1iZXJzIHRvIGJlIHNvcnRlZFxyXG4gKiBAcmV0dXJucyBUaGUgbWVkaWFuIG9mIHRoZSBhcnJheS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNZWRpYW4oeHM6IG51bWJlcltdKSB7XHJcblx0aWYgKCFpc1F1YW50KHhzKSkgcmV0dXJuIG51bGw7XHJcblx0Y29uc3Qgc29ydGVkID0geHMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcblx0cmV0dXJuIHNvcnRlZFtNYXRoLmZsb29yKHNvcnRlZC5sZW5ndGggLyAyKV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIGxpc3Qgb2YgaXRlbXMsIHJldHVybiB0aGUgbW9zdCBjb21tb24gaXRlbS5cclxuICogQHBhcmFtIHsoc3RyaW5nIHwgbnVtYmVyIHwgc3RyaW5nW10gfCBudW1iZXJbXSlbXX0geHMgLSBUaGUgYXJyYXkgb2YgdmFsdWVzIHRvIGNvdW50LlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IFRoZSBtb2RlKHMpIG9mIHRoZSBhcnJheS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNb2RlKFxyXG5cdHhzOiAoc3RyaW5nIHwgbnVtYmVyIHwgc3RyaW5nW10gfCBudW1iZXJbXSlbXVxyXG4pOiBzdHJpbmdbXSB7XHJcblx0Ly8gVE9ETzogQ2hlY2sgdGhlIGRhdGFUeXBlIG9mIHRoZSBhcnJheS5cclxuXHRjb25zdCBmbGF0dGVuZWQgPSB4cy5mbGF0KCk7XHJcblx0Y29uc3QgY291bnRzOiB7IFtpdGVtOiBzdHJpbmcgfCBudW1iZXJdOiBudW1iZXIgfSA9IHt9O1xyXG5cdGZsYXR0ZW5lZC5mb3JFYWNoKCh4KSA9PiB7XHJcblx0XHRpZiAoY291bnRzW3hdKSBjb3VudHNbeF0gPSBjb3VudHNbeF0gKyAxO1xyXG5cdFx0ZWxzZSBjb3VudHNbeF0gPSAxO1xyXG5cdH0pO1xyXG5cdGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLk9iamVjdC52YWx1ZXMoY291bnRzKSk7XHJcblx0cmV0dXJuIE9iamVjdC5rZXlzKGNvdW50cykuZmlsdGVyKCh4KSA9PiBjb3VudHNbeF0gPT09IG1heCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgdGhlIHZhcmlhbmNlIG9mIGEgc2V0IG9mIG51bWJlcnMuXHJcbiAqXHJcbiAqIENoZWNrcyBpZiB7QGxpbmsgaXNRdWFudH0uXHJcbiAqIEBwYXJhbSB7bnVtYmVyW119IHhzIC0gVGhlIGFycmF5IG9mIG51bWJlcnMgdG8gYmUgYW5hbHl6ZWRcclxuICogQHJldHVybnMgVGhlIHZhcmlhbmNlIG9mIHRoZSBhcnJheS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWYXJpYW5jZSh4czogbnVtYmVyW10pIHtcclxuXHRpZiAoIWlzUXVhbnQoeHMpKSByZXR1cm4gbnVsbDtcclxuXHRjb25zdCBtZWFuID0gZ2V0TWVhbih4cyk7XHJcblx0cmV0dXJuIHhzLnJlZHVjZSgoYSwgYikgPT4gYSArIE1hdGgucG93KGIgLSBtZWFuLCAyKSwgMCkgLyB4cy5sZW5ndGg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlIHRoZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgYSBzZXQgb2YgbnVtYmVycy5cclxuICpcclxuICogQ2hlY2tzIGlmIHtAbGluayBpc1F1YW50fS5cclxuICogQHBhcmFtIHtudW1iZXJbXX0geHMgLSB0aGUgYXJyYXkgb2YgbnVtYmVycyB0byBiZSBhbmFseXplZFxyXG4gKiBAcmV0dXJucyBUaGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBhcnJheS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGREZXYoeHM6IG51bWJlcltdKSB7XHJcblx0aWYgKCFpc1F1YW50KHhzKSkgcmV0dXJuIG51bGw7XHJcblx0cmV0dXJuIE1hdGguc3FydChnZXRWYXJpYW5jZSh4cykpO1xyXG59XHJcbiIsICJleHBvcnQgZnVuY3Rpb24gY2xlYW4oJCRwcm9wcywgZXh0cmFfa2V5cykge1xuICBsZXQga2V5cyA9IFtcImNoaWxkcmVuXCIsIFwiJCRzY29wZVwiLCBcIiQkc2xvdHNcIl0uY29uY2F0KGV4dHJhX2tleXMpXG4gIGNvbnN0IHJlc3QgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoJCRwcm9wcykpIHtcbiAgICBpZiAoIShrZXlzLmluY2x1ZGVzKGtleSkpKSB7XG4gICAgICByZXN0W2tleV0gPSAkJHByb3BzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN0O1xufVxuIiwgIi8qIVxuICogQ2hhcnQuanMgdjMuNy4wXG4gKiBodHRwczovL3d3dy5jaGFydGpzLm9yZ1xuICogKGMpIDIwMjEgQ2hhcnQuanMgQ29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gZm9udFN0cmluZyhwaXhlbFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSkge1xuICByZXR1cm4gZm9udFN0eWxlICsgJyAnICsgcGl4ZWxTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xufVxuY29uc3QgcmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xufSgpKTtcbmZ1bmN0aW9uIHRocm90dGxlZChmbiwgdGhpc0FyZywgdXBkYXRlRm4pIHtcbiAgY29uc3QgdXBkYXRlQXJncyA9IHVwZGF0ZUZuIHx8ICgoYXJncykgPT4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykpO1xuICBsZXQgdGlja2luZyA9IGZhbHNlO1xuICBsZXQgYXJncyA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24oLi4ucmVzdCkge1xuICAgIGFyZ3MgPSB1cGRhdGVBcmdzKHJlc3QpO1xuICAgIGlmICghdGlja2luZykge1xuICAgICAgdGlja2luZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICAgIHRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgZGVsYXkpIHtcbiAgbGV0IHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgZGVsYXksIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGF5O1xuICB9O1xufVxuY29uc3QgX3RvTGVmdFJpZ2h0Q2VudGVyID0gKGFsaWduKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/ICdsZWZ0JyA6IGFsaWduID09PSAnZW5kJyA/ICdyaWdodCcgOiAnY2VudGVyJztcbmNvbnN0IF9hbGlnblN0YXJ0RW5kID0gKGFsaWduLCBzdGFydCwgZW5kKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogYWxpZ24gPT09ICdlbmQnID8gZW5kIDogKHN0YXJ0ICsgZW5kKSAvIDI7XG5jb25zdCBfdGV4dFggPSAoYWxpZ24sIGxlZnQsIHJpZ2h0LCBydGwpID0+IHtcbiAgY29uc3QgY2hlY2sgPSBydGwgPyAnbGVmdCcgOiAncmlnaHQnO1xuICByZXR1cm4gYWxpZ24gPT09IGNoZWNrID8gcmlnaHQgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyAobGVmdCArIHJpZ2h0KSAvIDIgOiBsZWZ0O1xufTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5jb25zdCB1aWQgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBpZCA9IDA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaWQrKztcbiAgfTtcbn0oKSk7XG5mdW5jdGlvbiBpc051bGxPclVuZGVmKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodHlwZS5zdWJzdHIoMCwgNykgPT09ICdbb2JqZWN0JyAmJiB0eXBlLnN1YnN0cigtNikgPT09ICdBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuY29uc3QgaXNOdW1iZXJGaW5pdGUgPSAodmFsdWUpID0+ICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBpc0Zpbml0ZSgrdmFsdWUpO1xuZnVuY3Rpb24gZmluaXRlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIGlzTnVtYmVyRmluaXRlKHZhbHVlKSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuZnVuY3Rpb24gdmFsdWVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufVxuY29uc3QgdG9QZXJjZW50YWdlID0gKHZhbHVlLCBkaW1lbnNpb24pID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/XG4gICAgcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDBcbiAgICA6IHZhbHVlIC8gZGltZW5zaW9uO1xuY29uc3QgdG9EaW1lbnNpb24gPSAodmFsdWUsIGRpbWVuc2lvbikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIGRpbWVuc2lvblxuICAgIDogK3ZhbHVlO1xuZnVuY3Rpb24gY2FsbGJhY2soZm4sIGFyZ3MsIHRoaXNBcmcpIHtcbiAgaWYgKGZuICYmIHR5cGVvZiBmbi5jYWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlYWNoKGxvb3BhYmxlLCBmbiwgdGhpc0FyZywgcmV2ZXJzZSkge1xuICBsZXQgaSwgbGVuLCBrZXlzO1xuICBpZiAoaXNBcnJheShsb29wYWJsZSkpIHtcbiAgICBsZW4gPSBsb29wYWJsZS5sZW5ndGg7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxvb3BhYmxlKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhsb29wYWJsZSk7XG4gICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2tleXNbaV1dLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9lbGVtZW50c0VxdWFsKGEwLCBhMSkge1xuICBsZXQgaSwgaWxlbiwgdjAsIHYxO1xuICBpZiAoIWEwIHx8ICFhMSB8fCBhMC5sZW5ndGggIT09IGExLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGkgPSAwLCBpbGVuID0gYTAubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdjAgPSBhMFtpXTtcbiAgICB2MSA9IGExW2ldO1xuICAgIGlmICh2MC5kYXRhc2V0SW5kZXggIT09IHYxLmRhdGFzZXRJbmRleCB8fCB2MC5pbmRleCAhPT0gdjEuaW5kZXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjbG9uZSQxKHNvdXJjZSkge1xuICBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5tYXAoY2xvbmUkMSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGNvbnN0IGtsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQgayA9IDA7XG4gICAgZm9yICg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIHRhcmdldFtrZXlzW2tdXSA9IGNsb25lJDEoc291cmNlW2tleXNba11dKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gc291cmNlO1xufVxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXkpIHtcbiAgcmV0dXJuIFsnX19wcm90b19fJywgJ3Byb3RvdHlwZScsICdjb25zdHJ1Y3RvciddLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG59XG5mdW5jdGlvbiBfbWVyZ2VyKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdHZhbCA9IHRhcmdldFtrZXldO1xuICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIG1lcmdlKHR2YWwsIHN2YWwsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldFtrZXldID0gY2xvbmUkMShzdmFsKTtcbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc291cmNlcyA9IGlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IFtzb3VyY2VdO1xuICBjb25zdCBpbGVuID0gc291cmNlcy5sZW5ndGg7XG4gIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IG1lcmdlciA9IG9wdGlvbnMubWVyZ2VyIHx8IF9tZXJnZXI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgc291cmNlID0gc291cmNlc1tpXTtcbiAgICBpZiAoIWlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBmb3IgKGxldCBrID0gMCwga2xlbiA9IGtleXMubGVuZ3RoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICBtZXJnZXIoa2V5c1trXSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gbWVyZ2VJZih0YXJnZXQsIHNvdXJjZSkge1xuICByZXR1cm4gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IF9tZXJnZXJJZn0pO1xufVxuZnVuY3Rpb24gX21lcmdlcklmKGtleSwgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdHZhbCA9IHRhcmdldFtrZXldO1xuICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIG1lcmdlSWYodHZhbCwgc3ZhbCk7XG4gIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lJDEoc3ZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9kZXByZWNhdGVkKHNjb3BlLCB2YWx1ZSwgcHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oc2NvcGUgKyAnOiBcIicgKyBwcmV2aW91cyArXG5cdFx0XHQnXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIicgKyBjdXJyZW50ICsgJ1wiIGluc3RlYWQnKTtcbiAgfVxufVxuY29uc3QgZW1wdHlTdHJpbmcgPSAnJztcbmNvbnN0IGRvdCA9ICcuJztcbmZ1bmN0aW9uIGluZGV4T2ZEb3RPckxlbmd0aChrZXksIHN0YXJ0KSB7XG4gIGNvbnN0IGlkeCA9IGtleS5pbmRleE9mKGRvdCwgc3RhcnQpO1xuICByZXR1cm4gaWR4ID09PSAtMSA/IGtleS5sZW5ndGggOiBpZHg7XG59XG5mdW5jdGlvbiByZXNvbHZlT2JqZWN0S2V5KG9iaiwga2V5KSB7XG4gIGlmIChrZXkgPT09IGVtcHR5U3RyaW5nKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBsZXQgcG9zID0gMDtcbiAgbGV0IGlkeCA9IGluZGV4T2ZEb3RPckxlbmd0aChrZXksIHBvcyk7XG4gIHdoaWxlIChvYmogJiYgaWR4ID4gcG9zKSB7XG4gICAgb2JqID0gb2JqW2tleS5zdWJzdHIocG9zLCBpZHggLSBwb3MpXTtcbiAgICBwb3MgPSBpZHggKyAxO1xuICAgIGlkeCA9IGluZGV4T2ZEb3RPckxlbmd0aChrZXksIHBvcyk7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuY29uc3QgZGVmaW5lZCA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IHNldHNFcXVhbCA9IChhLCBiKSA9PiB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgYSkge1xuICAgIGlmICghYi5oYXMoaXRlbSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gX2lzQ2xpY2tFdmVudChlKSB7XG4gIHJldHVybiBlLnR5cGUgPT09ICdtb3VzZXVwJyB8fCBlLnR5cGUgPT09ICdjbGljaycgfHwgZS50eXBlID09PSAnY29udGV4dG1lbnUnO1xufVxuXG5jb25zdCBQSSA9IE1hdGguUEk7XG5jb25zdCBUQVUgPSAyICogUEk7XG5jb25zdCBQSVRBVSA9IFRBVSArIFBJO1xuY29uc3QgSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5jb25zdCBSQURfUEVSX0RFRyA9IFBJIC8gMTgwO1xuY29uc3QgSEFMRl9QSSA9IFBJIC8gMjtcbmNvbnN0IFFVQVJURVJfUEkgPSBQSSAvIDQ7XG5jb25zdCBUV09fVEhJUkRTX1BJID0gUEkgKiAyIC8gMztcbmNvbnN0IGxvZzEwID0gTWF0aC5sb2cxMDtcbmNvbnN0IHNpZ24gPSBNYXRoLnNpZ247XG5mdW5jdGlvbiBuaWNlTnVtKHJhbmdlKSB7XG4gIGNvbnN0IHJvdW5kZWRSYW5nZSA9IE1hdGgucm91bmQocmFuZ2UpO1xuICByYW5nZSA9IGFsbW9zdEVxdWFscyhyYW5nZSwgcm91bmRlZFJhbmdlLCByYW5nZSAvIDEwMDApID8gcm91bmRlZFJhbmdlIDogcmFuZ2U7XG4gIGNvbnN0IG5pY2VSYW5nZSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHJhbmdlKSkpO1xuICBjb25zdCBmcmFjdGlvbiA9IHJhbmdlIC8gbmljZVJhbmdlO1xuICBjb25zdCBuaWNlRnJhY3Rpb24gPSBmcmFjdGlvbiA8PSAxID8gMSA6IGZyYWN0aW9uIDw9IDIgPyAyIDogZnJhY3Rpb24gPD0gNSA/IDUgOiAxMDtcbiAgcmV0dXJuIG5pY2VGcmFjdGlvbiAqIG5pY2VSYW5nZTtcbn1cbmZ1bmN0aW9uIF9mYWN0b3JpemUodmFsdWUpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHNxcnQgPSBNYXRoLnNxcnQodmFsdWUpO1xuICBsZXQgaTtcbiAgZm9yIChpID0gMTsgaSA8IHNxcnQ7IGkrKykge1xuICAgIGlmICh2YWx1ZSAlIGkgPT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUgLyBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNxcnQgPT09IChzcXJ0IHwgMCkpIHtcbiAgICByZXN1bHQucHVzaChzcXJ0KTtcbiAgfVxuICByZXN1bHQuc29ydCgoYSwgYikgPT4gYSAtIGIpLnBvcCgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNOdW1iZXIobikge1xuICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuZnVuY3Rpb24gYWxtb3N0RXF1YWxzKHgsIHksIGVwc2lsb24pIHtcbiAgcmV0dXJuIE1hdGguYWJzKHggLSB5KSA8IGVwc2lsb247XG59XG5mdW5jdGlvbiBhbG1vc3RXaG9sZSh4LCBlcHNpbG9uKSB7XG4gIGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKHgpO1xuICByZXR1cm4gKChyb3VuZGVkIC0gZXBzaWxvbikgPD0geCkgJiYgKChyb3VuZGVkICsgZXBzaWxvbikgPj0geCk7XG59XG5mdW5jdGlvbiBfc2V0TWluQW5kTWF4QnlLZXkoYXJyYXksIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgbGV0IGksIGlsZW4sIHZhbHVlO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgdmFsdWUgPSBhcnJheVtpXVtwcm9wZXJ0eV07XG4gICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHRhcmdldC5taW4gPSBNYXRoLm1pbih0YXJnZXQubWluLCB2YWx1ZSk7XG4gICAgICB0YXJnZXQubWF4ID0gTWF0aC5tYXgodGFyZ2V0Lm1heCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgcmV0dXJuIGRlZ3JlZXMgKiAoUEkgLyAxODApO1xufVxuZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnMpIHtcbiAgcmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gUEkpO1xufVxuZnVuY3Rpb24gX2RlY2ltYWxQbGFjZXMoeCkge1xuICBpZiAoIWlzTnVtYmVyRmluaXRlKHgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBlID0gMTtcbiAgbGV0IHAgPSAwO1xuICB3aGlsZSAoTWF0aC5yb3VuZCh4ICogZSkgLyBlICE9PSB4KSB7XG4gICAgZSAqPSAxMDtcbiAgICBwKys7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBnZXRBbmdsZUZyb21Qb2ludChjZW50cmVQb2ludCwgYW5nbGVQb2ludCkge1xuICBjb25zdCBkaXN0YW5jZUZyb21YQ2VudGVyID0gYW5nbGVQb2ludC54IC0gY2VudHJlUG9pbnQueDtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWUNlbnRlciA9IGFuZ2xlUG9pbnQueSAtIGNlbnRyZVBvaW50Lnk7XG4gIGNvbnN0IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciA9IE1hdGguc3FydChkaXN0YW5jZUZyb21YQ2VudGVyICogZGlzdGFuY2VGcm9tWENlbnRlciArIGRpc3RhbmNlRnJvbVlDZW50ZXIgKiBkaXN0YW5jZUZyb21ZQ2VudGVyKTtcbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcbiAgaWYgKGFuZ2xlIDwgKC0wLjUgKiBQSSkpIHtcbiAgICBhbmdsZSArPSBUQVU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhbmdsZSxcbiAgICBkaXN0YW5jZTogcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyXG4gIH07XG59XG5mdW5jdGlvbiBkaXN0YW5jZUJldHdlZW5Qb2ludHMocHQxLCBwdDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcbn1cbmZ1bmN0aW9uIF9hbmdsZURpZmYoYSwgYikge1xuICByZXR1cm4gKGEgLSBiICsgUElUQVUpICUgVEFVIC0gUEk7XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplQW5nbGUoYSkge1xuICByZXR1cm4gKGEgJSBUQVUgKyBUQVUpICUgVEFVO1xufVxuZnVuY3Rpb24gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnQsIGVuZCwgc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlKSB7XG4gIGNvbnN0IGEgPSBfbm9ybWFsaXplQW5nbGUoYW5nbGUpO1xuICBjb25zdCBzID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgY29uc3QgZSA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICBjb25zdCBhbmdsZVRvU3RhcnQgPSBfbm9ybWFsaXplQW5nbGUocyAtIGEpO1xuICBjb25zdCBhbmdsZVRvRW5kID0gX25vcm1hbGl6ZUFuZ2xlKGUgLSBhKTtcbiAgY29uc3Qgc3RhcnRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBzKTtcbiAgY29uc3QgZW5kVG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gZSk7XG4gIHJldHVybiBhID09PSBzIHx8IGEgPT09IGUgfHwgKHNhbWVBbmdsZUlzRnVsbENpcmNsZSAmJiBzID09PSBlKVxuICAgIHx8IChhbmdsZVRvU3RhcnQgPiBhbmdsZVRvRW5kICYmIHN0YXJ0VG9BbmdsZSA8IGVuZFRvQW5nbGUpO1xufVxuZnVuY3Rpb24gX2xpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIF9pbnQxNlJhbmdlKHZhbHVlKSB7XG4gIHJldHVybiBfbGltaXRWYWx1ZSh2YWx1ZSwgLTMyNzY4LCAzMjc2Nyk7XG59XG5mdW5jdGlvbiBfaXNCZXR3ZWVuKHZhbHVlLCBzdGFydCwgZW5kLCBlcHNpbG9uID0gMWUtNikge1xuICByZXR1cm4gdmFsdWUgPj0gTWF0aC5taW4oc3RhcnQsIGVuZCkgLSBlcHNpbG9uICYmIHZhbHVlIDw9IE1hdGgubWF4KHN0YXJ0LCBlbmQpICsgZXBzaWxvbjtcbn1cblxuY29uc3QgYXRFZGdlID0gKHQpID0+IHQgPT09IDAgfHwgdCA9PT0gMTtcbmNvbnN0IGVsYXN0aWNJbiA9ICh0LCBzLCBwKSA9PiAtKE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApKTtcbmNvbnN0IGVsYXN0aWNPdXQgPSAodCwgcywgcCkgPT4gTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkgKyAxO1xuY29uc3QgZWZmZWN0cyA9IHtcbiAgbGluZWFyOiB0ID0+IHQsXG4gIGVhc2VJblF1YWQ6IHQgPT4gdCAqIHQsXG4gIGVhc2VPdXRRdWFkOiB0ID0+IC10ICogKHQgLSAyKSxcbiAgZWFzZUluT3V0UXVhZDogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdFxuICAgIDogLTAuNSAqICgoLS10KSAqICh0IC0gMikgLSAxKSxcbiAgZWFzZUluQ3ViaWM6IHQgPT4gdCAqIHQgKiB0LFxuICBlYXNlT3V0Q3ViaWM6IHQgPT4gKHQgLT0gMSkgKiB0ICogdCArIDEsXG4gIGVhc2VJbk91dEN1YmljOiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdFxuICAgIDogMC41ICogKCh0IC09IDIpICogdCAqIHQgKyAyKSxcbiAgZWFzZUluUXVhcnQ6IHQgPT4gdCAqIHQgKiB0ICogdCxcbiAgZWFzZU91dFF1YXJ0OiB0ID0+IC0oKHQgLT0gMSkgKiB0ICogdCAqIHQgLSAxKSxcbiAgZWFzZUluT3V0UXVhcnQ6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdFxuICAgIDogLTAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAtIDIpLFxuICBlYXNlSW5RdWludDogdCA9PiB0ICogdCAqIHQgKiB0ICogdCxcbiAgZWFzZU91dFF1aW50OiB0ID0+ICh0IC09IDEpICogdCAqIHQgKiB0ICogdCArIDEsXG4gIGVhc2VJbk91dFF1aW50OiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMiksXG4gIGVhc2VJblNpbmU6IHQgPT4gLU1hdGguY29zKHQgKiBIQUxGX1BJKSArIDEsXG4gIGVhc2VPdXRTaW5lOiB0ID0+IE1hdGguc2luKHQgKiBIQUxGX1BJKSxcbiAgZWFzZUluT3V0U2luZTogdCA9PiAtMC41ICogKE1hdGguY29zKFBJICogdCkgLSAxKSxcbiAgZWFzZUluRXhwbzogdCA9PiAodCA9PT0gMCkgPyAwIDogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKSxcbiAgZWFzZU91dEV4cG86IHQgPT4gKHQgPT09IDEpID8gMSA6IC1NYXRoLnBvdygyLCAtMTAgKiB0KSArIDEsXG4gIGVhc2VJbk91dEV4cG86IHQgPT4gYXRFZGdlKHQpID8gdCA6IHQgPCAwLjVcbiAgICA/IDAuNSAqIE1hdGgucG93KDIsIDEwICogKHQgKiAyIC0gMSkpXG4gICAgOiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqICh0ICogMiAtIDEpKSArIDIpLFxuICBlYXNlSW5DaXJjOiB0ID0+ICh0ID49IDEpID8gdCA6IC0oTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKSxcbiAgZWFzZU91dENpcmM6IHQgPT4gTWF0aC5zcXJ0KDEgLSAodCAtPSAxKSAqIHQpLFxuICBlYXNlSW5PdXRDaXJjOiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKVxuICAgIDogMC41ICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpLFxuICBlYXNlSW5FbGFzdGljOiB0ID0+IGF0RWRnZSh0KSA/IHQgOiBlbGFzdGljSW4odCwgMC4wNzUsIDAuMyksXG4gIGVhc2VPdXRFbGFzdGljOiB0ID0+IGF0RWRnZSh0KSA/IHQgOiBlbGFzdGljT3V0KHQsIDAuMDc1LCAwLjMpLFxuICBlYXNlSW5PdXRFbGFzdGljKHQpIHtcbiAgICBjb25zdCBzID0gMC4xMTI1O1xuICAgIGNvbnN0IHAgPSAwLjQ1O1xuICAgIHJldHVybiBhdEVkZ2UodCkgPyB0IDpcbiAgICAgIHQgPCAwLjVcbiAgICAgICAgPyAwLjUgKiBlbGFzdGljSW4odCAqIDIsIHMsIHApXG4gICAgICAgIDogMC41ICsgMC41ICogZWxhc3RpY091dCh0ICogMiAtIDEsIHMsIHApO1xuICB9LFxuICBlYXNlSW5CYWNrKHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbiAgfSxcbiAgZWFzZU91dEJhY2sodCkge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiAodCAtPSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG4gIH0sXG4gIGVhc2VJbk91dEJhY2sodCkge1xuICAgIGxldCBzID0gMS43MDE1ODtcbiAgICBpZiAoKHQgLz0gMC41KSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xuICAgIH1cbiAgICByZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpO1xuICB9LFxuICBlYXNlSW5Cb3VuY2U6IHQgPT4gMSAtIGVmZmVjdHMuZWFzZU91dEJvdW5jZSgxIC0gdCksXG4gIGVhc2VPdXRCb3VuY2UodCkge1xuICAgIGNvbnN0IG0gPSA3LjU2MjU7XG4gICAgY29uc3QgZCA9IDIuNzU7XG4gICAgaWYgKHQgPCAoMSAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqIHQgKiB0O1xuICAgIH1cbiAgICBpZiAodCA8ICgyIC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDEuNSAvIGQpKSAqIHQgKyAwLjc1O1xuICAgIH1cbiAgICBpZiAodCA8ICgyLjUgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiAodCAtPSAoMi4yNSAvIGQpKSAqIHQgKyAwLjkzNzU7XG4gICAgfVxuICAgIHJldHVybiBtICogKHQgLT0gKDIuNjI1IC8gZCkpICogdCArIDAuOTg0Mzc1O1xuICB9LFxuICBlYXNlSW5PdXRCb3VuY2U6IHQgPT4gKHQgPCAwLjUpXG4gICAgPyBlZmZlY3RzLmVhc2VJbkJvdW5jZSh0ICogMikgKiAwLjVcbiAgICA6IGVmZmVjdHMuZWFzZU91dEJvdW5jZSh0ICogMiAtIDEpICogMC41ICsgMC41LFxufTtcblxuLyohXG4gKiBAa3Vya2xlL2NvbG9yIHYwLjEuOVxuICogaHR0cHM6Ly9naXRodWIuY29tL2t1cmtsZS9jb2xvciNyZWFkbWVcbiAqIChjKSAyMDIwIEp1a2thIEt1cmtlbGFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5jb25zdCBtYXAgPSB7MDogMCwgMTogMSwgMjogMiwgMzogMywgNDogNCwgNTogNSwgNjogNiwgNzogNywgODogOCwgOTogOSwgQTogMTAsIEI6IDExLCBDOiAxMiwgRDogMTMsIEU6IDE0LCBGOiAxNSwgYTogMTAsIGI6IDExLCBjOiAxMiwgZDogMTMsIGU6IDE0LCBmOiAxNX07XG5jb25zdCBoZXggPSAnMDEyMzQ1Njc4OUFCQ0RFRic7XG5jb25zdCBoMSA9IChiKSA9PiBoZXhbYiAmIDB4Rl07XG5jb25zdCBoMiA9IChiKSA9PiBoZXhbKGIgJiAweEYwKSA+PiA0XSArIGhleFtiICYgMHhGXTtcbmNvbnN0IGVxID0gKGIpID0+ICgoKGIgJiAweEYwKSA+PiA0KSA9PT0gKGIgJiAweEYpKTtcbmZ1bmN0aW9uIGlzU2hvcnQodikge1xuXHRyZXR1cm4gZXEodi5yKSAmJiBlcSh2LmcpICYmIGVxKHYuYikgJiYgZXEodi5hKTtcbn1cbmZ1bmN0aW9uIGhleFBhcnNlKHN0cikge1xuXHR2YXIgbGVuID0gc3RyLmxlbmd0aDtcblx0dmFyIHJldDtcblx0aWYgKHN0clswXSA9PT0gJyMnKSB7XG5cdFx0aWYgKGxlbiA9PT0gNCB8fCBsZW4gPT09IDUpIHtcblx0XHRcdHJldCA9IHtcblx0XHRcdFx0cjogMjU1ICYgbWFwW3N0clsxXV0gKiAxNyxcblx0XHRcdFx0ZzogMjU1ICYgbWFwW3N0clsyXV0gKiAxNyxcblx0XHRcdFx0YjogMjU1ICYgbWFwW3N0clszXV0gKiAxNyxcblx0XHRcdFx0YTogbGVuID09PSA1ID8gbWFwW3N0cls0XV0gKiAxNyA6IDI1NVxuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKGxlbiA9PT0gNyB8fCBsZW4gPT09IDkpIHtcblx0XHRcdHJldCA9IHtcblx0XHRcdFx0cjogbWFwW3N0clsxXV0gPDwgNCB8IG1hcFtzdHJbMl1dLFxuXHRcdFx0XHRnOiBtYXBbc3RyWzNdXSA8PCA0IHwgbWFwW3N0cls0XV0sXG5cdFx0XHRcdGI6IG1hcFtzdHJbNV1dIDw8IDQgfCBtYXBbc3RyWzZdXSxcblx0XHRcdFx0YTogbGVuID09PSA5ID8gKG1hcFtzdHJbN11dIDw8IDQgfCBtYXBbc3RyWzhdXSkgOiAyNTVcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBoZXhTdHJpbmcodikge1xuXHR2YXIgZiA9IGlzU2hvcnQodikgPyBoMSA6IGgyO1xuXHRyZXR1cm4gdlxuXHRcdD8gJyMnICsgZih2LnIpICsgZih2LmcpICsgZih2LmIpICsgKHYuYSA8IDI1NSA/IGYodi5hKSA6ICcnKVxuXHRcdDogdjtcbn1cbmZ1bmN0aW9uIHJvdW5kKHYpIHtcblx0cmV0dXJuIHYgKyAwLjUgfCAwO1xufVxuY29uc3QgbGltID0gKHYsIGwsIGgpID0+IE1hdGgubWF4KE1hdGgubWluKHYsIGgpLCBsKTtcbmZ1bmN0aW9uIHAyYih2KSB7XG5cdHJldHVybiBsaW0ocm91bmQodiAqIDIuNTUpLCAwLCAyNTUpO1xufVxuZnVuY3Rpb24gbjJiKHYpIHtcblx0cmV0dXJuIGxpbShyb3VuZCh2ICogMjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIybih2KSB7XG5cdHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpIC8gMTAwLCAwLCAxKTtcbn1cbmZ1bmN0aW9uIG4ycCh2KSB7XG5cdHJldHVybiBsaW0ocm91bmQodiAqIDEwMCksIDAsIDEwMCk7XG59XG5jb25zdCBSR0JfUkUgPSAvXnJnYmE/XFwoXFxzKihbLSsuXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT8oPzpbXFxzLC9dKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcbmZ1bmN0aW9uIHJnYlBhcnNlKHN0cikge1xuXHRjb25zdCBtID0gUkdCX1JFLmV4ZWMoc3RyKTtcblx0bGV0IGEgPSAyNTU7XG5cdGxldCByLCBnLCBiO1xuXHRpZiAoIW0pIHtcblx0XHRyZXR1cm47XG5cdH1cblx0aWYgKG1bN10gIT09IHIpIHtcblx0XHRjb25zdCB2ID0gK21bN107XG5cdFx0YSA9IDI1NSAmIChtWzhdID8gcDJiKHYpIDogdiAqIDI1NSk7XG5cdH1cblx0ciA9ICttWzFdO1xuXHRnID0gK21bM107XG5cdGIgPSArbVs1XTtcblx0ciA9IDI1NSAmIChtWzJdID8gcDJiKHIpIDogcik7XG5cdGcgPSAyNTUgJiAobVs0XSA/IHAyYihnKSA6IGcpO1xuXHRiID0gMjU1ICYgKG1bNl0gPyBwMmIoYikgOiBiKTtcblx0cmV0dXJuIHtcblx0XHRyOiByLFxuXHRcdGc6IGcsXG5cdFx0YjogYixcblx0XHRhOiBhXG5cdH07XG59XG5mdW5jdGlvbiByZ2JTdHJpbmcodikge1xuXHRyZXR1cm4gdiAmJiAoXG5cdFx0di5hIDwgMjU1XG5cdFx0XHQ/IGByZ2JhKCR7di5yfSwgJHt2Lmd9LCAke3YuYn0sICR7YjJuKHYuYSl9KWBcblx0XHRcdDogYHJnYigke3Yucn0sICR7di5nfSwgJHt2LmJ9KWBcblx0KTtcbn1cbmNvbnN0IEhVRV9SRSA9IC9eKGhzbGE/fGh3Ynxoc3YpXFwoXFxzKihbLSsuZVxcZF0rKSg/OmRlZyk/W1xccyxdKyhbLSsuZVxcZF0rKSVbXFxzLF0rKFstKy5lXFxkXSspJSg/OltcXHMsXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiBoc2wycmdibihoLCBzLCBsKSB7XG5cdGNvbnN0IGEgPSBzICogTWF0aC5taW4obCwgMSAtIGwpO1xuXHRjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyAzMCkgJSAxMikgPT4gbCAtIGEgKiBNYXRoLm1heChNYXRoLm1pbihrIC0gMywgOSAtIGssIDEpLCAtMSk7XG5cdHJldHVybiBbZigwKSwgZig4KSwgZig0KV07XG59XG5mdW5jdGlvbiBoc3YycmdibihoLCBzLCB2KSB7XG5cdGNvbnN0IGYgPSAobiwgayA9IChuICsgaCAvIDYwKSAlIDYpID0+IHYgLSB2ICogcyAqIE1hdGgubWF4KE1hdGgubWluKGssIDQgLSBrLCAxKSwgMCk7XG5cdHJldHVybiBbZig1KSwgZigzKSwgZigxKV07XG59XG5mdW5jdGlvbiBod2IycmdibihoLCB3LCBiKSB7XG5cdGNvbnN0IHJnYiA9IGhzbDJyZ2JuKGgsIDEsIDAuNSk7XG5cdGxldCBpO1xuXHRpZiAodyArIGIgPiAxKSB7XG5cdFx0aSA9IDEgLyAodyArIGIpO1xuXHRcdHcgKj0gaTtcblx0XHRiICo9IGk7XG5cdH1cblx0Zm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdHJnYltpXSAqPSAxIC0gdyAtIGI7XG5cdFx0cmdiW2ldICs9IHc7XG5cdH1cblx0cmV0dXJuIHJnYjtcbn1cbmZ1bmN0aW9uIHJnYjJoc2wodikge1xuXHRjb25zdCByYW5nZSA9IDI1NTtcblx0Y29uc3QgciA9IHYuciAvIHJhbmdlO1xuXHRjb25zdCBnID0gdi5nIC8gcmFuZ2U7XG5cdGNvbnN0IGIgPSB2LmIgLyByYW5nZTtcblx0Y29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG5cdGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHRjb25zdCBsID0gKG1heCArIG1pbikgLyAyO1xuXHRsZXQgaCwgcywgZDtcblx0aWYgKG1heCAhPT0gbWluKSB7XG5cdFx0ZCA9IG1heCAtIG1pbjtcblx0XHRzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG5cdFx0aCA9IG1heCA9PT0gclxuXHRcdFx0PyAoKGcgLSBiKSAvIGQpICsgKGcgPCBiID8gNiA6IDApXG5cdFx0XHQ6IG1heCA9PT0gZ1xuXHRcdFx0XHQ/IChiIC0gcikgLyBkICsgMlxuXHRcdFx0XHQ6IChyIC0gZykgLyBkICsgNDtcblx0XHRoID0gaCAqIDYwICsgMC41O1xuXHR9XG5cdHJldHVybiBbaCB8IDAsIHMgfHwgMCwgbF07XG59XG5mdW5jdGlvbiBjYWxsbihmLCBhLCBiLCBjKSB7XG5cdHJldHVybiAoXG5cdFx0QXJyYXkuaXNBcnJheShhKVxuXHRcdFx0PyBmKGFbMF0sIGFbMV0sIGFbMl0pXG5cdFx0XHQ6IGYoYSwgYiwgYylcblx0KS5tYXAobjJiKTtcbn1cbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgcywgbCkge1xuXHRyZXR1cm4gY2FsbG4oaHNsMnJnYm4sIGgsIHMsIGwpO1xufVxuZnVuY3Rpb24gaHdiMnJnYihoLCB3LCBiKSB7XG5cdHJldHVybiBjYWxsbihod2IycmdibiwgaCwgdywgYik7XG59XG5mdW5jdGlvbiBoc3YycmdiKGgsIHMsIHYpIHtcblx0cmV0dXJuIGNhbGxuKGhzdjJyZ2JuLCBoLCBzLCB2KTtcbn1cbmZ1bmN0aW9uIGh1ZShoKSB7XG5cdHJldHVybiAoaCAlIDM2MCArIDM2MCkgJSAzNjA7XG59XG5mdW5jdGlvbiBodWVQYXJzZShzdHIpIHtcblx0Y29uc3QgbSA9IEhVRV9SRS5leGVjKHN0cik7XG5cdGxldCBhID0gMjU1O1xuXHRsZXQgdjtcblx0aWYgKCFtKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGlmIChtWzVdICE9PSB2KSB7XG5cdFx0YSA9IG1bNl0gPyBwMmIoK21bNV0pIDogbjJiKCttWzVdKTtcblx0fVxuXHRjb25zdCBoID0gaHVlKCttWzJdKTtcblx0Y29uc3QgcDEgPSArbVszXSAvIDEwMDtcblx0Y29uc3QgcDIgPSArbVs0XSAvIDEwMDtcblx0aWYgKG1bMV0gPT09ICdod2InKSB7XG5cdFx0diA9IGh3YjJyZ2IoaCwgcDEsIHAyKTtcblx0fSBlbHNlIGlmIChtWzFdID09PSAnaHN2Jykge1xuXHRcdHYgPSBoc3YycmdiKGgsIHAxLCBwMik7XG5cdH0gZWxzZSB7XG5cdFx0diA9IGhzbDJyZ2IoaCwgcDEsIHAyKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdHI6IHZbMF0sXG5cdFx0ZzogdlsxXSxcblx0XHRiOiB2WzJdLFxuXHRcdGE6IGFcblx0fTtcbn1cbmZ1bmN0aW9uIHJvdGF0ZSh2LCBkZWcpIHtcblx0dmFyIGggPSByZ2IyaHNsKHYpO1xuXHRoWzBdID0gaHVlKGhbMF0gKyBkZWcpO1xuXHRoID0gaHNsMnJnYihoKTtcblx0di5yID0gaFswXTtcblx0di5nID0gaFsxXTtcblx0di5iID0gaFsyXTtcbn1cbmZ1bmN0aW9uIGhzbFN0cmluZyh2KSB7XG5cdGlmICghdikge1xuXHRcdHJldHVybjtcblx0fVxuXHRjb25zdCBhID0gcmdiMmhzbCh2KTtcblx0Y29uc3QgaCA9IGFbMF07XG5cdGNvbnN0IHMgPSBuMnAoYVsxXSk7XG5cdGNvbnN0IGwgPSBuMnAoYVsyXSk7XG5cdHJldHVybiB2LmEgPCAyNTVcblx0XHQ/IGBoc2xhKCR7aH0sICR7c30lLCAke2x9JSwgJHtiMm4odi5hKX0pYFxuXHRcdDogYGhzbCgke2h9LCAke3N9JSwgJHtsfSUpYDtcbn1cbmNvbnN0IG1hcCQxID0ge1xuXHR4OiAnZGFyaycsXG5cdFo6ICdsaWdodCcsXG5cdFk6ICdyZScsXG5cdFg6ICdibHUnLFxuXHRXOiAnZ3InLFxuXHRWOiAnbWVkaXVtJyxcblx0VTogJ3NsYXRlJyxcblx0QTogJ2VlJyxcblx0VDogJ29sJyxcblx0UzogJ29yJyxcblx0QjogJ3JhJyxcblx0QzogJ2xhdGVnJyxcblx0RDogJ2lnaHRzJyxcblx0UjogJ2luJyxcblx0UTogJ3R1cnF1b2lzJyxcblx0RTogJ2hpJyxcblx0UDogJ3JvJyxcblx0TzogJ2FsJyxcblx0TjogJ2xlJyxcblx0TTogJ2RlJyxcblx0TDogJ3llbGxvJyxcblx0RjogJ2VuJyxcblx0SzogJ2NoJyxcblx0RzogJ2Fya3MnLFxuXHRIOiAnZWEnLFxuXHRJOiAnaWdodGcnLFxuXHRKOiAnd2gnXG59O1xuY29uc3QgbmFtZXMgPSB7XG5cdE9pY2VYZTogJ2YwZjhmZicsXG5cdGFudGlxdWV3RXRlOiAnZmFlYmQ3Jyxcblx0YXF1YTogJ2ZmZmYnLFxuXHRhcXVhbWFyUmU6ICc3ZmZmZDQnLFxuXHRhenVZOiAnZjBmZmZmJyxcblx0YmVpZ2U6ICdmNWY1ZGMnLFxuXHRiaXNxdWU6ICdmZmU0YzQnLFxuXHRibGFjazogJzAnLFxuXHRibGFuS2VkT21vbmQ6ICdmZmViY2QnLFxuXHRYZTogJ2ZmJyxcblx0WGV2aVRldDogJzhhMmJlMicsXG5cdGJQd246ICdhNTJhMmEnLFxuXHRidXJseXdvb2Q6ICdkZWI4ODcnLFxuXHRjYU10WGU6ICc1ZjllYTAnLFxuXHRLYXJ0WXVzZTogJzdmZmYwMCcsXG5cdEtvY1RhdGU6ICdkMjY5MWUnLFxuXHRjU086ICdmZjdmNTAnLFxuXHRjU25mbG93ZXJYZTogJzY0OTVlZCcsXG5cdGNTbnNpbGs6ICdmZmY4ZGMnLFxuXHRjcmltc29uOiAnZGMxNDNjJyxcblx0Y3lhbjogJ2ZmZmYnLFxuXHR4WGU6ICc4YicsXG5cdHhjeWFuOiAnOGI4YicsXG5cdHhnVE1uUGQ6ICdiODg2MGInLFxuXHR4V2F5OiAnYTlhOWE5Jyxcblx0eGdZRjogJzY0MDAnLFxuXHR4Z1l5OiAnYTlhOWE5Jyxcblx0eGtoYWtpOiAnYmRiNzZiJyxcblx0eG1hZ0Z0YTogJzhiMDA4YicsXG5cdHhUaXZlZ1lGOiAnNTU2YjJmJyxcblx0eFNhbmdlOiAnZmY4YzAwJyxcblx0eFNjRWQ6ICc5OTMyY2MnLFxuXHR4WWQ6ICc4YjAwMDAnLFxuXHR4c09tb246ICdlOTk2N2EnLFxuXHR4c0hnWUY6ICc4ZmJjOGYnLFxuXHR4VVhlOiAnNDgzZDhiJyxcblx0eFVXYXk6ICcyZjRmNGYnLFxuXHR4VWdZeTogJzJmNGY0ZicsXG5cdHhRZTogJ2NlZDEnLFxuXHR4dmlUZXQ6ICc5NDAwZDMnLFxuXHRkQXBwUms6ICdmZjE0OTMnLFxuXHRkQXBza3lYZTogJ2JmZmYnLFxuXHRkaW1XYXk6ICc2OTY5NjknLFxuXHRkaW1nWXk6ICc2OTY5NjknLFxuXHRkb2RnZXJYZTogJzFlOTBmZicsXG5cdGZpWWJyaWNrOiAnYjIyMjIyJyxcblx0ZmxTT3dFdGU6ICdmZmZhZjAnLFxuXHRmb1lzdFdBbjogJzIyOGIyMicsXG5cdGZ1S3NpYTogJ2ZmMDBmZicsXG5cdGdhUnNiU286ICdkY2RjZGMnLFxuXHRnaG9zdHdFdGU6ICdmOGY4ZmYnLFxuXHRnVGQ6ICdmZmQ3MDAnLFxuXHRnVE1uUGQ6ICdkYWE1MjAnLFxuXHRXYXk6ICc4MDgwODAnLFxuXHRnWUY6ICc4MDAwJyxcblx0Z1lGTHc6ICdhZGZmMmYnLFxuXHRnWXk6ICc4MDgwODAnLFxuXHRob25leU13OiAnZjBmZmYwJyxcblx0aG90cFJrOiAnZmY2OWI0Jyxcblx0UmRpYW5ZZDogJ2NkNWM1YycsXG5cdFJkaWdvOiAnNGIwMDgyJyxcblx0aXZTeTogJ2ZmZmZmMCcsXG5cdGtoYWtpOiAnZjBlNjhjJyxcblx0bGF2Rk1yOiAnZTZlNmZhJyxcblx0bGF2Rk1yWHNoOiAnZmZmMGY1Jyxcblx0bGF3bmdZRjogJzdjZmMwMCcsXG5cdE5tb25jRWZmb246ICdmZmZhY2QnLFxuXHRaWGU6ICdhZGQ4ZTYnLFxuXHRaY1NPOiAnZjA4MDgwJyxcblx0WmN5YW46ICdlMGZmZmYnLFxuXHRaZ1RNblBkTHc6ICdmYWZhZDInLFxuXHRaV2F5OiAnZDNkM2QzJyxcblx0WmdZRjogJzkwZWU5MCcsXG5cdFpnWXk6ICdkM2QzZDMnLFxuXHRacFJrOiAnZmZiNmMxJyxcblx0WnNPbW9uOiAnZmZhMDdhJyxcblx0WnNIZ1lGOiAnMjBiMmFhJyxcblx0WnNreVhlOiAnODdjZWZhJyxcblx0WlVXYXk6ICc3Nzg4OTknLFxuXHRaVWdZeTogJzc3ODg5OScsXG5cdFpzdEFsWGU6ICdiMGM0ZGUnLFxuXHRaTHc6ICdmZmZmZTAnLFxuXHRsaW1lOiAnZmYwMCcsXG5cdGxpbWVnWUY6ICczMmNkMzInLFxuXHRsUkY6ICdmYWYwZTYnLFxuXHRtYWdGdGE6ICdmZjAwZmYnLFxuXHRtYVBvbjogJzgwMDAwMCcsXG5cdFZhcXVhbWFyUmU6ICc2NmNkYWEnLFxuXHRWWGU6ICdjZCcsXG5cdFZTY0VkOiAnYmE1NWQzJyxcblx0VnB1cnBOOiAnOTM3MGRiJyxcblx0VnNIZ1lGOiAnM2NiMzcxJyxcblx0VlVYZTogJzdiNjhlZScsXG5cdFZzcHJSZ2dZRjogJ2ZhOWEnLFxuXHRWUWU6ICc0OGQxY2MnLFxuXHRWdmlUZXRZZDogJ2M3MTU4NScsXG5cdG1pZG5pZ2h0WGU6ICcxOTE5NzAnLFxuXHRtUnRjWWFtOiAnZjVmZmZhJyxcblx0bWlzdHlQc2U6ICdmZmU0ZTEnLFxuXHRtb2NjYXNSOiAnZmZlNGI1Jyxcblx0bmF2YWpvd0V0ZTogJ2ZmZGVhZCcsXG5cdG5hdnk6ICc4MCcsXG5cdFRkbGFjZTogJ2ZkZjVlNicsXG5cdFRpdmU6ICc4MDgwMDAnLFxuXHRUaXZlZEJiOiAnNmI4ZTIzJyxcblx0U2FuZ2U6ICdmZmE1MDAnLFxuXHRTYW5nZVlkOiAnZmY0NTAwJyxcblx0U2NFZDogJ2RhNzBkNicsXG5cdHBPZWdUTW5QZDogJ2VlZThhYScsXG5cdHBPZWdZRjogJzk4ZmI5OCcsXG5cdHBPZVFlOiAnYWZlZWVlJyxcblx0cE9ldmlUZXRZZDogJ2RiNzA5MycsXG5cdHBhcGF5YXdFcDogJ2ZmZWZkNScsXG5cdHBIS3B1ZmY6ICdmZmRhYjknLFxuXHRwZXJ1OiAnY2Q4NTNmJyxcblx0cFJrOiAnZmZjMGNiJyxcblx0cGx1bTogJ2RkYTBkZCcsXG5cdHBvd01yWGU6ICdiMGUwZTYnLFxuXHRwdXJwTjogJzgwMDA4MCcsXG5cdFliZWNjYXB1cnBOOiAnNjYzMzk5Jyxcblx0WWQ6ICdmZjAwMDAnLFxuXHRQc3licm93bjogJ2JjOGY4ZicsXG5cdFB5T1hlOiAnNDE2OWUxJyxcblx0c2FkZE5iUHduOiAnOGI0NTEzJyxcblx0c09tb246ICdmYTgwNzInLFxuXHRzYW5keWJQd246ICdmNGE0NjAnLFxuXHRzSGdZRjogJzJlOGI1NycsXG5cdHNIc2hlbGw6ICdmZmY1ZWUnLFxuXHRzaUZuYTogJ2EwNTIyZCcsXG5cdHNpbHZlcjogJ2MwYzBjMCcsXG5cdHNreVhlOiAnODdjZWViJyxcblx0VVhlOiAnNmE1YWNkJyxcblx0VVdheTogJzcwODA5MCcsXG5cdFVnWXk6ICc3MDgwOTAnLFxuXHRzbm93OiAnZmZmYWZhJyxcblx0c3ByUmdnWUY6ICdmZjdmJyxcblx0c3RBbFhlOiAnNDY4MmI0Jyxcblx0dGFuOiAnZDJiNDhjJyxcblx0dGVPOiAnODA4MCcsXG5cdHRFc3ROOiAnZDhiZmQ4Jyxcblx0dG9tYXRvOiAnZmY2MzQ3Jyxcblx0UWU6ICc0MGUwZDAnLFxuXHR2aVRldDogJ2VlODJlZScsXG5cdEpIdDogJ2Y1ZGViMycsXG5cdHdFdGU6ICdmZmZmZmYnLFxuXHR3RXRlc21va2U6ICdmNWY1ZjUnLFxuXHRMdzogJ2ZmZmYwMCcsXG5cdEx3Z1lGOiAnOWFjZDMyJ1xufTtcbmZ1bmN0aW9uIHVucGFjaygpIHtcblx0Y29uc3QgdW5wYWNrZWQgPSB7fTtcblx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG5hbWVzKTtcblx0Y29uc3QgdGtleXMgPSBPYmplY3Qua2V5cyhtYXAkMSk7XG5cdGxldCBpLCBqLCBrLCBvaywgbms7XG5cdGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0b2sgPSBuayA9IGtleXNbaV07XG5cdFx0Zm9yIChqID0gMDsgaiA8IHRrZXlzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRrID0gdGtleXNbal07XG5cdFx0XHRuayA9IG5rLnJlcGxhY2UoaywgbWFwJDFba10pO1xuXHRcdH1cblx0XHRrID0gcGFyc2VJbnQobmFtZXNbb2tdLCAxNik7XG5cdFx0dW5wYWNrZWRbbmtdID0gW2sgPj4gMTYgJiAweEZGLCBrID4+IDggJiAweEZGLCBrICYgMHhGRl07XG5cdH1cblx0cmV0dXJuIHVucGFja2VkO1xufVxubGV0IG5hbWVzJDE7XG5mdW5jdGlvbiBuYW1lUGFyc2Uoc3RyKSB7XG5cdGlmICghbmFtZXMkMSkge1xuXHRcdG5hbWVzJDEgPSB1bnBhY2soKTtcblx0XHRuYW1lcyQxLnRyYW5zcGFyZW50ID0gWzAsIDAsIDAsIDBdO1xuXHR9XG5cdGNvbnN0IGEgPSBuYW1lcyQxW3N0ci50b0xvd2VyQ2FzZSgpXTtcblx0cmV0dXJuIGEgJiYge1xuXHRcdHI6IGFbMF0sXG5cdFx0ZzogYVsxXSxcblx0XHRiOiBhWzJdLFxuXHRcdGE6IGEubGVuZ3RoID09PSA0ID8gYVszXSA6IDI1NVxuXHR9O1xufVxuZnVuY3Rpb24gbW9kSFNMKHYsIGksIHJhdGlvKSB7XG5cdGlmICh2KSB7XG5cdFx0bGV0IHRtcCA9IHJnYjJoc2wodik7XG5cdFx0dG1wW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odG1wW2ldICsgdG1wW2ldICogcmF0aW8sIGkgPT09IDAgPyAzNjAgOiAxKSk7XG5cdFx0dG1wID0gaHNsMnJnYih0bXApO1xuXHRcdHYuciA9IHRtcFswXTtcblx0XHR2LmcgPSB0bXBbMV07XG5cdFx0di5iID0gdG1wWzJdO1xuXHR9XG59XG5mdW5jdGlvbiBjbG9uZSh2LCBwcm90bykge1xuXHRyZXR1cm4gdiA/IE9iamVjdC5hc3NpZ24ocHJvdG8gfHwge30sIHYpIDogdjtcbn1cbmZ1bmN0aW9uIGZyb21PYmplY3QoaW5wdXQpIHtcblx0dmFyIHYgPSB7cjogMCwgZzogMCwgYjogMCwgYTogMjU1fTtcblx0aWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG5cdFx0aWYgKGlucHV0Lmxlbmd0aCA+PSAzKSB7XG5cdFx0XHR2ID0ge3I6IGlucHV0WzBdLCBnOiBpbnB1dFsxXSwgYjogaW5wdXRbMl0sIGE6IDI1NX07XG5cdFx0XHRpZiAoaW5wdXQubGVuZ3RoID4gMykge1xuXHRcdFx0XHR2LmEgPSBuMmIoaW5wdXRbM10pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR2ID0gY2xvbmUoaW5wdXQsIHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAxfSk7XG5cdFx0di5hID0gbjJiKHYuYSk7XG5cdH1cblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBmdW5jdGlvblBhcnNlKHN0cikge1xuXHRpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJ3InKSB7XG5cdFx0cmV0dXJuIHJnYlBhcnNlKHN0cik7XG5cdH1cblx0cmV0dXJuIGh1ZVBhcnNlKHN0cik7XG59XG5jbGFzcyBDb2xvciB7XG5cdGNvbnN0cnVjdG9yKGlucHV0KSB7XG5cdFx0aWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IpIHtcblx0XHRcdHJldHVybiBpbnB1dDtcblx0XHR9XG5cdFx0Y29uc3QgdHlwZSA9IHR5cGVvZiBpbnB1dDtcblx0XHRsZXQgdjtcblx0XHRpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHYgPSBmcm9tT2JqZWN0KGlucHV0KTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR2ID0gaGV4UGFyc2UoaW5wdXQpIHx8IG5hbWVQYXJzZShpbnB1dCkgfHwgZnVuY3Rpb25QYXJzZShpbnB1dCk7XG5cdFx0fVxuXHRcdHRoaXMuX3JnYiA9IHY7XG5cdFx0dGhpcy5fdmFsaWQgPSAhIXY7XG5cdH1cblx0Z2V0IHZhbGlkKCkge1xuXHRcdHJldHVybiB0aGlzLl92YWxpZDtcblx0fVxuXHRnZXQgcmdiKCkge1xuXHRcdHZhciB2ID0gY2xvbmUodGhpcy5fcmdiKTtcblx0XHRpZiAodikge1xuXHRcdFx0di5hID0gYjJuKHYuYSk7XG5cdFx0fVxuXHRcdHJldHVybiB2O1xuXHR9XG5cdHNldCByZ2Iob2JqKSB7XG5cdFx0dGhpcy5fcmdiID0gZnJvbU9iamVjdChvYmopO1xuXHR9XG5cdHJnYlN0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmFsaWQgPyByZ2JTdHJpbmcodGhpcy5fcmdiKSA6IHRoaXMuX3JnYjtcblx0fVxuXHRoZXhTdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbGlkID8gaGV4U3RyaW5nKHRoaXMuX3JnYikgOiB0aGlzLl9yZ2I7XG5cdH1cblx0aHNsU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLl92YWxpZCA/IGhzbFN0cmluZyh0aGlzLl9yZ2IpIDogdGhpcy5fcmdiO1xuXHR9XG5cdG1peChjb2xvciwgd2VpZ2h0KSB7XG5cdFx0Y29uc3QgbWUgPSB0aGlzO1xuXHRcdGlmIChjb2xvcikge1xuXHRcdFx0Y29uc3QgYzEgPSBtZS5yZ2I7XG5cdFx0XHRjb25zdCBjMiA9IGNvbG9yLnJnYjtcblx0XHRcdGxldCB3Mjtcblx0XHRcdGNvbnN0IHAgPSB3ZWlnaHQgPT09IHcyID8gMC41IDogd2VpZ2h0O1xuXHRcdFx0Y29uc3QgdyA9IDIgKiBwIC0gMTtcblx0XHRcdGNvbnN0IGEgPSBjMS5hIC0gYzIuYTtcblx0XHRcdGNvbnN0IHcxID0gKCh3ICogYSA9PT0gLTEgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMi4wO1xuXHRcdFx0dzIgPSAxIC0gdzE7XG5cdFx0XHRjMS5yID0gMHhGRiAmIHcxICogYzEuciArIHcyICogYzIuciArIDAuNTtcblx0XHRcdGMxLmcgPSAweEZGICYgdzEgKiBjMS5nICsgdzIgKiBjMi5nICsgMC41O1xuXHRcdFx0YzEuYiA9IDB4RkYgJiB3MSAqIGMxLmIgKyB3MiAqIGMyLmIgKyAwLjU7XG5cdFx0XHRjMS5hID0gcCAqIGMxLmEgKyAoMSAtIHApICogYzIuYTtcblx0XHRcdG1lLnJnYiA9IGMxO1xuXHRcdH1cblx0XHRyZXR1cm4gbWU7XG5cdH1cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcih0aGlzLnJnYik7XG5cdH1cblx0YWxwaGEoYSkge1xuXHRcdHRoaXMuX3JnYi5hID0gbjJiKGEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNsZWFyZXIocmF0aW8pIHtcblx0XHRjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG5cdFx0cmdiLmEgKj0gMSAtIHJhdGlvO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGdyZXlzY2FsZSgpIHtcblx0XHRjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG5cdFx0Y29uc3QgdmFsID0gcm91bmQocmdiLnIgKiAwLjMgKyByZ2IuZyAqIDAuNTkgKyByZ2IuYiAqIDAuMTEpO1xuXHRcdHJnYi5yID0gcmdiLmcgPSByZ2IuYiA9IHZhbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRvcGFxdWVyKHJhdGlvKSB7XG5cdFx0Y29uc3QgcmdiID0gdGhpcy5fcmdiO1xuXHRcdHJnYi5hICo9IDEgKyByYXRpbztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRuZWdhdGUoKSB7XG5cdFx0Y29uc3QgdiA9IHRoaXMuX3JnYjtcblx0XHR2LnIgPSAyNTUgLSB2LnI7XG5cdFx0di5nID0gMjU1IC0gdi5nO1xuXHRcdHYuYiA9IDI1NSAtIHYuYjtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRsaWdodGVuKHJhdGlvKSB7XG5cdFx0bW9kSFNMKHRoaXMuX3JnYiwgMiwgcmF0aW8pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGRhcmtlbihyYXRpbykge1xuXHRcdG1vZEhTTCh0aGlzLl9yZ2IsIDIsIC1yYXRpbyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0c2F0dXJhdGUocmF0aW8pIHtcblx0XHRtb2RIU0wodGhpcy5fcmdiLCAxLCByYXRpbyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZGVzYXR1cmF0ZShyYXRpbykge1xuXHRcdG1vZEhTTCh0aGlzLl9yZ2IsIDEsIC1yYXRpbyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0cm90YXRlKGRlZykge1xuXHRcdHJvdGF0ZSh0aGlzLl9yZ2IsIGRlZyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn1cbmZ1bmN0aW9uIGluZGV4X2VzbShpbnB1dCkge1xuXHRyZXR1cm4gbmV3IENvbG9yKGlucHV0KTtcbn1cblxuY29uc3QgaXNQYXR0ZXJuT3JHcmFkaWVudCA9ICh2YWx1ZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiBDYW52YXNHcmFkaWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIENhbnZhc1BhdHRlcm47XG5mdW5jdGlvbiBjb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkgPyB2YWx1ZSA6IGluZGV4X2VzbSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKVxuICAgID8gdmFsdWVcbiAgICA6IGluZGV4X2VzbSh2YWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5oZXhTdHJpbmcoKTtcbn1cblxuY29uc3Qgb3ZlcnJpZGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGdldFNjb3BlJDEobm9kZSwga2V5KSB7XG4gIGlmICgha2V5KSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgY29uc3Qga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICBmb3IgKGxldCBpID0gMCwgbiA9IGtleXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgY29uc3QgayA9IGtleXNbaV07XG4gICAgbm9kZSA9IG5vZGVba10gfHwgKG5vZGVba10gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHNldChyb290LCBzY29wZSwgdmFsdWVzKSB7XG4gIGlmICh0eXBlb2Ygc2NvcGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG1lcmdlKGdldFNjb3BlJDEocm9vdCwgc2NvcGUpLCB2YWx1ZXMpO1xuICB9XG4gIHJldHVybiBtZXJnZShnZXRTY29wZSQxKHJvb3QsICcnKSwgc2NvcGUpO1xufVxuY2xhc3MgRGVmYXVsdHMge1xuICBjb25zdHJ1Y3RvcihfZGVzY3JpcHRvcnMpIHtcbiAgICB0aGlzLmFuaW1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgIHRoaXMuYm9yZGVyQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICB0aGlzLmNvbG9yID0gJyM2NjYnO1xuICAgIHRoaXMuZGF0YXNldHMgPSB7fTtcbiAgICB0aGlzLmRldmljZVBpeGVsUmF0aW8gPSAoY29udGV4dCkgPT4gY29udGV4dC5jaGFydC5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgdGhpcy5lbGVtZW50cyA9IHt9O1xuICAgIHRoaXMuZXZlbnRzID0gW1xuICAgICAgJ21vdXNlbW92ZScsXG4gICAgICAnbW91c2VvdXQnLFxuICAgICAgJ2NsaWNrJyxcbiAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICd0b3VjaG1vdmUnXG4gICAgXTtcbiAgICB0aGlzLmZvbnQgPSB7XG4gICAgICBmYW1pbHk6IFwiJ0hlbHZldGljYSBOZXVlJywgJ0hlbHZldGljYScsICdBcmlhbCcsIHNhbnMtc2VyaWZcIixcbiAgICAgIHNpemU6IDEyLFxuICAgICAgc3R5bGU6ICdub3JtYWwnLFxuICAgICAgbGluZUhlaWdodDogMS4yLFxuICAgICAgd2VpZ2h0OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLmhvdmVyID0ge307XG4gICAgdGhpcy5ob3ZlckJhY2tncm91bmRDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgIHRoaXMuaG92ZXJCb3JkZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcik7XG4gICAgdGhpcy5ob3ZlckNvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmNvbG9yKTtcbiAgICB0aGlzLmluZGV4QXhpcyA9ICd4JztcbiAgICB0aGlzLmludGVyYWN0aW9uID0ge1xuICAgICAgbW9kZTogJ25lYXJlc3QnLFxuICAgICAgaW50ZXJzZWN0OiB0cnVlXG4gICAgfTtcbiAgICB0aGlzLm1haW50YWluQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIHRoaXMub25Ib3ZlciA9IG51bGw7XG4gICAgdGhpcy5vbkNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnBhcnNpbmcgPSB0cnVlO1xuICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2l2ZSA9IHRydWU7XG4gICAgdGhpcy5zY2FsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuc2hvd0xpbmUgPSB0cnVlO1xuICAgIHRoaXMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0cnVlO1xuICAgIHRoaXMuZGVzY3JpYmUoX2Rlc2NyaXB0b3JzKTtcbiAgfVxuICBzZXQoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQodGhpcywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cbiAgZ2V0KHNjb3BlKSB7XG4gICAgcmV0dXJuIGdldFNjb3BlJDEodGhpcywgc2NvcGUpO1xuICB9XG4gIGRlc2NyaWJlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KGRlc2NyaXB0b3JzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuICBvdmVycmlkZShzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldChvdmVycmlkZXMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG4gIHJvdXRlKHNjb3BlLCBuYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSkge1xuICAgIGNvbnN0IHNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUkMSh0aGlzLCBzY29wZSk7XG4gICAgY29uc3QgdGFyZ2V0U2NvcGVPYmplY3QgPSBnZXRTY29wZSQxKHRoaXMsIHRhcmdldFNjb3BlKTtcbiAgICBjb25zdCBwcml2YXRlTmFtZSA9ICdfJyArIG5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2NvcGVPYmplY3QsIHtcbiAgICAgIFtwcml2YXRlTmFtZV06IHtcbiAgICAgICAgdmFsdWU6IHNjb3BlT2JqZWN0W25hbWVdLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIFtuYW1lXToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3QgbG9jYWwgPSB0aGlzW3ByaXZhdGVOYW1lXTtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRTY29wZU9iamVjdFt0YXJnZXROYW1lXTtcbiAgICAgICAgICBpZiAoaXNPYmplY3QobG9jYWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LCBsb2NhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdChsb2NhbCwgdGFyZ2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdGhpc1twcml2YXRlTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG52YXIgZGVmYXVsdHMgPSBuZXcgRGVmYXVsdHMoe1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZXZlbnRzJyxcbiAgaG92ZXI6IHtcbiAgICBfZmFsbGJhY2s6ICdpbnRlcmFjdGlvbidcbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB0b0ZvbnRTdHJpbmcoZm9udCkge1xuICBpZiAoIWZvbnQgfHwgaXNOdWxsT3JVbmRlZihmb250LnNpemUpIHx8IGlzTnVsbE9yVW5kZWYoZm9udC5mYW1pbHkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIChmb250LnN0eWxlID8gZm9udC5zdHlsZSArICcgJyA6ICcnKVxuXHRcdCsgKGZvbnQud2VpZ2h0ID8gZm9udC53ZWlnaHQgKyAnICcgOiAnJylcblx0XHQrIGZvbnQuc2l6ZSArICdweCAnXG5cdFx0KyBmb250LmZhbWlseTtcbn1cbmZ1bmN0aW9uIF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBzdHJpbmcpIHtcbiAgbGV0IHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXTtcbiAgaWYgKCF0ZXh0V2lkdGgpIHtcbiAgICB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ10gPSBjdHgubWVhc3VyZVRleHQoc3RyaW5nKS53aWR0aDtcbiAgICBnYy5wdXNoKHN0cmluZyk7XG4gIH1cbiAgaWYgKHRleHRXaWR0aCA+IGxvbmdlc3QpIHtcbiAgICBsb25nZXN0ID0gdGV4dFdpZHRoO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuZnVuY3Rpb24gX2xvbmdlc3RUZXh0KGN0eCwgZm9udCwgYXJyYXlPZlRoaW5ncywgY2FjaGUpIHtcbiAgY2FjaGUgPSBjYWNoZSB8fCB7fTtcbiAgbGV0IGRhdGEgPSBjYWNoZS5kYXRhID0gY2FjaGUuZGF0YSB8fCB7fTtcbiAgbGV0IGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCB8fCBbXTtcbiAgaWYgKGNhY2hlLmZvbnQgIT09IGZvbnQpIHtcbiAgICBkYXRhID0gY2FjaGUuZGF0YSA9IHt9O1xuICAgIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcbiAgICBjYWNoZS5mb250ID0gZm9udDtcbiAgfVxuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IGZvbnQ7XG4gIGxldCBsb25nZXN0ID0gMDtcbiAgY29uc3QgaWxlbiA9IGFycmF5T2ZUaGluZ3MubGVuZ3RoO1xuICBsZXQgaSwgaiwgamxlbiwgdGhpbmcsIG5lc3RlZFRoaW5nO1xuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgdGhpbmcgPSBhcnJheU9mVGhpbmdzW2ldO1xuICAgIGlmICh0aGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaW5nICE9PSBudWxsICYmIGlzQXJyYXkodGhpbmcpICE9PSB0cnVlKSB7XG4gICAgICBsb25nZXN0ID0gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHRoaW5nKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpbmcpKSB7XG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gdGhpbmcubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgIG5lc3RlZFRoaW5nID0gdGhpbmdbal07XG4gICAgICAgIGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KG5lc3RlZFRoaW5nKSkge1xuICAgICAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGN0eC5yZXN0b3JlKCk7XG4gIGNvbnN0IGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcbiAgaWYgKGdjTGVuID4gYXJyYXlPZlRoaW5ncy5sZW5ndGgpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2NMZW47IGkrKykge1xuICAgICAgZGVsZXRlIGRhdGFbZ2NbaV1dO1xuICAgIH1cbiAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuZnVuY3Rpb24gX2FsaWduUGl4ZWwoY2hhcnQsIHBpeGVsLCB3aWR0aCkge1xuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XG4gIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoICE9PSAwID8gTWF0aC5tYXgod2lkdGggLyAyLCAwLjUpIDogMDtcbiAgcmV0dXJuIE1hdGgucm91bmQoKHBpeGVsIC0gaGFsZldpZHRoKSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIGhhbGZXaWR0aDtcbn1cbmZ1bmN0aW9uIGNsZWFyQ2FudmFzKGNhbnZhcywgY3R4KSB7XG4gIGN0eCA9IGN0eCB8fCBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGRyYXdQb2ludChjdHgsIG9wdGlvbnMsIHgsIHkpIHtcbiAgbGV0IHR5cGUsIHhPZmZzZXQsIHlPZmZzZXQsIHNpemUsIGNvcm5lclJhZGl1cztcbiAgY29uc3Qgc3R5bGUgPSBvcHRpb25zLnBvaW50U3R5bGU7XG4gIGNvbnN0IHJvdGF0aW9uID0gb3B0aW9ucy5yb3RhdGlvbjtcbiAgY29uc3QgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XG4gIGxldCByYWQgPSAocm90YXRpb24gfHwgMCkgKiBSQURfUEVSX0RFRztcbiAgaWYgKHN0eWxlICYmIHR5cGVvZiBzdHlsZSA9PT0gJ29iamVjdCcpIHtcbiAgICB0eXBlID0gc3R5bGUudG9TdHJpbmcoKTtcbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSFRNTEltYWdlRWxlbWVudF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XScpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4LnJvdGF0ZShyYWQpO1xuICAgICAgY3R4LmRyYXdJbWFnZShzdHlsZSwgLXN0eWxlLndpZHRoIC8gMiwgLXN0eWxlLmhlaWdodCAvIDIsIHN0eWxlLndpZHRoLCBzdHlsZS5oZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBzd2l0Y2ggKHN0eWxlKSB7XG4gIGRlZmF1bHQ6XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIFRBVSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICd0cmlhbmdsZSc6XG4gICAgY3R4Lm1vdmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xuICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICdyZWN0Um91bmRlZCc6XG4gICAgY29ybmVyUmFkaXVzID0gcmFkaXVzICogMC41MTY7XG4gICAgc2l6ZSA9IHJhZGl1cyAtIGNvcm5lclJhZGl1cztcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgY3R4LmFyYyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gUEksIHJhZCAtIEhBTEZfUEkpO1xuICAgIGN0eC5hcmMoeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIEhBTEZfUEksIHJhZCk7XG4gICAgY3R4LmFyYyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkLCByYWQgKyBIQUxGX1BJKTtcbiAgICBjdHguYXJjKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgKyBIQUxGX1BJLCByYWQgKyBQSSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICdyZWN0JzpcbiAgICBpZiAoIXJvdGF0aW9uKSB7XG4gICAgICBzaXplID0gTWF0aC5TUVJUMV8yICogcmFkaXVzO1xuICAgICAgY3R4LnJlY3QoeCAtIHNpemUsIHkgLSBzaXplLCAyICogc2l6ZSwgMiAqIHNpemUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICBjYXNlICdyZWN0Um90JzpcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICdjcm9zc1JvdCc6XG4gICAgcmFkICs9IFFVQVJURVJfUEk7XG4gIGNhc2UgJ2Nyb3NzJzpcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3N0YXInOlxuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2xpbmUnOlxuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2Rhc2gnOlxuICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5jb3MocmFkKSAqIHJhZGl1cywgeSArIE1hdGguc2luKHJhZCkgKiByYWRpdXMpO1xuICAgIGJyZWFrO1xuICB9XG4gIGN0eC5maWxsKCk7XG4gIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gX2lzUG9pbnRJbkFyZWEocG9pbnQsIGFyZWEsIG1hcmdpbikge1xuICBtYXJnaW4gPSBtYXJnaW4gfHwgMC41O1xuICByZXR1cm4gIWFyZWEgfHwgKHBvaW50ICYmIHBvaW50LnggPiBhcmVhLmxlZnQgLSBtYXJnaW4gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBtYXJnaW4gJiZcblx0XHRwb2ludC55ID4gYXJlYS50b3AgLSBtYXJnaW4gJiYgcG9pbnQueSA8IGFyZWEuYm90dG9tICsgbWFyZ2luKTtcbn1cbmZ1bmN0aW9uIGNsaXBBcmVhKGN0eCwgYXJlYSkge1xuICBjdHguc2F2ZSgpO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5yZWN0KGFyZWEubGVmdCwgYXJlYS50b3AsIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuICBjdHguY2xpcCgpO1xufVxuZnVuY3Rpb24gdW5jbGlwQXJlYShjdHgpIHtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIF9zdGVwcGVkTGluZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCwgbW9kZSkge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBpZiAobW9kZSA9PT0gJ21pZGRsZScpIHtcbiAgICBjb25zdCBtaWRwb2ludCA9IChwcmV2aW91cy54ICsgdGFyZ2V0LngpIC8gMi4wO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHByZXZpb3VzLnkpO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHRhcmdldC55KTtcbiAgfSBlbHNlIGlmIChtb2RlID09PSAnYWZ0ZXInICE9PSAhIWZsaXApIHtcbiAgICBjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVRvKHRhcmdldC54LCBwcmV2aW91cy55KTtcbiAgfVxuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5mdW5jdGlvbiBfYmV6aWVyQ3VydmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQsIGZsaXApIHtcbiAgaWYgKCFwcmV2aW91cykge1xuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gIH1cbiAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXggOiBwcmV2aW91cy5jcDJ4LFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF5IDogcHJldmlvdXMuY3AyeSxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnggOiB0YXJnZXQuY3AxeCxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnkgOiB0YXJnZXQuY3AxeSxcbiAgICB0YXJnZXQueCxcbiAgICB0YXJnZXQueSk7XG59XG5mdW5jdGlvbiByZW5kZXJUZXh0KGN0eCwgdGV4dCwgeCwgeSwgZm9udCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGxpbmVzID0gaXNBcnJheSh0ZXh0KSA/IHRleHQgOiBbdGV4dF07XG4gIGNvbnN0IHN0cm9rZSA9IG9wdHMuc3Ryb2tlV2lkdGggPiAwICYmIG9wdHMuc3Ryb2tlQ29sb3IgIT09ICcnO1xuICBsZXQgaSwgbGluZTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcbiAgc2V0UmVuZGVyT3B0cyhjdHgsIG9wdHMpO1xuICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgaWYgKG9wdHMuc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0cy5zdHJva2VDb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnN0cm9rZVdpZHRoKSkge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aDtcbiAgICAgIH1cbiAgICAgIGN0eC5zdHJva2VUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgIH1cbiAgICBjdHguZmlsbFRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgZGVjb3JhdGVUZXh0KGN0eCwgeCwgeSwgbGluZSwgb3B0cyk7XG4gICAgeSArPSBmb250LmxpbmVIZWlnaHQ7XG4gIH1cbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIHNldFJlbmRlck9wdHMoY3R4LCBvcHRzKSB7XG4gIGlmIChvcHRzLnRyYW5zbGF0aW9uKSB7XG4gICAgY3R4LnRyYW5zbGF0ZShvcHRzLnRyYW5zbGF0aW9uWzBdLCBvcHRzLnRyYW5zbGF0aW9uWzFdKTtcbiAgfVxuICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5yb3RhdGlvbikpIHtcbiAgICBjdHgucm90YXRlKG9wdHMucm90YXRpb24pO1xuICB9XG4gIGlmIChvcHRzLmNvbG9yKSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdHMuY29sb3I7XG4gIH1cbiAgaWYgKG9wdHMudGV4dEFsaWduKSB7XG4gICAgY3R4LnRleHRBbGlnbiA9IG9wdHMudGV4dEFsaWduO1xuICB9XG4gIGlmIChvcHRzLnRleHRCYXNlbGluZSkge1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvcHRzLnRleHRCYXNlbGluZTtcbiAgfVxufVxuZnVuY3Rpb24gZGVjb3JhdGVUZXh0KGN0eCwgeCwgeSwgbGluZSwgb3B0cykge1xuICBpZiAob3B0cy5zdHJpa2V0aHJvdWdoIHx8IG9wdHMudW5kZXJsaW5lKSB7XG4gICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChsaW5lKTtcbiAgICBjb25zdCBsZWZ0ID0geCAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hMZWZ0O1xuICAgIGNvbnN0IHJpZ2h0ID0geCArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodDtcbiAgICBjb25zdCB0b3AgPSB5IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcbiAgICBjb25zdCBib3R0b20gPSB5ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ7XG4gICAgY29uc3QgeURlY29yYXRpb24gPSBvcHRzLnN0cmlrZXRocm91Z2ggPyAodG9wICsgYm90dG9tKSAvIDIgOiBib3R0b207XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuZGVjb3JhdGlvbldpZHRoIHx8IDI7XG4gICAgY3R4Lm1vdmVUbyhsZWZ0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LmxpbmVUbyhyaWdodCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwgcmVjdCkge1xuICBjb25zdCB7eCwgeSwgdywgaCwgcmFkaXVzfSA9IHJlY3Q7XG4gIGN0eC5hcmMoeCArIHJhZGl1cy50b3BMZWZ0LCB5ICsgcmFkaXVzLnRvcExlZnQsIHJhZGl1cy50b3BMZWZ0LCAtSEFMRl9QSSwgUEksIHRydWUpO1xuICBjdHgubGluZVRvKHgsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQpO1xuICBjdHguYXJjKHggKyByYWRpdXMuYm90dG9tTGVmdCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCwgcmFkaXVzLmJvdHRvbUxlZnQsIFBJLCBIQUxGX1BJLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4ICsgdyAtIHJhZGl1cy5ib3R0b21SaWdodCwgeSArIGgpO1xuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21SaWdodCwgcmFkaXVzLmJvdHRvbVJpZ2h0LCBIQUxGX1BJLCAwLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4ICsgdywgeSArIHJhZGl1cy50b3BSaWdodCk7XG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMudG9wUmlnaHQsIHkgKyByYWRpdXMudG9wUmlnaHQsIHJhZGl1cy50b3BSaWdodCwgMCwgLUhBTEZfUEksIHRydWUpO1xuICBjdHgubGluZVRvKHggKyByYWRpdXMudG9wTGVmdCwgeSk7XG59XG5cbmNvbnN0IExJTkVfSEVJR0hUID0gbmV3IFJlZ0V4cCgvXihub3JtYWx8KFxcZCsoPzpcXC5cXGQrKT8pKHB4fGVtfCUpPykkLyk7XG5jb25zdCBGT05UX1NUWUxFID0gbmV3IFJlZ0V4cCgvXihub3JtYWx8aXRhbGljfGluaXRpYWx8aW5oZXJpdHx1bnNldHwob2JsaXF1ZSggLT9bMC05XT9bMC05XWRlZyk/KSkkLyk7XG5mdW5jdGlvbiB0b0xpbmVIZWlnaHQodmFsdWUsIHNpemUpIHtcbiAgY29uc3QgbWF0Y2hlcyA9ICgnJyArIHZhbHVlKS5tYXRjaChMSU5FX0hFSUdIVCk7XG4gIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzWzFdID09PSAnbm9ybWFsJykge1xuICAgIHJldHVybiBzaXplICogMS4yO1xuICB9XG4gIHZhbHVlID0gK21hdGNoZXNbMl07XG4gIHN3aXRjaCAobWF0Y2hlc1szXSkge1xuICBjYXNlICdweCc6XG4gICAgcmV0dXJuIHZhbHVlO1xuICBjYXNlICclJzpcbiAgICB2YWx1ZSAvPSAxMDA7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHNpemUgKiB2YWx1ZTtcbn1cbmNvbnN0IG51bWJlck9yWmVybyA9IHYgPT4gK3YgfHwgMDtcbmZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBwcm9wcykge1xuICBjb25zdCByZXQgPSB7fTtcbiAgY29uc3Qgb2JqUHJvcHMgPSBpc09iamVjdChwcm9wcyk7XG4gIGNvbnN0IGtleXMgPSBvYmpQcm9wcyA/IE9iamVjdC5rZXlzKHByb3BzKSA6IHByb3BzO1xuICBjb25zdCByZWFkID0gaXNPYmplY3QodmFsdWUpXG4gICAgPyBvYmpQcm9wc1xuICAgICAgPyBwcm9wID0+IHZhbHVlT3JEZWZhdWx0KHZhbHVlW3Byb3BdLCB2YWx1ZVtwcm9wc1twcm9wXV0pXG4gICAgICA6IHByb3AgPT4gdmFsdWVbcHJvcF1cbiAgICA6ICgpID0+IHZhbHVlO1xuICBmb3IgKGNvbnN0IHByb3Agb2Yga2V5cykge1xuICAgIHJldFtwcm9wXSA9IG51bWJlck9yWmVybyhyZWFkKHByb3ApKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gdG9UUkJMKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwge3RvcDogJ3knLCByaWdodDogJ3gnLCBib3R0b206ICd5JywgbGVmdDogJ3gnfSk7XG59XG5mdW5jdGlvbiB0b1RSQkxDb3JuZXJzKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWyd0b3BMZWZ0JywgJ3RvcFJpZ2h0JywgJ2JvdHRvbUxlZnQnLCAnYm90dG9tUmlnaHQnXSk7XG59XG5mdW5jdGlvbiB0b1BhZGRpbmcodmFsdWUpIHtcbiAgY29uc3Qgb2JqID0gdG9UUkJMKHZhbHVlKTtcbiAgb2JqLndpZHRoID0gb2JqLmxlZnQgKyBvYmoucmlnaHQ7XG4gIG9iai5oZWlnaHQgPSBvYmoudG9wICsgb2JqLmJvdHRvbTtcbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIHRvRm9udChvcHRpb25zLCBmYWxsYmFjaykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZmFsbGJhY2sgPSBmYWxsYmFjayB8fCBkZWZhdWx0cy5mb250O1xuICBsZXQgc2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc2l6ZSwgZmFsbGJhY2suc2l6ZSk7XG4gIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzaXplID0gcGFyc2VJbnQoc2l6ZSwgMTApO1xuICB9XG4gIGxldCBzdHlsZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc3R5bGUsIGZhbGxiYWNrLnN0eWxlKTtcbiAgaWYgKHN0eWxlICYmICEoJycgKyBzdHlsZSkubWF0Y2goRk9OVF9TVFlMRSkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgZm9udCBzdHlsZSBzcGVjaWZpZWQ6IFwiJyArIHN0eWxlICsgJ1wiJyk7XG4gICAgc3R5bGUgPSAnJztcbiAgfVxuICBjb25zdCBmb250ID0ge1xuICAgIGZhbWlseTogdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mYW1pbHksIGZhbGxiYWNrLmZhbWlseSksXG4gICAgbGluZUhlaWdodDogdG9MaW5lSGVpZ2h0KHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubGluZUhlaWdodCwgZmFsbGJhY2subGluZUhlaWdodCksIHNpemUpLFxuICAgIHNpemUsXG4gICAgc3R5bGUsXG4gICAgd2VpZ2h0OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLndlaWdodCwgZmFsbGJhY2sud2VpZ2h0KSxcbiAgICBzdHJpbmc6ICcnXG4gIH07XG4gIGZvbnQuc3RyaW5nID0gdG9Gb250U3RyaW5nKGZvbnQpO1xuICByZXR1cm4gZm9udDtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoaW5wdXRzLCBjb250ZXh0LCBpbmRleCwgaW5mbykge1xuICBsZXQgY2FjaGVhYmxlID0gdHJ1ZTtcbiAgbGV0IGksIGlsZW4sIHZhbHVlO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gaW5wdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHZhbHVlID0gaW5wdXRzW2ldO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoY29udGV4dCk7XG4gICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVbaW5kZXggJSB2YWx1ZS5sZW5ndGhdO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5mbyAmJiAhY2FjaGVhYmxlKSB7XG4gICAgICAgIGluZm8uY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfYWRkR3JhY2UobWlubWF4LCBncmFjZSwgYmVnaW5BdFplcm8pIHtcbiAgY29uc3Qge21pbiwgbWF4fSA9IG1pbm1heDtcbiAgY29uc3QgY2hhbmdlID0gdG9EaW1lbnNpb24oZ3JhY2UsIChtYXggLSBtaW4pIC8gMik7XG4gIGNvbnN0IGtlZXBaZXJvID0gKHZhbHVlLCBhZGQpID0+IGJlZ2luQXRaZXJvICYmIHZhbHVlID09PSAwID8gMCA6IHZhbHVlICsgYWRkO1xuICByZXR1cm4ge1xuICAgIG1pbjoga2VlcFplcm8obWluLCAtTWF0aC5hYnMoY2hhbmdlKSksXG4gICAgbWF4OiBrZWVwWmVybyhtYXgsIGNoYW5nZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQocGFyZW50Q29udGV4dCwgY29udGV4dCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHBhcmVudENvbnRleHQpLCBjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGNtcCkge1xuICBjbXAgPSBjbXAgfHwgKChpbmRleCkgPT4gdGFibGVbaW5kZXhdIDwgdmFsdWUpO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgbG8gPSAwO1xuICBsZXQgbWlkO1xuICB3aGlsZSAoaGkgLSBsbyA+IDEpIHtcbiAgICBtaWQgPSAobG8gKyBoaSkgPj4gMTtcbiAgICBpZiAoY21wKG1pZCkpIHtcbiAgICAgIGxvID0gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaSA9IG1pZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtsbywgaGl9O1xufVxuY29uc3QgX2xvb2t1cEJ5S2V5ID0gKHRhYmxlLCBrZXksIHZhbHVlKSA9PlxuICBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPCB2YWx1ZSk7XG5jb25zdCBfcmxvb2t1cEJ5S2V5ID0gKHRhYmxlLCBrZXksIHZhbHVlKSA9PlxuICBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPj0gdmFsdWUpO1xuZnVuY3Rpb24gX2ZpbHRlckJldHdlZW4odmFsdWVzLCBtaW4sIG1heCkge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gdmFsdWVzLmxlbmd0aDtcbiAgd2hpbGUgKHN0YXJ0IDwgZW5kICYmIHZhbHVlc1tzdGFydF0gPCBtaW4pIHtcbiAgICBzdGFydCsrO1xuICB9XG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiB2YWx1ZXNbZW5kIC0gMV0gPiBtYXgpIHtcbiAgICBlbmQtLTtcbiAgfVxuICByZXR1cm4gc3RhcnQgPiAwIHx8IGVuZCA8IHZhbHVlcy5sZW5ndGhcbiAgICA/IHZhbHVlcy5zbGljZShzdGFydCwgZW5kKVxuICAgIDogdmFsdWVzO1xufVxuY29uc3QgYXJyYXlFdmVudHMgPSBbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsICd1bnNoaWZ0J107XG5mdW5jdGlvbiBsaXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgaWYgKGFycmF5Ll9jaGFydGpzKSB7XG4gICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybjtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksICdfY2hhcnRqcycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IHtcbiAgICAgIGxpc3RlbmVyczogW2xpc3RlbmVyXVxuICAgIH1cbiAgfSk7XG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdfb25EYXRhJyArIF9jYXBpdGFsaXplKGtleSk7XG4gICAgY29uc3QgYmFzZSA9IGFycmF5W2tleV07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWUoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXMgPSBiYXNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMuZm9yRWFjaCgob2JqZWN0KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3RbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb2JqZWN0W21ldGhvZF0oLi4uYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1bmxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICBjb25zdCBzdHViID0gYXJyYXkuX2NoYXJ0anM7XG4gIGlmICghc3R1Yikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcbiAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXJyYXlFdmVudHMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgZGVsZXRlIGFycmF5W2tleV07XG4gIH0pO1xuICBkZWxldGUgYXJyYXkuX2NoYXJ0anM7XG59XG5mdW5jdGlvbiBfYXJyYXlVbmlxdWUoaXRlbXMpIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHNldC5hZGQoaXRlbXNbaV0pO1xuICB9XG4gIGlmIChzZXQuc2l6ZSA9PT0gaWxlbikge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBwcmVmaXhlcyA9IFsnJ10sIHJvb3RTY29wZXMgPSBzY29wZXMsIGZhbGxiYWNrLCBnZXRUYXJnZXQgPSAoKSA9PiBzY29wZXNbMF0pIHtcbiAgaWYgKCFkZWZpbmVkKGZhbGxiYWNrKSkge1xuICAgIGZhbGxiYWNrID0gX3Jlc29sdmUoJ19mYWxsYmFjaycsIHNjb3Blcyk7XG4gIH1cbiAgY29uc3QgY2FjaGUgPSB7XG4gICAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdPYmplY3QnLFxuICAgIF9jYWNoZWFibGU6IHRydWUsXG4gICAgX3Njb3Blczogc2NvcGVzLFxuICAgIF9yb290U2NvcGVzOiByb290U2NvcGVzLFxuICAgIF9mYWxsYmFjazogZmFsbGJhY2ssXG4gICAgX2dldFRhcmdldDogZ2V0VGFyZ2V0LFxuICAgIG92ZXJyaWRlOiAoc2NvcGUpID0+IF9jcmVhdGVSZXNvbHZlcihbc2NvcGUsIC4uLnNjb3Blc10sIHByZWZpeGVzLCByb290U2NvcGVzLCBmYWxsYmFjayksXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoY2FjaGUsIHtcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07XG4gICAgICBkZWxldGUgdGFyZ2V0Ll9rZXlzO1xuICAgICAgZGVsZXRlIHNjb3Blc1swXVtwcm9wXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCB0YXJnZXQpKTtcbiAgICB9LFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuX3Njb3Blc1swXSwgcHJvcCk7XG4gICAgfSxcbiAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHNjb3Blc1swXSk7XG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KS5pbmNsdWRlcyhwcm9wKTtcbiAgICB9LFxuICAgIG93bktleXModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KTtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBjb25zdCBzdG9yYWdlID0gdGFyZ2V0Ll9zdG9yYWdlIHx8ICh0YXJnZXQuX3N0b3JhZ2UgPSBnZXRUYXJnZXQoKSk7XG4gICAgICB0YXJnZXRbcHJvcF0gPSBzdG9yYWdlW3Byb3BdID0gdmFsdWU7XG4gICAgICBkZWxldGUgdGFyZ2V0Ll9rZXlzO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIF9hdHRhY2hDb250ZXh0KHByb3h5LCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSB7XG4gIGNvbnN0IGNhY2hlID0ge1xuICAgIF9jYWNoZWFibGU6IGZhbHNlLFxuICAgIF9wcm94eTogcHJveHksXG4gICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgX3N1YlByb3h5OiBzdWJQcm94eSxcbiAgICBfc3RhY2s6IG5ldyBTZXQoKSxcbiAgICBfZGVzY3JpcHRvcnM6IF9kZXNjcmlwdG9ycyhwcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBzZXRDb250ZXh0OiAoY3R4KSA9PiBfYXR0YWNoQ29udGV4dChwcm94eSwgY3R4LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBvdmVycmlkZTogKHNjb3BlKSA9PiBfYXR0YWNoQ29udGV4dChwcm94eS5vdmVycmlkZShzY29wZSksIGNvbnRleHQsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoY2FjaGUsIHtcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07XG4gICAgICBkZWxldGUgcHJveHlbcHJvcF07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXG4gICAgICAgICgpID0+IF9yZXNvbHZlV2l0aENvbnRleHQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikpO1xuICAgIH0sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIHRhcmdldC5fZGVzY3JpcHRvcnMuYWxsS2V5c1xuICAgICAgICA/IFJlZmxlY3QuaGFzKHByb3h5LCBwcm9wKSA/IHtlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9IDogdW5kZWZpbmVkXG4gICAgICAgIDogUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJveHksIHByb3ApO1xuICAgIH0sXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihwcm94eSk7XG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXMocHJveHksIHByb3ApO1xuICAgIH0sXG4gICAgb3duS2V5cygpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMocHJveHkpO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIHByb3h5W3Byb3BdID0gdmFsdWU7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIF9kZXNjcmlwdG9ycyhwcm94eSwgZGVmYXVsdHMgPSB7c2NyaXB0YWJsZTogdHJ1ZSwgaW5kZXhhYmxlOiB0cnVlfSkge1xuICBjb25zdCB7X3NjcmlwdGFibGUgPSBkZWZhdWx0cy5zY3JpcHRhYmxlLCBfaW5kZXhhYmxlID0gZGVmYXVsdHMuaW5kZXhhYmxlLCBfYWxsS2V5cyA9IGRlZmF1bHRzLmFsbEtleXN9ID0gcHJveHk7XG4gIHJldHVybiB7XG4gICAgYWxsS2V5czogX2FsbEtleXMsXG4gICAgc2NyaXB0YWJsZTogX3NjcmlwdGFibGUsXG4gICAgaW5kZXhhYmxlOiBfaW5kZXhhYmxlLFxuICAgIGlzU2NyaXB0YWJsZTogaXNGdW5jdGlvbihfc2NyaXB0YWJsZSkgPyBfc2NyaXB0YWJsZSA6ICgpID0+IF9zY3JpcHRhYmxlLFxuICAgIGlzSW5kZXhhYmxlOiBpc0Z1bmN0aW9uKF9pbmRleGFibGUpID8gX2luZGV4YWJsZSA6ICgpID0+IF9pbmRleGFibGVcbiAgfTtcbn1cbmNvbnN0IHJlYWRLZXkgPSAocHJlZml4LCBuYW1lKSA9PiBwcmVmaXggPyBwcmVmaXggKyBfY2FwaXRhbGl6ZShuYW1lKSA6IG5hbWU7XG5jb25zdCBuZWVkc1N1YlJlc29sdmVyID0gKHByb3AsIHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgcHJvcCAhPT0gJ2FkYXB0ZXJzJyAmJlxuICAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCB8fCB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcbmZ1bmN0aW9uIF9jYWNoZWQodGFyZ2V0LCBwcm9wLCByZXNvbHZlKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBwcm9wKSkge1xuICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gIH1cbiAgY29uc3QgdmFsdWUgPSByZXNvbHZlKCk7XG4gIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhDb250ZXh0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX2Rlc2NyaXB0b3JzOiBkZXNjcmlwdG9yc30gPSB0YXJnZXQ7XG4gIGxldCB2YWx1ZSA9IF9wcm94eVtwcm9wXTtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpICYmIGRlc2NyaXB0b3JzLmlzU2NyaXB0YWJsZShwcm9wKSkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVTY3JpcHRhYmxlKHByb3AsIHZhbHVlLCB0YXJnZXQsIHJlY2VpdmVyKTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZUFycmF5KHByb3AsIHZhbHVlLCB0YXJnZXQsIGRlc2NyaXB0b3JzLmlzSW5kZXhhYmxlKTtcbiAgfVxuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IF9hdHRhY2hDb250ZXh0KHZhbHVlLCBfY29udGV4dCwgX3N1YlByb3h5ICYmIF9zdWJQcm94eVtwcm9wXSwgZGVzY3JpcHRvcnMpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfc3RhY2t9ID0gdGFyZ2V0O1xuICBpZiAoX3N0YWNrLmhhcyhwcm9wKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVjdXJzaW9uIGRldGVjdGVkOiAnICsgQXJyYXkuZnJvbShfc3RhY2spLmpvaW4oJy0+JykgKyAnLT4nICsgcHJvcCk7XG4gIH1cbiAgX3N0YWNrLmFkZChwcm9wKTtcbiAgdmFsdWUgPSB2YWx1ZShfY29udGV4dCwgX3N1YlByb3h5IHx8IHJlY2VpdmVyKTtcbiAgX3N0YWNrLmRlbGV0ZShwcm9wKTtcbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgdmFsdWUgPSBjcmVhdGVTdWJSZXNvbHZlcihfcHJveHkuX3Njb3BlcywgX3Byb3h5LCBwcm9wLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBpc0luZGV4YWJsZSkge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcbiAgaWYgKGRlZmluZWQoX2NvbnRleHQuaW5kZXgpICYmIGlzSW5kZXhhYmxlKHByb3ApKSB7XG4gICAgdmFsdWUgPSB2YWx1ZVtfY29udGV4dC5pbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWVbMF0pKSB7XG4gICAgY29uc3QgYXJyID0gdmFsdWU7XG4gICAgY29uc3Qgc2NvcGVzID0gX3Byb3h5Ll9zY29wZXMuZmlsdGVyKHMgPT4gcyAhPT0gYXJyKTtcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBfcHJveHksIHByb3AsIGl0ZW0pO1xuICAgICAgdmFsdWUucHVzaChfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVGYWxsYmFjayhmYWxsYmFjaywgcHJvcCwgdmFsdWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oZmFsbGJhY2spID8gZmFsbGJhY2socHJvcCwgdmFsdWUpIDogZmFsbGJhY2s7XG59XG5jb25zdCBnZXRTY29wZSA9IChrZXksIHBhcmVudCkgPT4ga2V5ID09PSB0cnVlID8gcGFyZW50XG4gIDogdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgPyByZXNvbHZlT2JqZWN0S2V5KHBhcmVudCwga2V5KSA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGFkZFNjb3BlcyhzZXQsIHBhcmVudFNjb3Blcywga2V5LCBwYXJlbnRGYWxsYmFjaywgdmFsdWUpIHtcbiAgZm9yIChjb25zdCBwYXJlbnQgb2YgcGFyZW50U2NvcGVzKSB7XG4gICAgY29uc3Qgc2NvcGUgPSBnZXRTY29wZShrZXksIHBhcmVudCk7XG4gICAgaWYgKHNjb3BlKSB7XG4gICAgICBzZXQuYWRkKHNjb3BlKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHNjb3BlLl9mYWxsYmFjaywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoZGVmaW5lZChmYWxsYmFjaykgJiYgZmFsbGJhY2sgIT09IGtleSAmJiBmYWxsYmFjayAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2NvcGUgPT09IGZhbHNlICYmIGRlZmluZWQocGFyZW50RmFsbGJhY2spICYmIGtleSAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVTdWJSZXNvbHZlcihwYXJlbnRTY29wZXMsIHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkge1xuICBjb25zdCByb290U2NvcGVzID0gcmVzb2x2ZXIuX3Jvb3RTY29wZXM7XG4gIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHJlc29sdmVyLl9mYWxsYmFjaywgcHJvcCwgdmFsdWUpO1xuICBjb25zdCBhbGxTY29wZXMgPSBbLi4ucGFyZW50U2NvcGVzLCAuLi5yb290U2NvcGVzXTtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBzZXQuYWRkKHZhbHVlKTtcbiAgbGV0IGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIHByb3AsIGZhbGxiYWNrIHx8IHByb3AsIHZhbHVlKTtcbiAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGVmaW5lZChmYWxsYmFjaykgJiYgZmFsbGJhY2sgIT09IHByb3ApIHtcbiAgICBrZXkgPSBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBmYWxsYmFjaywga2V5LCB2YWx1ZSk7XG4gICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2NyZWF0ZVJlc29sdmVyKEFycmF5LmZyb20oc2V0KSwgWycnXSwgcm9vdFNjb3BlcywgZmFsbGJhY2ssXG4gICAgKCkgPT4gc3ViR2V0VGFyZ2V0KHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkpO1xufVxuZnVuY3Rpb24gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3Blcywga2V5LCBmYWxsYmFjaywgaXRlbSkge1xuICB3aGlsZSAoa2V5KSB7XG4gICAga2V5ID0gYWRkU2NvcGVzKHNldCwgYWxsU2NvcGVzLCBrZXksIGZhbGxiYWNrLCBpdGVtKTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gc3ViR2V0VGFyZ2V0KHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkge1xuICBjb25zdCBwYXJlbnQgPSByZXNvbHZlci5fZ2V0VGFyZ2V0KCk7XG4gIGlmICghKHByb3AgaW4gcGFyZW50KSkge1xuICAgIHBhcmVudFtwcm9wXSA9IHt9O1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IHBhcmVudFtwcm9wXTtcbiAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aFByZWZpeGVzKHByb3AsIHByZWZpeGVzLCBzY29wZXMsIHByb3h5KSB7XG4gIGxldCB2YWx1ZTtcbiAgZm9yIChjb25zdCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlKHJlYWRLZXkocHJlZml4LCBwcm9wKSwgc2NvcGVzKTtcbiAgICBpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKVxuICAgICAgICA/IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgcHJveHksIHByb3AsIHZhbHVlKVxuICAgICAgICA6IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX3Jlc29sdmUoa2V5LCBzY29wZXMpIHtcbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICBpZiAoIXNjb3BlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBzY29wZVtrZXldO1xuICAgIGlmIChkZWZpbmVkKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KSB7XG4gIGxldCBrZXlzID0gdGFyZ2V0Ll9rZXlzO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gdGFyZ2V0Ll9rZXlzID0gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHRhcmdldC5fc2NvcGVzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIHJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyhzY29wZXMpIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjb3BlKS5maWx0ZXIoayA9PiAhay5zdGFydHNXaXRoKCdfJykpKSB7XG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG5cbmNvbnN0IEVQU0lMT04gPSBOdW1iZXIuRVBTSUxPTiB8fCAxZS0xNDtcbmNvbnN0IGdldFBvaW50ID0gKHBvaW50cywgaSkgPT4gaSA8IHBvaW50cy5sZW5ndGggJiYgIXBvaW50c1tpXS5za2lwICYmIHBvaW50c1tpXTtcbmNvbnN0IGdldFZhbHVlQXhpcyA9IChpbmRleEF4aXMpID0+IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuZnVuY3Rpb24gc3BsaW5lQ3VydmUoZmlyc3RQb2ludCwgbWlkZGxlUG9pbnQsIGFmdGVyUG9pbnQsIHQpIHtcbiAgY29uc3QgcHJldmlvdXMgPSBmaXJzdFBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGZpcnN0UG9pbnQ7XG4gIGNvbnN0IGN1cnJlbnQgPSBtaWRkbGVQb2ludDtcbiAgY29uc3QgbmV4dCA9IGFmdGVyUG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogYWZ0ZXJQb2ludDtcbiAgY29uc3QgZDAxID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGN1cnJlbnQsIHByZXZpb3VzKTtcbiAgY29uc3QgZDEyID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKG5leHQsIGN1cnJlbnQpO1xuICBsZXQgczAxID0gZDAxIC8gKGQwMSArIGQxMik7XG4gIGxldCBzMTIgPSBkMTIgLyAoZDAxICsgZDEyKTtcbiAgczAxID0gaXNOYU4oczAxKSA/IDAgOiBzMDE7XG4gIHMxMiA9IGlzTmFOKHMxMikgPyAwIDogczEyO1xuICBjb25zdCBmYSA9IHQgKiBzMDE7XG4gIGNvbnN0IGZiID0gdCAqIHMxMjtcbiAgcmV0dXJuIHtcbiAgICBwcmV2aW91czoge1xuICAgICAgeDogY3VycmVudC54IC0gZmEgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG4gICAgICB5OiBjdXJyZW50LnkgLSBmYSAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuICAgIH0sXG4gICAgbmV4dDoge1xuICAgICAgeDogY3VycmVudC54ICsgZmIgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG4gICAgICB5OiBjdXJyZW50LnkgKyBmYiAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSykge1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgYWxwaGFLLCBiZXRhSywgdGF1Sywgc3F1YXJlZE1hZ25pdHVkZSwgcG9pbnRDdXJyZW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuIC0gMTsgKytpKSB7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQgfHwgIXBvaW50QWZ0ZXIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxtb3N0RXF1YWxzKGRlbHRhS1tpXSwgMCwgRVBTSUxPTikpIHtcbiAgICAgIG1LW2ldID0gbUtbaSArIDFdID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBhbHBoYUsgPSBtS1tpXSAvIGRlbHRhS1tpXTtcbiAgICBiZXRhSyA9IG1LW2kgKyAxXSAvIGRlbHRhS1tpXTtcbiAgICBzcXVhcmVkTWFnbml0dWRlID0gTWF0aC5wb3coYWxwaGFLLCAyKSArIE1hdGgucG93KGJldGFLLCAyKTtcbiAgICBpZiAoc3F1YXJlZE1hZ25pdHVkZSA8PSA5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGF1SyA9IDMgLyBNYXRoLnNxcnQoc3F1YXJlZE1hZ25pdHVkZSk7XG4gICAgbUtbaV0gPSBhbHBoYUsgKiB0YXVLICogZGVsdGFLW2ldO1xuICAgIG1LW2kgKyAxXSA9IGJldGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgfVxufVxuZnVuY3Rpb24gbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGRlbHRhLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGlQaXhlbCA9IHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuICAgIGNvbnN0IHZQaXhlbCA9IHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdO1xuICAgIGlmIChwb2ludEJlZm9yZSkge1xuICAgICAgZGVsdGEgPSAoaVBpeGVsIC0gcG9pbnRCZWZvcmVbaW5kZXhBeGlzXSkgLyAzO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke2luZGV4QXhpc31gXSA9IGlQaXhlbCAtIGRlbHRhO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCAtIGRlbHRhICogbUtbaV07XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBkZWx0YSA9IChwb2ludEFmdGVyW2luZGV4QXhpc10gLSBpUGl4ZWwpIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgKyBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgKyBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMsIGluZGV4QXhpcyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgZGVsdGFLID0gQXJyYXkocG9pbnRzTGVuKS5maWxsKDApO1xuICBjb25zdCBtSyA9IEFycmF5KHBvaW50c0xlbik7XG4gIGxldCBpLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG4gIGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHBvaW50QWZ0ZXIpIHtcbiAgICAgIGNvbnN0IHNsb3BlRGVsdGEgPSBwb2ludEFmdGVyW2luZGV4QXhpc10gLSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcbiAgICAgIGRlbHRhS1tpXSA9IHNsb3BlRGVsdGEgIT09IDAgPyAocG9pbnRBZnRlclt2YWx1ZUF4aXNdIC0gcG9pbnRDdXJyZW50W3ZhbHVlQXhpc10pIC8gc2xvcGVEZWx0YSA6IDA7XG4gICAgfVxuICAgIG1LW2ldID0gIXBvaW50QmVmb3JlID8gZGVsdGFLW2ldXG4gICAgICA6ICFwb2ludEFmdGVyID8gZGVsdGFLW2kgLSAxXVxuICAgICAgOiAoc2lnbihkZWx0YUtbaSAtIDFdKSAhPT0gc2lnbihkZWx0YUtbaV0pKSA/IDBcbiAgICAgIDogKGRlbHRhS1tpIC0gMV0gKyBkZWx0YUtbaV0pIC8gMjtcbiAgfVxuICBtb25vdG9uZUFkanVzdChwb2ludHMsIGRlbHRhSywgbUspO1xuICBtb25vdG9uZUNvbXB1dGUocG9pbnRzLCBtSywgaW5kZXhBeGlzKTtcbn1cbmZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xufVxuZnVuY3Rpb24gY2FwQmV6aWVyUG9pbnRzKHBvaW50cywgYXJlYSkge1xuICBsZXQgaSwgaWxlbiwgcG9pbnQsIGluQXJlYSwgaW5BcmVhUHJldjtcbiAgbGV0IGluQXJlYU5leHQgPSBfaXNQb2ludEluQXJlYShwb2ludHNbMF0sIGFyZWEpO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGluQXJlYVByZXYgPSBpbkFyZWE7XG4gICAgaW5BcmVhID0gaW5BcmVhTmV4dDtcbiAgICBpbkFyZWFOZXh0ID0gaSA8IGlsZW4gLSAxICYmIF9pc1BvaW50SW5BcmVhKHBvaW50c1tpICsgMV0sIGFyZWEpO1xuICAgIGlmICghaW5BcmVhKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgaWYgKGluQXJlYVByZXYpIHtcbiAgICAgIHBvaW50LmNwMXggPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AxeCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcbiAgICAgIHBvaW50LmNwMXkgPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AxeSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcbiAgICB9XG4gICAgaWYgKGluQXJlYU5leHQpIHtcbiAgICAgIHBvaW50LmNwMnggPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AyeCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcbiAgICAgIHBvaW50LmNwMnkgPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AyeSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKHBvaW50cywgb3B0aW9ucywgYXJlYSwgbG9vcCwgaW5kZXhBeGlzKSB7XG4gIGxldCBpLCBpbGVuLCBwb2ludCwgY29udHJvbFBvaW50cztcbiAgaWYgKG9wdGlvbnMuc3BhbkdhcHMpIHtcbiAgICBwb2ludHMgPSBwb2ludHMuZmlsdGVyKChwdCkgPT4gIXB0LnNraXApO1xuICB9XG4gIGlmIChvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJldiA9IGxvb3AgPyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIDogcG9pbnRzWzBdO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnRyb2xQb2ludHMgPSBzcGxpbmVDdXJ2ZShcbiAgICAgICAgcHJldixcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHBvaW50c1tNYXRoLm1pbihpICsgMSwgaWxlbiAtIChsb29wID8gMCA6IDEpKSAlIGlsZW5dLFxuICAgICAgICBvcHRpb25zLnRlbnNpb25cbiAgICAgICk7XG4gICAgICBwb2ludC5jcDF4ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy54O1xuICAgICAgcG9pbnQuY3AxeSA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueTtcbiAgICAgIHBvaW50LmNwMnggPSBjb250cm9sUG9pbnRzLm5leHQueDtcbiAgICAgIHBvaW50LmNwMnkgPSBjb250cm9sUG9pbnRzLm5leHQueTtcbiAgICAgIHByZXYgPSBwb2ludDtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuY2FwQmV6aWVyUG9pbnRzKSB7XG4gICAgY2FwQmV6aWVyUG9pbnRzKHBvaW50cywgYXJlYSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2lzRG9tU3VwcG9ydGVkKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIF9nZXRQYXJlbnROb2RlKGRvbU5vZGUpIHtcbiAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG4gICAgcGFyZW50ID0gcGFyZW50Lmhvc3Q7XG4gIH1cbiAgcmV0dXJuIHBhcmVudDtcbn1cbmZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZSwgbm9kZSwgcGFyZW50UHJvcGVydHkpIHtcbiAgbGV0IHZhbHVlSW5QaXhlbHM7XG4gIGlmICh0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZUluUGl4ZWxzID0gcGFyc2VJbnQoc3R5bGVWYWx1ZSwgMTApO1xuICAgIGlmIChzdHlsZVZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgIHZhbHVlSW5QaXhlbHMgPSB2YWx1ZUluUGl4ZWxzIC8gMTAwICogbm9kZS5wYXJlbnROb2RlW3BhcmVudFByb3BlcnR5XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHN0eWxlVmFsdWU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlSW5QaXhlbHM7XG59XG5jb25zdCBnZXRDb21wdXRlZFN0eWxlID0gKGVsZW1lbnQpID0+IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuZnVuY3Rpb24gZ2V0U3R5bGUoZWwsIHByb3BlcnR5KSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbn1cbmNvbnN0IHBvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG5mdW5jdGlvbiBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGVzLCBzdHlsZSwgc3VmZml4KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBzdWZmaXggPSBzdWZmaXggPyAnLScgKyBzdWZmaXggOiAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnNbaV07XG4gICAgcmVzdWx0W3Bvc10gPSBwYXJzZUZsb2F0KHN0eWxlc1tzdHlsZSArICctJyArIHBvcyArIHN1ZmZpeF0pIHx8IDA7XG4gIH1cbiAgcmVzdWx0LndpZHRoID0gcmVzdWx0LmxlZnQgKyByZXN1bHQucmlnaHQ7XG4gIHJlc3VsdC5oZWlnaHQgPSByZXN1bHQudG9wICsgcmVzdWx0LmJvdHRvbTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IHVzZU9mZnNldFBvcyA9ICh4LCB5LCB0YXJnZXQpID0+ICh4ID4gMCB8fCB5ID4gMCkgJiYgKCF0YXJnZXQgfHwgIXRhcmdldC5zaGFkb3dSb290KTtcbmZ1bmN0aW9uIGdldENhbnZhc1Bvc2l0aW9uKGV2dCwgY2FudmFzKSB7XG4gIGNvbnN0IGUgPSBldnQubmF0aXZlIHx8IGV2dDtcbiAgY29uc3QgdG91Y2hlcyA9IGUudG91Y2hlcztcbiAgY29uc3Qgc291cmNlID0gdG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA/IHRvdWNoZXNbMF0gOiBlO1xuICBjb25zdCB7b2Zmc2V0WCwgb2Zmc2V0WX0gPSBzb3VyY2U7XG4gIGxldCBib3ggPSBmYWxzZTtcbiAgbGV0IHgsIHk7XG4gIGlmICh1c2VPZmZzZXRQb3Mob2Zmc2V0WCwgb2Zmc2V0WSwgZS50YXJnZXQpKSB7XG4gICAgeCA9IG9mZnNldFg7XG4gICAgeSA9IG9mZnNldFk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB4ID0gc291cmNlLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgeSA9IHNvdXJjZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgYm94ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge3gsIHksIGJveH07XG59XG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGV2dCwgY2hhcnQpIHtcbiAgY29uc3Qge2NhbnZhcywgY3VycmVudERldmljZVBpeGVsUmF0aW99ID0gY2hhcnQ7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBib3JkZXJCb3ggPSBzdHlsZS5ib3hTaXppbmcgPT09ICdib3JkZXItYm94JztcbiAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgY29uc3Qge3gsIHksIGJveH0gPSBnZXRDYW52YXNQb3NpdGlvbihldnQsIGNhbnZhcyk7XG4gIGNvbnN0IHhPZmZzZXQgPSBwYWRkaW5ncy5sZWZ0ICsgKGJveCAmJiBib3JkZXJzLmxlZnQpO1xuICBjb25zdCB5T2Zmc2V0ID0gcGFkZGluZ3MudG9wICsgKGJveCAmJiBib3JkZXJzLnRvcCk7XG4gIGxldCB7d2lkdGgsIGhlaWdodH0gPSBjaGFydDtcbiAgaWYgKGJvcmRlckJveCkge1xuICAgIHdpZHRoIC09IHBhZGRpbmdzLndpZHRoICsgYm9yZGVycy53aWR0aDtcbiAgICBoZWlnaHQgLT0gcGFkZGluZ3MuaGVpZ2h0ICsgYm9yZGVycy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBNYXRoLnJvdW5kKCh4IC0geE9mZnNldCkgLyB3aWR0aCAqIGNhbnZhcy53aWR0aCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKSxcbiAgICB5OiBNYXRoLnJvdW5kKCh5IC0geU9mZnNldCkgLyBoZWlnaHQgKiBjYW52YXMuaGVpZ2h0IC8gY3VycmVudERldmljZVBpeGVsUmF0aW8pXG4gIH07XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXJTaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCkge1xuICBsZXQgbWF4V2lkdGgsIG1heEhlaWdodDtcbiAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICB3aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgIGhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjb250YWluZXJTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lckJvcmRlciA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgICAgY29uc3QgY29udGFpbmVyUGFkZGluZyA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICAgIHdpZHRoID0gcmVjdC53aWR0aCAtIGNvbnRhaW5lclBhZGRpbmcud2lkdGggLSBjb250YWluZXJCb3JkZXIud2lkdGg7XG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodCAtIGNvbnRhaW5lclBhZGRpbmcuaGVpZ2h0IC0gY29udGFpbmVyQm9yZGVyLmhlaWdodDtcbiAgICAgIG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhXaWR0aCwgY29udGFpbmVyLCAnY2xpZW50V2lkdGgnKTtcbiAgICAgIG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4SGVpZ2h0LCBjb250YWluZXIsICdjbGllbnRIZWlnaHQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbWF4V2lkdGg6IG1heFdpZHRoIHx8IElORklOSVRZLFxuICAgIG1heEhlaWdodDogbWF4SGVpZ2h0IHx8IElORklOSVRZXG4gIH07XG59XG5jb25zdCByb3VuZDEgPSB2ID0+IE1hdGgucm91bmQodiAqIDEwKSAvIDEwO1xuZnVuY3Rpb24gZ2V0TWF4aW11bVNpemUoY2FudmFzLCBiYldpZHRoLCBiYkhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XG4gIGNvbnN0IG1hcmdpbnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdtYXJnaW4nKTtcbiAgY29uc3QgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heFdpZHRoLCBjYW52YXMsICdjbGllbnRXaWR0aCcpIHx8IElORklOSVRZO1xuICBjb25zdCBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heEhlaWdodCwgY2FudmFzLCAnY2xpZW50SGVpZ2h0JykgfHwgSU5GSU5JVFk7XG4gIGNvbnN0IGNvbnRhaW5lclNpemUgPSBnZXRDb250YWluZXJTaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQpO1xuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY29udGFpbmVyU2l6ZTtcbiAgaWYgKHN0eWxlLmJveFNpemluZyA9PT0gJ2NvbnRlbnQtYm94Jykge1xuICAgIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICBjb25zdCBwYWRkaW5ncyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggLSBtYXJnaW5zLndpZHRoKTtcbiAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyBNYXRoLmZsb29yKHdpZHRoIC8gYXNwZWN0UmF0aW8pIDogaGVpZ2h0IC0gbWFyZ2lucy5oZWlnaHQpO1xuICB3aWR0aCA9IHJvdW5kMShNYXRoLm1pbih3aWR0aCwgbWF4V2lkdGgsIGNvbnRhaW5lclNpemUubWF4V2lkdGgpKTtcbiAgaGVpZ2h0ID0gcm91bmQxKE1hdGgubWluKGhlaWdodCwgbWF4SGVpZ2h0LCBjb250YWluZXJTaXplLm1heEhlaWdodCkpO1xuICBpZiAod2lkdGggJiYgIWhlaWdodCkge1xuICAgIGhlaWdodCA9IHJvdW5kMSh3aWR0aCAvIDIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiByZXRpbmFTY2FsZShjaGFydCwgZm9yY2VSYXRpbywgZm9yY2VTdHlsZSkge1xuICBjb25zdCBwaXhlbFJhdGlvID0gZm9yY2VSYXRpbyB8fCAxO1xuICBjb25zdCBkZXZpY2VIZWlnaHQgPSBNYXRoLmZsb29yKGNoYXJ0LmhlaWdodCAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VXaWR0aCA9IE1hdGguZmxvb3IoY2hhcnQud2lkdGggKiBwaXhlbFJhdGlvKTtcbiAgY2hhcnQuaGVpZ2h0ID0gZGV2aWNlSGVpZ2h0IC8gcGl4ZWxSYXRpbztcbiAgY2hhcnQud2lkdGggPSBkZXZpY2VXaWR0aCAvIHBpeGVsUmF0aW87XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgaWYgKGNhbnZhcy5zdHlsZSAmJiAoZm9yY2VTdHlsZSB8fCAoIWNhbnZhcy5zdHlsZS5oZWlnaHQgJiYgIWNhbnZhcy5zdHlsZS53aWR0aCkpKSB7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NoYXJ0LmhlaWdodH1weGA7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7Y2hhcnQud2lkdGh9cHhgO1xuICB9XG4gIGlmIChjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gcGl4ZWxSYXRpb1xuICAgICAgfHwgY2FudmFzLmhlaWdodCAhPT0gZGV2aWNlSGVpZ2h0XG4gICAgICB8fCBjYW52YXMud2lkdGggIT09IGRldmljZVdpZHRoKSB7XG4gICAgY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBkZXZpY2VIZWlnaHQ7XG4gICAgY2FudmFzLndpZHRoID0gZGV2aWNlV2lkdGg7XG4gICAgY2hhcnQuY3R4LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xufSgpKTtcbmZ1bmN0aW9uIHJlYWRVc2VkU2l6ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCB2YWx1ZSA9IGdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KTtcbiAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9eKFxcZCspKFxcLlxcZCspP3B4JC8pO1xuICByZXR1cm4gbWF0Y2hlcyA/ICttYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBfcG9pbnRJbkxpbmUocDEsIHAyLCB0LCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IHAxLnkgKyB0ICogKHAyLnkgLSBwMS55KVxuICB9O1xufVxuZnVuY3Rpb24gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uKHAxLCBwMiwgdCwgbW9kZSkge1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBtb2RlID09PSAnbWlkZGxlJyA/IHQgPCAwLjUgPyBwMS55IDogcDIueVxuICAgIDogbW9kZSA9PT0gJ2FmdGVyJyA/IHQgPCAxID8gcDEueSA6IHAyLnlcbiAgICA6IHQgPiAwID8gcDIueSA6IHAxLnlcbiAgfTtcbn1cbmZ1bmN0aW9uIF9iZXppZXJJbnRlcnBvbGF0aW9uKHAxLCBwMiwgdCwgbW9kZSkge1xuICBjb25zdCBjcDEgPSB7eDogcDEuY3AyeCwgeTogcDEuY3AyeX07XG4gIGNvbnN0IGNwMiA9IHt4OiBwMi5jcDF4LCB5OiBwMi5jcDF5fTtcbiAgY29uc3QgYSA9IF9wb2ludEluTGluZShwMSwgY3AxLCB0KTtcbiAgY29uc3QgYiA9IF9wb2ludEluTGluZShjcDEsIGNwMiwgdCk7XG4gIGNvbnN0IGMgPSBfcG9pbnRJbkxpbmUoY3AyLCBwMiwgdCk7XG4gIGNvbnN0IGQgPSBfcG9pbnRJbkxpbmUoYSwgYiwgdCk7XG4gIGNvbnN0IGUgPSBfcG9pbnRJbkxpbmUoYiwgYywgdCk7XG4gIHJldHVybiBfcG9pbnRJbkxpbmUoZCwgZSwgdCk7XG59XG5cbmNvbnN0IGludGxDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGNhY2hlS2V5ID0gbG9jYWxlICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gIGxldCBmb3JtYXR0ZXIgPSBpbnRsQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFmb3JtYXR0ZXIpIHtcbiAgICBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICBpbnRsQ2FjaGUuc2V0KGNhY2hlS2V5LCBmb3JtYXR0ZXIpO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZXI7XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdChudW0pO1xufVxuXG5jb25zdCBnZXRSaWdodFRvTGVmdEFkYXB0ZXIgPSBmdW5jdGlvbihyZWN0WCwgd2lkdGgpIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiByZWN0WCArIHJlY3RYICsgd2lkdGggLSB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykge1xuICAgICAgd2lkdGggPSB3O1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHJldHVybiBhbGlnbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggLSB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geCAtIGl0ZW1XaWR0aDtcbiAgICB9LFxuICB9O1xufTtcbmNvbnN0IGdldExlZnRUb1JpZ2h0QWRhcHRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7XG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIHJldHVybiBhbGlnbjtcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCArIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBfaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICB9O1xufTtcbmZ1bmN0aW9uIGdldFJ0bEFkYXB0ZXIocnRsLCByZWN0WCwgd2lkdGgpIHtcbiAgcmV0dXJuIHJ0bCA/IGdldFJpZ2h0VG9MZWZ0QWRhcHRlcihyZWN0WCwgd2lkdGgpIDogZ2V0TGVmdFRvUmlnaHRBZGFwdGVyKCk7XG59XG5mdW5jdGlvbiBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBkaXJlY3Rpb24pIHtcbiAgbGV0IHN0eWxlLCBvcmlnaW5hbDtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ2x0cicgfHwgZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHN0eWxlID0gY3R4LmNhbnZhcy5zdHlsZTtcbiAgICBvcmlnaW5hbCA9IFtcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpLFxuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eSgnZGlyZWN0aW9uJyksXG4gICAgXTtcbiAgICBzdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgZGlyZWN0aW9uLCAnaW1wb3J0YW50Jyk7XG4gICAgY3R4LnByZXZUZXh0RGlyZWN0aW9uID0gb3JpZ2luYWw7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgb3JpZ2luYWwpIHtcbiAgaWYgKG9yaWdpbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgY3R4LnByZXZUZXh0RGlyZWN0aW9uO1xuICAgIGN0eC5jYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIG9yaWdpbmFsWzBdLCBvcmlnaW5hbFsxXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGVydHlGbihwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmV0d2VlbjogX2FuZ2xlQmV0d2VlbixcbiAgICAgIGNvbXBhcmU6IF9hbmdsZURpZmYsXG4gICAgICBub3JtYWxpemU6IF9ub3JtYWxpemVBbmdsZSxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgYmV0d2VlbjogX2lzQmV0d2VlbixcbiAgICBjb21wYXJlOiAoYSwgYikgPT4gYSAtIGIsXG4gICAgbm9ybWFsaXplOiB4ID0+IHhcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0LCBlbmQsIGNvdW50LCBsb29wLCBzdHlsZX0pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQgJSBjb3VudCxcbiAgICBlbmQ6IGVuZCAlIGNvdW50LFxuICAgIGxvb3A6IGxvb3AgJiYgKGVuZCAtIHN0YXJ0ICsgMSkgJSBjb3VudCA9PT0gMCxcbiAgICBzdHlsZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3Qge2JldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQge3N0YXJ0LCBlbmQsIGxvb3B9ID0gc2VnbWVudDtcbiAgbGV0IGksIGlsZW47XG4gIGlmIChsb29wKSB7XG4gICAgc3RhcnQgKz0gY291bnQ7XG4gICAgZW5kICs9IGNvdW50O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKCFiZXR3ZWVuKG5vcm1hbGl6ZShwb2ludHNbc3RhcnQgJSBjb3VudF1bcHJvcGVydHldKSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhcnQtLTtcbiAgICAgIGVuZC0tO1xuICAgIH1cbiAgICBzdGFydCAlPSBjb3VudDtcbiAgICBlbmQgJT0gY291bnQ7XG4gIH1cbiAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgZW5kICs9IGNvdW50O1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGU6IHNlZ21lbnQuc3R5bGV9O1xufVxuZnVuY3Rpb24gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBpZiAoIWJvdW5kcykge1xuICAgIHJldHVybiBbc2VnbWVudF07XG4gIH1cbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge2NvbXBhcmUsIGJldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3Qge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlfSA9IGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICBsZXQgc3ViU3RhcnQgPSBudWxsO1xuICBsZXQgdmFsdWUsIHBvaW50LCBwcmV2VmFsdWU7XG4gIGNvbnN0IHN0YXJ0SXNCZWZvcmUgPSAoKSA9PiBiZXR3ZWVuKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpICYmIGNvbXBhcmUoc3RhcnRCb3VuZCwgcHJldlZhbHVlKSAhPT0gMDtcbiAgY29uc3QgZW5kSXNCZWZvcmUgPSAoKSA9PiBjb21wYXJlKGVuZEJvdW5kLCB2YWx1ZSkgPT09IDAgfHwgYmV0d2VlbihlbmRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSk7XG4gIGNvbnN0IHNob3VsZFN0YXJ0ID0gKCkgPT4gaW5zaWRlIHx8IHN0YXJ0SXNCZWZvcmUoKTtcbiAgY29uc3Qgc2hvdWxkU3RvcCA9ICgpID0+ICFpbnNpZGUgfHwgZW5kSXNCZWZvcmUoKTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0LCBwcmV2ID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFsdWUgPSBub3JtYWxpemUocG9pbnRbcHJvcGVydHldKTtcbiAgICBpZiAodmFsdWUgPT09IHByZXZWYWx1ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGluc2lkZSA9IGJldHdlZW4odmFsdWUsIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKTtcbiAgICBpZiAoc3ViU3RhcnQgPT09IG51bGwgJiYgc2hvdWxkU3RhcnQoKSkge1xuICAgICAgc3ViU3RhcnQgPSBjb21wYXJlKHZhbHVlLCBzdGFydEJvdW5kKSA9PT0gMCA/IGkgOiBwcmV2O1xuICAgIH1cbiAgICBpZiAoc3ViU3RhcnQgIT09IG51bGwgJiYgc2hvdWxkU3RvcCgpKSB7XG4gICAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZDogaSwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICAgICAgc3ViU3RhcnQgPSBudWxsO1xuICAgIH1cbiAgICBwcmV2ID0gaTtcbiAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBpZiAoc3ViU3RhcnQgIT09IG51bGwpIHtcbiAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZCwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfYm91bmRTZWdtZW50cyhsaW5lLCBib3VuZHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN1YiA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudHNbaV0sIGxpbmUucG9pbnRzLCBib3VuZHMpO1xuICAgIGlmIChzdWIubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaCguLi5zdWIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSBjb3VudCAtIDE7XG4gIGlmIChsb29wICYmICFzcGFuR2Fwcykge1xuICAgIHdoaWxlIChzdGFydCA8IGNvdW50ICYmICFwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICB9XG4gIHdoaWxlIChzdGFydCA8IGNvdW50ICYmIHBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgIHN0YXJ0Kys7XG4gIH1cbiAgc3RhcnQgJT0gY291bnQ7XG4gIGlmIChsb29wKSB7XG4gICAgZW5kICs9IHN0YXJ0O1xuICB9XG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiBwb2ludHNbZW5kICUgY291bnRdLnNraXApIHtcbiAgICBlbmQtLTtcbiAgfVxuICBlbmQgJT0gY291bnQ7XG4gIHJldHVybiB7c3RhcnQsIGVuZH07XG59XG5mdW5jdGlvbiBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgbG9vcCkge1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgbGFzdCA9IHN0YXJ0O1xuICBsZXQgcHJldiA9IHBvaW50c1tzdGFydF07XG4gIGxldCBlbmQ7XG4gIGZvciAoZW5kID0gc3RhcnQgKyAxOyBlbmQgPD0gbWF4OyArK2VuZCkge1xuICAgIGNvbnN0IGN1ciA9IHBvaW50c1tlbmQgJSBjb3VudF07XG4gICAgaWYgKGN1ci5za2lwIHx8IGN1ci5zdG9wKSB7XG4gICAgICBpZiAoIXByZXYuc2tpcCkge1xuICAgICAgICBsb29wID0gZmFsc2U7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiAoZW5kIC0gMSkgJSBjb3VudCwgbG9vcH0pO1xuICAgICAgICBzdGFydCA9IGxhc3QgPSBjdXIuc3RvcCA/IGVuZCA6IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBlbmQ7XG4gICAgICBpZiAocHJldi5za2lwKSB7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmV2ID0gY3VyO1xuICB9XG4gIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCAlIGNvdW50LCBlbmQ6IGxhc3QgJSBjb3VudCwgbG9vcH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfY29tcHV0ZVNlZ21lbnRzKGxpbmUsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBzcGFuR2FwcyA9IGxpbmUub3B0aW9ucy5zcGFuR2FwcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBpZiAoIWNvdW50KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IGxvb3AgPSAhIWxpbmUuX2xvb3A7XG4gIGNvbnN0IHtzdGFydCwgZW5kfSA9IGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcyk7XG4gIGlmIChzcGFuR2FwcyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIFt7c3RhcnQsIGVuZCwgbG9vcH1dLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbiAgfVxuICBjb25zdCBtYXggPSBlbmQgPCBzdGFydCA/IGVuZCArIGNvdW50IDogZW5kO1xuICBjb25zdCBjb21wbGV0ZUxvb3AgPSAhIWxpbmUuX2Z1bGxMb29wICYmIHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gY291bnQgLSAxO1xuICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgY29tcGxldGVMb29wKSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5mdW5jdGlvbiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGlmICghc2VnbWVudE9wdGlvbnMgfHwgIXNlZ21lbnRPcHRpb25zLnNldENvbnRleHQgfHwgIXBvaW50cykge1xuICAgIHJldHVybiBzZWdtZW50cztcbiAgfVxuICByZXR1cm4gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBjaGFydENvbnRleHQgPSBsaW5lLl9jaGFydC5nZXRDb250ZXh0KCk7XG4gIGNvbnN0IGJhc2VTdHlsZSA9IHJlYWRTdHlsZShsaW5lLm9wdGlvbnMpO1xuICBjb25zdCB7X2RhdGFzZXRJbmRleDogZGF0YXNldEluZGV4LCBvcHRpb25zOiB7c3BhbkdhcHN9fSA9IGxpbmU7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBwcmV2U3R5bGUgPSBiYXNlU3R5bGU7XG4gIGxldCBzdGFydCA9IHNlZ21lbnRzWzBdLnN0YXJ0O1xuICBsZXQgaSA9IHN0YXJ0O1xuICBmdW5jdGlvbiBhZGRTdHlsZShzLCBlLCBsLCBzdCkge1xuICAgIGNvbnN0IGRpciA9IHNwYW5HYXBzID8gLTEgOiAxO1xuICAgIGlmIChzID09PSBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHMgKz0gY291bnQ7XG4gICAgd2hpbGUgKHBvaW50c1tzICUgY291bnRdLnNraXApIHtcbiAgICAgIHMgLT0gZGlyO1xuICAgIH1cbiAgICB3aGlsZSAocG9pbnRzW2UgJSBjb3VudF0uc2tpcCkge1xuICAgICAgZSArPSBkaXI7XG4gICAgfVxuICAgIGlmIChzICUgY291bnQgIT09IGUgJSBjb3VudCkge1xuICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzICUgY291bnQsIGVuZDogZSAlIGNvdW50LCBsb29wOiBsLCBzdHlsZTogc3R9KTtcbiAgICAgIHByZXZTdHlsZSA9IHN0O1xuICAgICAgc3RhcnQgPSBlICUgY291bnQ7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIHN0YXJ0ID0gc3BhbkdhcHMgPyBzdGFydCA6IHNlZ21lbnQuc3RhcnQ7XG4gICAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnQgJSBjb3VudF07XG4gICAgbGV0IHN0eWxlO1xuICAgIGZvciAoaSA9IHN0YXJ0ICsgMTsgaSA8PSBzZWdtZW50LmVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBwdCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgICAgc3R5bGUgPSByZWFkU3R5bGUoc2VnbWVudE9wdGlvbnMuc2V0Q29udGV4dChjcmVhdGVDb250ZXh0KGNoYXJ0Q29udGV4dCwge1xuICAgICAgICB0eXBlOiAnc2VnbWVudCcsXG4gICAgICAgIHAwOiBwcmV2LFxuICAgICAgICBwMTogcHQsXG4gICAgICAgIHAwRGF0YUluZGV4OiAoaSAtIDEpICUgY291bnQsXG4gICAgICAgIHAxRGF0YUluZGV4OiBpICUgY291bnQsXG4gICAgICAgIGRhdGFzZXRJbmRleFxuICAgICAgfSkpKTtcbiAgICAgIGlmIChzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkpIHtcbiAgICAgICAgYWRkU3R5bGUoc3RhcnQsIGkgLSAxLCBzZWdtZW50Lmxvb3AsIHByZXZTdHlsZSk7XG4gICAgICB9XG4gICAgICBwcmV2ID0gcHQ7XG4gICAgICBwcmV2U3R5bGUgPSBzdHlsZTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0IDwgaSAtIDEpIHtcbiAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVhZFN0eWxlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgIGJvcmRlckNhcFN0eWxlOiBvcHRpb25zLmJvcmRlckNhcFN0eWxlLFxuICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgYm9yZGVySm9pblN0eWxlOiBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSxcbiAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvclxuICB9O1xufVxuZnVuY3Rpb24gc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpIHtcbiAgcmV0dXJuIHByZXZTdHlsZSAmJiBKU09OLnN0cmluZ2lmeShzdHlsZSkgIT09IEpTT04uc3RyaW5naWZ5KHByZXZTdHlsZSk7XG59XG5cbmV4cG9ydCB7IF90b0xlZnRSaWdodENlbnRlciBhcyAkLCBfcmxvb2t1cEJ5S2V5IGFzIEEsIGdldEFuZ2xlRnJvbVBvaW50IGFzIEIsIHRvUGFkZGluZyBhcyBDLCBlYWNoIGFzIEQsIGdldE1heGltdW1TaXplIGFzIEUsIF9nZXRQYXJlbnROb2RlIGFzIEYsIHJlYWRVc2VkU2l6ZSBhcyBHLCBIQUxGX1BJIGFzIEgsIHRocm90dGxlZCBhcyBJLCBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIGFzIEosIF9pc0RvbVN1cHBvcnRlZCBhcyBLLCBsb2cxMCBhcyBMLCBfZmFjdG9yaXplIGFzIE0sIGZpbml0ZU9yRGVmYXVsdCBhcyBOLCBjYWxsYmFjayBhcyBPLCBQSSBhcyBQLCBfYWRkR3JhY2UgYXMgUSwgdG9EZWdyZWVzIGFzIFIsIF9tZWFzdXJlVGV4dCBhcyBTLCBUQVUgYXMgVCwgX2ludDE2UmFuZ2UgYXMgVSwgX2FsaWduUGl4ZWwgYXMgViwgY2xpcEFyZWEgYXMgVywgcmVuZGVyVGV4dCBhcyBYLCB1bmNsaXBBcmVhIGFzIFksIHRvRm9udCBhcyBaLCBfYXJyYXlVbmlxdWUgYXMgXywgcmVzb2x2ZSBhcyBhLCBfYW5nbGVEaWZmIGFzIGEkLCBfYWxpZ25TdGFydEVuZCBhcyBhMCwgb3ZlcnJpZGVzIGFzIGExLCBtZXJnZSBhcyBhMiwgX2NhcGl0YWxpemUgYXMgYTMsIGRlc2NyaXB0b3JzIGFzIGE0LCBpc0Z1bmN0aW9uIGFzIGE1LCBfYXR0YWNoQ29udGV4dCBhcyBhNiwgX2NyZWF0ZVJlc29sdmVyIGFzIGE3LCBfZGVzY3JpcHRvcnMgYXMgYTgsIG1lcmdlSWYgYXMgYTksIHJlc3RvcmVUZXh0RGlyZWN0aW9uIGFzIGFBLCBub29wIGFzIGFCLCBkaXN0YW5jZUJldHdlZW5Qb2ludHMgYXMgYUMsIF9zZXRNaW5BbmRNYXhCeUtleSBhcyBhRCwgbmljZU51bSBhcyBhRSwgYWxtb3N0V2hvbGUgYXMgYUYsIGFsbW9zdEVxdWFscyBhcyBhRywgX2RlY2ltYWxQbGFjZXMgYXMgYUgsIF9sb25nZXN0VGV4dCBhcyBhSSwgX2ZpbHRlckJldHdlZW4gYXMgYUosIF9sb29rdXAgYXMgYUssIGdldEhvdmVyQ29sb3IgYXMgYUwsIGNsb25lJDEgYXMgYU0sIF9tZXJnZXIgYXMgYU4sIF9tZXJnZXJJZiBhcyBhTywgX2RlcHJlY2F0ZWQgYXMgYVAsIHRvRm9udFN0cmluZyBhcyBhUSwgc3BsaW5lQ3VydmUgYXMgYVIsIHNwbGluZUN1cnZlTW9ub3RvbmUgYXMgYVMsIGdldFN0eWxlIGFzIGFULCBmb250U3RyaW5nIGFzIGFVLCB0b0xpbmVIZWlnaHQgYXMgYVYsIFBJVEFVIGFzIGFXLCBJTkZJTklUWSBhcyBhWCwgUkFEX1BFUl9ERUcgYXMgYVksIFFVQVJURVJfUEkgYXMgYVosIFRXT19USElSRFNfUEkgYXMgYV8sIHVpZCBhcyBhYSwgZGVib3VuY2UgYXMgYWIsIHJldGluYVNjYWxlIGFzIGFjLCBjbGVhckNhbnZhcyBhcyBhZCwgc2V0c0VxdWFsIGFzIGFlLCBfZWxlbWVudHNFcXVhbCBhcyBhZiwgX2lzQ2xpY2tFdmVudCBhcyBhZywgX2lzQmV0d2VlbiBhcyBhaCwgX3JlYWRWYWx1ZVRvUHJvcHMgYXMgYWksIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzIGFzIGFqLCBfY29tcHV0ZVNlZ21lbnRzIGFzIGFrLCBfYm91bmRTZWdtZW50cyBhcyBhbCwgX3N0ZXBwZWRJbnRlcnBvbGF0aW9uIGFzIGFtLCBfYmV6aWVySW50ZXJwb2xhdGlvbiBhcyBhbiwgX3BvaW50SW5MaW5lIGFzIGFvLCBfc3RlcHBlZExpbmVUbyBhcyBhcCwgX2JlemllckN1cnZlVG8gYXMgYXEsIGRyYXdQb2ludCBhcyBhciwgYWRkUm91bmRlZFJlY3RQYXRoIGFzIGFzLCB0b1RSQkwgYXMgYXQsIHRvVFJCTENvcm5lcnMgYXMgYXUsIF9ib3VuZFNlZ21lbnQgYXMgYXYsIF9ub3JtYWxpemVBbmdsZSBhcyBhdywgZ2V0UnRsQWRhcHRlciBhcyBheCwgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uIGFzIGF5LCBfdGV4dFggYXMgYXosIGlzQXJyYXkgYXMgYiwgY29sb3IgYXMgYywgZGVmYXVsdHMgYXMgZCwgZWZmZWN0cyBhcyBlLCByZXNvbHZlT2JqZWN0S2V5IGFzIGYsIGlzTnVtYmVyRmluaXRlIGFzIGcsIGNyZWF0ZUNvbnRleHQgYXMgaCwgaXNPYmplY3QgYXMgaSwgZGVmaW5lZCBhcyBqLCBpc051bGxPclVuZGVmIGFzIGssIGxpc3RlbkFycmF5RXZlbnRzIGFzIGwsIHRvUGVyY2VudGFnZSBhcyBtLCB0b0RpbWVuc2lvbiBhcyBuLCBmb3JtYXROdW1iZXIgYXMgbywgX2FuZ2xlQmV0d2VlbiBhcyBwLCBpc051bWJlciBhcyBxLCByZXF1ZXN0QW5pbUZyYW1lIGFzIHIsIHNpZ24gYXMgcywgdG9SYWRpYW5zIGFzIHQsIHVubGlzdGVuQXJyYXlFdmVudHMgYXMgdSwgdmFsdWVPckRlZmF1bHQgYXMgdiwgX2xpbWl0VmFsdWUgYXMgdywgX2xvb2t1cEJ5S2V5IGFzIHgsIGdldFJlbGF0aXZlUG9zaXRpb24gYXMgeSwgX2lzUG9pbnRJbkFyZWEgYXMgeiB9O1xuIiwgIi8qIVxuICogQ2hhcnQuanMgdjMuNy4wXG4gKiBodHRwczovL3d3dy5jaGFydGpzLm9yZ1xuICogKGMpIDIwMjEgQ2hhcnQuanMgQ29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgciBhcyByZXF1ZXN0QW5pbUZyYW1lLCBhIGFzIHJlc29sdmUsIGUgYXMgZWZmZWN0cywgYyBhcyBjb2xvciwgZCBhcyBkZWZhdWx0cywgaSBhcyBpc09iamVjdCwgYiBhcyBpc0FycmF5LCB2IGFzIHZhbHVlT3JEZWZhdWx0LCB1IGFzIHVubGlzdGVuQXJyYXlFdmVudHMsIGwgYXMgbGlzdGVuQXJyYXlFdmVudHMsIGYgYXMgcmVzb2x2ZU9iamVjdEtleSwgZyBhcyBpc051bWJlckZpbml0ZSwgaCBhcyBjcmVhdGVDb250ZXh0LCBqIGFzIGRlZmluZWQsIHMgYXMgc2lnbiwgayBhcyBpc051bGxPclVuZGVmLCBfIGFzIF9hcnJheVVuaXF1ZSwgdCBhcyB0b1JhZGlhbnMsIG0gYXMgdG9QZXJjZW50YWdlLCBuIGFzIHRvRGltZW5zaW9uLCBUIGFzIFRBVSwgbyBhcyBmb3JtYXROdW1iZXIsIHAgYXMgX2FuZ2xlQmV0d2VlbiwgSCBhcyBIQUxGX1BJLCBQIGFzIFBJLCBxIGFzIGlzTnVtYmVyLCB3IGFzIF9saW1pdFZhbHVlLCB4IGFzIF9sb29rdXBCeUtleSwgeSBhcyBnZXRSZWxhdGl2ZVBvc2l0aW9uJDEsIHogYXMgX2lzUG9pbnRJbkFyZWEsIEEgYXMgX3Jsb29rdXBCeUtleSwgQiBhcyBnZXRBbmdsZUZyb21Qb2ludCwgQyBhcyB0b1BhZGRpbmcsIEQgYXMgZWFjaCwgRSBhcyBnZXRNYXhpbXVtU2l6ZSwgRiBhcyBfZ2V0UGFyZW50Tm9kZSwgRyBhcyByZWFkVXNlZFNpemUsIEkgYXMgdGhyb3R0bGVkLCBKIGFzIHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMsIEsgYXMgX2lzRG9tU3VwcG9ydGVkLCBMIGFzIGxvZzEwLCBNIGFzIF9mYWN0b3JpemUsIE4gYXMgZmluaXRlT3JEZWZhdWx0LCBPIGFzIGNhbGxiYWNrLCBRIGFzIF9hZGRHcmFjZSwgUiBhcyB0b0RlZ3JlZXMsIFMgYXMgX21lYXN1cmVUZXh0LCBVIGFzIF9pbnQxNlJhbmdlLCBWIGFzIF9hbGlnblBpeGVsLCBXIGFzIGNsaXBBcmVhLCBYIGFzIHJlbmRlclRleHQsIFkgYXMgdW5jbGlwQXJlYSwgWiBhcyB0b0ZvbnQsICQgYXMgX3RvTGVmdFJpZ2h0Q2VudGVyLCBhMCBhcyBfYWxpZ25TdGFydEVuZCwgYTEgYXMgb3ZlcnJpZGVzLCBhMiBhcyBtZXJnZSwgYTMgYXMgX2NhcGl0YWxpemUsIGE0IGFzIGRlc2NyaXB0b3JzLCBhNSBhcyBpc0Z1bmN0aW9uLCBhNiBhcyBfYXR0YWNoQ29udGV4dCwgYTcgYXMgX2NyZWF0ZVJlc29sdmVyLCBhOCBhcyBfZGVzY3JpcHRvcnMsIGE5IGFzIG1lcmdlSWYsIGFhIGFzIHVpZCwgYWIgYXMgZGVib3VuY2UsIGFjIGFzIHJldGluYVNjYWxlLCBhZCBhcyBjbGVhckNhbnZhcywgYWUgYXMgc2V0c0VxdWFsLCBhZiBhcyBfZWxlbWVudHNFcXVhbCwgYWcgYXMgX2lzQ2xpY2tFdmVudCwgYWggYXMgX2lzQmV0d2VlbiwgYWkgYXMgX3JlYWRWYWx1ZVRvUHJvcHMsIGFqIGFzIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzLCBhayBhcyBfY29tcHV0ZVNlZ21lbnRzLCBhbCBhcyBfYm91bmRTZWdtZW50cywgYW0gYXMgX3N0ZXBwZWRJbnRlcnBvbGF0aW9uLCBhbiBhcyBfYmV6aWVySW50ZXJwb2xhdGlvbiwgYW8gYXMgX3BvaW50SW5MaW5lLCBhcCBhcyBfc3RlcHBlZExpbmVUbywgYXEgYXMgX2JlemllckN1cnZlVG8sIGFyIGFzIGRyYXdQb2ludCwgYXMgYXMgYWRkUm91bmRlZFJlY3RQYXRoLCBhdCBhcyB0b1RSQkwsIGF1IGFzIHRvVFJCTENvcm5lcnMsIGF2IGFzIF9ib3VuZFNlZ21lbnQsIGF3IGFzIF9ub3JtYWxpemVBbmdsZSwgYXggYXMgZ2V0UnRsQWRhcHRlciwgYXkgYXMgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uLCBheiBhcyBfdGV4dFgsIGFBIGFzIHJlc3RvcmVUZXh0RGlyZWN0aW9uLCBhQiBhcyBub29wLCBhQyBhcyBkaXN0YW5jZUJldHdlZW5Qb2ludHMsIGFEIGFzIF9zZXRNaW5BbmRNYXhCeUtleSwgYUUgYXMgbmljZU51bSwgYUYgYXMgYWxtb3N0V2hvbGUsIGFHIGFzIGFsbW9zdEVxdWFscywgYUggYXMgX2RlY2ltYWxQbGFjZXMsIGFJIGFzIF9sb25nZXN0VGV4dCwgYUogYXMgX2ZpbHRlckJldHdlZW4sIGFLIGFzIF9sb29rdXAgfSBmcm9tICcuL2NodW5rcy9oZWxwZXJzLnNlZ21lbnQuanMnO1xuZXhwb3J0IHsgZCBhcyBkZWZhdWx0cyB9IGZyb20gJy4vY2h1bmtzL2hlbHBlcnMuc2VnbWVudC5qcyc7XG5cbmNsYXNzIEFuaW1hdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgdGhpcy5fY2hhcnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXN0RGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBfbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgdHlwZSkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGFuaW1zLmxpc3RlbmVyc1t0eXBlXTtcbiAgICBjb25zdCBudW1TdGVwcyA9IGFuaW1zLmR1cmF0aW9uO1xuICAgIGNhbGxiYWNrcy5mb3JFYWNoKGZuID0+IGZuKHtcbiAgICAgIGNoYXJ0LFxuICAgICAgaW5pdGlhbDogYW5pbXMuaW5pdGlhbCxcbiAgICAgIG51bVN0ZXBzLFxuICAgICAgY3VycmVudFN0ZXA6IE1hdGgubWluKGRhdGUgLSBhbmltcy5zdGFydCwgbnVtU3RlcHMpXG4gICAgfSkpO1xuICB9XG4gIF9yZWZyZXNoKCkge1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF91cGRhdGUoZGF0ZSA9IERhdGUubm93KCkpIHtcbiAgICBsZXQgcmVtYWluaW5nID0gMDtcbiAgICB0aGlzLl9jaGFydHMuZm9yRWFjaCgoYW5pbXMsIGNoYXJ0KSA9PiB7XG4gICAgICBpZiAoIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGRyYXcgPSBmYWxzZTtcbiAgICAgIGxldCBpdGVtO1xuICAgICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0uX2FjdGl2ZSkge1xuICAgICAgICAgIGlmIChpdGVtLl90b3RhbCA+IGFuaW1zLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICBhbmltcy5kdXJhdGlvbiA9IGl0ZW0uX3RvdGFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtLnRpY2soZGF0ZSk7XG4gICAgICAgICAgZHJhdyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbXNbaV0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpdGVtcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRyYXcpIHtcbiAgICAgICAgY2hhcnQuZHJhdygpO1xuICAgICAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCAncHJvZ3Jlc3MnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGFuaW1zLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ2NvbXBsZXRlJyk7XG4gICAgICAgIGFuaW1zLmluaXRpYWwgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJlbWFpbmluZyArPSBpdGVtcy5sZW5ndGg7XG4gICAgfSk7XG4gICAgdGhpcy5fbGFzdERhdGUgPSBkYXRlO1xuICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcbiAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgX2dldEFuaW1zKGNoYXJ0KSB7XG4gICAgY29uc3QgY2hhcnRzID0gdGhpcy5fY2hhcnRzO1xuICAgIGxldCBhbmltcyA9IGNoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIGFuaW1zID0ge1xuICAgICAgICBydW5uaW5nOiBmYWxzZSxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICBjb21wbGV0ZTogW10sXG4gICAgICAgICAgcHJvZ3Jlc3M6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaGFydHMuc2V0KGNoYXJ0LCBhbmltcyk7XG4gICAgfVxuICAgIHJldHVybiBhbmltcztcbiAgfVxuICBsaXN0ZW4oY2hhcnQsIGV2ZW50LCBjYikge1xuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5saXN0ZW5lcnNbZXZlbnRdLnB1c2goY2IpO1xuICB9XG4gIGFkZChjaGFydCwgaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLnB1c2goLi4uaXRlbXMpO1xuICB9XG4gIGhhcyhjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMubGVuZ3RoID4gMDtcbiAgfVxuICBzdGFydChjaGFydCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhbmltcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICBhbmltcy5zdGFydCA9IERhdGUubm93KCk7XG4gICAgYW5pbXMuZHVyYXRpb24gPSBhbmltcy5pdGVtcy5yZWR1Y2UoKGFjYywgY3VyKSA9PiBNYXRoLm1heChhY2MsIGN1ci5fZHVyYXRpb24pLCAwKTtcbiAgICB0aGlzLl9yZWZyZXNoKCk7XG4gIH1cbiAgcnVubmluZyhjaGFydCkge1xuICAgIGlmICghdGhpcy5fcnVubmluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdG9wKGNoYXJ0KSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpdGVtc1tpXS5jYW5jZWwoKTtcbiAgICB9XG4gICAgYW5pbXMuaXRlbXMgPSBbXTtcbiAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBEYXRlLm5vdygpLCAnY29tcGxldGUnKTtcbiAgfVxuICByZW1vdmUoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gIH1cbn1cbnZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcigpO1xuXG5jb25zdCB0cmFuc3BhcmVudCA9ICd0cmFuc3BhcmVudCc7XG5jb25zdCBpbnRlcnBvbGF0b3JzID0ge1xuICBib29sZWFuKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICByZXR1cm4gZmFjdG9yID4gMC41ID8gdG8gOiBmcm9tO1xuICB9LFxuICBjb2xvcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgY29uc3QgYzAgPSBjb2xvcihmcm9tIHx8IHRyYW5zcGFyZW50KTtcbiAgICBjb25zdCBjMSA9IGMwLnZhbGlkICYmIGNvbG9yKHRvIHx8IHRyYW5zcGFyZW50KTtcbiAgICByZXR1cm4gYzEgJiYgYzEudmFsaWRcbiAgICAgID8gYzEubWl4KGMwLCBmYWN0b3IpLmhleFN0cmluZygpXG4gICAgICA6IHRvO1xuICB9LFxuICBudW1iZXIoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiBmYWN0b3I7XG4gIH1cbn07XG5jbGFzcyBBbmltYXRpb24ge1xuICBjb25zdHJ1Y3RvcihjZmcsIHRhcmdldCwgcHJvcCwgdG8pIHtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcHJvcF07XG4gICAgdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgY29uc3QgZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLl9mbiA9IGNmZy5mbiB8fCBpbnRlcnBvbGF0b3JzW2NmZy50eXBlIHx8IHR5cGVvZiBmcm9tXTtcbiAgICB0aGlzLl9lYXNpbmcgPSBlZmZlY3RzW2NmZy5lYXNpbmddIHx8IGVmZmVjdHMubGluZWFyO1xuICAgIHRoaXMuX3N0YXJ0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpICsgKGNmZy5kZWxheSB8fCAwKSk7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbCA9IE1hdGguZmxvb3IoY2ZnLmR1cmF0aW9uKTtcbiAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5fcHJvcCA9IHByb3A7XG4gICAgdGhpcy5fZnJvbSA9IGZyb207XG4gICAgdGhpcy5fdG8gPSB0bztcbiAgICB0aGlzLl9wcm9taXNlcyA9IHVuZGVmaW5lZDtcbiAgfVxuICBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgfVxuICB1cGRhdGUoY2ZnLCB0bywgZGF0ZSkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLl90YXJnZXRbdGhpcy5fcHJvcF07XG4gICAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgICAgY29uc3QgcmVtYWluID0gdGhpcy5fZHVyYXRpb24gLSBlbGFwc2VkO1xuICAgICAgdGhpcy5fc3RhcnQgPSBkYXRlO1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSBNYXRoLmZsb29yKE1hdGgubWF4KHJlbWFpbiwgY2ZnLmR1cmF0aW9uKSk7XG4gICAgICB0aGlzLl90b3RhbCArPSBlbGFwc2VkO1xuICAgICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgICB0aGlzLl90byA9IHJlc29sdmUoW2NmZy50bywgdG8sIGN1cnJlbnRWYWx1ZSwgY2ZnLmZyb21dKTtcbiAgICAgIHRoaXMuX2Zyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuICAgIH1cbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy50aWNrKERhdGUubm93KCkpO1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuICAgIH1cbiAgfVxuICB0aWNrKGRhdGUpIHtcbiAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgY29uc3QgcHJvcCA9IHRoaXMuX3Byb3A7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuX2Zyb207XG4gICAgY29uc3QgbG9vcCA9IHRoaXMuX2xvb3A7XG4gICAgY29uc3QgdG8gPSB0aGlzLl90bztcbiAgICBsZXQgZmFjdG9yO1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZyb20gIT09IHRvICYmIChsb29wIHx8IChlbGFwc2VkIDwgZHVyYXRpb24pKTtcbiAgICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdG87XG4gICAgICB0aGlzLl9ub3RpZnkodHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGFwc2VkIDwgMCkge1xuICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gZnJvbTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmFjdG9yID0gKGVsYXBzZWQgLyBkdXJhdGlvbikgJSAyO1xuICAgIGZhY3RvciA9IGxvb3AgJiYgZmFjdG9yID4gMSA/IDIgLSBmYWN0b3IgOiBmYWN0b3I7XG4gICAgZmFjdG9yID0gdGhpcy5fZWFzaW5nKE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGZhY3RvcikpKTtcbiAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSB0aGlzLl9mbihmcm9tLCB0bywgZmFjdG9yKTtcbiAgfVxuICB3YWl0KCkge1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgKHRoaXMuX3Byb21pc2VzID0gW10pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgIHByb21pc2VzLnB1c2goe3JlcywgcmVqfSk7XG4gICAgfSk7XG4gIH1cbiAgX25vdGlmeShyZXNvbHZlZCkge1xuICAgIGNvbnN0IG1ldGhvZCA9IHJlc29sdmVkID8gJ3JlcycgOiAncmVqJztcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb21pc2VzW2ldW21ldGhvZF0oKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgbnVtYmVycyA9IFsneCcsICd5JywgJ2JvcmRlcldpZHRoJywgJ3JhZGl1cycsICd0ZW5zaW9uJ107XG5jb25zdCBjb2xvcnMgPSBbJ2NvbG9yJywgJ2JvcmRlckNvbG9yJywgJ2JhY2tncm91bmRDb2xvciddO1xuZGVmYXVsdHMuc2V0KCdhbmltYXRpb24nLCB7XG4gIGRlbGF5OiB1bmRlZmluZWQsXG4gIGR1cmF0aW9uOiAxMDAwLFxuICBlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuICBmbjogdW5kZWZpbmVkLFxuICBmcm9tOiB1bmRlZmluZWQsXG4gIGxvb3A6IHVuZGVmaW5lZCxcbiAgdG86IHVuZGVmaW5lZCxcbiAgdHlwZTogdW5kZWZpbmVkLFxufSk7XG5jb25zdCBhbmltYXRpb25PcHRpb25zID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuYW5pbWF0aW9uKTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb24nLCB7XG4gIF9mYWxsYmFjazogZmFsc2UsXG4gIF9pbmRleGFibGU6IGZhbHNlLFxuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdvblByb2dyZXNzJyAmJiBuYW1lICE9PSAnb25Db21wbGV0ZScgJiYgbmFtZSAhPT0gJ2ZuJyxcbn0pO1xuZGVmYXVsdHMuc2V0KCdhbmltYXRpb25zJywge1xuICBjb2xvcnM6IHtcbiAgICB0eXBlOiAnY29sb3InLFxuICAgIHByb3BlcnRpZXM6IGNvbG9yc1xuICB9LFxuICBudW1iZXJzOiB7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgcHJvcGVydGllczogbnVtYmVyc1xuICB9LFxufSk7XG5kZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9ucycsIHtcbiAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJyxcbn0pO1xuZGVmYXVsdHMuc2V0KCd0cmFuc2l0aW9ucycsIHtcbiAgYWN0aXZlOiB7XG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwXG4gICAgfVxuICB9LFxuICByZXNpemU6IHtcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiAwXG4gICAgfVxuICB9LFxuICBzaG93OiB7XG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgY29sb3JzOiB7XG4gICAgICAgIGZyb206ICd0cmFuc3BhcmVudCdcbiAgICAgIH0sXG4gICAgICB2aXNpYmxlOiB7XG4gICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgZHVyYXRpb246IDBcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuICBoaWRlOiB7XG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgY29sb3JzOiB7XG4gICAgICAgIHRvOiAndHJhbnNwYXJlbnQnXG4gICAgICB9LFxuICAgICAgdmlzaWJsZToge1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgIGVhc2luZzogJ2xpbmVhcicsXG4gICAgICAgIGZuOiB2ID0+IHYgfCAwXG4gICAgICB9LFxuICAgIH1cbiAgfVxufSk7XG5jbGFzcyBBbmltYXRpb25zIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGNvbmZpZykge1xuICAgIHRoaXMuX2NoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5fcHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmNvbmZpZ3VyZShjb25maWcpO1xuICB9XG4gIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICBpZiAoIWlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY29uZmlnKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBjZmcgPSBjb25maWdba2V5XTtcbiAgICAgIGlmICghaXNPYmplY3QoY2ZnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgYW5pbWF0aW9uT3B0aW9ucykge1xuICAgICAgICByZXNvbHZlZFtvcHRpb25dID0gY2ZnW29wdGlvbl07XG4gICAgICB9XG4gICAgICAoaXNBcnJheShjZmcucHJvcGVydGllcykgJiYgY2ZnLnByb3BlcnRpZXMgfHwgW2tleV0pLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgaWYgKHByb3AgPT09IGtleSB8fCAhYW5pbWF0ZWRQcm9wcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICBhbmltYXRlZFByb3BzLnNldChwcm9wLCByZXNvbHZlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSB2YWx1ZXMub3B0aW9ucztcbiAgICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnMob3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgaWYgKG5ld09wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgYXdhaXRBbGwodGFyZ2V0Lm9wdGlvbnMuJGFuaW1hdGlvbnMsIG5ld09wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgY29uc3QgcnVubmluZyA9IHRhcmdldC4kYW5pbWF0aW9ucyB8fCAodGFyZ2V0LiRhbmltYXRpb25zID0ge30pO1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXModmFsdWVzKTtcbiAgICBjb25zdCBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSBwcm9wcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHByb3AuY2hhckF0KDApID09PSAnJCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcCA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaCguLi50aGlzLl9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3Byb3BdO1xuICAgICAgbGV0IGFuaW1hdGlvbiA9IHJ1bm5pbmdbcHJvcF07XG4gICAgICBjb25zdCBjZmcgPSBhbmltYXRlZFByb3BzLmdldChwcm9wKTtcbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgaWYgKGNmZyAmJiBhbmltYXRpb24uYWN0aXZlKCkpIHtcbiAgICAgICAgICBhbmltYXRpb24udXBkYXRlKGNmZywgdmFsdWUsIGRhdGUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjZmcgfHwgIWNmZy5kdXJhdGlvbikge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBydW5uaW5nW3Byb3BdID0gYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihjZmcsIHRhcmdldCwgcHJvcCwgdmFsdWUpO1xuICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIHVwZGF0ZSh0YXJnZXQsIHZhbHVlcykge1xuICAgIGlmICh0aGlzLl9wcm9wZXJ0aWVzLnNpemUgPT09IDApIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB2YWx1ZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcyk7XG4gICAgaWYgKGFuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICBhbmltYXRvci5hZGQodGhpcy5fY2hhcnQsIGFuaW1hdGlvbnMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhd2FpdEFsbChhbmltYXRpb25zLCBwcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IHJ1bm5pbmcgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhbmltID0gYW5pbWF0aW9uc1trZXlzW2ldXTtcbiAgICBpZiAoYW5pbSAmJiBhbmltLmFjdGl2ZSgpKSB7XG4gICAgICBydW5uaW5nLnB1c2goYW5pbS53YWl0KCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwocnVubmluZyk7XG59XG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpIHtcbiAgaWYgKCFuZXdPcHRpb25zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvcHRpb25zID0gdGFyZ2V0Lm9wdGlvbnM7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9wdGlvbnMuJHNoYXJlZCkge1xuICAgIHRhcmdldC5vcHRpb25zID0gb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHskc2hhcmVkOiBmYWxzZSwgJGFuaW1hdGlvbnM6IHt9fSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHNjYWxlQ2xpcChzY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zIHx8IHt9O1xuICBjb25zdCByZXZlcnNlID0gb3B0cy5yZXZlcnNlO1xuICBjb25zdCBtaW4gPSBvcHRzLm1pbiA9PT0gdW5kZWZpbmVkID8gYWxsb3dlZE92ZXJmbG93IDogMDtcbiAgY29uc3QgbWF4ID0gb3B0cy5tYXggPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHJldmVyc2UgPyBtYXggOiBtaW4sXG4gICAgZW5kOiByZXZlcnNlID8gbWluIDogbWF4XG4gIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xpcCh4U2NhbGUsIHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGlmIChhbGxvd2VkT3ZlcmZsb3cgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHggPSBzY2FsZUNsaXAoeFNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpO1xuICBjb25zdCB5ID0gc2NhbGVDbGlwKHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IHkuZW5kLFxuICAgIHJpZ2h0OiB4LmVuZCxcbiAgICBib3R0b206IHkuc3RhcnQsXG4gICAgbGVmdDogeC5zdGFydFxuICB9O1xufVxuZnVuY3Rpb24gdG9DbGlwKHZhbHVlKSB7XG4gIGxldCB0LCByLCBiLCBsO1xuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdCA9IHZhbHVlLnRvcDtcbiAgICByID0gdmFsdWUucmlnaHQ7XG4gICAgYiA9IHZhbHVlLmJvdHRvbTtcbiAgICBsID0gdmFsdWUubGVmdDtcbiAgfSBlbHNlIHtcbiAgICB0ID0gciA9IGIgPSBsID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHQsXG4gICAgcmlnaHQ6IHIsXG4gICAgYm90dG9tOiBiLFxuICAgIGxlZnQ6IGwsXG4gICAgZGlzYWJsZWQ6IHZhbHVlID09PSBmYWxzZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIGZpbHRlclZpc2libGUpIHtcbiAgY29uc3Qga2V5cyA9IFtdO1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSk7XG4gIGxldCBpLCBpbGVuO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5cy5wdXNoKG1ldGFzZXRzW2ldLmluZGV4KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIGFwcGx5U3RhY2soc3RhY2ssIHZhbHVlLCBkc0luZGV4LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qga2V5cyA9IHN0YWNrLmtleXM7XG4gIGNvbnN0IHNpbmdsZU1vZGUgPSBvcHRpb25zLm1vZGUgPT09ICdzaW5nbGUnO1xuICBsZXQgaSwgaWxlbiwgZGF0YXNldEluZGV4LCBvdGhlclZhbHVlO1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgZGF0YXNldEluZGV4ID0gK2tleXNbaV07XG4gICAgaWYgKGRhdGFzZXRJbmRleCA9PT0gZHNJbmRleCkge1xuICAgICAgaWYgKG9wdGlvbnMuYWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG90aGVyVmFsdWUgPSBzdGFjay52YWx1ZXNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAoaXNOdW1iZXJGaW5pdGUob3RoZXJWYWx1ZSkgJiYgKHNpbmdsZU1vZGUgfHwgKHZhbHVlID09PSAwIHx8IHNpZ24odmFsdWUpID09PSBzaWduKG90aGVyVmFsdWUpKSkpIHtcbiAgICAgIHZhbHVlICs9IG90aGVyVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgY29uc3QgYWRhdGEgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICBsZXQgaSwgaWxlbiwga2V5O1xuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIGFkYXRhW2ldID0ge1xuICAgICAgeDoga2V5LFxuICAgICAgeTogZGF0YVtrZXldXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYWRhdGE7XG59XG5mdW5jdGlvbiBpc1N0YWNrZWQoc2NhbGUsIG1ldGEpIHtcbiAgY29uc3Qgc3RhY2tlZCA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgcmV0dXJuIHN0YWNrZWQgfHwgKHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gZ2V0U3RhY2tLZXkoaW5kZXhTY2FsZSwgdmFsdWVTY2FsZSwgbWV0YSkge1xuICByZXR1cm4gYCR7aW5kZXhTY2FsZS5pZH0uJHt2YWx1ZVNjYWxlLmlkfS4ke21ldGEuc3RhY2sgfHwgbWV0YS50eXBlfWA7XG59XG5mdW5jdGlvbiBnZXRVc2VyQm91bmRzKHNjYWxlKSB7XG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBzY2FsZS5nZXRVc2VyQm91bmRzKCk7XG4gIHJldHVybiB7XG4gICAgbWluOiBtaW5EZWZpbmVkID8gbWluIDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgIG1heDogbWF4RGVmaW5lZCA/IG1heCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIHN0YWNrS2V5LCBpbmRleFZhbHVlKSB7XG4gIGNvbnN0IHN1YlN0YWNrID0gc3RhY2tzW3N0YWNrS2V5XSB8fCAoc3RhY2tzW3N0YWNrS2V5XSA9IHt9KTtcbiAgcmV0dXJuIHN1YlN0YWNrW2luZGV4VmFsdWVdIHx8IChzdWJTdGFja1tpbmRleFZhbHVlXSA9IHt9KTtcbn1cbmZ1bmN0aW9uIGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgcG9zaXRpdmUsIHR5cGUpIHtcbiAgZm9yIChjb25zdCBtZXRhIG9mIHZTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKS5yZXZlcnNlKCkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0YWNrW21ldGEuaW5kZXhdO1xuICAgIGlmICgocG9zaXRpdmUgJiYgdmFsdWUgPiAwKSB8fCAoIXBvc2l0aXZlICYmIHZhbHVlIDwgMCkpIHtcbiAgICAgIHJldHVybiBtZXRhLmluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN0YWNrcyhjb250cm9sbGVyLCBwYXJzZWQpIHtcbiAgY29uc3Qge2NoYXJ0LCBfY2FjaGVkTWV0YTogbWV0YX0gPSBjb250cm9sbGVyO1xuICBjb25zdCBzdGFja3MgPSBjaGFydC5fc3RhY2tzIHx8IChjaGFydC5fc3RhY2tzID0ge30pO1xuICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIGluZGV4OiBkYXRhc2V0SW5kZXh9ID0gbWV0YTtcbiAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgY29uc3Qga2V5ID0gZ2V0U3RhY2tLZXkoaVNjYWxlLCB2U2NhbGUsIG1ldGEpO1xuICBjb25zdCBpbGVuID0gcGFyc2VkLmxlbmd0aDtcbiAgbGV0IHN0YWNrO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IGl0ZW0gPSBwYXJzZWRbaV07XG4gICAgY29uc3Qge1tpQXhpc106IGluZGV4LCBbdkF4aXNdOiB2YWx1ZX0gPSBpdGVtO1xuICAgIGNvbnN0IGl0ZW1TdGFja3MgPSBpdGVtLl9zdGFja3MgfHwgKGl0ZW0uX3N0YWNrcyA9IHt9KTtcbiAgICBzdGFjayA9IGl0ZW1TdGFja3NbdkF4aXNdID0gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIGtleSwgaW5kZXgpO1xuICAgIHN0YWNrW2RhdGFzZXRJbmRleF0gPSB2YWx1ZTtcbiAgICBzdGFjay5fdG9wID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCB0cnVlLCBtZXRhLnR5cGUpO1xuICAgIHN0YWNrLl9ib3R0b20gPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIGZhbHNlLCBtZXRhLnR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsIGF4aXMpIHtcbiAgY29uc3Qgc2NhbGVzID0gY2hhcnQuc2NhbGVzO1xuICByZXR1cm4gT2JqZWN0LmtleXMoc2NhbGVzKS5maWx0ZXIoa2V5ID0+IHNjYWxlc1trZXldLmF4aXMgPT09IGF4aXMpLnNoaWZ0KCk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhc2V0Q29udGV4dChwYXJlbnQsIGluZGV4KSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCxcbiAgICB7XG4gICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgZGF0YXNldDogdW5kZWZpbmVkLFxuICAgICAgZGF0YXNldEluZGV4OiBpbmRleCxcbiAgICAgIGluZGV4LFxuICAgICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgICAgdHlwZTogJ2RhdGFzZXQnXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlRGF0YUNvbnRleHQocGFyZW50LCBpbmRleCwgZWxlbWVudCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIGRhdGFJbmRleDogaW5kZXgsXG4gICAgcGFyc2VkOiB1bmRlZmluZWQsXG4gICAgcmF3OiB1bmRlZmluZWQsXG4gICAgZWxlbWVudCxcbiAgICBpbmRleCxcbiAgICBtb2RlOiAnZGVmYXVsdCcsXG4gICAgdHlwZTogJ2RhdGEnXG4gIH0pO1xufVxuZnVuY3Rpb24gY2xlYXJTdGFja3MobWV0YSwgaXRlbXMpIHtcbiAgY29uc3QgZGF0YXNldEluZGV4ID0gbWV0YS5jb250cm9sbGVyLmluZGV4O1xuICBjb25zdCBheGlzID0gbWV0YS52U2NhbGUgJiYgbWV0YS52U2NhbGUuYXhpcztcbiAgaWYgKCFheGlzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGl0ZW1zID0gaXRlbXMgfHwgbWV0YS5fcGFyc2VkO1xuICBmb3IgKGNvbnN0IHBhcnNlZCBvZiBpdGVtcykge1xuICAgIGNvbnN0IHN0YWNrcyA9IHBhcnNlZC5fc3RhY2tzO1xuICAgIGlmICghc3RhY2tzIHx8IHN0YWNrc1theGlzXSA9PT0gdW5kZWZpbmVkIHx8IHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdO1xuICB9XG59XG5jb25zdCBpc0RpcmVjdFVwZGF0ZU1vZGUgPSAobW9kZSkgPT4gbW9kZSA9PT0gJ3Jlc2V0JyB8fCBtb2RlID09PSAnbm9uZSc7XG5jb25zdCBjbG9uZUlmTm90U2hhcmVkID0gKGNhY2hlZCwgc2hhcmVkKSA9PiBzaGFyZWQgPyBjYWNoZWQgOiBPYmplY3QuYXNzaWduKHt9LCBjYWNoZWQpO1xuY29uc3QgY3JlYXRlU3RhY2sgPSAoY2FuU3RhY2ssIG1ldGEsIGNoYXJ0KSA9PiBjYW5TdGFjayAmJiAhbWV0YS5oaWRkZW4gJiYgbWV0YS5fc3RhY2tlZFxuICAmJiB7a2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLCB2YWx1ZXM6IG51bGx9O1xuY2xhc3MgRGF0YXNldENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX2N0eCA9IGNoYXJ0LmN0eDtcbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gICAgdGhpcy5fY2FjaGVkTWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuICAgIHRoaXMuX3R5cGUgPSB0aGlzLl9jYWNoZWRNZXRhLnR5cGU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BhcnNpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29iamVjdERhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2hhcmVkT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kcmF3U3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuICBpbml0aWFsaXplKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMuY29uZmlndXJlKCk7XG4gICAgdGhpcy5saW5rU2NhbGVzKCk7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG4gICAgdGhpcy5hZGRFbGVtZW50cygpO1xuICB9XG4gIHVwZGF0ZUluZGV4KGRhdGFzZXRJbmRleCkge1xuICAgIGlmICh0aGlzLmluZGV4ICE9PSBkYXRhc2V0SW5kZXgpIHtcbiAgICAgIGNsZWFyU3RhY2tzKHRoaXMuX2NhY2hlZE1ldGEpO1xuICAgIH1cbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICB9XG4gIGxpbmtTY2FsZXMoKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBjaG9vc2VJZCA9IChheGlzLCB4LCB5LCByKSA9PiBheGlzID09PSAneCcgPyB4IDogYXhpcyA9PT0gJ3InID8gciA6IHk7XG4gICAgY29uc3QgeGlkID0gbWV0YS54QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC54QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd4JykpO1xuICAgIGNvbnN0IHlpZCA9IG1ldGEueUF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueUF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneScpKTtcbiAgICBjb25zdCByaWQgPSBtZXRhLnJBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnJBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3InKSk7XG4gICAgY29uc3QgaW5kZXhBeGlzID0gbWV0YS5pbmRleEF4aXM7XG4gICAgY29uc3QgaWlkID0gbWV0YS5pQXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB4aWQsIHlpZCwgcmlkKTtcbiAgICBjb25zdCB2aWQgPSBtZXRhLnZBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHlpZCwgeGlkLCByaWQpO1xuICAgIG1ldGEueFNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHhpZCk7XG4gICAgbWV0YS55U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoeWlkKTtcbiAgICBtZXRhLnJTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChyaWQpO1xuICAgIG1ldGEuaVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKGlpZCk7XG4gICAgbWV0YS52U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQodmlkKTtcbiAgfVxuICBnZXREYXRhc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbdGhpcy5pbmRleF07XG4gIH1cbiAgZ2V0TWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YSh0aGlzLmluZGV4KTtcbiAgfVxuICBnZXRTY2FsZUZvcklkKHNjYWxlSUQpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5zY2FsZXNbc2NhbGVJRF07XG4gIH1cbiAgX2dldE90aGVyU2NhbGUoc2NhbGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICByZXR1cm4gc2NhbGUgPT09IG1ldGEuaVNjYWxlXG4gICAgICA/IG1ldGEudlNjYWxlXG4gICAgICA6IG1ldGEuaVNjYWxlO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3VwZGF0ZSgncmVzZXQnKTtcbiAgfVxuICBfZGVzdHJveSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyh0aGlzLl9kYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgIH1cbiAgfVxuICBfZGF0YUNoZWNrKCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBkYXRhID0gZGF0YXNldC5kYXRhIHx8IChkYXRhc2V0LmRhdGEgPSBbXSk7XG4gICAgY29uc3QgX2RhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGlmIChpc09iamVjdChkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKF9kYXRhICE9PSBkYXRhKSB7XG4gICAgICBpZiAoX2RhdGEpIHtcbiAgICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyhfZGF0YSwgdGhpcyk7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgICAgbWV0YS5fcGFyc2VkID0gW107XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGRhdGEpKSB7XG4gICAgICAgIGxpc3RlbkFycmF5RXZlbnRzKGRhdGEsIHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgfVxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcbiAgICBpZiAodGhpcy5kYXRhc2V0RWxlbWVudFR5cGUpIHtcbiAgICAgIG1ldGEuZGF0YXNldCA9IG5ldyB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSgpO1xuICAgIH1cbiAgfVxuICBidWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBsZXQgc3RhY2tDaGFuZ2VkID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YUNoZWNrKCk7XG4gICAgY29uc3Qgb2xkU3RhY2tlZCA9IG1ldGEuX3N0YWNrZWQ7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG4gICAgaWYgKG1ldGEuc3RhY2sgIT09IGRhdGFzZXQuc3RhY2spIHtcbiAgICAgIHN0YWNrQ2hhbmdlZCA9IHRydWU7XG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgIG1ldGEuc3RhY2sgPSBkYXRhc2V0LnN0YWNrO1xuICAgIH1cbiAgICB0aGlzLl9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKTtcbiAgICBpZiAoc3RhY2tDaGFuZ2VkIHx8IG9sZFN0YWNrZWQgIT09IG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgIHVwZGF0ZVN0YWNrcyh0aGlzLCBtZXRhLl9wYXJzZWQpO1xuICAgIH1cbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRTY29wZUtleXModGhpcy5fdHlwZSk7XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzLCB0cnVlKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5fcGFyc2luZyA9IHRoaXMub3B0aW9ucy5wYXJzaW5nO1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gIH1cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiBtZXRhLCBfZGF0YTogZGF0YX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpU2NhbGUsIF9zdGFja2VkfSA9IG1ldGE7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBsZXQgc29ydGVkID0gc3RhcnQgPT09IDAgJiYgY291bnQgPT09IGRhdGEubGVuZ3RoID8gdHJ1ZSA6IG1ldGEuX3NvcnRlZDtcbiAgICBsZXQgcHJldiA9IHN0YXJ0ID4gMCAmJiBtZXRhLl9wYXJzZWRbc3RhcnQgLSAxXTtcbiAgICBsZXQgaSwgY3VyLCBwYXJzZWQ7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgICAgbWV0YS5fc29ydGVkID0gdHJ1ZTtcbiAgICAgIHBhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0FycmF5KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2ID0gKCkgPT4gY3VyW2lBeGlzXSA9PT0gbnVsbCB8fCAocHJldiAmJiBjdXJbaUF4aXNdIDwgcHJldltpQXhpc10pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2kgKyBzdGFydF0gPSBjdXIgPSBwYXJzZWRbaV07XG4gICAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgICBpZiAoaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYoKSkge1xuICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1ldGEuX3NvcnRlZCA9IHNvcnRlZDtcbiAgICB9XG4gICAgaWYgKF9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3ModGhpcywgcGFyc2VkKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICBbaUF4aXNdOiBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2luZGV4XSwgaW5kZXgpLFxuICAgICAgICBbdkF4aXNdOiB2U2NhbGUucGFyc2UoZGF0YVtpbmRleF0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UoaXRlbVswXSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UoaXRlbVsxXSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeEF4aXNLZXkpLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHlBeGlzS2V5KSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIGdldFBhcnNlZChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWRbaW5kZXhdO1xuICB9XG4gIGdldERhdGFFbGVtZW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gIH1cbiAgYXBwbHlTdGFjayhzY2FsZSwgcGFyc2VkLCBtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGNvbnN0IHN0YWNrID0ge1xuICAgICAga2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLFxuICAgICAgdmFsdWVzOiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXVxuICAgIH07XG4gICAgcmV0dXJuIGFwcGx5U3RhY2soc3RhY2ssIHZhbHVlLCBtZXRhLmluZGV4LCB7bW9kZX0pO1xuICB9XG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlZFtzY2FsZS5heGlzXTtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZWRWYWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHBhcnNlZFZhbHVlO1xuICAgIGNvbnN0IHZhbHVlcyA9IHN0YWNrICYmIHBhcnNlZC5fc3RhY2tzW3NjYWxlLmF4aXNdO1xuICAgIGlmIChzdGFjayAmJiB2YWx1ZXMpIHtcbiAgICAgIHN0YWNrLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgIHZhbHVlID0gYXBwbHlTdGFjayhzdGFjaywgcGFyc2VkVmFsdWUsIHRoaXMuX2NhY2hlZE1ldGEuaW5kZXgpO1xuICAgIH1cbiAgICByYW5nZS5taW4gPSBNYXRoLm1pbihyYW5nZS5taW4sIHZhbHVlKTtcbiAgICByYW5nZS5tYXggPSBNYXRoLm1heChyYW5nZS5tYXgsIHZhbHVlKTtcbiAgfVxuICBnZXRNaW5NYXgoc2NhbGUsIGNhblN0YWNrKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgX3BhcnNlZCA9IG1ldGEuX3BhcnNlZDtcbiAgICBjb25zdCBzb3J0ZWQgPSBtZXRhLl9zb3J0ZWQgJiYgc2NhbGUgPT09IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IGlsZW4gPSBfcGFyc2VkLmxlbmd0aDtcbiAgICBjb25zdCBvdGhlclNjYWxlID0gdGhpcy5fZ2V0T3RoZXJTY2FsZShzY2FsZSk7XG4gICAgY29uc3Qgc3RhY2sgPSBjcmVhdGVTdGFjayhjYW5TdGFjaywgbWV0YSwgdGhpcy5jaGFydCk7XG4gICAgY29uc3QgcmFuZ2UgPSB7bWluOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1heDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZfTtcbiAgICBjb25zdCB7bWluOiBvdGhlck1pbiwgbWF4OiBvdGhlck1heH0gPSBnZXRVc2VyQm91bmRzKG90aGVyU2NhbGUpO1xuICAgIGxldCBpLCBwYXJzZWQ7XG4gICAgZnVuY3Rpb24gX3NraXAoKSB7XG4gICAgICBwYXJzZWQgPSBfcGFyc2VkW2ldO1xuICAgICAgY29uc3Qgb3RoZXJWYWx1ZSA9IHBhcnNlZFtvdGhlclNjYWxlLmF4aXNdO1xuICAgICAgcmV0dXJuICFpc051bWJlckZpbml0ZShwYXJzZWRbc2NhbGUuYXhpc10pIHx8IG90aGVyTWluID4gb3RoZXJWYWx1ZSB8fCBvdGhlck1heCA8IG90aGVyVmFsdWU7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgIGZvciAoaSA9IGlsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cbiAgZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcGFyc2VkLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdmFsdWUgPSBwYXJzZWRbaV1bc2NhbGUuYXhpc107XG4gICAgICBpZiAoaXNOdW1iZXJGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGlTY2FsZSA/ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSkgOiAnJyxcbiAgICAgIHZhbHVlOiB2U2NhbGUgPyAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pIDogJydcbiAgICB9O1xuICB9XG4gIF91cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMudXBkYXRlKG1vZGUgfHwgJ2RlZmF1bHQnKTtcbiAgICBtZXRhLl9jbGlwID0gdG9DbGlwKHZhbHVlT3JEZWZhdWx0KHRoaXMub3B0aW9ucy5jbGlwLCBkZWZhdWx0Q2xpcChtZXRhLnhTY2FsZSwgbWV0YS55U2NhbGUsIHRoaXMuZ2V0TWF4T3ZlcmZsb3coKSkpKTtcbiAgfVxuICB1cGRhdGUobW9kZSkge31cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9jdHg7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3QgYWN0aXZlID0gW107XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9kcmF3U3RhcnQgfHwgMDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2RyYXdDb3VudCB8fCAoZWxlbWVudHMubGVuZ3RoIC0gc3RhcnQpO1xuICAgIGNvbnN0IGRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdGhpcy5vcHRpb25zLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wO1xuICAgIGxldCBpO1xuICAgIGlmIChtZXRhLmRhdGFzZXQpIHtcbiAgICAgIG1ldGEuZGF0YXNldC5kcmF3KGN0eCwgYXJlYSwgc3RhcnQsIGNvdW50KTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmIChlbGVtZW50LmhpZGRlbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50LmFjdGl2ZSAmJiBkcmF3QWN0aXZlRWxlbWVudHNPblRvcCkge1xuICAgICAgICBhY3RpdmUucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuZHJhdyhjdHgsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgKytpKSB7XG4gICAgICBhY3RpdmVbaV0uZHJhdyhjdHgsIGFyZWEpO1xuICAgIH1cbiAgfVxuICBnZXRTdHlsZShpbmRleCwgYWN0aXZlKSB7XG4gICAgY29uc3QgbW9kZSA9IGFjdGl2ZSA/ICdhY3RpdmUnIDogJ2RlZmF1bHQnO1xuICAgIHJldHVybiBpbmRleCA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldFxuICAgICAgPyB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSlcbiAgICAgIDogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4IHx8IDAsIG1vZGUpO1xuICB9XG4gIGdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgbW9kZSkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBsZXQgY29udGV4dDtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX2NhY2hlZE1ldGEuZGF0YS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFbaW5kZXhdO1xuICAgICAgY29udGV4dCA9IGVsZW1lbnQuJGNvbnRleHQgfHxcbiAgICAgICAgKGVsZW1lbnQuJGNvbnRleHQgPSBjcmVhdGVEYXRhQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIGVsZW1lbnQpKTtcbiAgICAgIGNvbnRleHQucGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgICAgY29udGV4dC5yYXcgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuICAgICAgY29udGV4dC5pbmRleCA9IGNvbnRleHQuZGF0YUluZGV4ID0gaW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzLiRjb250ZXh0IHx8XG4gICAgICAgICh0aGlzLiRjb250ZXh0ID0gY3JlYXRlRGF0YXNldENvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMuaW5kZXgpKTtcbiAgICAgIGNvbnRleHQuZGF0YXNldCA9IGRhdGFzZXQ7XG4gICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgIH1cbiAgICBjb250ZXh0LmFjdGl2ZSA9ICEhYWN0aXZlO1xuICAgIGNvbnRleHQubW9kZSA9IG1vZGU7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbiAgcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZS5pZCwgbW9kZSk7XG4gIH1cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhRWxlbWVudFR5cGUuaWQsIG1vZGUsIGluZGV4KTtcbiAgfVxuICBfcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGVsZW1lbnRUeXBlLCBtb2RlID0gJ2RlZmF1bHQnLCBpbmRleCkge1xuICAgIGNvbnN0IGFjdGl2ZSA9IG1vZGUgPT09ICdhY3RpdmUnO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkRGF0YU9wdHM7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBlbGVtZW50VHlwZSArICctJyArIG1vZGU7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGNvbnN0IHNoYXJpbmcgPSB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgJiYgZGVmaW5lZChpbmRleCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNsb25lSWZOb3RTaGFyZWQoY2FjaGVkLCBzaGFyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKHRoaXMuX3R5cGUsIGVsZW1lbnRUeXBlKTtcbiAgICBjb25zdCBwcmVmaXhlcyA9IGFjdGl2ZSA/IFtgJHtlbGVtZW50VHlwZX1Ib3ZlcmAsICdob3ZlcicsIGVsZW1lbnRUeXBlLCAnJ10gOiBbZWxlbWVudFR5cGUsICcnXTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuZWxlbWVudHNbZWxlbWVudFR5cGVdKTtcbiAgICBjb25zdCBjb250ZXh0ID0gKCkgPT4gdGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUpO1xuICAgIGNvbnN0IHZhbHVlcyA9IGNvbmZpZy5yZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzKTtcbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIHZhbHVlcy4kc2hhcmVkID0gc2hhcmluZztcbiAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IE9iamVjdC5mcmVlemUoY2xvbmVJZk5vdFNoYXJlZCh2YWx1ZXMsIHNoYXJpbmcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICBfcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIHRyYW5zaXRpb24sIGFjdGl2ZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYGFuaW1hdGlvbi0ke3RyYW5zaXRpb259YDtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICE9PSBmYWxzZSkge1xuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyh0aGlzLl90eXBlLCB0cmFuc2l0aW9uKTtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XG4gICAgICBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIHRyYW5zaXRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKGNoYXJ0LCBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5fY2FjaGVhYmxlKSB7XG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICBnZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2hhcmVkT3B0aW9ucyB8fCAodGhpcy5fc2hhcmVkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgfVxuICBpbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKSB7XG4gICAgcmV0dXJuICFzaGFyZWRPcHRpb25zIHx8IGlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSB8fCB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gIH1cbiAgdXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgcHJvcGVydGllcywgbW9kZSkge1xuICAgIGlmIChpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlKS51cGRhdGUoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgbmV3T3B0aW9ucykge1xuICAgIGlmIChzaGFyZWRPcHRpb25zICYmICFpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKHVuZGVmaW5lZCwgbW9kZSkudXBkYXRlKHNoYXJlZE9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBfc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsIG1vZGUsIGFjdGl2ZSkge1xuICAgIGVsZW1lbnQuYWN0aXZlID0gYWN0aXZlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldFN0eWxlKGluZGV4LCBhY3RpdmUpO1xuICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlLCBhY3RpdmUpLnVwZGF0ZShlbGVtZW50LCB7XG4gICAgICBvcHRpb25zOiAoIWFjdGl2ZSAmJiB0aGlzLmdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykpIHx8IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICByZW1vdmVIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgfVxuICBzZXRIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIHRydWUpO1xuICB9XG4gIF9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCB1bmRlZmluZWQsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIF9zZXREYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCB1bmRlZmluZWQsICdhY3RpdmUnLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICBmb3IgKGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdIG9mIHRoaXMuX3N5bmNMaXN0KSB7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgY29uc3QgbnVtTWV0YSA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICBjb25zdCBudW1EYXRhID0gZGF0YS5sZW5ndGg7XG4gICAgY29uc3QgY291bnQgPSBNYXRoLm1pbihudW1EYXRhLCBudW1NZXRhKTtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMucGFyc2UoMCwgY291bnQpO1xuICAgIH1cbiAgICBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX2luc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhLCByZXNldE5ld0VsZW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKG51bURhdGEgPCBudW1NZXRhKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFbGVtZW50cyhudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICB9XG4gIF9pbnNlcnRFbGVtZW50cyhzdGFydCwgY291bnQsIHJlc2V0TmV3RWxlbWVudHMgPSB0cnVlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgIGxldCBpO1xuICAgIGNvbnN0IG1vdmUgPSAoYXJyKSA9PiB7XG4gICAgICBhcnIubGVuZ3RoICs9IGNvdW50O1xuICAgICAgZm9yIChpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gZW5kOyBpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyW2kgLSBjb3VudF07XG4gICAgICB9XG4gICAgfTtcbiAgICBtb3ZlKGRhdGEpO1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIGRhdGFbaV0gPSBuZXcgdGhpcy5kYXRhRWxlbWVudFR5cGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIG1vdmUobWV0YS5fcGFyc2VkKTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZShzdGFydCwgY291bnQpO1xuICAgIGlmIChyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGRhdGEsIHN0YXJ0LCBjb3VudCwgJ3Jlc2V0Jyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGVsZW1lbnQsIHN0YXJ0LCBjb3VudCwgbW9kZSkge31cbiAgX3JlbW92ZUVsZW1lbnRzKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBjb25zdCByZW1vdmVkID0gbWV0YS5fcGFyc2VkLnNwbGljZShzdGFydCwgY291bnQpO1xuICAgICAgaWYgKG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSwgcmVtb3ZlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIG1ldGEuZGF0YS5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgfVxuICBfc3luYyhhcmdzKSB7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIHRoaXMuX3N5bmNMaXN0LnB1c2goYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdID0gYXJncztcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5jaGFydC5fZGF0YUNoYW5nZXMucHVzaChbdGhpcy5pbmRleCwgLi4uYXJnc10pO1xuICB9XG4gIF9vbkRhdGFQdXNoKCkge1xuICAgIGNvbnN0IGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgdGhpcy5nZXREYXRhc2V0KCkuZGF0YS5sZW5ndGggLSBjb3VudCwgY291bnRdKTtcbiAgfVxuICBfb25EYXRhUG9wKCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoIC0gMSwgMV0pO1xuICB9XG4gIF9vbkRhdGFTaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgMCwgMV0pO1xuICB9XG4gIF9vbkRhdGFTcGxpY2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgc3RhcnQsIGNvdW50XSk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgaWYgKG5ld0NvdW50KSB7XG4gICAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgc3RhcnQsIG5ld0NvdW50XSk7XG4gICAgfVxuICB9XG4gIF9vbkRhdGFVbnNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCAwLCBhcmd1bWVudHMubGVuZ3RoXSk7XG4gIH1cbn1cbkRhdGFzZXRDb250cm9sbGVyLmRlZmF1bHRzID0ge307XG5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuZGF0YXNldEVsZW1lbnRUeXBlID0gbnVsbDtcbkRhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5kYXRhRWxlbWVudFR5cGUgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgdHlwZSkge1xuICBpZiAoIXNjYWxlLl9jYWNoZS4kYmFyKSB7XG4gICAgY29uc3QgdmlzaWJsZU1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSk7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdmlzaWJsZU1ldGFzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh2aXNpYmxlTWV0YXNbaV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXMoc2NhbGUpKTtcbiAgICB9XG4gICAgc2NhbGUuX2NhY2hlLiRiYXIgPSBfYXJyYXlVbmlxdWUodmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKSk7XG4gIH1cbiAgcmV0dXJuIHNjYWxlLl9jYWNoZS4kYmFyO1xufVxuZnVuY3Rpb24gY29tcHV0ZU1pblNhbXBsZVNpemUobWV0YSkge1xuICBjb25zdCBzY2FsZSA9IG1ldGEuaVNjYWxlO1xuICBjb25zdCB2YWx1ZXMgPSBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgbWV0YS50eXBlKTtcbiAgbGV0IG1pbiA9IHNjYWxlLl9sZW5ndGg7XG4gIGxldCBpLCBpbGVuLCBjdXJyLCBwcmV2O1xuICBjb25zdCB1cGRhdGVNaW5BbmRQcmV2ID0gKCkgPT4ge1xuICAgIGlmIChjdXJyID09PSAzMjc2NyB8fCBjdXJyID09PSAtMzI3NjgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRlZmluZWQocHJldikpIHtcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5hYnMoY3VyciAtIHByZXYpIHx8IG1pbik7XG4gICAgfVxuICAgIHByZXYgPSBjdXJyO1xuICB9O1xuICBmb3IgKGkgPSAwLCBpbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlc1tpXSk7XG4gICAgdXBkYXRlTWluQW5kUHJldigpO1xuICB9XG4gIHByZXYgPSB1bmRlZmluZWQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBzY2FsZS50aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGkpO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuICByZXR1cm4gbWluO1xufVxuZnVuY3Rpb24gY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCB0aGlja25lc3MgPSBvcHRpb25zLmJhclRoaWNrbmVzcztcbiAgbGV0IHNpemUsIHJhdGlvO1xuICBpZiAoaXNOdWxsT3JVbmRlZih0aGlja25lc3MpKSB7XG4gICAgc2l6ZSA9IHJ1bGVyLm1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICAgIHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSB0aGlja25lc3MgKiBzdGFja0NvdW50O1xuICAgIHJhdGlvID0gMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNodW5rOiBzaXplIC8gc3RhY2tDb3VudCxcbiAgICByYXRpbyxcbiAgICBzdGFydDogcnVsZXIucGl4ZWxzW2luZGV4XSAtIChzaXplIC8gMilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KSB7XG4gIGNvbnN0IHBpeGVscyA9IHJ1bGVyLnBpeGVscztcbiAgY29uc3QgY3VyciA9IHBpeGVsc1tpbmRleF07XG4gIGxldCBwcmV2ID0gaW5kZXggPiAwID8gcGl4ZWxzW2luZGV4IC0gMV0gOiBudWxsO1xuICBsZXQgbmV4dCA9IGluZGV4IDwgcGl4ZWxzLmxlbmd0aCAtIDEgPyBwaXhlbHNbaW5kZXggKyAxXSA6IG51bGw7XG4gIGNvbnN0IHBlcmNlbnQgPSBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICBwcmV2ID0gY3VyciAtIChuZXh0ID09PSBudWxsID8gcnVsZXIuZW5kIC0gcnVsZXIuc3RhcnQgOiBuZXh0IC0gY3Vycik7XG4gIH1cbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICBuZXh0ID0gY3VyciArIGN1cnIgLSBwcmV2O1xuICB9XG4gIGNvbnN0IHN0YXJ0ID0gY3VyciAtIChjdXJyIC0gTWF0aC5taW4ocHJldiwgbmV4dCkpIC8gMiAqIHBlcmNlbnQ7XG4gIGNvbnN0IHNpemUgPSBNYXRoLmFicyhuZXh0IC0gcHJldikgLyAyICogcGVyY2VudDtcbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW86IG9wdGlvbnMuYmFyUGVyY2VudGFnZSxcbiAgICBzdGFydFxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGNvbnN0IHN0YXJ0VmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMF0sIGkpO1xuICBjb25zdCBlbmRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVsxXSwgaSk7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBsZXQgYmFyU3RhcnQgPSBtaW47XG4gIGxldCBiYXJFbmQgPSBtYXg7XG4gIGlmIChNYXRoLmFicyhtaW4pID4gTWF0aC5hYnMobWF4KSkge1xuICAgIGJhclN0YXJ0ID0gbWF4O1xuICAgIGJhckVuZCA9IG1pbjtcbiAgfVxuICBpdGVtW3ZTY2FsZS5heGlzXSA9IGJhckVuZDtcbiAgaXRlbS5fY3VzdG9tID0ge1xuICAgIGJhclN0YXJ0LFxuICAgIGJhckVuZCxcbiAgICBzdGFydDogc3RhcnRWYWx1ZSxcbiAgICBlbmQ6IGVuZFZhbHVlLFxuICAgIG1pbixcbiAgICBtYXhcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBpZiAoaXNBcnJheShlbnRyeSkpIHtcbiAgICBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpO1xuICB9IGVsc2Uge1xuICAgIGl0ZW1bdlNjYWxlLmF4aXNdID0gdlNjYWxlLnBhcnNlKGVudHJ5LCBpKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gIGNvbnN0IHBhcnNlZCA9IFtdO1xuICBsZXQgaSwgaWxlbiwgaXRlbSwgZW50cnk7XG4gIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgIGVudHJ5ID0gZGF0YVtpXTtcbiAgICBpdGVtID0ge307XG4gICAgaXRlbVtpU2NhbGUuYXhpc10gPSBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2ldLCBpKTtcbiAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuZnVuY3Rpb24gaXNGbG9hdEJhcihjdXN0b20pIHtcbiAgcmV0dXJuIGN1c3RvbSAmJiBjdXN0b20uYmFyU3RhcnQgIT09IHVuZGVmaW5lZCAmJiBjdXN0b20uYmFyRW5kICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBiYXJTaWduKHNpemUsIHZTY2FsZSwgYWN0dWFsQmFzZSkge1xuICBpZiAoc2l6ZSAhPT0gMCkge1xuICAgIHJldHVybiBzaWduKHNpemUpO1xuICB9XG4gIHJldHVybiAodlNjYWxlLmlzSG9yaXpvbnRhbCgpID8gMSA6IC0xKSAqICh2U2NhbGUubWluID49IGFjdHVhbEJhc2UgPyAxIDogLTEpO1xufVxuZnVuY3Rpb24gYm9yZGVyUHJvcHMocHJvcGVydGllcykge1xuICBsZXQgcmV2ZXJzZSwgc3RhcnQsIGVuZCwgdG9wLCBib3R0b207XG4gIGlmIChwcm9wZXJ0aWVzLmhvcml6b250YWwpIHtcbiAgICByZXZlcnNlID0gcHJvcGVydGllcy5iYXNlID4gcHJvcGVydGllcy54O1xuICAgIHN0YXJ0ID0gJ2xlZnQnO1xuICAgIGVuZCA9ICdyaWdodCc7XG4gIH0gZWxzZSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA8IHByb3BlcnRpZXMueTtcbiAgICBzdGFydCA9ICdib3R0b20nO1xuICAgIGVuZCA9ICd0b3AnO1xuICB9XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgdG9wID0gJ2VuZCc7XG4gICAgYm90dG9tID0gJ3N0YXJ0JztcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSAnc3RhcnQnO1xuICAgIGJvdHRvbSA9ICdlbmQnO1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219O1xufVxuZnVuY3Rpb24gc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpIHtcbiAgbGV0IGVkZ2UgPSBvcHRpb25zLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBpZiAoIWVkZ2UpIHtcbiAgICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX0gPSBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKTtcbiAgaWYgKGVkZ2UgPT09ICdtaWRkbGUnICYmIHN0YWNrKSB7XG4gICAgcHJvcGVydGllcy5lbmFibGVCb3JkZXJSYWRpdXMgPSB0cnVlO1xuICAgIGlmICgoc3RhY2suX3RvcCB8fCAwKSA9PT0gaW5kZXgpIHtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfSBlbHNlIGlmICgoc3RhY2suX2JvdHRvbSB8fCAwKSA9PT0gaW5kZXgpIHtcbiAgICAgIGVkZ2UgPSBib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1twYXJzZUVkZ2UoYm90dG9tLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICAgICAgZWRnZSA9IHRvcDtcbiAgICB9XG4gIH1cbiAgcmVzW3BhcnNlRWRnZShlZGdlLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG59XG5mdW5jdGlvbiBwYXJzZUVkZ2UoZWRnZSwgYSwgYiwgcmV2ZXJzZSkge1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGVkZ2UgPSBzd2FwKGVkZ2UsIGEsIGIpO1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBiLCBhKTtcbiAgfSBlbHNlIHtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYSwgYik7XG4gIH1cbiAgcmV0dXJuIGVkZ2U7XG59XG5mdW5jdGlvbiBzd2FwKG9yaWcsIHYxLCB2Mikge1xuICByZXR1cm4gb3JpZyA9PT0gdjEgPyB2MiA6IG9yaWcgPT09IHYyID8gdjEgOiBvcmlnO1xufVxuZnVuY3Rpb24gc3RhcnRFbmQodiwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogdiA9PT0gJ2VuZCcgPyBlbmQgOiB2O1xufVxuZnVuY3Rpb24gc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCB7aW5mbGF0ZUFtb3VudH0sIHJhdGlvKSB7XG4gIHByb3BlcnRpZXMuaW5mbGF0ZUFtb3VudCA9IGluZmxhdGVBbW91bnQgPT09ICdhdXRvJ1xuICAgID8gcmF0aW8gPT09IDEgPyAwLjMzIDogMFxuICAgIDogaW5mbGF0ZUFtb3VudDtcbn1cbmNsYXNzIEJhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgaUF4aXNLZXkgPSBpU2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCB2QXhpc0tleSA9IHZTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHBhcnNlZCA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBpdGVtLCBvYmo7XG4gICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvYmogPSBkYXRhW2ldO1xuICAgICAgaXRlbSA9IHt9O1xuICAgICAgaXRlbVtpU2NhbGUuYXhpc10gPSBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShvYmosIGlBeGlzS2V5KSwgaSk7XG4gICAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKHJlc29sdmVPYmplY3RLZXkob2JqLCB2QXhpc0tleSksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICBzdXBlci51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBpZiAoY3VzdG9tICYmIHNjYWxlID09PSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZSkge1xuICAgICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCBjdXN0b20ubWluKTtcbiAgICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgY3VzdG9tLm1heCk7XG4gICAgfVxuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgY29uc3QgdmFsdWUgPSBpc0Zsb2F0QmFyKGN1c3RvbSlcbiAgICAgID8gJ1snICsgY3VzdG9tLnN0YXJ0ICsgJywgJyArIGN1c3RvbS5lbmQgKyAnXSdcbiAgICAgIDogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSksXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLnN0YWNrID0gdGhpcy5nZXREYXRhc2V0KCkuc3RhY2s7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKG1ldGEuZGF0YSwgMCwgbWV0YS5kYXRhLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMoYmFycywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpbmRleCwgX2NhY2hlZE1ldGE6IHt2U2NhbGV9fSA9IHRoaXM7XG4gICAgY29uc3QgYmFzZSA9IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgICBjb25zdCBob3Jpem9udGFsID0gdlNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHJ1bGVyID0gdGhpcy5fZ2V0UnVsZXIoKTtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XG4gICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIGZpcnN0T3B0cyk7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHZwaXhlbHMgPSByZXNldCB8fCBpc051bGxPclVuZGVmKHBhcnNlZFt2U2NhbGUuYXhpc10pID8ge2Jhc2UsIGhlYWQ6IGJhc2V9IDogdGhpcy5fY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaSk7XG4gICAgICBjb25zdCBpcGl4ZWxzID0gdGhpcy5fY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaSwgcnVsZXIpO1xuICAgICAgY29uc3Qgc3RhY2sgPSAocGFyc2VkLl9zdGFja3MgfHwge30pW3ZTY2FsZS5heGlzXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIGhvcml6b250YWwsXG4gICAgICAgIGJhc2U6IHZwaXhlbHMuYmFzZSxcbiAgICAgICAgZW5hYmxlQm9yZGVyUmFkaXVzOiAhc3RhY2sgfHwgaXNGbG9hdEJhcihwYXJzZWQuX2N1c3RvbSkgfHwgKGluZGV4ID09PSBzdGFjay5fdG9wIHx8IGluZGV4ID09PSBzdGFjay5fYm90dG9tKSxcbiAgICAgICAgeDogaG9yaXpvbnRhbCA/IHZwaXhlbHMuaGVhZCA6IGlwaXhlbHMuY2VudGVyLFxuICAgICAgICB5OiBob3Jpem9udGFsID8gaXBpeGVscy5jZW50ZXIgOiB2cGl4ZWxzLmhlYWQsXG4gICAgICAgIGhlaWdodDogaG9yaXpvbnRhbCA/IGlwaXhlbHMuc2l6ZSA6IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSksXG4gICAgICAgIHdpZHRoOiBob3Jpem9udGFsID8gTWF0aC5hYnModnBpeGVscy5zaXplKSA6IGlwaXhlbHMuc2l6ZVxuICAgICAgfTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBiYXJzW2ldLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRpb25zID0gcHJvcGVydGllcy5vcHRpb25zIHx8IGJhcnNbaV0ub3B0aW9ucztcbiAgICAgIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgb3B0aW9ucywgc3RhY2ssIGluZGV4KTtcbiAgICAgIHNldEluZmxhdGVBbW91bnQocHJvcGVydGllcywgb3B0aW9ucywgcnVsZXIucmF0aW8pO1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGJhcnNbaV0sIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuICBfZ2V0U3RhY2tzKGxhc3QsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gaVNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHRoaXMuX3R5cGUpO1xuICAgIGNvbnN0IHN0YWNrZWQgPSBpU2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICAgIGNvbnN0IGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3Qgc3RhY2tzID0gW107XG4gICAgbGV0IGksIGl0ZW07XG4gICAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaXRlbSA9IG1ldGFzZXRzW2ldO1xuICAgICAgaWYgKCFpdGVtLmNvbnRyb2xsZXIub3B0aW9ucy5ncm91cGVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkYXRhSW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGl0ZW0uY29udHJvbGxlci5nZXRQYXJzZWQoZGF0YUluZGV4KVtcbiAgICAgICAgICBpdGVtLmNvbnRyb2xsZXIuX2NhY2hlZE1ldGEudlNjYWxlLmF4aXNcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsKSB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGFja2VkID09PSBmYWxzZSB8fCBzdGFja3MuaW5kZXhPZihpdGVtLnN0YWNrKSA9PT0gLTEgfHxcblx0XHRcdFx0KHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBpdGVtLnN0YWNrID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHN0YWNrcy5wdXNoKGl0ZW0uc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0uaW5kZXggPT09IGxhc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc3RhY2tzLmxlbmd0aCkge1xuICAgICAgc3RhY2tzLnB1c2godW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrcztcbiAgfVxuICBfZ2V0U3RhY2tDb3VudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGFja3ModW5kZWZpbmVkLCBpbmRleCkubGVuZ3RoO1xuICB9XG4gIF9nZXRTdGFja0luZGV4KGRhdGFzZXRJbmRleCwgbmFtZSwgZGF0YUluZGV4KSB7XG4gICAgY29uc3Qgc3RhY2tzID0gdGhpcy5fZ2V0U3RhY2tzKGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KTtcbiAgICBjb25zdCBpbmRleCA9IChuYW1lICE9PSB1bmRlZmluZWQpXG4gICAgICA/IHN0YWNrcy5pbmRleE9mKG5hbWUpXG4gICAgICA6IC0xO1xuICAgIHJldHVybiAoaW5kZXggPT09IC0xKVxuICAgICAgPyBzdGFja3MubGVuZ3RoIC0gMVxuICAgICAgOiBpbmRleDtcbiAgfVxuICBfZ2V0UnVsZXIoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBwaXhlbHMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcGl4ZWxzLnB1c2goaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSlbaVNjYWxlLmF4aXNdLCBpKSk7XG4gICAgfVxuICAgIGNvbnN0IGJhclRoaWNrbmVzcyA9IG9wdHMuYmFyVGhpY2tuZXNzO1xuICAgIGNvbnN0IG1pbiA9IGJhclRoaWNrbmVzcyB8fCBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWluLFxuICAgICAgcGl4ZWxzLFxuICAgICAgc3RhcnQ6IGlTY2FsZS5fc3RhcnRQaXhlbCxcbiAgICAgIGVuZDogaVNjYWxlLl9lbmRQaXhlbCxcbiAgICAgIHN0YWNrQ291bnQ6IHRoaXMuX2dldFN0YWNrQ291bnQoKSxcbiAgICAgIHNjYWxlOiBpU2NhbGUsXG4gICAgICBncm91cGVkOiBvcHRzLmdyb3VwZWQsXG4gICAgICByYXRpbzogYmFyVGhpY2tuZXNzID8gMSA6IG9wdHMuY2F0ZWdvcnlQZXJjZW50YWdlICogb3B0cy5iYXJQZXJjZW50YWdlXG4gICAgfTtcbiAgfVxuICBfY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaW5kZXgpIHtcbiAgICBjb25zdCB7X2NhY2hlZE1ldGE6IHt2U2NhbGUsIF9zdGFja2VkfSwgb3B0aW9uczoge2Jhc2U6IGJhc2VWYWx1ZSwgbWluQmFyTGVuZ3RofX0gPSB0aGlzO1xuICAgIGNvbnN0IGFjdHVhbEJhc2UgPSBiYXNlVmFsdWUgfHwgMDtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgY29uc3QgZmxvYXRpbmcgPSBpc0Zsb2F0QmFyKGN1c3RvbSk7XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkW3ZTY2FsZS5heGlzXTtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBsZW5ndGggPSBfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogdmFsdWU7XG4gICAgbGV0IGhlYWQsIHNpemU7XG4gICAgaWYgKGxlbmd0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHN0YXJ0ID0gbGVuZ3RoIC0gdmFsdWU7XG4gICAgICBsZW5ndGggPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGZsb2F0aW5nKSB7XG4gICAgICB2YWx1ZSA9IGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIGxlbmd0aCA9IGN1c3RvbS5iYXJFbmQgLSBjdXN0b20uYmFyU3RhcnQ7XG4gICAgICBpZiAodmFsdWUgIT09IDAgJiYgc2lnbih2YWx1ZSkgIT09IHNpZ24oY3VzdG9tLmJhckVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgKz0gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSAhaXNOdWxsT3JVbmRlZihiYXNlVmFsdWUpICYmICFmbG9hdGluZyA/IGJhc2VWYWx1ZSA6IHN0YXJ0O1xuICAgIGxldCBiYXNlID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnRWYWx1ZSk7XG4gICAgaWYgKHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICBoZWFkID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnQgKyBsZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkID0gYmFzZTtcbiAgICB9XG4gICAgc2l6ZSA9IGhlYWQgLSBiYXNlO1xuICAgIGlmIChNYXRoLmFicyhzaXplKSA8IG1pbkJhckxlbmd0aCkge1xuICAgICAgc2l6ZSA9IGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSAqIG1pbkJhckxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZSA9PT0gYWN0dWFsQmFzZSkge1xuICAgICAgICBiYXNlIC09IHNpemUgLyAyO1xuICAgICAgfVxuICAgICAgaGVhZCA9IGJhc2UgKyBzaXplO1xuICAgIH1cbiAgICBpZiAoYmFzZSA9PT0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoYWN0dWFsQmFzZSkpIHtcbiAgICAgIGNvbnN0IGhhbGZHcmlkID0gc2lnbihzaXplKSAqIHZTY2FsZS5nZXRMaW5lV2lkdGhGb3JWYWx1ZShhY3R1YWxCYXNlKSAvIDI7XG4gICAgICBiYXNlICs9IGhhbGZHcmlkO1xuICAgICAgc2l6ZSAtPSBoYWxmR3JpZDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpemUsXG4gICAgICBiYXNlLFxuICAgICAgaGVhZCxcbiAgICAgIGNlbnRlcjogaGVhZCArIHNpemUgLyAyXG4gICAgfTtcbiAgfVxuICBfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaW5kZXgsIHJ1bGVyKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBydWxlci5zY2FsZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNraXBOdWxsID0gb3B0aW9ucy5za2lwTnVsbDtcbiAgICBjb25zdCBtYXhCYXJUaGlja25lc3MgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpO1xuICAgIGxldCBjZW50ZXIsIHNpemU7XG4gICAgaWYgKHJ1bGVyLmdyb3VwZWQpIHtcbiAgICAgIGNvbnN0IHN0YWNrQ291bnQgPSBza2lwTnVsbCA/IHRoaXMuX2dldFN0YWNrQ291bnQoaW5kZXgpIDogcnVsZXIuc3RhY2tDb3VudDtcbiAgICAgIGNvbnN0IHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuICAgICAgICA/IGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KVxuICAgICAgICA6IGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpO1xuICAgICAgY29uc3Qgc3RhY2tJbmRleCA9IHRoaXMuX2dldFN0YWNrSW5kZXgodGhpcy5pbmRleCwgdGhpcy5fY2FjaGVkTWV0YS5zdGFjaywgc2tpcE51bGwgPyBpbmRleCA6IHVuZGVmaW5lZCk7XG4gICAgICBjZW50ZXIgPSByYW5nZS5zdGFydCArIChyYW5nZS5jaHVuayAqIHN0YWNrSW5kZXgpICsgKHJhbmdlLmNodW5rIC8gMik7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCByYW5nZS5jaHVuayAqIHJhbmdlLnJhdGlvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VudGVyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpbmRleClbc2NhbGUuYXhpc10sIGluZGV4KTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJ1bGVyLm1pbiAqIHJ1bGVyLnJhdGlvKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2U6IGNlbnRlciAtIHNpemUgLyAyLFxuICAgICAgaGVhZDogY2VudGVyICsgc2l6ZSAvIDIsXG4gICAgICBjZW50ZXIsXG4gICAgICBzaXplXG4gICAgfTtcbiAgfVxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHJlY3RzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGlsZW4gPSByZWN0cy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAodGhpcy5nZXRQYXJzZWQoaSlbdlNjYWxlLmF4aXNdICE9PSBudWxsKSB7XG4gICAgICAgIHJlY3RzW2ldLmRyYXcodGhpcy5fY3R4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbkJhckNvbnRyb2xsZXIuaWQgPSAnYmFyJztcbkJhckNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gIGRhdGFFbGVtZW50VHlwZTogJ2JhcicsXG4gIGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxuICBiYXJQZXJjZW50YWdlOiAwLjksXG4gIGdyb3VwZWQ6IHRydWUsXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J11cbiAgICB9XG4gIH1cbn07XG5CYXJDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgc2NhbGVzOiB7XG4gICAgX2luZGV4Xzoge1xuICAgICAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgICAgIG9mZnNldDogdHJ1ZSxcbiAgICAgIGdyaWQ6IHtcbiAgICAgICAgb2Zmc2V0OiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBfdmFsdWVfOiB7XG4gICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgQnViYmxlQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW1bMl0sIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtICYmIGl0ZW0uciAmJiAraXRlbS5yLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZGF0YVtpXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKSkgLyAyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgeCA9IHhTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC54KTtcbiAgICBjb25zdCB5ID0geVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLnkpO1xuICAgIGNvbnN0IHIgPSBwYXJzZWQuX2N1c3RvbTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IG1ldGEubGFiZWwsXG4gICAgICB2YWx1ZTogJygnICsgeCArICcsICcgKyB5ICsgKHIgPyAnLCAnICsgciA6ICcnKSArICcpJ1xuICAgIH07XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9ICFyZXNldCAmJiB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gcmVzZXQgPyBpU2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDAuNSkgOiBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbdkF4aXNdKTtcbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgICAgcHJvcGVydGllcy5vcHRpb25zLnJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICB9XG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgbGV0IHZhbHVlcyA9IHN1cGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpO1xuICAgIGlmICh2YWx1ZXMuJHNoYXJlZCkge1xuICAgICAgdmFsdWVzID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWVzLCB7JHNoYXJlZDogZmFsc2V9KTtcbiAgICB9XG4gICAgY29uc3QgcmFkaXVzID0gdmFsdWVzLnJhZGl1cztcbiAgICBpZiAobW9kZSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHZhbHVlcy5yYWRpdXMgPSAwO1xuICAgIH1cbiAgICB2YWx1ZXMucmFkaXVzICs9IHZhbHVlT3JEZWZhdWx0KHBhcnNlZCAmJiBwYXJzZWQuX2N1c3RvbSwgcmFkaXVzKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG59XG5CdWJibGVDb250cm9sbGVyLmlkID0gJ2J1YmJsZSc7XG5CdWJibGVDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2JvcmRlcldpZHRoJywgJ3JhZGl1cyddXG4gICAgfVxuICB9XG59O1xuQnViYmxlQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIHg6IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH1cbiAgfSxcbiAgcGx1Z2luczoge1xuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpIHtcbiAgbGV0IHJhdGlvWCA9IDE7XG4gIGxldCByYXRpb1kgPSAxO1xuICBsZXQgb2Zmc2V0WCA9IDA7XG4gIGxldCBvZmZzZXRZID0gMDtcbiAgaWYgKGNpcmN1bWZlcmVuY2UgPCBUQVUpIHtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gcm90YXRpb247XG4gICAgY29uc3QgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZTtcbiAgICBjb25zdCBzdGFydFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBzdGFydFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBlbmRYID0gTWF0aC5jb3MoZW5kQW5nbGUpO1xuICAgIGNvbnN0IGVuZFkgPSBNYXRoLnNpbihlbmRBbmdsZSk7XG4gICAgY29uc3QgY2FsY01heCA9IChhbmdsZSwgYSwgYikgPT4gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUpID8gMSA6IE1hdGgubWF4KGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IGNhbGNNaW4gPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IC0xIDogTWF0aC5taW4oYSwgYSAqIGN1dG91dCwgYiwgYiAqIGN1dG91dCk7XG4gICAgY29uc3QgbWF4WCA9IGNhbGNNYXgoMCwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtYXhZID0gY2FsY01heChIQUxGX1BJLCBzdGFydFksIGVuZFkpO1xuICAgIGNvbnN0IG1pblggPSBjYWxjTWluKFBJLCBzdGFydFgsIGVuZFgpO1xuICAgIGNvbnN0IG1pblkgPSBjYWxjTWluKFBJICsgSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICByYXRpb1ggPSAobWF4WCAtIG1pblgpIC8gMjtcbiAgICByYXRpb1kgPSAobWF4WSAtIG1pblkpIC8gMjtcbiAgICBvZmZzZXRYID0gLShtYXhYICsgbWluWCkgLyAyO1xuICAgIG9mZnNldFkgPSAtKG1heFkgKyBtaW5ZKSAvIDI7XG4gIH1cbiAgcmV0dXJuIHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX07XG59XG5jbGFzcyBEb3VnaG51dENvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9mZnNldFggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRZID0gdW5kZWZpbmVkO1xuICB9XG4gIGxpbmtTY2FsZXMoKSB7fVxuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhc2V0KCkuZGF0YTtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIG1ldGEuX3BhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBnZXR0ZXIgPSAoaSkgPT4gK2RhdGFbaV07XG4gICAgICBpZiAoaXNPYmplY3QoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgIGNvbnN0IHtrZXkgPSAndmFsdWUnfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgICAgIGdldHRlciA9IChpKSA9PiArcmVzb2x2ZU9iamVjdEtleShkYXRhW2ldLCBrZXkpO1xuICAgICAgfVxuICAgICAgbGV0IGksIGlsZW47XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2ldID0gZ2V0dGVyKGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMucm90YXRpb24gLSA5MCk7XG4gIH1cbiAgX2dldENpcmN1bWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMuY2lyY3VtZmVyZW5jZSk7XG4gIH1cbiAgX2dldFJvdGF0aW9uRXh0ZW50cygpIHtcbiAgICBsZXQgbWluID0gVEFVO1xuICAgIGxldCBtYXggPSAtVEFVO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXI7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uID0gY29udHJvbGxlci5fZ2V0Um90YXRpb24oKTtcbiAgICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IGNvbnRyb2xsZXIuX2dldENpcmN1bWZlcmVuY2UoKTtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByb3RhdGlvbik7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcm90YXRpb24gKyBjaXJjdW1mZXJlbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdGF0aW9uOiBtaW4sXG4gICAgICBjaXJjdW1mZXJlbmNlOiBtYXggLSBtaW4sXG4gICAgfTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCB7Y2hhcnRBcmVhfSA9IGNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgY29uc3Qgc3BhY2luZyA9IHRoaXMuZ2V0TWF4Qm9yZGVyV2lkdGgoKSArIHRoaXMuZ2V0TWF4T2Zmc2V0KGFyY3MpICsgdGhpcy5vcHRpb25zLnNwYWNpbmc7XG4gICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgubWF4KChNYXRoLm1pbihjaGFydEFyZWEud2lkdGgsIGNoYXJ0QXJlYS5oZWlnaHQpIC0gc3BhY2luZykgLyAyLCAwKTtcbiAgICBjb25zdCBjdXRvdXQgPSBNYXRoLm1pbih0b1BlcmNlbnRhZ2UodGhpcy5vcHRpb25zLmN1dG91dCwgbWF4U2l6ZSksIDEpO1xuICAgIGNvbnN0IGNoYXJ0V2VpZ2h0ID0gdGhpcy5fZ2V0UmluZ1dlaWdodCh0aGlzLmluZGV4KTtcbiAgICBjb25zdCB7Y2lyY3VtZmVyZW5jZSwgcm90YXRpb259ID0gdGhpcy5fZ2V0Um90YXRpb25FeHRlbnRzKCk7XG4gICAgY29uc3Qge3JhdGlvWCwgcmF0aW9ZLCBvZmZzZXRYLCBvZmZzZXRZfSA9IGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFdpZHRoID0gKGNoYXJ0QXJlYS53aWR0aCAtIHNwYWNpbmcpIC8gcmF0aW9YO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IChjaGFydEFyZWEuaGVpZ2h0IC0gc3BhY2luZykgLyByYXRpb1k7XG4gICAgY29uc3QgbWF4UmFkaXVzID0gTWF0aC5tYXgoTWF0aC5taW4obWF4V2lkdGgsIG1heEhlaWdodCkgLyAyLCAwKTtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IHRvRGltZW5zaW9uKHRoaXMub3B0aW9ucy5yYWRpdXMsIG1heFJhZGl1cyk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvdXRlclJhZGl1cyAqIGN1dG91dCwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gdGhpcy5fZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpO1xuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFggKiBvdXRlclJhZGl1cztcbiAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZICogb3V0ZXJSYWRpdXM7XG4gICAgbWV0YS50b3RhbCA9IHRoaXMuY2FsY3VsYXRlVG90YWwoKTtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSBNYXRoLm1heCh0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogY2hhcnRXZWlnaHQsIDApO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIF9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gdGhpcy5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuICAgIGlmICgocmVzZXQgJiYgb3B0cy5hbmltYXRpb24uYW5pbWF0ZVJvdGF0ZSkgfHwgIXRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgfHwgbWV0YS5fcGFyc2VkW2ldID09PSBudWxsIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKG1ldGEuX3BhcnNlZFtpXSAqIGNpcmN1bWZlcmVuY2UgLyBUQVUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBjZW50ZXJYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyO1xuICAgIGNvbnN0IGFuaW1hdGVTY2FsZSA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMuaW5uZXJSYWRpdXM7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5vdXRlclJhZGl1cztcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XG4gICAgbGV0IHN0YXJ0QW5nbGUgPSB0aGlzLl9nZXRSb3RhdGlvbigpO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBzdGFydEFuZ2xlICs9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHg6IGNlbnRlclggKyB0aGlzLm9mZnNldFgsXG4gICAgICAgIHk6IGNlbnRlclkgKyB0aGlzLm9mZnNldFksXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIGlubmVyUmFkaXVzXG4gICAgICB9O1xuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgc3RhcnRBbmdsZSArPSBjaXJjdW1mZXJlbmNlO1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICB9XG4gIGNhbGN1bGF0ZVRvdGFsKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IG1ldGFEYXRhID0gbWV0YS5kYXRhO1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IG1ldGFEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG1ldGEuX3BhcnNlZFtpXTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiAhaXNOYU4odmFsdWUpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgJiYgIW1ldGFEYXRhW2ldLmhpZGRlbikge1xuICAgICAgICB0b3RhbCArPSBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuICBjYWxjdWxhdGVDaXJjdW1mZXJlbmNlKHZhbHVlKSB7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLl9jYWNoZWRNZXRhLnRvdGFsO1xuICAgIGlmICh0b3RhbCA+IDAgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFRBVSAqIChNYXRoLmFicyh2YWx1ZSkgLyB0b3RhbCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XSwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cbiAgZ2V0TWF4Qm9yZGVyV2lkdGgoYXJjcykge1xuICAgIGxldCBtYXggPSAwO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBsZXQgaSwgaWxlbiwgbWV0YSwgY29udHJvbGxlciwgb3B0aW9ucztcbiAgICBpZiAoIWFyY3MpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgICAgICBhcmNzID0gbWV0YS5kYXRhO1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBtZXRhLmNvbnRyb2xsZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvcHRpb25zID0gY29udHJvbGxlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgaWYgKG9wdGlvbnMuYm9yZGVyQWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLmJvcmRlcldpZHRoIHx8IDAsIG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCB8fCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuICBnZXRNYXhPZmZzZXQoYXJjcykge1xuICAgIGxldCBtYXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMub2Zmc2V0IHx8IDAsIG9wdGlvbnMuaG92ZXJPZmZzZXQgfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cbiAgX2dldFJpbmdXZWlnaHRPZmZzZXQoZGF0YXNldEluZGV4KSB7XG4gICAgbGV0IHJpbmdXZWlnaHRPZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgcmluZ1dlaWdodE9mZnNldCArPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KGkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmluZ1dlaWdodE9mZnNldDtcbiAgfVxuICBfZ2V0UmluZ1dlaWdodChkYXRhc2V0SW5kZXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodmFsdWVPckRlZmF1bHQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0ud2VpZ2h0LCAxKSwgMCk7XG4gIH1cbiAgX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aCkgfHwgMTtcbiAgfVxufVxuRG91Z2hudXRDb250cm9sbGVyLmlkID0gJ2RvdWdobnV0JztcbkRvdWdobnV0Q29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgYW5pbWF0aW9uOiB7XG4gICAgYW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcbiAgICBhbmltYXRlU2NhbGU6IGZhbHNlXG4gIH0sXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsnY2lyY3VtZmVyZW5jZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cycsICdzdGFydEFuZ2xlJywgJ3gnLCAneScsICdvZmZzZXQnLCAnYm9yZGVyV2lkdGgnLCAnc3BhY2luZyddXG4gICAgfSxcbiAgfSxcbiAgY3V0b3V0OiAnNTAlJyxcbiAgcm90YXRpb246IDAsXG4gIGNpcmN1bWZlcmVuY2U6IDM2MCxcbiAgcmFkaXVzOiAnMTAwJScsXG4gIHNwYWNpbmc6IDAsXG4gIGluZGV4QXhpczogJ3InLFxufTtcbkRvdWdobnV0Q29udHJvbGxlci5kZXNjcmlwdG9ycyA9IHtcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnc3BhY2luZycsXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnc3BhY2luZycsXG59O1xuRG91Z2hudXRDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgYXNwZWN0UmF0aW86IDEsXG4gIHBsdWdpbnM6IHtcbiAgICBsZWdlbmQ6IHtcbiAgICAgIGxhYmVsczoge1xuICAgICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcbiAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgIGxlZ2VuZC5jaGFydC50b2dnbGVEYXRhVmlzaWJpbGl0eShsZWdlbmRJdGVtLmluZGV4KTtcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWwodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgICBsZXQgZGF0YUxhYmVsID0gdG9vbHRpcEl0ZW0ubGFiZWw7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSAnOiAnICsgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoZGF0YUxhYmVsKSkge1xuICAgICAgICAgICAgZGF0YUxhYmVsID0gZGF0YUxhYmVsLnNsaWNlKCk7XG4gICAgICAgICAgICBkYXRhTGFiZWxbMF0gKz0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbCArPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRhdGFMYWJlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgTGluZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgZGF0YTogcG9pbnRzID0gW10sIF9kYXRhc2V0fSA9IG1ldGE7XG4gICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpO1xuICAgIHRoaXMuX2RyYXdTdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xuICAgIGlmIChzY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgbGluZS5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgbGluZS5fZGVjaW1hdGVkID0gISFfZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgIH1cbiAgICBvcHRpb25zLnNlZ21lbnQgPSB0aGlzLm9wdGlvbnMuc2VnbWVudDtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCB7XG4gICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcbiAgICAgIG9wdGlvbnNcbiAgICB9LCBtb2RlKTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG4gICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10sIGkpO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCB8fCBudWxsRGF0YSA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiBwYXJzZWRbdkF4aXNdLCBpKTtcbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIChwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pID4gbWF4R2FwTGVuZ3RoO1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIHByb3BlcnRpZXMucmF3ID0gX2RhdGFzZXQuZGF0YVtpXTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGRhdGFbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgfVxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuZGF0YXNldC51cGRhdGVDb250cm9sUG9pbnRzKHRoaXMuY2hhcnQuY2hhcnRBcmVhLCBtZXRhLmlTY2FsZS5heGlzKTtcbiAgICBzdXBlci5kcmF3KCk7XG4gIH1cbn1cbkxpbmVDb250cm9sbGVyLmlkID0gJ2xpbmUnO1xuTGluZUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gIHNob3dMaW5lOiB0cnVlLFxuICBzcGFuR2FwczogZmFsc2UsXG59O1xuTGluZUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBzY2FsZXM6IHtcbiAgICBfaW5kZXhfOiB7XG4gICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgIH0sXG4gICAgX3ZhbHVlXzoge1xuICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgfSxcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpIHtcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudCA9IHBvaW50Q291bnQ7XG4gIGlmIChtZXRhLl9zb3J0ZWQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCBfcGFyc2VkfSA9IG1ldGE7XG4gICAgY29uc3QgYXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICAgIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgICBzdGFydCA9IF9saW1pdFZhbHVlKE1hdGgubWluKFxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgaVNjYWxlLmF4aXMsIG1pbikubG8sXG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IHBvaW50Q291bnQgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtaW4pKS5sbyksXG4gICAgICAwLCBwb2ludENvdW50IC0gMSk7XG4gICAgfVxuICAgIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgICBjb3VudCA9IF9saW1pdFZhbHVlKE1hdGgubWF4KFxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgaVNjYWxlLmF4aXMsIG1heCkuaGkgKyAxLFxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyAwIDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWF4KSkuaGkgKyAxKSxcbiAgICAgIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IHBvaW50Q291bnQgLSBzdGFydDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxuZnVuY3Rpb24gc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpIHtcbiAgY29uc3Qge3hTY2FsZSwgeVNjYWxlLCBfc2NhbGVSYW5nZXN9ID0gbWV0YTtcbiAgY29uc3QgbmV3UmFuZ2VzID0ge1xuICAgIHhtaW46IHhTY2FsZS5taW4sXG4gICAgeG1heDogeFNjYWxlLm1heCxcbiAgICB5bWluOiB5U2NhbGUubWluLFxuICAgIHltYXg6IHlTY2FsZS5tYXhcbiAgfTtcbiAgaWYgKCFfc2NhbGVSYW5nZXMpIHtcbiAgICBtZXRhLl9zY2FsZVJhbmdlcyA9IG5ld1JhbmdlcztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBjaGFuZ2VkID0gX3NjYWxlUmFuZ2VzLnhtaW4gIT09IHhTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueG1heCAhPT0geFNjYWxlLm1heFxuXHRcdHx8IF9zY2FsZVJhbmdlcy55bWluICE9PSB5U2NhbGUubWluXG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltYXggIT09IHlTY2FsZS5tYXg7XG4gIE9iamVjdC5hc3NpZ24oX3NjYWxlUmFuZ2VzLCBuZXdSYW5nZXMpO1xuICByZXR1cm4gY2hhbmdlZDtcbn1cblxuY2xhc3MgUG9sYXJBcmVhQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHN1cGVyKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0uciwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBhcmNzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIHRoaXMuX3VwZGF0ZVJhZGl1cygpO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIF91cGRhdGVSYWRpdXMoKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBtaW5TaXplID0gTWF0aC5taW4oY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQsIGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wKTtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KG1pblNpemUgLyAyLCAwKTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWF4KG9wdHMuY3V0b3V0UGVyY2VudGFnZSA/IChvdXRlclJhZGl1cyAvIDEwMCkgKiAob3B0cy5jdXRvdXRQZXJjZW50YWdlKSA6IDEsIDApO1xuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIGNoYXJ0LmdldFZpc2libGVEYXRhc2V0Q291bnQoKTtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSAocmFkaXVzTGVuZ3RoICogdGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGg7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgY29uc3QgY2VudGVyWCA9IHNjYWxlLnhDZW50ZXI7XG4gICAgY29uc3QgY2VudGVyWSA9IHNjYWxlLnlDZW50ZXI7XG4gICAgY29uc3QgZGF0YXNldFN0YXJ0QW5nbGUgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKDApIC0gMC41ICogUEk7XG4gICAgbGV0IGFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgZGVmYXVsdEFuZ2xlID0gMzYwIC8gdGhpcy5jb3VudFZpc2libGVFbGVtZW50cygpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBhbmdsZSArPSB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBsZXQgc3RhcnRBbmdsZSA9IGFuZ2xlO1xuICAgICAgbGV0IGVuZEFuZ2xlID0gYW5nbGUgKyB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICAgIGxldCBvdXRlclJhZGl1cyA9IGNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpID8gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUoZGF0YXNldC5kYXRhW2ldKSA6IDA7XG4gICAgICBhbmdsZSA9IGVuZEFuZ2xlO1xuICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSkge1xuICAgICAgICAgIG91dGVyUmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlKSB7XG4gICAgICAgICAgc3RhcnRBbmdsZSA9IGVuZEFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHg6IGNlbnRlclgsXG4gICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgIGlubmVyUmFkaXVzOiAwLFxuICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKVxuICAgICAgfTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuICBjb3VudFZpc2libGVFbGVtZW50cygpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGlmICghaXNOYU4oZGF0YXNldC5kYXRhW2luZGV4XSkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgX2NvbXB1dGVBbmdsZShpbmRleCwgbW9kZSwgZGVmYXVsdEFuZ2xlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpXG4gICAgICA/IHRvUmFkaWFucyh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpLmFuZ2xlIHx8IGRlZmF1bHRBbmdsZSlcbiAgICAgIDogMDtcbiAgfVxufVxuUG9sYXJBcmVhQ29udHJvbGxlci5pZCA9ICdwb2xhckFyZWEnO1xuUG9sYXJBcmVhQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgYW5pbWF0aW9uOiB7XG4gICAgYW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcbiAgICBhbmltYXRlU2NhbGU6IHRydWVcbiAgfSxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnc3RhcnRBbmdsZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cyddXG4gICAgfSxcbiAgfSxcbiAgaW5kZXhBeGlzOiAncicsXG4gIHN0YXJ0QW5nbGU6IDAsXG59O1xuUG9sYXJBcmVhQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBwbHVnaW5zOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZX19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG4gICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5jaGFydC5kYXRhLmxhYmVsc1tjb250ZXh0LmRhdGFJbmRleF0gKyAnOiAnICsgY29udGV4dC5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2NhbGVzOiB7XG4gICAgcjoge1xuICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgICBhbmdsZUxpbmVzOiB7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgICBncmlkOiB7XG4gICAgICAgIGNpcmN1bGFyOiB0cnVlXG4gICAgICB9LFxuICAgICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzdGFydEFuZ2xlOiAwXG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBQaWVDb250cm9sbGVyIGV4dGVuZHMgRG91Z2hudXRDb250cm9sbGVyIHtcbn1cblBpZUNvbnRyb2xsZXIuaWQgPSAncGllJztcblBpZUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGN1dG91dDogMCxcbiAgcm90YXRpb246IDAsXG4gIGNpcmN1bWZlcmVuY2U6IDM2MCxcbiAgcmFkaXVzOiAnMTAwJSdcbn07XG5cbmNsYXNzIFJhZGFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IHZTY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IHZTY2FsZS5nZXRMYWJlbHMoKVtpbmRleF0sXG4gICAgICB2YWx1ZTogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKVxuICAgIH07XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBsaW5lID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBjb25zdCBsYWJlbHMgPSBtZXRhLmlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICBpZiAobW9kZSAhPT0gJ3Jlc2l6ZScpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIF9sb29wOiB0cnVlLFxuICAgICAgICBfZnVsbExvb3A6IGxhYmVscy5sZW5ndGggPT09IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIGRhdGFzZXQuZGF0YVtpXSk7XG4gICAgICBjb25zdCB4ID0gcmVzZXQgPyBzY2FsZS54Q2VudGVyIDogcG9pbnRQb3NpdGlvbi54O1xuICAgICAgY29uc3QgeSA9IHJlc2V0ID8gc2NhbGUueUNlbnRlciA6IHBvaW50UG9zaXRpb24ueTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGFuZ2xlOiBwb2ludFBvc2l0aW9uLmFuZ2xlLFxuICAgICAgICBza2lwOiBpc05hTih4KSB8fCBpc05hTih5KSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG59XG5SYWRhckNvbnRyb2xsZXIuaWQgPSAncmFkYXInO1xuUmFkYXJDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBpbmRleEF4aXM6ICdyJyxcbiAgc2hvd0xpbmU6IHRydWUsXG4gIGVsZW1lbnRzOiB7XG4gICAgbGluZToge1xuICAgICAgZmlsbDogJ3N0YXJ0J1xuICAgIH1cbiAgfSxcbn07XG5SYWRhckNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBhc3BlY3RSYXRpbzogMSxcbiAgc2NhbGVzOiB7XG4gICAgcjoge1xuICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBTY2F0dGVyQ29udHJvbGxlciBleHRlbmRzIExpbmVDb250cm9sbGVyIHtcbn1cblNjYXR0ZXJDb250cm9sbGVyLmlkID0gJ3NjYXR0ZXInO1xuU2NhdHRlckNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIHNob3dMaW5lOiBmYWxzZSxcbiAgZmlsbDogZmFsc2Vcbn07XG5TY2F0dGVyQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGludGVyYWN0aW9uOiB7XG4gICAgbW9kZTogJ3BvaW50J1xuICB9LFxuICBwbHVnaW5zOiB7XG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWwoaXRlbSkge1xuICAgICAgICAgIHJldHVybiAnKCcgKyBpdGVtLmxhYmVsICsgJywgJyArIGl0ZW0uZm9ybWF0dGVkVmFsdWUgKyAnKSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNjYWxlczoge1xuICAgIHg6IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH1cbiAgfVxufTtcblxudmFyIGNvbnRyb2xsZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuQmFyQ29udHJvbGxlcjogQmFyQ29udHJvbGxlcixcbkJ1YmJsZUNvbnRyb2xsZXI6IEJ1YmJsZUNvbnRyb2xsZXIsXG5Eb3VnaG51dENvbnRyb2xsZXI6IERvdWdobnV0Q29udHJvbGxlcixcbkxpbmVDb250cm9sbGVyOiBMaW5lQ29udHJvbGxlcixcblBvbGFyQXJlYUNvbnRyb2xsZXI6IFBvbGFyQXJlYUNvbnRyb2xsZXIsXG5QaWVDb250cm9sbGVyOiBQaWVDb250cm9sbGVyLFxuUmFkYXJDb250cm9sbGVyOiBSYWRhckNvbnRyb2xsZXIsXG5TY2F0dGVyQ29udHJvbGxlcjogU2NhdHRlckNvbnRyb2xsZXJcbn0pO1xuXG5mdW5jdGlvbiBhYnN0cmFjdCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQ6IENoZWNrIHRoYXQgYSBjb21wbGV0ZSBkYXRlIGFkYXB0ZXIgaXMgcHJvdmlkZWQuJyk7XG59XG5jbGFzcyBEYXRlQWRhcHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB9XG4gIGZvcm1hdHMoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgcGFyc2UodmFsdWUsIGZvcm1hdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGZvcm1hdCh0aW1lc3RhbXAsIGZvcm1hdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGFkZCh0aW1lc3RhbXAsIGFtb3VudCwgdW5pdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGRpZmYoYSwgYiwgdW5pdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIHN0YXJ0T2YodGltZXN0YW1wLCB1bml0LCB3ZWVrZGF5KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgZW5kT2YodGltZXN0YW1wLCB1bml0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbn1cbkRhdGVBZGFwdGVyLm92ZXJyaWRlID0gZnVuY3Rpb24obWVtYmVycykge1xuICBPYmplY3QuYXNzaWduKERhdGVBZGFwdGVyLnByb3RvdHlwZSwgbWVtYmVycyk7XG59O1xudmFyIGFkYXB0ZXJzID0ge1xuICBfZGF0ZTogRGF0ZUFkYXB0ZXJcbn07XG5cbmZ1bmN0aW9uIGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpIHtcbiAgaWYgKCduYXRpdmUnIGluIGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZS54LFxuICAgICAgeTogZS55XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZ2V0UmVsYXRpdmVQb3NpdGlvbiQxKGUsIGNoYXJ0KTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlQWxsVmlzaWJsZUl0ZW1zKGNoYXJ0LCBoYW5kbGVyKSB7XG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICBsZXQgaW5kZXgsIGRhdGEsIGVsZW1lbnQ7XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgKHtpbmRleCwgZGF0YX0gPSBtZXRhc2V0c1tpXSk7XG4gICAgZm9yIChsZXQgaiA9IDAsIGpsZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgZWxlbWVudCA9IGRhdGFbal07XG4gICAgICBpZiAoIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICBoYW5kbGVyKGVsZW1lbnQsIGluZGV4LCBqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChtZXRhc2V0LCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KSB7XG4gIGNvbnN0IHtjb250cm9sbGVyLCBkYXRhLCBfc29ydGVkfSA9IG1ldGFzZXQ7XG4gIGNvbnN0IGlTY2FsZSA9IGNvbnRyb2xsZXIuX2NhY2hlZE1ldGEuaVNjYWxlO1xuICBpZiAoaVNjYWxlICYmIGF4aXMgPT09IGlTY2FsZS5heGlzICYmIGF4aXMgIT09ICdyJyAmJiBfc29ydGVkICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgbG9va3VwTWV0aG9kID0gaVNjYWxlLl9yZXZlcnNlUGl4ZWxzID8gX3Jsb29rdXBCeUtleSA6IF9sb29rdXBCeUtleTtcbiAgICBpZiAoIWludGVyc2VjdCkge1xuICAgICAgcmV0dXJuIGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyLl9zaGFyZWRPcHRpb25zKSB7XG4gICAgICBjb25zdCBlbCA9IGRhdGFbMF07XG4gICAgICBjb25zdCByYW5nZSA9IHR5cGVvZiBlbC5nZXRSYW5nZSA9PT0gJ2Z1bmN0aW9uJyAmJiBlbC5nZXRSYW5nZShheGlzKTtcbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSAtIHJhbmdlKTtcbiAgICAgICAgY29uc3QgZW5kID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlICsgcmFuZ2UpO1xuICAgICAgICByZXR1cm4ge2xvOiBzdGFydC5sbywgaGk6IGVuZC5oaX07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7bG86IDAsIGhpOiBkYXRhLmxlbmd0aCAtIDF9O1xufVxuZnVuY3Rpb24gb3B0aW1pemVkRXZhbHVhdGVJdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGhhbmRsZXIsIGludGVyc2VjdCkge1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltheGlzXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCB7aW5kZXgsIGRhdGF9ID0gbWV0YXNldHNbaV07XG4gICAgY29uc3Qge2xvLCBoaX0gPSBiaW5hcnlTZWFyY2gobWV0YXNldHNbaV0sIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpO1xuICAgIGZvciAobGV0IGogPSBsbzsgaiA8PSBoaTsgKytqKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZGF0YVtqXTtcbiAgICAgIGlmICghZWxlbWVudC5za2lwKSB7XG4gICAgICAgIGhhbmRsZXIoZWxlbWVudCwgaW5kZXgsIGopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpIHtcbiAgY29uc3QgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcbiAgY29uc3QgdXNlWSA9IGF4aXMuaW5kZXhPZigneScpICE9PSAtMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG4gICAgY29uc3QgZGVsdGFYID0gdXNlWCA/IE1hdGguYWJzKHB0MS54IC0gcHQyLngpIDogMDtcbiAgICBjb25zdCBkZWx0YVkgPSB1c2VZID8gTWF0aC5hYnMocHQxLnkgLSBwdDIueSkgOiAwO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZGVsdGFYLCAyKSArIE1hdGgucG93KGRlbHRhWSwgMikpO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGlmICghX2lzUG9pbnRJbkFyZWEocG9zaXRpb24sIGNoYXJ0LmNoYXJ0QXJlYSwgY2hhcnQuX21pblBhZGRpbmcpKSB7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIGNvbnN0IGV2YWx1YXRpb25GdW5jID0gZnVuY3Rpb24oZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH07XG4gIG9wdGltaXplZEV2YWx1YXRlSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYywgdHJ1ZSk7XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgbGV0IGl0ZW1zID0gW107XG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGV9ID0gZWxlbWVudC5nZXRQcm9wcyhbJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge2FuZ2xlfSA9IGdldEFuZ2xlRnJvbVBvaW50KGVsZW1lbnQsIHt4OiBwb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55fSk7XG4gICAgaWYgKF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuICBvcHRpbWl6ZWRFdmFsdWF0ZUl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgbGV0IGl0ZW1zID0gW107XG4gIGNvbnN0IGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpO1xuICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCBpblJhbmdlID0gZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGlmIChpbnRlcnNlY3QgJiYgIWluUmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2VudGVyID0gZWxlbWVudC5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCBwb2ludEluQXJlYSA9IF9pc1BvaW50SW5BcmVhKGNlbnRlciwgY2hhcnQuY2hhcnRBcmVhLCBjaGFydC5fbWluUGFkZGluZyk7XG4gICAgaWYgKCFwb2ludEluQXJlYSAmJiAhaW5SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaXN0YW5jZSA9IGRpc3RhbmNlTWV0cmljKHBvc2l0aW9uLCBjZW50ZXIpO1xuICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICBpdGVtcyA9IFt7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH1dO1xuICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlID09PSBtaW5EaXN0YW5jZSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuICBvcHRpbWl6ZWRFdmFsdWF0ZUl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgaWYgKCFfaXNQb2ludEluQXJlYShwb3NpdGlvbiwgY2hhcnQuY2hhcnRBcmVhLCBjaGFydC5fbWluUGFkZGluZykpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGF4aXMgPT09ICdyJyAmJiAhaW50ZXJzZWN0XG4gICAgPyBnZXROZWFyZXN0UmFkaWFsSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKVxuICAgIDogZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbn1cbmZ1bmN0aW9uIGdldEF4aXNJdGVtcyhjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzO1xuICBjb25zdCByYW5nZU1ldGhvZCA9IGF4aXMgPT09ICd4JyA/ICdpblhSYW5nZScgOiAnaW5ZUmFuZ2UnO1xuICBsZXQgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcbiAgZXZhbHVhdGVBbGxWaXNpYmxlSXRlbXMoY2hhcnQsIChlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSA9PiB7XG4gICAgaWYgKGVsZW1lbnRbcmFuZ2VNZXRob2RdKHBvc2l0aW9uW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpbnRlcnNlY3RzSXRlbSA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgaWYgKG9wdGlvbnMuaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG52YXIgSW50ZXJhY3Rpb24gPSB7XG4gIG1vZGVzOiB7XG4gICAgaW5kZXgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4JztcbiAgICAgIGNvbnN0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pXG4gICAgICAgIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5mb3JFYWNoKChtZXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaXRlbXNbMF0uaW5kZXg7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBtZXRhLmRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5za2lwKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4LCBpbmRleH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9LFxuICAgIGRhdGFzZXQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBsZXQgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikgOlxuICAgICAgICBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0SW5kZXggPSBpdGVtc1swXS5kYXRhc2V0SW5kZXg7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmRhdGE7XG4gICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQ6IGRhdGFbaV0sIGRhdGFzZXRJbmRleCwgaW5kZXg6IGl9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG4gICAgcG9pbnQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9LFxuICAgIG5lYXJlc3QoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICByZXR1cm4gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH0sXG4gICAgeChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgZSwge2F4aXM6ICd4JywgaW50ZXJzZWN0OiBvcHRpb25zLmludGVyc2VjdH0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH0sXG4gICAgeShjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgZSwge2F4aXM6ICd5JywgaW50ZXJzZWN0OiBvcHRpb25zLmludGVyc2VjdH0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgU1RBVElDX1BPU0lUSU9OUyA9IFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ107XG5mdW5jdGlvbiBmaWx0ZXJCeVBvc2l0aW9uKGFycmF5LCBwb3NpdGlvbikge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gdi5wb3MgPT09IHBvc2l0aW9uKTtcbn1cbmZ1bmN0aW9uIGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhhcnJheSwgYXhpcykge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gU1RBVElDX1BPU0lUSU9OUy5pbmRleE9mKHYucG9zKSA9PT0gLTEgJiYgdi5ib3guYXhpcyA9PT0gYXhpcyk7XG59XG5mdW5jdGlvbiBzb3J0QnlXZWlnaHQoYXJyYXksIHJldmVyc2UpIHtcbiAgcmV0dXJuIGFycmF5LnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB2MCA9IHJldmVyc2UgPyBiIDogYTtcbiAgICBjb25zdCB2MSA9IHJldmVyc2UgPyBhIDogYjtcbiAgICByZXR1cm4gdjAud2VpZ2h0ID09PSB2MS53ZWlnaHQgP1xuICAgICAgdjAuaW5kZXggLSB2MS5pbmRleCA6XG4gICAgICB2MC53ZWlnaHQgLSB2MS53ZWlnaHQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gd3JhcEJveGVzKGJveGVzKSB7XG4gIGNvbnN0IGxheW91dEJveGVzID0gW107XG4gIGxldCBpLCBpbGVuLCBib3gsIHBvcywgc3RhY2ssIHN0YWNrV2VpZ2h0O1xuICBmb3IgKGkgPSAwLCBpbGVuID0gKGJveGVzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBib3ggPSBib3hlc1tpXTtcbiAgICAoe3Bvc2l0aW9uOiBwb3MsIG9wdGlvbnM6IHtzdGFjaywgc3RhY2tXZWlnaHQgPSAxfX0gPSBib3gpO1xuICAgIGxheW91dEJveGVzLnB1c2goe1xuICAgICAgaW5kZXg6IGksXG4gICAgICBib3gsXG4gICAgICBwb3MsXG4gICAgICBob3Jpem9udGFsOiBib3guaXNIb3Jpem9udGFsKCksXG4gICAgICB3ZWlnaHQ6IGJveC53ZWlnaHQsXG4gICAgICBzdGFjazogc3RhY2sgJiYgKHBvcyArIHN0YWNrKSxcbiAgICAgIHN0YWNrV2VpZ2h0XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxheW91dEJveGVzO1xufVxuZnVuY3Rpb24gYnVpbGRTdGFja3MobGF5b3V0cykge1xuICBjb25zdCBzdGFja3MgPSB7fTtcbiAgZm9yIChjb25zdCB3cmFwIG9mIGxheW91dHMpIHtcbiAgICBjb25zdCB7c3RhY2ssIHBvcywgc3RhY2tXZWlnaHR9ID0gd3JhcDtcbiAgICBpZiAoIXN0YWNrIHx8ICFTVEFUSUNfUE9TSVRJT05TLmluY2x1ZGVzKHBvcykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBfc3RhY2sgPSBzdGFja3Nbc3RhY2tdIHx8IChzdGFja3Nbc3RhY2tdID0ge2NvdW50OiAwLCBwbGFjZWQ6IDAsIHdlaWdodDogMCwgc2l6ZTogMH0pO1xuICAgIF9zdGFjay5jb3VudCsrO1xuICAgIF9zdGFjay53ZWlnaHQgKz0gc3RhY2tXZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHN0YWNrcztcbn1cbmZ1bmN0aW9uIHNldExheW91dERpbXMobGF5b3V0cywgcGFyYW1zKSB7XG4gIGNvbnN0IHN0YWNrcyA9IGJ1aWxkU3RhY2tzKGxheW91dHMpO1xuICBjb25zdCB7dkJveE1heFdpZHRoLCBoQm94TWF4SGVpZ2h0fSA9IHBhcmFtcztcbiAgbGV0IGksIGlsZW4sIGxheW91dDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGxheW91dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gbGF5b3V0c1tpXTtcbiAgICBjb25zdCB7ZnVsbFNpemV9ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdO1xuICAgIGNvbnN0IGZhY3RvciA9IHN0YWNrICYmIGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodDtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGxheW91dC53aWR0aCA9IGZhY3RvciA/IGZhY3RvciAqIHZCb3hNYXhXaWR0aCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVXaWR0aDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSBoQm94TWF4SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXlvdXQud2lkdGggPSB2Qm94TWF4V2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gZmFjdG9yID8gZmFjdG9yICogaEJveE1heEhlaWdodCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVIZWlnaHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5mdW5jdGlvbiBidWlsZExheW91dEJveGVzKGJveGVzKSB7XG4gIGNvbnN0IGxheW91dEJveGVzID0gd3JhcEJveGVzKGJveGVzKTtcbiAgY29uc3QgZnVsbFNpemUgPSBzb3J0QnlXZWlnaHQobGF5b3V0Qm94ZXMuZmlsdGVyKHdyYXAgPT4gd3JhcC5ib3guZnVsbFNpemUpLCB0cnVlKTtcbiAgY29uc3QgbGVmdCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnbGVmdCcpLCB0cnVlKTtcbiAgY29uc3QgcmlnaHQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3JpZ2h0JykpO1xuICBjb25zdCB0b3AgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3RvcCcpLCB0cnVlKTtcbiAgY29uc3QgYm90dG9tID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdib3R0b20nKSk7XG4gIGNvbnN0IGNlbnRlckhvcml6b250YWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd4Jyk7XG4gIGNvbnN0IGNlbnRlclZlcnRpY2FsID0gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGxheW91dEJveGVzLCAneScpO1xuICByZXR1cm4ge1xuICAgIGZ1bGxTaXplLFxuICAgIGxlZnRBbmRUb3A6IGxlZnQuY29uY2F0KHRvcCksXG4gICAgcmlnaHRBbmRCb3R0b206IHJpZ2h0LmNvbmNhdChjZW50ZXJWZXJ0aWNhbCkuY29uY2F0KGJvdHRvbSkuY29uY2F0KGNlbnRlckhvcml6b250YWwpLFxuICAgIGNoYXJ0QXJlYTogZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2NoYXJ0QXJlYScpLFxuICAgIHZlcnRpY2FsOiBsZWZ0LmNvbmNhdChyaWdodCkuY29uY2F0KGNlbnRlclZlcnRpY2FsKSxcbiAgICBob3Jpem9udGFsOiB0b3AuY29uY2F0KGJvdHRvbSkuY29uY2F0KGNlbnRlckhvcml6b250YWwpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsIGEsIGIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1heFBhZGRpbmdbYV0sIGNoYXJ0QXJlYVthXSkgKyBNYXRoLm1heChtYXhQYWRkaW5nW2JdLCBjaGFydEFyZWFbYl0pO1xufVxuZnVuY3Rpb24gdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCBib3hQYWRkaW5nKSB7XG4gIG1heFBhZGRpbmcudG9wID0gTWF0aC5tYXgobWF4UGFkZGluZy50b3AsIGJveFBhZGRpbmcudG9wKTtcbiAgbWF4UGFkZGluZy5sZWZ0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5sZWZ0LCBib3hQYWRkaW5nLmxlZnQpO1xuICBtYXhQYWRkaW5nLmJvdHRvbSA9IE1hdGgubWF4KG1heFBhZGRpbmcuYm90dG9tLCBib3hQYWRkaW5nLmJvdHRvbSk7XG4gIG1heFBhZGRpbmcucmlnaHQgPSBNYXRoLm1heChtYXhQYWRkaW5nLnJpZ2h0LCBib3hQYWRkaW5nLnJpZ2h0KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKSB7XG4gIGNvbnN0IHtwb3MsIGJveH0gPSBsYXlvdXQ7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcbiAgaWYgKCFpc09iamVjdChwb3MpKSB7XG4gICAgaWYgKGxheW91dC5zaXplKSB7XG4gICAgICBjaGFydEFyZWFbcG9zXSAtPSBsYXlvdXQuc2l6ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXSB8fCB7c2l6ZTogMCwgY291bnQ6IDF9O1xuICAgIHN0YWNrLnNpemUgPSBNYXRoLm1heChzdGFjay5zaXplLCBsYXlvdXQuaG9yaXpvbnRhbCA/IGJveC5oZWlnaHQgOiBib3gud2lkdGgpO1xuICAgIGxheW91dC5zaXplID0gc3RhY2suc2l6ZSAvIHN0YWNrLmNvdW50O1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGxheW91dC5zaXplO1xuICB9XG4gIGlmIChib3guZ2V0UGFkZGluZykge1xuICAgIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgYm94LmdldFBhZGRpbmcoKSk7XG4gIH1cbiAgY29uc3QgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJXaWR0aCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ2xlZnQnLCAncmlnaHQnKSk7XG4gIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlckhlaWdodCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ3RvcCcsICdib3R0b20nKSk7XG4gIGNvbnN0IHdpZHRoQ2hhbmdlZCA9IG5ld1dpZHRoICE9PSBjaGFydEFyZWEudztcbiAgY29uc3QgaGVpZ2h0Q2hhbmdlZCA9IG5ld0hlaWdodCAhPT0gY2hhcnRBcmVhLmg7XG4gIGNoYXJ0QXJlYS53ID0gbmV3V2lkdGg7XG4gIGNoYXJ0QXJlYS5oID0gbmV3SGVpZ2h0O1xuICByZXR1cm4gbGF5b3V0Lmhvcml6b250YWxcbiAgICA/IHtzYW1lOiB3aWR0aENoYW5nZWQsIG90aGVyOiBoZWlnaHRDaGFuZ2VkfVxuICAgIDoge3NhbWU6IGhlaWdodENoYW5nZWQsIG90aGVyOiB3aWR0aENoYW5nZWR9O1xufVxuZnVuY3Rpb24gaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpIHtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuICBmdW5jdGlvbiB1cGRhdGVQb3MocG9zKSB7XG4gICAgY29uc3QgY2hhbmdlID0gTWF0aC5tYXgobWF4UGFkZGluZ1twb3NdIC0gY2hhcnRBcmVhW3Bvc10sIDApO1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGNoYW5nZTtcbiAgICByZXR1cm4gY2hhbmdlO1xuICB9XG4gIGNoYXJ0QXJlYS55ICs9IHVwZGF0ZVBvcygndG9wJyk7XG4gIGNoYXJ0QXJlYS54ICs9IHVwZGF0ZVBvcygnbGVmdCcpO1xuICB1cGRhdGVQb3MoJ3JpZ2h0Jyk7XG4gIHVwZGF0ZVBvcygnYm90dG9tJyk7XG59XG5mdW5jdGlvbiBnZXRNYXJnaW5zKGhvcml6b250YWwsIGNoYXJ0QXJlYSkge1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG4gIGZ1bmN0aW9uIG1hcmdpbkZvclBvc2l0aW9ucyhwb3NpdGlvbnMpIHtcbiAgICBjb25zdCBtYXJnaW4gPSB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfTtcbiAgICBwb3NpdGlvbnMuZm9yRWFjaCgocG9zKSA9PiB7XG4gICAgICBtYXJnaW5bcG9zXSA9IE1hdGgubWF4KGNoYXJ0QXJlYVtwb3NdLCBtYXhQYWRkaW5nW3Bvc10pO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXJnaW47XG4gIH1cbiAgcmV0dXJuIGhvcml6b250YWxcbiAgICA/IG1hcmdpbkZvclBvc2l0aW9ucyhbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICA6IG1hcmdpbkZvclBvc2l0aW9ucyhbJ3RvcCcsICdib3R0b20nXSk7XG59XG5mdW5jdGlvbiBmaXRCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCByZWZpdEJveGVzID0gW107XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQsIGJveCwgcmVmaXQsIGNoYW5nZWQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBib3hlcy5sZW5ndGgsIHJlZml0ID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGxheW91dCA9IGJveGVzW2ldO1xuICAgIGJveCA9IGxheW91dC5ib3g7XG4gICAgYm94LnVwZGF0ZShcbiAgICAgIGxheW91dC53aWR0aCB8fCBjaGFydEFyZWEudyxcbiAgICAgIGxheW91dC5oZWlnaHQgfHwgY2hhcnRBcmVhLmgsXG4gICAgICBnZXRNYXJnaW5zKGxheW91dC5ob3Jpem9udGFsLCBjaGFydEFyZWEpXG4gICAgKTtcbiAgICBjb25zdCB7c2FtZSwgb3RoZXJ9ID0gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpO1xuICAgIHJlZml0IHw9IHNhbWUgJiYgcmVmaXRCb3hlcy5sZW5ndGg7XG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgb3RoZXI7XG4gICAgaWYgKCFib3guZnVsbFNpemUpIHtcbiAgICAgIHJlZml0Qm94ZXMucHVzaChsYXlvdXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVmaXQgJiYgZml0Qm94ZXMocmVmaXRCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykgfHwgY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIHNldEJveERpbXMoYm94LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgYm94LnRvcCA9IHRvcDtcbiAgYm94LmxlZnQgPSBsZWZ0O1xuICBib3gucmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gIGJveC5ib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gIGJveC53aWR0aCA9IHdpZHRoO1xuICBib3guaGVpZ2h0ID0gaGVpZ2h0O1xufVxuZnVuY3Rpb24gcGxhY2VCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCB1c2VyUGFkZGluZyA9IHBhcmFtcy5wYWRkaW5nO1xuICBsZXQge3gsIHl9ID0gY2hhcnRBcmVhO1xuICBmb3IgKGNvbnN0IGxheW91dCBvZiBib3hlcykge1xuICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXSB8fCB7Y291bnQ6IDEsIHBsYWNlZDogMCwgd2VpZ2h0OiAxfTtcbiAgICBjb25zdCB3ZWlnaHQgPSAobGF5b3V0LnN0YWNrV2VpZ2h0IC8gc3RhY2sud2VpZ2h0KSB8fCAxO1xuICAgIGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xuICAgICAgY29uc3Qgd2lkdGggPSBjaGFydEFyZWEudyAqIHdlaWdodDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHN0YWNrLnNpemUgfHwgYm94LmhlaWdodDtcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICB5ID0gc3RhY2suc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB1c2VyUGFkZGluZy5sZWZ0LCB5LCBwYXJhbXMub3V0ZXJXaWR0aCAtIHVzZXJQYWRkaW5nLnJpZ2h0IC0gdXNlclBhZGRpbmcubGVmdCwgaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCBjaGFydEFyZWEubGVmdCArIHN0YWNrLnBsYWNlZCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBzdGFjay5zdGFydCA9IHk7XG4gICAgICBzdGFjay5wbGFjZWQgKz0gd2lkdGg7XG4gICAgICB5ID0gYm94LmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gY2hhcnRBcmVhLmggKiB3ZWlnaHQ7XG4gICAgICBjb25zdCB3aWR0aCA9IHN0YWNrLnNpemUgfHwgYm94LndpZHRoO1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHggPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIHVzZXJQYWRkaW5nLnRvcCwgd2lkdGgsIHBhcmFtcy5vdXRlckhlaWdodCAtIHVzZXJQYWRkaW5nLmJvdHRvbSAtIHVzZXJQYWRkaW5nLnRvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgY2hhcnRBcmVhLnRvcCArIHN0YWNrLnBsYWNlZCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBzdGFjay5zdGFydCA9IHg7XG4gICAgICBzdGFjay5wbGFjZWQgKz0gaGVpZ2h0O1xuICAgICAgeCA9IGJveC5yaWdodDtcbiAgICB9XG4gIH1cbiAgY2hhcnRBcmVhLnggPSB4O1xuICBjaGFydEFyZWEueSA9IHk7XG59XG5kZWZhdWx0cy5zZXQoJ2xheW91dCcsIHtcbiAgYXV0b1BhZGRpbmc6IHRydWUsXG4gIHBhZGRpbmc6IHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfVxufSk7XG52YXIgbGF5b3V0cyA9IHtcbiAgYWRkQm94KGNoYXJ0LCBpdGVtKSB7XG4gICAgaWYgKCFjaGFydC5ib3hlcykge1xuICAgICAgY2hhcnQuYm94ZXMgPSBbXTtcbiAgICB9XG4gICAgaXRlbS5mdWxsU2l6ZSA9IGl0ZW0uZnVsbFNpemUgfHwgZmFsc2U7XG4gICAgaXRlbS5wb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb24gfHwgJ3RvcCc7XG4gICAgaXRlbS53ZWlnaHQgPSBpdGVtLndlaWdodCB8fCAwO1xuICAgIGl0ZW0uX2xheWVycyA9IGl0ZW0uX2xheWVycyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB6OiAwLFxuICAgICAgICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgICAgICAgIGl0ZW0uZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9O1xuICAgIGNoYXJ0LmJveGVzLnB1c2goaXRlbSk7XG4gIH0sXG4gIHJlbW92ZUJveChjaGFydCwgbGF5b3V0SXRlbSkge1xuICAgIGNvbnN0IGluZGV4ID0gY2hhcnQuYm94ZXMgPyBjaGFydC5ib3hlcy5pbmRleE9mKGxheW91dEl0ZW0pIDogLTE7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH0sXG4gIGNvbmZpZ3VyZShjaGFydCwgaXRlbSwgb3B0aW9ucykge1xuICAgIGl0ZW0uZnVsbFNpemUgPSBvcHRpb25zLmZ1bGxTaXplO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xuICAgIGl0ZW0ud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQ7XG4gIH0sXG4gIHVwZGF0ZShjaGFydCwgd2lkdGgsIGhlaWdodCwgbWluUGFkZGluZykge1xuICAgIGlmICghY2hhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhjaGFydC5vcHRpb25zLmxheW91dC5wYWRkaW5nKTtcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gcGFkZGluZy53aWR0aCwgMCk7XG4gICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQsIDApO1xuICAgIGNvbnN0IGJveGVzID0gYnVpbGRMYXlvdXRCb3hlcyhjaGFydC5ib3hlcyk7XG4gICAgY29uc3QgdmVydGljYWxCb3hlcyA9IGJveGVzLnZlcnRpY2FsO1xuICAgIGNvbnN0IGhvcml6b250YWxCb3hlcyA9IGJveGVzLmhvcml6b250YWw7XG4gICAgZWFjaChjaGFydC5ib3hlcywgYm94ID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYm94LmJlZm9yZUxheW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBib3guYmVmb3JlTGF5b3V0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgdmlzaWJsZVZlcnRpY2FsQm94Q291bnQgPSB2ZXJ0aWNhbEJveGVzLnJlZHVjZSgodG90YWwsIHdyYXApID0+XG4gICAgICB3cmFwLmJveC5vcHRpb25zICYmIHdyYXAuYm94Lm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2UgPyB0b3RhbCA6IHRvdGFsICsgMSwgMCkgfHwgMTtcbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgIG91dGVyV2lkdGg6IHdpZHRoLFxuICAgICAgb3V0ZXJIZWlnaHQ6IGhlaWdodCxcbiAgICAgIHBhZGRpbmcsXG4gICAgICBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHZCb3hNYXhXaWR0aDogYXZhaWxhYmxlV2lkdGggLyAyIC8gdmlzaWJsZVZlcnRpY2FsQm94Q291bnQsXG4gICAgICBoQm94TWF4SGVpZ2h0OiBhdmFpbGFibGVIZWlnaHQgLyAyXG4gICAgfSk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IE9iamVjdC5hc3NpZ24oe30sIHBhZGRpbmcpO1xuICAgIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgdG9QYWRkaW5nKG1pblBhZGRpbmcpKTtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG1heFBhZGRpbmcsXG4gICAgICB3OiBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGg6IGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHg6IHBhZGRpbmcubGVmdCxcbiAgICAgIHk6IHBhZGRpbmcudG9wXG4gICAgfSwgcGFkZGluZyk7XG4gICAgY29uc3Qgc3RhY2tzID0gc2V0TGF5b3V0RGltcyh2ZXJ0aWNhbEJveGVzLmNvbmNhdChob3Jpem9udGFsQm94ZXMpLCBwYXJhbXMpO1xuICAgIGZpdEJveGVzKGJveGVzLmZ1bGxTaXplLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBpZiAoZml0Qm94ZXMoaG9yaXpvbnRhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSkge1xuICAgICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgfVxuICAgIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKTtcbiAgICBwbGFjZUJveGVzKGJveGVzLmxlZnRBbmRUb3AsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIGNoYXJ0QXJlYS54ICs9IGNoYXJ0QXJlYS53O1xuICAgIGNoYXJ0QXJlYS55ICs9IGNoYXJ0QXJlYS5oO1xuICAgIHBsYWNlQm94ZXMoYm94ZXMucmlnaHRBbmRCb3R0b20sIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIGNoYXJ0LmNoYXJ0QXJlYSA9IHtcbiAgICAgIGxlZnQ6IGNoYXJ0QXJlYS5sZWZ0LFxuICAgICAgdG9wOiBjaGFydEFyZWEudG9wLFxuICAgICAgcmlnaHQ6IGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLncsXG4gICAgICBib3R0b206IGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuaCxcbiAgICAgIGhlaWdodDogY2hhcnRBcmVhLmgsXG4gICAgICB3aWR0aDogY2hhcnRBcmVhLncsXG4gICAgfTtcbiAgICBlYWNoKGJveGVzLmNoYXJ0QXJlYSwgKGxheW91dCkgPT4ge1xuICAgICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICAgIE9iamVjdC5hc3NpZ24oYm94LCBjaGFydC5jaGFydEFyZWEpO1xuICAgICAgYm94LnVwZGF0ZShjaGFydEFyZWEudywgY2hhcnRBcmVhLmgsIHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDB9KTtcbiAgICB9KTtcbiAgfVxufTtcblxuY2xhc3MgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge31cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge31cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHt9XG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZ2V0TWF4aW11bVNpemUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIHx8IGVsZW1lbnQud2lkdGgpO1xuICAgIGhlaWdodCA9IGhlaWdodCB8fCBlbGVtZW50LmhlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gTWF0aC5mbG9vcih3aWR0aCAvIGFzcGVjdFJhdGlvKSA6IGhlaWdodClcbiAgICB9O1xuICB9XG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykge1xuICB9XG59XG5cbmNsYXNzIEJhc2ljUGxhdGZvcm0gZXh0ZW5kcyBCYXNlUGxhdGZvcm0ge1xuICBhY3F1aXJlQ29udGV4dChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0ICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKSB8fCBudWxsO1xuICB9XG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcub3B0aW9ucy5hbmltYXRpb24gPSBmYWxzZTtcbiAgfVxufVxuXG5jb25zdCBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG5jb25zdCBFVkVOVF9UWVBFUyA9IHtcbiAgdG91Y2hzdGFydDogJ21vdXNlZG93bicsXG4gIHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG4gIHRvdWNoZW5kOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJlbnRlcjogJ21vdXNlZW50ZXInLFxuICBwb2ludGVyZG93bjogJ21vdXNlZG93bicsXG4gIHBvaW50ZXJtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgcG9pbnRlcnVwOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJsZWF2ZTogJ21vdXNlb3V0JyxcbiAgcG9pbnRlcm91dDogJ21vdXNlb3V0J1xufTtcbmNvbnN0IGlzTnVsbE9yRW1wdHkgPSB2YWx1ZSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJyc7XG5mdW5jdGlvbiBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcbiAgY29uc3Qgc3R5bGUgPSBjYW52YXMuc3R5bGU7XG4gIGNvbnN0IHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuICBjb25zdCByZW5kZXJXaWR0aCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gIGNhbnZhc1tFWFBBTkRPX0tFWV0gPSB7XG4gICAgaW5pdGlhbDoge1xuICAgICAgaGVpZ2h0OiByZW5kZXJIZWlnaHQsXG4gICAgICB3aWR0aDogcmVuZGVyV2lkdGgsXG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiBzdHlsZS5kaXNwbGF5LFxuICAgICAgICBoZWlnaHQ6IHN0eWxlLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IHN0eWxlLndpZHRoXG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xuICBzdHlsZS5ib3hTaXppbmcgPSBzdHlsZS5ib3hTaXppbmcgfHwgJ2JvcmRlci1ib3gnO1xuICBpZiAoaXNOdWxsT3JFbXB0eShyZW5kZXJXaWR0aCkpIHtcbiAgICBjb25zdCBkaXNwbGF5V2lkdGggPSByZWFkVXNlZFNpemUoY2FudmFzLCAnd2lkdGgnKTtcbiAgICBpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGRpc3BsYXlXaWR0aDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVySGVpZ2h0KSkge1xuICAgIGlmIChjYW52YXMuc3R5bGUuaGVpZ2h0ID09PSAnJykge1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCAvIChhc3BlY3RSYXRpbyB8fCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGlzcGxheUhlaWdodCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICdoZWlnaHQnKTtcbiAgICAgIGlmIChkaXNwbGF5SGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW52YXM7XG59XG5jb25zdCBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoYXJ0LmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG59XG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHR5cGUgPSBFVkVOVF9UWVBFU1tldmVudC50eXBlXSB8fCBldmVudC50eXBlO1xuICBjb25zdCB7eCwgeX0gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uJDEoZXZlbnQsIGNoYXJ0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIGNoYXJ0LFxuICAgIG5hdGl2ZTogZXZlbnQsXG4gICAgeDogeCAhPT0gdW5kZWZpbmVkID8geCA6IG51bGwsXG4gICAgeTogeSAhPT0gdW5kZWZpbmVkID8geSA6IG51bGwsXG4gIH07XG59XG5mdW5jdGlvbiBub2RlTGlzdENvbnRhaW5zKG5vZGVMaXN0LCBjYW52YXMpIHtcbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVMaXN0KSB7XG4gICAgaWYgKG5vZGUgPT09IGNhbnZhcyB8fCBub2RlLmNvbnRhaW5zKGNhbnZhcykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQXR0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURldGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5jb25zdCBkcnBMaXN0ZW5pbmdDaGFydHMgPSBuZXcgTWFwKCk7XG5sZXQgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IDA7XG5mdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSgpIHtcbiAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGlmIChkcHIgPT09IG9sZERldmljZVBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IGRwcjtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmZvckVhY2goKHJlc2l6ZSwgY2hhcnQpID0+IHtcbiAgICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IGRwcikge1xuICAgICAgcmVzaXplKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpIHtcbiAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gIH1cbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLnNldChjaGFydCwgcmVzaXplKTtcbn1cbmZ1bmN0aW9uIHVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQpIHtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gIGlmICghZHJwTGlzdGVuaW5nQ2hhcnRzLnNpemUpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25XaW5kb3dSZXNpemUpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNpemVPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVzaXplID0gdGhyb3R0bGVkKCh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgdyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICBsaXN0ZW5lcih3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAodyA8IGNvbnRhaW5lci5jbGllbnRXaWR0aCkge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0sIHdpbmRvdyk7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICBjb25zdCB3aWR0aCA9IGVudHJ5LmNvbnRlbnRSZWN0LndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGVudHJ5LmNvbnRlbnRSZWN0LmhlaWdodDtcbiAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyKTtcbiAgbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIHJlbGVhc2VPYnNlcnZlcihjaGFydCwgdHlwZSwgb2JzZXJ2ZXIpIHtcbiAgaWYgKG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIGlmICh0eXBlID09PSAncmVzaXplJykge1xuICAgIHVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQcm94eUFuZExpc3RlbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBwcm94eSA9IHRocm90dGxlZCgoZXZlbnQpID0+IHtcbiAgICBpZiAoY2hhcnQuY3R4ICE9PSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XG4gICAgfVxuICB9LCBjaGFydCwgKGFyZ3MpID0+IHtcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIFtldmVudCwgZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WV07XG4gIH0pO1xuICBhZGRMaXN0ZW5lcihjYW52YXMsIHR5cGUsIHByb3h5KTtcbiAgcmV0dXJuIHByb3h5O1xufVxuY2xhc3MgRG9tUGxhdGZvcm0gZXh0ZW5kcyBCYXNlUGxhdGZvcm0ge1xuICBhY3F1aXJlQ29udGV4dChjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCAmJiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gY2FudmFzKSB7XG4gICAgICBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICBpZiAoIWNhbnZhc1tFWFBBTkRPX0tFWV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaW5pdGlhbCA9IGNhbnZhc1tFWFBBTkRPX0tFWV0uaW5pdGlhbDtcbiAgICBbJ2hlaWdodCcsICd3aWR0aCddLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gaW5pdGlhbFtwcm9wXTtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgICBjYW52YXMucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShwcm9wLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3R5bGUgPSBpbml0aWFsLnN0eWxlIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNhbnZhcy5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICB9KTtcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgZGVsZXRlIGNhbnZhc1tFWFBBTkRPX0tFWV07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpO1xuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBhdHRhY2g6IGNyZWF0ZUF0dGFjaE9ic2VydmVyLFxuICAgICAgZGV0YWNoOiBjcmVhdGVEZXRhY2hPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogY3JlYXRlUmVzaXplT2JzZXJ2ZXJcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXSB8fCBjcmVhdGVQcm94eUFuZExpc3RlbjtcbiAgICBwcm94aWVzW3R5cGVdID0gaGFuZGxlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpIHtcbiAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgIGNvbnN0IHByb3h5ID0gcHJveGllc1t0eXBlXTtcbiAgICBpZiAoIXByb3h5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogcmVsZWFzZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgcmVtb3ZlTGlzdGVuZXI7XG4gICAgaGFuZGxlcihjaGFydCwgdHlwZSwgcHJveHkpO1xuICAgIHByb3hpZXNbdHlwZV0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIH1cbiAgZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgIHJldHVybiBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgfVxuICBpc0F0dGFjaGVkKGNhbnZhcykge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgcmV0dXJuICEhKGNvbnRhaW5lciAmJiBjb250YWluZXIuaXNDb25uZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZXRlY3RQbGF0Zm9ybShjYW52YXMpIHtcbiAgaWYgKCFfaXNEb21TdXBwb3J0ZWQoKSB8fCAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSkge1xuICAgIHJldHVybiBCYXNpY1BsYXRmb3JtO1xuICB9XG4gIHJldHVybiBEb21QbGF0Zm9ybTtcbn1cblxuY2xhc3MgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kYW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHt4LCB5fTtcbiAgfVxuICBoYXNWYWx1ZSgpIHtcbiAgICByZXR1cm4gaXNOdW1iZXIodGhpcy54KSAmJiBpc051bWJlcih0aGlzLnkpO1xuICB9XG4gIGdldFByb3BzKHByb3BzLCBmaW5hbCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBpZiAoIWZpbmFsIHx8ICFhbmltcykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIHByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICByZXRbcHJvcF0gPSBhbmltc1twcm9wXSAmJiBhbmltc1twcm9wXS5hY3RpdmUoKSA/IGFuaW1zW3Byb3BdLl90byA6IHRoaXNbcHJvcF07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuRWxlbWVudC5kZWZhdWx0cyA9IHt9O1xuRWxlbWVudC5kZWZhdWx0Um91dGVzID0gdW5kZWZpbmVkO1xuXG5jb25zdCBmb3JtYXR0ZXJzID0ge1xuICB2YWx1ZXModmFsdWUpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6ICcnICsgdmFsdWU7XG4gIH0sXG4gIG51bWVyaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbGUgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlO1xuICAgIGxldCBub3RhdGlvbjtcbiAgICBsZXQgZGVsdGEgPSB0aWNrVmFsdWU7XG4gICAgaWYgKHRpY2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IG1heFRpY2sgPSBNYXRoLm1heChNYXRoLmFicyh0aWNrc1swXS52YWx1ZSksIE1hdGguYWJzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlKSk7XG4gICAgICBpZiAobWF4VGljayA8IDFlLTQgfHwgbWF4VGljayA+IDFlKzE1KSB7XG4gICAgICAgIG5vdGF0aW9uID0gJ3NjaWVudGlmaWMnO1xuICAgICAgfVxuICAgICAgZGVsdGEgPSBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKTtcbiAgICB9XG4gICAgY29uc3QgbG9nRGVsdGEgPSBsb2cxMChNYXRoLmFicyhkZWx0YSkpO1xuICAgIGNvbnN0IG51bURlY2ltYWwgPSBNYXRoLm1heChNYXRoLm1pbigtMSAqIE1hdGguZmxvb3IobG9nRGVsdGEpLCAyMCksIDApO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7bm90YXRpb24sIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbCwgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsfTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIodGlja1ZhbHVlLCBsb2NhbGUsIG9wdGlvbnMpO1xuICB9LFxuICBsb2dhcml0aG1pYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgIGlmICh0aWNrVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbiA9IHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsdWUpKSkpO1xuICAgIGlmIChyZW1haW4gPT09IDEgfHwgcmVtYWluID09PSAyIHx8IHJlbWFpbiA9PT0gNSkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMubnVtZXJpYy5jYWxsKHRoaXMsIHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG59O1xuZnVuY3Rpb24gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcykge1xuICBsZXQgZGVsdGEgPSB0aWNrcy5sZW5ndGggPiAzID8gdGlja3NbMl0udmFsdWUgLSB0aWNrc1sxXS52YWx1ZSA6IHRpY2tzWzFdLnZhbHVlIC0gdGlja3NbMF0udmFsdWU7XG4gIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMSAmJiB0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuICAgIGRlbHRhID0gdGlja1ZhbHVlIC0gTWF0aC5mbG9vcih0aWNrVmFsdWUpO1xuICB9XG4gIHJldHVybiBkZWx0YTtcbn1cbnZhciBUaWNrcyA9IHtmb3JtYXR0ZXJzfTtcblxuZGVmYXVsdHMuc2V0KCdzY2FsZScsIHtcbiAgZGlzcGxheTogdHJ1ZSxcbiAgb2Zmc2V0OiBmYWxzZSxcbiAgcmV2ZXJzZTogZmFsc2UsXG4gIGJlZ2luQXRaZXJvOiBmYWxzZSxcbiAgYm91bmRzOiAndGlja3MnLFxuICBncmFjZTogMCxcbiAgZ3JpZDoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgbGluZVdpZHRoOiAxLFxuICAgIGRyYXdCb3JkZXI6IHRydWUsXG4gICAgZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxuICAgIGRyYXdUaWNrczogdHJ1ZSxcbiAgICB0aWNrTGVuZ3RoOiA4LFxuICAgIHRpY2tXaWR0aDogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMubGluZVdpZHRoLFxuICAgIHRpY2tDb2xvcjogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMuY29sb3IsXG4gICAgb2Zmc2V0OiBmYWxzZSxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLjAsXG4gICAgYm9yZGVyV2lkdGg6IDFcbiAgfSxcbiAgdGl0bGU6IHtcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICB0ZXh0OiAnJyxcbiAgICBwYWRkaW5nOiB7XG4gICAgICB0b3A6IDQsXG4gICAgICBib3R0b206IDRcbiAgICB9XG4gIH0sXG4gIHRpY2tzOiB7XG4gICAgbWluUm90YXRpb246IDAsXG4gICAgbWF4Um90YXRpb246IDUwLFxuICAgIG1pcnJvcjogZmFsc2UsXG4gICAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuICAgIHRleHRTdHJva2VDb2xvcjogJycsXG4gICAgcGFkZGluZzogMyxcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGF1dG9Ta2lwOiB0cnVlLFxuICAgIGF1dG9Ta2lwUGFkZGluZzogMyxcbiAgICBsYWJlbE9mZnNldDogMCxcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXG4gICAgbWlub3I6IHt9LFxuICAgIG1ham9yOiB7fSxcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgY3Jvc3NBbGlnbjogJ25lYXInLFxuICAgIHNob3dMYWJlbEJhY2tkcm9wOiBmYWxzZSxcbiAgICBiYWNrZHJvcENvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KScsXG4gICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuICB9XG59KTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aWNrcycsICdjb2xvcicsICcnLCAnY29sb3InKTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ncmlkJywgJ2NvbG9yJywgJycsICdib3JkZXJDb2xvcicpO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnYm9yZGVyQ29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGl0bGUnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG5kZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUnLCB7XG4gIF9mYWxsYmFjazogZmFsc2UsXG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnYmVmb3JlJykgJiYgIW5hbWUuc3RhcnRzV2l0aCgnYWZ0ZXInKSAmJiBuYW1lICE9PSAnY2FsbGJhY2snICYmIG5hbWUgIT09ICdwYXJzZXInLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICd0aWNrQm9yZGVyRGFzaCcsXG59KTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZXMnLCB7XG4gIF9mYWxsYmFjazogJ3NjYWxlJyxcbn0pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlLnRpY2tzJywge1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdiYWNrZHJvcFBhZGRpbmcnICYmIG5hbWUgIT09ICdjYWxsYmFjaycsXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyxcbn0pO1xuXG5mdW5jdGlvbiBhdXRvU2tpcChzY2FsZSwgdGlja3MpIHtcbiAgY29uc3QgdGlja09wdHMgPSBzY2FsZS5vcHRpb25zLnRpY2tzO1xuICBjb25zdCB0aWNrc0xpbWl0ID0gdGlja09wdHMubWF4VGlja3NMaW1pdCB8fCBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSk7XG4gIGNvbnN0IG1ham9ySW5kaWNlcyA9IHRpY2tPcHRzLm1ham9yLmVuYWJsZWQgPyBnZXRNYWpvckluZGljZXModGlja3MpIDogW107XG4gIGNvbnN0IG51bU1ham9ySW5kaWNlcyA9IG1ham9ySW5kaWNlcy5sZW5ndGg7XG4gIGNvbnN0IGZpcnN0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBjb25zdCBsYXN0ID0gbWFqb3JJbmRpY2VzW251bU1ham9ySW5kaWNlcyAtIDFdO1xuICBjb25zdCBuZXdUaWNrcyA9IFtdO1xuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gdGlja3NMaW1pdCkge1xuICAgIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIG51bU1ham9ySW5kaWNlcyAvIHRpY2tzTGltaXQpO1xuICAgIHJldHVybiBuZXdUaWNrcztcbiAgfVxuICBjb25zdCBzcGFjaW5nID0gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KTtcbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IDApIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBjb25zdCBhdmdNYWpvclNwYWNpbmcgPSBudW1NYWpvckluZGljZXMgPiAxID8gTWF0aC5yb3VuZCgobGFzdCAtIGZpcnN0KSAvIChudW1NYWpvckluZGljZXMgLSAxKSkgOiBudWxsO1xuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyAwIDogZmlyc3QgLSBhdmdNYWpvclNwYWNpbmcsIGZpcnN0KTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbnVtTWFqb3JJbmRpY2VzIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9ySW5kaWNlc1tpXSwgbWFqb3JJbmRpY2VzW2kgKyAxXSk7XG4gICAgfVxuICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBsYXN0LCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyB0aWNrcy5sZW5ndGggOiBsYXN0ICsgYXZnTWFqb3JTcGFjaW5nKTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cbiAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcpO1xuICByZXR1cm4gbmV3VGlja3M7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSkge1xuICBjb25zdCBvZmZzZXQgPSBzY2FsZS5vcHRpb25zLm9mZnNldDtcbiAgY29uc3QgdGlja0xlbmd0aCA9IHNjYWxlLl90aWNrU2l6ZSgpO1xuICBjb25zdCBtYXhTY2FsZSA9IHNjYWxlLl9sZW5ndGggLyB0aWNrTGVuZ3RoICsgKG9mZnNldCA/IDAgOiAxKTtcbiAgY29uc3QgbWF4Q2hhcnQgPSBzY2FsZS5fbWF4TGVuZ3RoIC8gdGlja0xlbmd0aDtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5taW4obWF4U2NhbGUsIG1heENoYXJ0KSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpIHtcbiAgY29uc3QgZXZlbk1ham9yU3BhY2luZyA9IGdldEV2ZW5TcGFjaW5nKG1ham9ySW5kaWNlcyk7XG4gIGNvbnN0IHNwYWNpbmcgPSB0aWNrcy5sZW5ndGggLyB0aWNrc0xpbWl0O1xuICBpZiAoIWV2ZW5NYWpvclNwYWNpbmcpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG4gIH1cbiAgY29uc3QgZmFjdG9ycyA9IF9mYWN0b3JpemUoZXZlbk1ham9yU3BhY2luZyk7XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gZmFjdG9ycy5sZW5ndGggLSAxOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgY29uc3QgZmFjdG9yID0gZmFjdG9yc1tpXTtcbiAgICBpZiAoZmFjdG9yID4gc3BhY2luZykge1xuICAgICAgcmV0dXJuIGZhY3RvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xufVxuZnVuY3Rpb24gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIGlmICh0aWNrc1tpXS5tYWpvcikge1xuICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBzcGFjaW5nKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBuZXh0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBsZXQgaTtcbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgZm9yIChpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBtYWpvckluZGljZXNbY291bnQgKiBzcGFjaW5nXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvclN0YXJ0LCBtYWpvckVuZCkge1xuICBjb25zdCBzdGFydCA9IHZhbHVlT3JEZWZhdWx0KG1ham9yU3RhcnQsIDApO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbih2YWx1ZU9yRGVmYXVsdChtYWpvckVuZCwgdGlja3MubGVuZ3RoKSwgdGlja3MubGVuZ3RoKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IGxlbmd0aCwgaSwgbmV4dDtcbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgaWYgKG1ham9yRW5kKSB7XG4gICAgbGVuZ3RoID0gbWFqb3JFbmQgLSBtYWpvclN0YXJ0O1xuICAgIHNwYWNpbmcgPSBsZW5ndGggLyBNYXRoLmZsb29yKGxlbmd0aCAvIHNwYWNpbmcpO1xuICB9XG4gIG5leHQgPSBzdGFydDtcbiAgd2hpbGUgKG5leHQgPCAwKSB7XG4gICAgY291bnQrKztcbiAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gIH1cbiAgZm9yIChpID0gTWF0aC5tYXgoc3RhcnQsIDApOyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICBjb3VudCsrO1xuICAgICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0RXZlblNwYWNpbmcoYXJyKSB7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGxldCBpLCBkaWZmO1xuICBpZiAobGVuIDwgMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGRpZmYgPSBhcnJbMF0sIGkgPSAxOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldIC0gYXJyW2kgLSAxXSAhPT0gZGlmZikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZjtcbn1cblxuY29uc3QgcmV2ZXJzZUFsaWduID0gKGFsaWduKSA9PiBhbGlnbiA9PT0gJ2xlZnQnID8gJ3JpZ2h0JyA6IGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogYWxpZ247XG5jb25zdCBvZmZzZXRGcm9tRWRnZSA9IChzY2FsZSwgZWRnZSwgb2Zmc2V0KSA9PiBlZGdlID09PSAndG9wJyB8fCBlZGdlID09PSAnbGVmdCcgPyBzY2FsZVtlZGdlXSArIG9mZnNldCA6IHNjYWxlW2VkZ2VdIC0gb2Zmc2V0O1xuZnVuY3Rpb24gc2FtcGxlKGFyciwgbnVtSXRlbXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGluY3JlbWVudCA9IGFyci5sZW5ndGggLyBudW1JdGVtcztcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKDsgaSA8IGxlbjsgaSArPSBpbmNyZW1lbnQpIHtcbiAgICByZXN1bHQucHVzaChhcnJbTWF0aC5mbG9vcihpKV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRQaXhlbEZvckdyaWRMaW5lKHNjYWxlLCBpbmRleCwgb2Zmc2V0R3JpZExpbmVzKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLnRpY2tzLmxlbmd0aDtcbiAgY29uc3QgdmFsaWRJbmRleCA9IE1hdGgubWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgY29uc3Qgc3RhcnQgPSBzY2FsZS5fc3RhcnRQaXhlbDtcbiAgY29uc3QgZW5kID0gc2NhbGUuX2VuZFBpeGVsO1xuICBjb25zdCBlcHNpbG9uID0gMWUtNjtcbiAgbGV0IGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4KTtcbiAgbGV0IG9mZnNldDtcbiAgaWYgKG9mZnNldEdyaWRMaW5lcykge1xuICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIG9mZnNldCA9IE1hdGgubWF4KGxpbmVWYWx1ZSAtIHN0YXJ0LCBlbmQgLSBsaW5lVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIG9mZnNldCA9IChzY2FsZS5nZXRQaXhlbEZvclRpY2soMSkgLSBsaW5lVmFsdWUpIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gKGxpbmVWYWx1ZSAtIHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4IC0gMSkpIC8gMjtcbiAgICB9XG4gICAgbGluZVZhbHVlICs9IHZhbGlkSW5kZXggPCBpbmRleCA/IG9mZnNldCA6IC1vZmZzZXQ7XG4gICAgaWYgKGxpbmVWYWx1ZSA8IHN0YXJ0IC0gZXBzaWxvbiB8fCBsaW5lVmFsdWUgPiBlbmQgKyBlcHNpbG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJldHVybiBsaW5lVmFsdWU7XG59XG5mdW5jdGlvbiBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCkge1xuICBlYWNoKGNhY2hlcywgKGNhY2hlKSA9PiB7XG4gICAgY29uc3QgZ2MgPSBjYWNoZS5nYztcbiAgICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gICAgbGV0IGk7XG4gICAgaWYgKGdjTGVuID4gbGVuZ3RoKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ2NMZW47ICsraSkge1xuICAgICAgICBkZWxldGUgY2FjaGUuZGF0YVtnY1tpXV07XG4gICAgICB9XG4gICAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmRyYXdUaWNrcyA/IG9wdGlvbnMudGlja0xlbmd0aCA6IDA7XG59XG5mdW5jdGlvbiBnZXRUaXRsZUhlaWdodChvcHRpb25zLCBmYWxsYmFjaykge1xuICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IGZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb250LCBmYWxsYmFjayk7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KG9wdGlvbnMudGV4dCkgPyBvcHRpb25zLnRleHQubGVuZ3RoIDogMTtcbiAgcmV0dXJuIChsaW5lcyAqIGZvbnQubGluZUhlaWdodCkgKyBwYWRkaW5nLmhlaWdodDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlQ29udGV4dChwYXJlbnQsIHNjYWxlKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHNjYWxlLFxuICAgIHR5cGU6ICdzY2FsZSdcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUaWNrQ29udGV4dChwYXJlbnQsIGluZGV4LCB0aWNrKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRpY2ssXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3RpY2snXG4gIH0pO1xufVxuZnVuY3Rpb24gdGl0bGVBbGlnbihhbGlnbiwgcG9zaXRpb24sIHJldmVyc2UpIHtcbiAgbGV0IHJldCA9IF90b0xlZnRSaWdodENlbnRlcihhbGlnbik7XG4gIGlmICgocmV2ZXJzZSAmJiBwb3NpdGlvbiAhPT0gJ3JpZ2h0JykgfHwgKCFyZXZlcnNlICYmIHBvc2l0aW9uID09PSAncmlnaHQnKSkge1xuICAgIHJldCA9IHJldmVyc2VBbGlnbihyZXQpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiB0aXRsZUFyZ3Moc2NhbGUsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKSB7XG4gIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIGNoYXJ0fSA9IHNjYWxlO1xuICBjb25zdCB7Y2hhcnRBcmVhLCBzY2FsZXN9ID0gY2hhcnQ7XG4gIGxldCByb3RhdGlvbiA9IDA7XG4gIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG4gIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIGlmIChzY2FsZS5pc0hvcml6b250YWwoKSkge1xuICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWSA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWSA9IChjaGFydEFyZWEuYm90dG9tICsgY2hhcnRBcmVhLnRvcCkgLyAyICsgaGVpZ2h0IC0gb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZVkgPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgfVxuICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICB9IGVsc2Uge1xuICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICB0aXRsZVggPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWCA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICByb3RhdGlvbiA9IHBvc2l0aW9uID09PSAnbGVmdCcgPyAtSEFMRl9QSSA6IEhBTEZfUEk7XG4gIH1cbiAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcbn1cbmNsYXNzIFNjYWxlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pZCA9IGNmZy5pZDtcbiAgICB0aGlzLnR5cGUgPSBjZmcudHlwZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jdHggPSBjZmcuY3R4O1xuICAgIHRoaXMuY2hhcnQgPSBjZmcuY2hhcnQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ1RvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmF4aXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JhbmdlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGlja3MgPSBbXTtcbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX21heExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbG9uZ2VzdFRleHRDYWNoZSA9IHt9O1xuICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZW5kUGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZXJNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdXNlck1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IDA7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMuYXhpcyA9IG9wdGlvbnMuYXhpcztcbiAgICB0aGlzLl91c2VyTWluID0gdGhpcy5wYXJzZShvcHRpb25zLm1pbik7XG4gICAgdGhpcy5fdXNlck1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5tYXgpO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNaW4pO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNYXgpO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICByZXR1cm4gcmF3O1xuICB9XG4gIGdldFVzZXJCb3VuZHMoKSB7XG4gICAgbGV0IHtfdXNlck1pbiwgX3VzZXJNYXgsIF9zdWdnZXN0ZWRNaW4sIF9zdWdnZXN0ZWRNYXh9ID0gdGhpcztcbiAgICBfdXNlck1pbiA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfdXNlck1heCA9IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWluID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1heCA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgX3N1Z2dlc3RlZE1pbiksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChfdXNlck1heCwgX3N1Z2dlc3RlZE1heCksXG4gICAgICBtaW5EZWZpbmVkOiBpc051bWJlckZpbml0ZShfdXNlck1pbiksXG4gICAgICBtYXhEZWZpbmVkOiBpc051bWJlckZpbml0ZShfdXNlck1heClcbiAgICB9O1xuICB9XG4gIGdldE1pbk1heChjYW5TdGFjaykge1xuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHJhbmdlO1xuICAgIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQpIHtcbiAgICAgIHJldHVybiB7bWluLCBtYXh9O1xuICAgIH1cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcmFuZ2UgPSBtZXRhc1tpXS5jb250cm9sbGVyLmdldE1pbk1heCh0aGlzLCBjYW5TdGFjayk7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByYW5nZS5taW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcmFuZ2UubWF4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWluID0gbWF4RGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtYXggOiBtaW47XG4gICAgbWF4ID0gbWluRGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtaW4gOiBtYXg7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogZmluaXRlT3JEZWZhdWx0KG1pbiwgZmluaXRlT3JEZWZhdWx0KG1heCwgbWluKSksXG4gICAgICBtYXg6IGZpbml0ZU9yRGVmYXVsdChtYXgsIGZpbml0ZU9yRGVmYXVsdChtaW4sIG1heCkpXG4gICAgfTtcbiAgfVxuICBnZXRQYWRkaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLnBhZGRpbmdMZWZ0IHx8IDAsXG4gICAgICB0b3A6IHRoaXMucGFkZGluZ1RvcCB8fCAwLFxuICAgICAgcmlnaHQ6IHRoaXMucGFkZGluZ1JpZ2h0IHx8IDAsXG4gICAgICBib3R0b206IHRoaXMucGFkZGluZ0JvdHRvbSB8fCAwXG4gICAgfTtcbiAgfVxuICBnZXRUaWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50aWNrcztcbiAgfVxuICBnZXRMYWJlbHMoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHMgfHwgW107XG4gIH1cbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICB9XG4gIGJlZm9yZVVwZGF0ZSgpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbdGhpc10pO1xuICB9XG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvLCBncmFjZSwgdGlja3M6IHRpY2tPcHRzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzYW1wbGVTaXplID0gdGlja09wdHMuc2FtcGxlU2l6ZTtcbiAgICB0aGlzLmJlZm9yZVVwZGF0ZSgpO1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfSwgbWFyZ2lucyk7XG4gICAgdGhpcy50aWNrcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5hZnRlclNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSB0aGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICA/IHRoaXMud2lkdGggKyBtYXJnaW5zLmxlZnQgKyBtYXJnaW5zLnJpZ2h0XG4gICAgICA6IHRoaXMuaGVpZ2h0ICsgbWFyZ2lucy50b3AgKyBtYXJnaW5zLmJvdHRvbTtcbiAgICBpZiAoIXRoaXMuX2RhdGFMaW1pdHNDYWNoZWQpIHtcbiAgICAgIHRoaXMuYmVmb3JlRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmFmdGVyRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5fcmFuZ2UgPSBfYWRkR3JhY2UodGhpcywgZ3JhY2UsIGJlZ2luQXRaZXJvKTtcbiAgICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmJlZm9yZUJ1aWxkVGlja3MoKTtcbiAgICB0aGlzLnRpY2tzID0gdGhpcy5idWlsZFRpY2tzKCkgfHwgW107XG4gICAgdGhpcy5hZnRlckJ1aWxkVGlja3MoKTtcbiAgICBjb25zdCBzYW1wbGluZ0VuYWJsZWQgPSBzYW1wbGVTaXplIDwgdGhpcy50aWNrcy5sZW5ndGg7XG4gICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHMoc2FtcGxpbmdFbmFibGVkID8gc2FtcGxlKHRoaXMudGlja3MsIHNhbXBsZVNpemUpIDogdGhpcy50aWNrcyk7XG4gICAgdGhpcy5jb25maWd1cmUoKTtcbiAgICB0aGlzLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICB0aGlzLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmICh0aWNrT3B0cy5hdXRvU2tpcCB8fCB0aWNrT3B0cy5zb3VyY2UgPT09ICdhdXRvJykpIHtcbiAgICAgIHRoaXMudGlja3MgPSBhdXRvU2tpcCh0aGlzLCB0aGlzLnRpY2tzKTtcbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoc2FtcGxpbmdFbmFibGVkKSB7XG4gICAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyh0aGlzLnRpY2tzKTtcbiAgICB9XG4gICAgdGhpcy5iZWZvcmVGaXQoKTtcbiAgICB0aGlzLmZpdCgpO1xuICAgIHRoaXMuYWZ0ZXJGaXQoKTtcbiAgICB0aGlzLmFmdGVyVXBkYXRlKCk7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGxldCByZXZlcnNlUGl4ZWxzID0gdGhpcy5vcHRpb25zLnJldmVyc2U7XG4gICAgbGV0IHN0YXJ0UGl4ZWwsIGVuZFBpeGVsO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy5sZWZ0O1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy50b3A7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMuYm90dG9tO1xuICAgICAgcmV2ZXJzZVBpeGVscyA9ICFyZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFBpeGVsID0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9lbmRQaXhlbCA9IGVuZFBpeGVsO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSByZXZlcnNlUGl4ZWxzO1xuICAgIHRoaXMuX2xlbmd0aCA9IGVuZFBpeGVsIC0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9hbGlnblRvUGl4ZWxzID0gdGhpcy5vcHRpb25zLmFsaWduVG9QaXhlbHM7XG4gIH1cbiAgYWZ0ZXJVcGRhdGUoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVXBkYXRlLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZVNldERpbWVuc2lvbnMoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICB0aGlzLmxlZnQgPSAwO1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IDA7XG4gICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdUb3AgPSAwO1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSAwO1xuICB9XG4gIGFmdGVyU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG4gIF9jYWxsSG9va3MobmFtZSkge1xuICAgIHRoaXMuY2hhcnQubm90aWZ5UGx1Z2lucyhuYW1lLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zW25hbWVdLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZURhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVEYXRhTGltaXRzJyk7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHt9XG4gIGFmdGVyRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyRGF0YUxpbWl0cycpO1xuICB9XG4gIGJlZm9yZUJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVCdWlsZFRpY2tzJyk7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgYWZ0ZXJCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJCdWlsZFRpY2tzJyk7XG4gIH1cbiAgYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IGNhbGxiYWNrKHRpY2tPcHRzLmNhbGxiYWNrLCBbdGljay52YWx1ZSwgaSwgdGlja3NdLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcbiAgICBjb25zdCBudW1UaWNrcyA9IHRoaXMudGlja3MubGVuZ3RoO1xuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdGlja09wdHMubWluUm90YXRpb24gfHwgMDtcbiAgICBjb25zdCBtYXhSb3RhdGlvbiA9IHRpY2tPcHRzLm1heFJvdGF0aW9uO1xuICAgIGxldCBsYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgbGV0IHRpY2tXaWR0aCwgbWF4SGVpZ2h0LCBtYXhMYWJlbERpYWdvbmFsO1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIXRpY2tPcHRzLmRpc3BsYXkgfHwgbWluUm90YXRpb24gPj0gbWF4Um90YXRpb24gfHwgbnVtVGlja3MgPD0gMSB8fCAhdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgbWF4TGFiZWxXaWR0aCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuICAgIGNvbnN0IG1heExhYmVsSGVpZ2h0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodDtcbiAgICBjb25zdCBtYXhXaWR0aCA9IF9saW1pdFZhbHVlKHRoaXMuY2hhcnQud2lkdGggLSBtYXhMYWJlbFdpZHRoLCAwLCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aWNrV2lkdGggPSBvcHRpb25zLm9mZnNldCA/IHRoaXMubWF4V2lkdGggLyBudW1UaWNrcyA6IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gMSk7XG4gICAgaWYgKG1heExhYmVsV2lkdGggKyA2ID4gdGlja1dpZHRoKSB7XG4gICAgICB0aWNrV2lkdGggPSBtYXhXaWR0aCAvIChudW1UaWNrcyAtIChvcHRpb25zLm9mZnNldCA/IDAuNSA6IDEpKTtcbiAgICAgIG1heEhlaWdodCA9IHRoaXMubWF4SGVpZ2h0IC0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkKVxuXHRcdFx0XHQtIHRpY2tPcHRzLnBhZGRpbmcgLSBnZXRUaXRsZUhlaWdodChvcHRpb25zLnRpdGxlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBtYXhMYWJlbERpYWdvbmFsID0gTWF0aC5zcXJ0KG1heExhYmVsV2lkdGggKiBtYXhMYWJlbFdpZHRoICsgbWF4TGFiZWxIZWlnaHQgKiBtYXhMYWJlbEhlaWdodCk7XG4gICAgICBsYWJlbFJvdGF0aW9uID0gdG9EZWdyZWVzKE1hdGgubWluKFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUoKGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyA2KSAvIHRpY2tXaWR0aCwgLTEsIDEpKSxcbiAgICAgICAgTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSkgLSBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4TGFiZWxIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpXG4gICAgICApKTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSBNYXRoLm1heChtaW5Sb3RhdGlvbiwgTWF0aC5taW4obWF4Um90YXRpb24sIGxhYmVsUm90YXRpb24pKTtcbiAgICB9XG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbGFiZWxSb3RhdGlvbjtcbiAgfVxuICBhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBiZWZvcmVGaXQoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcbiAgfVxuICBmaXQoKSB7XG4gICAgY29uc3QgbWluU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICBjb25zdCB7Y2hhcnQsIG9wdGlvbnM6IHt0aWNrczogdGlja09wdHMsIHRpdGxlOiB0aXRsZU9wdHMsIGdyaWQ6IGdyaWRPcHRzfX0gPSB0aGlzO1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLl9pc1Zpc2libGUoKTtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICBjb25zdCB0aXRsZUhlaWdodCA9IGdldFRpdGxlSGVpZ2h0KHRpdGxlT3B0cywgY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICAgIG1pblNpemUuaGVpZ2h0ID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgICBtaW5TaXplLndpZHRoID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiB0aGlzLnRpY2tzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHdpZGVzdCwgaGlnaGVzdH0gPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgICAgIGNvbnN0IHRpY2tQYWRkaW5nID0gdGlja09wdHMucGFkZGluZyAqIDI7XG4gICAgICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IHRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgY29uc3QgbGFiZWxIZWlnaHQgPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogc2luICogd2lkZXN0LndpZHRoICsgY29zICogaGlnaGVzdC5oZWlnaHQ7XG4gICAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBNYXRoLm1pbih0aGlzLm1heEhlaWdodCwgbWluU2l6ZS5oZWlnaHQgKyBsYWJlbEhlaWdodCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGlja09wdHMubWlycm9yID8gMCA6IGNvcyAqIHdpZGVzdC53aWR0aCArIHNpbiAqIGhpZ2hlc3QuaGVpZ2h0O1xuICAgICAgICAgIG1pblNpemUud2lkdGggPSBNYXRoLm1pbih0aGlzLm1heFdpZHRoLCBtaW5TaXplLndpZHRoICsgbGFiZWxXaWR0aCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2hhbmRsZU1hcmdpbnMoKTtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQud2lkdGggLSB0aGlzLl9tYXJnaW5zLmxlZnQgLSB0aGlzLl9tYXJnaW5zLnJpZ2h0O1xuICAgICAgdGhpcy5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IG1pblNpemUud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LmhlaWdodCAtIHRoaXMuX21hcmdpbnMudG9wIC0gdGhpcy5fbWFyZ2lucy5ib3R0b207XG4gICAgfVxuICB9XG4gIF9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcykge1xuICAgIGNvbnN0IHt0aWNrczoge2FsaWduLCBwYWRkaW5nfSwgcG9zaXRpb259ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGlzUm90YXRlZCA9IHRoaXMubGFiZWxSb3RhdGlvbiAhPT0gMDtcbiAgICBjb25zdCBsYWJlbHNCZWxvd1RpY2tzID0gcG9zaXRpb24gIT09ICd0b3AnICYmIHRoaXMuYXhpcyA9PT0gJ3gnO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gdGhpcy5nZXRQaXhlbEZvclRpY2soMCkgLSB0aGlzLmxlZnQ7XG4gICAgICBjb25zdCBvZmZzZXRSaWdodCA9IHRoaXMucmlnaHQgLSB0aGlzLmdldFBpeGVsRm9yVGljayh0aGlzLnRpY2tzLmxlbmd0aCAtIDEpO1xuICAgICAgbGV0IHBhZGRpbmdMZWZ0ID0gMDtcbiAgICAgIGxldCBwYWRkaW5nUmlnaHQgPSAwO1xuICAgICAgaWYgKGlzUm90YXRlZCkge1xuICAgICAgICBpZiAobGFiZWxzQmVsb3dUaWNrcykge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gY29zICogZmlyc3Qud2lkdGg7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gc2luICogbGFzdC5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBzaW4gKiBmaXJzdC5oZWlnaHQ7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gY29zICogbGFzdC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGggLyAyO1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFkZGluZ0xlZnQgPSBNYXRoLm1heCgocGFkZGluZ0xlZnQgLSBvZmZzZXRMZWZ0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRMZWZ0KSwgMCk7XG4gICAgICB0aGlzLnBhZGRpbmdSaWdodCA9IE1hdGgubWF4KChwYWRkaW5nUmlnaHQgLSBvZmZzZXRSaWdodCArIHBhZGRpbmcpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gb2Zmc2V0UmlnaHQpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodCAvIDI7XG4gICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9IGZpcnN0LmhlaWdodCAvIDI7XG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IDA7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQ7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcCArIHBhZGRpbmc7XG4gICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBwYWRkaW5nQm90dG9tICsgcGFkZGluZztcbiAgICB9XG4gIH1cbiAgX2hhbmRsZU1hcmdpbnMoKSB7XG4gICAgaWYgKHRoaXMuX21hcmdpbnMpIHtcbiAgICAgIHRoaXMuX21hcmdpbnMubGVmdCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0xlZnQsIHRoaXMuX21hcmdpbnMubGVmdCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLnRvcCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1RvcCwgdGhpcy5fbWFyZ2lucy50b3ApO1xuICAgICAgdGhpcy5fbWFyZ2lucy5yaWdodCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1JpZ2h0LCB0aGlzLl9tYXJnaW5zLnJpZ2h0KTtcbiAgICAgIHRoaXMuX21hcmdpbnMuYm90dG9tID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nQm90dG9tLCB0aGlzLl9tYXJnaW5zLmJvdHRvbSk7XG4gICAgfVxuICB9XG4gIGFmdGVyRml0KCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckZpdCwgW3RoaXNdKTtcbiAgfVxuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3Qge2F4aXMsIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBheGlzID09PSAneCc7XG4gIH1cbiAgaXNGdWxsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZ1bGxTaXplO1xuICB9XG4gIF9jb252ZXJ0VGlja3NUb0xhYmVscyh0aWNrcykge1xuICAgIHRoaXMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gICAgdGhpcy5nZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHRpY2tzW2ldLmxhYmVsKSkge1xuICAgICAgICB0aWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGlsZW4tLTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gIH1cbiAgX2dldExhYmVsU2l6ZXMoKSB7XG4gICAgbGV0IGxhYmVsU2l6ZXMgPSB0aGlzLl9sYWJlbFNpemVzO1xuICAgIGlmICghbGFiZWxTaXplcykge1xuICAgICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWNrcy5zYW1wbGVTaXplO1xuICAgICAgbGV0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICAgIGlmIChzYW1wbGVTaXplIDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICAgIHRpY2tzID0gc2FtcGxlKHRpY2tzLCBzYW1wbGVTaXplKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBsYWJlbFNpemVzID0gdGhpcy5fY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIHRpY2tzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBsYWJlbFNpemVzO1xuICB9XG4gIF9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgbGVuZ3RoKSB7XG4gICAgY29uc3Qge2N0eCwgX2xvbmdlc3RUZXh0Q2FjaGU6IGNhY2hlc30gPSB0aGlzO1xuICAgIGNvbnN0IHdpZHRocyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodHMgPSBbXTtcbiAgICBsZXQgd2lkZXN0TGFiZWxTaXplID0gMDtcbiAgICBsZXQgaGlnaGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGksIGosIGpsZW4sIGxhYmVsLCB0aWNrRm9udCwgZm9udFN0cmluZywgY2FjaGUsIGxpbmVIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIG5lc3RlZExhYmVsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgbGFiZWwgPSB0aWNrc1tpXS5sYWJlbDtcbiAgICAgIHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgIGN0eC5mb250ID0gZm9udFN0cmluZyA9IHRpY2tGb250LnN0cmluZztcbiAgICAgIGNhY2hlID0gY2FjaGVzW2ZvbnRTdHJpbmddID0gY2FjaGVzW2ZvbnRTdHJpbmddIHx8IHtkYXRhOiB7fSwgZ2M6IFtdfTtcbiAgICAgIGxpbmVIZWlnaHQgPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xuICAgICAgd2lkdGggPSBoZWlnaHQgPSAwO1xuICAgICAgaWYgKCFpc051bGxPclVuZGVmKGxhYmVsKSAmJiAhaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIGxhYmVsKTtcbiAgICAgICAgaGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxhYmVsLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICAgIG5lc3RlZExhYmVsID0gbGFiZWxbal07XG4gICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKG5lc3RlZExhYmVsKSAmJiAhaXNBcnJheShuZXN0ZWRMYWJlbCkpIHtcbiAgICAgICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBuZXN0ZWRMYWJlbCk7XG4gICAgICAgICAgICBoZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdpZHRocy5wdXNoKHdpZHRoKTtcbiAgICAgIGhlaWdodHMucHVzaChoZWlnaHQpO1xuICAgICAgd2lkZXN0TGFiZWxTaXplID0gTWF0aC5tYXgod2lkdGgsIHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgICBoaWdoZXN0TGFiZWxTaXplID0gTWF0aC5tYXgoaGVpZ2h0LCBoaWdoZXN0TGFiZWxTaXplKTtcbiAgICB9XG4gICAgZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpO1xuICAgIGNvbnN0IHdpZGVzdCA9IHdpZHRocy5pbmRleE9mKHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgY29uc3QgaGlnaGVzdCA9IGhlaWdodHMuaW5kZXhPZihoaWdoZXN0TGFiZWxTaXplKTtcbiAgICBjb25zdCB2YWx1ZUF0ID0gKGlkeCkgPT4gKHt3aWR0aDogd2lkdGhzW2lkeF0gfHwgMCwgaGVpZ2h0OiBoZWlnaHRzW2lkeF0gfHwgMH0pO1xuICAgIHJldHVybiB7XG4gICAgICBmaXJzdDogdmFsdWVBdCgwKSxcbiAgICAgIGxhc3Q6IHZhbHVlQXQobGVuZ3RoIC0gMSksXG4gICAgICB3aWRlc3Q6IHZhbHVlQXQod2lkZXN0KSxcbiAgICAgIGhpZ2hlc3Q6IHZhbHVlQXQoaGlnaGVzdCksXG4gICAgICB3aWR0aHMsXG4gICAgICBoZWlnaHRzLFxuICAgIH07XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlLCBpbmRleCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge31cbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG4gIGdldFBpeGVsRm9yRGVjaW1hbChkZWNpbWFsKSB7XG4gICAgaWYgKHRoaXMuX3JldmVyc2VQaXhlbHMpIHtcbiAgICAgIGRlY2ltYWwgPSAxIC0gZGVjaW1hbDtcbiAgICB9XG4gICAgY29uc3QgcGl4ZWwgPSB0aGlzLl9zdGFydFBpeGVsICsgZGVjaW1hbCAqIHRoaXMuX2xlbmd0aDtcbiAgICByZXR1cm4gX2ludDE2UmFuZ2UodGhpcy5fYWxpZ25Ub1BpeGVscyA/IF9hbGlnblBpeGVsKHRoaXMuY2hhcnQsIHBpeGVsLCAwKSA6IHBpeGVsKTtcbiAgfVxuICBnZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gKHBpeGVsIC0gdGhpcy5fc3RhcnRQaXhlbCkgLyB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX3JldmVyc2VQaXhlbHMgPyAxIC0gZGVjaW1hbCA6IGRlY2ltYWw7XG4gIH1cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gIH1cbiAgZ2V0QmFzZVZhbHVlKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIHJldHVybiBtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxuICAgICAgbWluID4gMCAmJiBtYXggPiAwID8gbWluIDpcbiAgICAgIDA7XG4gIH1cbiAgZ2V0Q29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcyB8fCBbXTtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICAgIHJldHVybiB0aWNrLiRjb250ZXh0IHx8XG5cdFx0XHRcdCh0aWNrLiRjb250ZXh0ID0gY3JlYXRlVGlja0NvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCB0aWNrKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVNjYWxlQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcykpO1xuICB9XG4gIF90aWNrU2l6ZSgpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBjb25zdCByb3QgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3QpKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihyb3QpKTtcbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcgfHwgMDtcbiAgICBjb25zdCB3ID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoICsgcGFkZGluZyA6IDA7XG4gICAgY29uc3QgaCA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgcGFkZGluZyA6IDA7XG4gICAgcmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgID8gaCAqIGNvcyA+IHcgKiBzaW4gPyB3IC8gY29zIDogaCAvIHNpblxuICAgICAgOiBoICogc2luIDwgdyAqIGNvcyA/IGggLyBjb3MgOiB3IC8gc2luO1xuICB9XG4gIF9pc1Zpc2libGUoKSB7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMub3B0aW9ucy5kaXNwbGF5O1xuICAgIGlmIChkaXNwbGF5ICE9PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiAhIWRpc3BsYXk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCkubGVuZ3RoID4gMDtcbiAgfVxuICBfY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7Z3JpZCwgcG9zaXRpb259ID0gb3B0aW9ucztcbiAgICBjb25zdCBvZmZzZXQgPSBncmlkLm9mZnNldDtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCB0aWNrc0xlbmd0aCA9IHRpY2tzLmxlbmd0aCArIChvZmZzZXQgPyAxIDogMCk7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGJvcmRlck9wdHMuZHJhd0JvcmRlciA/IGJvcmRlck9wdHMuYm9yZGVyV2lkdGggOiAwO1xuICAgIGNvbnN0IGF4aXNIYWxmV2lkdGggPSBheGlzV2lkdGggLyAyO1xuICAgIGNvbnN0IGFsaWduQm9yZGVyVmFsdWUgPSBmdW5jdGlvbihwaXhlbCkge1xuICAgICAgcmV0dXJuIF9hbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgYXhpc1dpZHRoKTtcbiAgICB9O1xuICAgIGxldCBib3JkZXJWYWx1ZSwgaSwgbGluZVZhbHVlLCBhbGlnbmVkTGluZVZhbHVlO1xuICAgIGxldCB0eDEsIHR5MSwgdHgyLCB0eTIsIHgxLCB5MSwgeDIsIHkyO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmJvdHRvbSk7XG4gICAgICB0eTEgPSB0aGlzLmJvdHRvbSAtIHRsO1xuICAgICAgdHkyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeTEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS50b3ApICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMudG9wKTtcbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEuYm90dG9tKSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0aGlzLnRvcCArIHRsO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMucmlnaHQpO1xuICAgICAgdHgxID0gdGhpcy5yaWdodCAtIHRsO1xuICAgICAgdHgyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeDEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5sZWZ0KSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5sZWZ0KTtcbiAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB4MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnJpZ2h0KSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDIgPSB0aGlzLmxlZnQgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIgKyAwLjUpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHR5MSArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMik7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdHgxIC0gdGw7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0LCB0aWNrc0xlbmd0aCk7XG4gICAgY29uc3Qgc3RlcCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbCh0aWNrc0xlbmd0aCAvIGxpbWl0KSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRpY2tzTGVuZ3RoOyBpICs9IHN0ZXApIHtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpKSk7XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSBvcHRzQXRJbmRleC5saW5lV2lkdGg7XG4gICAgICBjb25zdCBsaW5lQ29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2ggPSBncmlkLmJvcmRlckRhc2ggfHwgW107XG4gICAgICBjb25zdCBib3JkZXJEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaE9mZnNldDtcbiAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IG9wdHNBdEluZGV4LnRpY2tXaWR0aDtcbiAgICAgIGNvbnN0IHRpY2tDb2xvciA9IG9wdHNBdEluZGV4LnRpY2tDb2xvcjtcbiAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2ggfHwgW107XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgbGluZVZhbHVlID0gZ2V0UGl4ZWxGb3JHcmlkTGluZSh0aGlzLCBpLCBvZmZzZXQpO1xuICAgICAgaWYgKGxpbmVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYWxpZ25lZExpbmVWYWx1ZSA9IF9hbGlnblBpeGVsKGNoYXJ0LCBsaW5lVmFsdWUsIGxpbmVXaWR0aCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHkxID0gdHkyID0geTEgPSB5MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9XG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgdHgxLFxuICAgICAgICB0eTEsXG4gICAgICAgIHR4MixcbiAgICAgICAgdHkyLFxuICAgICAgICB4MSxcbiAgICAgICAgeTEsXG4gICAgICAgIHgyLFxuICAgICAgICB5MixcbiAgICAgICAgd2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgICAgY29sb3I6IGxpbmVDb2xvcixcbiAgICAgICAgYm9yZGVyRGFzaCxcbiAgICAgICAgYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgdGlja1dpZHRoLFxuICAgICAgICB0aWNrQ29sb3IsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaE9mZnNldCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IHRpY2tzTGVuZ3RoO1xuICAgIHRoaXMuX2JvcmRlclZhbHVlID0gYm9yZGVyVmFsdWU7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIF9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczogb3B0aW9uVGlja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCB7YWxpZ24sIGNyb3NzQWxpZ24sIHBhZGRpbmcsIG1pcnJvcn0gPSBvcHRpb25UaWNrcztcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZCk7XG4gICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgY29uc3QgaFRpY2tBbmRQYWRkaW5nID0gbWlycm9yID8gLXBhZGRpbmcgOiB0aWNrQW5kUGFkZGluZztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrLCBsYWJlbCwgeCwgeSwgdGV4dEFsaWduLCBwaXhlbCwgZm9udCwgbGluZUhlaWdodCwgbGluZUNvdW50LCB0ZXh0T2Zmc2V0O1xuICAgIGxldCB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICB5ID0gdGhpcy5ib3R0b20gLSBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHkgPSB0aGlzLnRvcCArIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeSA9ICgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMikgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeSA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHggPSAoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpIC0gdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHggPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKS50ZXh0QWxpZ247XG4gICAgfVxuICAgIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIGxhYmVsID0gdGljay5sYWJlbDtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gb3B0aW9uVGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaSkpO1xuICAgICAgcGl4ZWwgPSB0aGlzLmdldFBpeGVsRm9yVGljayhpKSArIG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xuICAgICAgZm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBsaW5lSGVpZ2h0ID0gZm9udC5saW5lSGVpZ2h0O1xuICAgICAgbGluZUNvdW50ID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbC5sZW5ndGggOiAxO1xuICAgICAgY29uc3QgaGFsZkNvdW50ID0gbGluZUNvdW50IC8gMjtcbiAgICAgIGNvbnN0IGNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBzdHJva2VDb2xvciA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VDb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB4ID0gcGl4ZWw7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxpbmVDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaGFsZkNvdW50ICogbGluZUhlaWdodCArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaGFsZkNvdW50ICogbGluZUhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLSBsaW5lQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgICAgdGV4dE9mZnNldCAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IHBpeGVsO1xuICAgICAgICB0ZXh0T2Zmc2V0ID0gKDEgLSBsaW5lQ291bnQpICogbGluZUhlaWdodCAvIDI7XG4gICAgICB9XG4gICAgICBsZXQgYmFja2Ryb3A7XG4gICAgICBpZiAob3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgY29uc3QgbGFiZWxQYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGxhYmVsU2l6ZXMuaGVpZ2h0c1tpXTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBsYWJlbFNpemVzLndpZHRoc1tpXTtcbiAgICAgICAgbGV0IHRvcCA9IHkgKyB0ZXh0T2Zmc2V0IC0gbGFiZWxQYWRkaW5nLnRvcDtcbiAgICAgICAgbGV0IGxlZnQgPSB4IC0gbGFiZWxQYWRkaW5nLmxlZnQ7XG4gICAgICAgIHN3aXRjaCAodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgdG9wIC09IGhlaWdodCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRleHRBbGlnbikge1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGggLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBiYWNrZHJvcCA9IHtcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICB3aWR0aDogd2lkdGggKyBsYWJlbFBhZGRpbmcud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyBsYWJlbFBhZGRpbmcuaGVpZ2h0LFxuICAgICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgZm9udCxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHN0cm9rZUNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgdGV4dE9mZnNldCxcbiAgICAgICAgdGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICAgIHRyYW5zbGF0aW9uOiBbeCwgeV0sXG4gICAgICAgIGJhY2tkcm9wLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICBfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBpZiAocm90YXRpb24pIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH1cbiAgICBsZXQgYWxpZ24gPSAnY2VudGVyJztcbiAgICBpZiAodGlja3MuYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgIGFsaWduID0gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICBhbGlnbiA9ICdyaWdodCc7XG4gICAgfVxuICAgIHJldHVybiBhbGlnbjtcbiAgfVxuICBfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IHtjcm9zc0FsaWduLCBtaXJyb3IsIHBhZGRpbmd9fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IHdpZGVzdCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuICAgIGxldCB0ZXh0QWxpZ247XG4gICAgbGV0IHg7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgKyBwYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ICs9IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgLSB0aWNrQW5kUGFkZGluZztcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCA9IHRoaXMubGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCAtPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIHggLT0gd2lkZXN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4ICs9IHdpZGVzdCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ID0gdGhpcy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgIH1cbiAgICByZXR1cm4ge3RleHRBbGlnbiwgeH07XG4gIH1cbiAgX2NvbXB1dGVMYWJlbEFyZWEoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50aWNrcy5taXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICByZXR1cm4ge3RvcDogMCwgbGVmdDogdGhpcy5sZWZ0LCBib3R0b206IGNoYXJ0LmhlaWdodCwgcmlnaHQ6IHRoaXMucmlnaHR9O1xuICAgIH0gaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHJldHVybiB7dG9wOiB0aGlzLnRvcCwgbGVmdDogMCwgYm90dG9tOiB0aGlzLmJvdHRvbSwgcmlnaHQ6IGNoYXJ0LndpZHRofTtcbiAgICB9XG4gIH1cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge2JhY2tncm91bmRDb2xvcn0sIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodH0gPSB0aGlzO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBnZXRMaW5lV2lkdGhGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICFncmlkLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3QgaW5kZXggPSB0aWNrcy5maW5kSW5kZXgodCA9PiB0LnZhbHVlID09PSB2YWx1ZSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IG9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICByZXR1cm4gb3B0cy5saW5lV2lkdGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGRyYXdHcmlkKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dyaWRMaW5lSXRlbXMgfHwgKHRoaXMuX2dyaWRMaW5lSXRlbXMgPSB0aGlzLl9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBjb25zdCBkcmF3TGluZSA9IChwMSwgcDIsIHN0eWxlKSA9PiB7XG4gICAgICBpZiAoIXN0eWxlLndpZHRoIHx8ICFzdHlsZS5jb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2goc3R5bGUuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55KTtcbiAgICAgIGN0eC5saW5lVG8ocDIueCwgcDIueSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChncmlkLmRyYXdPbkNoYXJ0QXJlYSkge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0ueDEsIHk6IGl0ZW0ueTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0ueDIsIHk6IGl0ZW0ueTJ9LFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyaWQuZHJhd1RpY2tzKSB7XG4gICAgICAgICAgZHJhd0xpbmUoXG4gICAgICAgICAgICB7eDogaXRlbS50eDEsIHk6IGl0ZW0udHkxfSxcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MiwgeTogaXRlbS50eTJ9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb2xvcjogaXRlbS50aWNrQ29sb3IsXG4gICAgICAgICAgICAgIHdpZHRoOiBpdGVtLnRpY2tXaWR0aCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaDogaXRlbS50aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogaXRlbS50aWNrQm9yZGVyRGFzaE9mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJhd0JvcmRlcigpIHtcbiAgICBjb25zdCB7Y2hhcnQsIGN0eCwgb3B0aW9uczoge2dyaWR9fSA9IHRoaXM7XG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gZ3JpZC5kcmF3Qm9yZGVyID8gYm9yZGVyT3B0cy5ib3JkZXJXaWR0aCA6IDA7XG4gICAgaWYgKCFheGlzV2lkdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdExpbmVXaWR0aCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoMCkpLmxpbmVXaWR0aDtcbiAgICBjb25zdCBib3JkZXJWYWx1ZSA9IHRoaXMuX2JvcmRlclZhbHVlO1xuICAgIGxldCB4MSwgeDIsIHkxLCB5MjtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgeDEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5sZWZ0LCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHgyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMucmlnaHQsIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG4gICAgICB5MSA9IHkyID0gYm9yZGVyVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMudG9wLCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHkyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMuYm90dG9tLCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeDEgPSB4MiA9IGJvcmRlclZhbHVlO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJPcHRzLmJvcmRlcldpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlck9wdHMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgZHJhd0xhYmVscyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBpZiAoIW9wdGlvblRpY2tzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuX2NvbXB1dGVMYWJlbEFyZWEoKTtcbiAgICBpZiAoYXJlYSkge1xuICAgICAgY2xpcEFyZWEoY3R4LCBhcmVhKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9sYWJlbEl0ZW1zIHx8ICh0aGlzLl9sYWJlbEl0ZW1zID0gdGhpcy5fY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSBpdGVtLmZvbnQ7XG4gICAgICBjb25zdCBsYWJlbCA9IGl0ZW0ubGFiZWw7XG4gICAgICBpZiAoaXRlbS5iYWNrZHJvcCkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gaXRlbS5iYWNrZHJvcC5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KGl0ZW0uYmFja2Ryb3AubGVmdCwgaXRlbS5iYWNrZHJvcC50b3AsIGl0ZW0uYmFja2Ryb3Aud2lkdGgsIGl0ZW0uYmFja2Ryb3AuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGxldCB5ID0gaXRlbS50ZXh0T2Zmc2V0O1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxhYmVsLCAwLCB5LCB0aWNrRm9udCwgaXRlbSk7XG4gICAgfVxuICAgIGlmIChhcmVhKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICB9XG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9zaXRpb24sIHRpdGxlLCByZXZlcnNlfX0gPSB0aGlzO1xuICAgIGlmICghdGl0bGUuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmb250ID0gdG9Gb250KHRpdGxlLmZvbnQpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGUucGFkZGluZyk7XG4gICAgY29uc3QgYWxpZ24gPSB0aXRsZS5hbGlnbjtcbiAgICBsZXQgb2Zmc2V0ID0gZm9udC5saW5lSGVpZ2h0IC8gMjtcbiAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nIHx8IHBvc2l0aW9uID09PSAnY2VudGVyJyB8fCBpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLmJvdHRvbTtcbiAgICAgIGlmIChpc0FycmF5KHRpdGxlLnRleHQpKSB7XG4gICAgICAgIG9mZnNldCArPSBmb250LmxpbmVIZWlnaHQgKiAodGl0bGUudGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcudG9wO1xuICAgIH1cbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aXRsZUFyZ3ModGhpcywgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pO1xuICAgIHJlbmRlclRleHQoY3R4LCB0aXRsZS50ZXh0LCAwLCAwLCBmb250LCB7XG4gICAgICBjb2xvcjogdGl0bGUuY29sb3IsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduOiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSksXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgdHJhbnNsYXRpb246IFt0aXRsZVgsIHRpdGxlWV0sXG4gICAgfSk7XG4gIH1cbiAgZHJhdyhjaGFydEFyZWEpIHtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgfVxuICBfbGF5ZXJzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdHogPSBvcHRzLnRpY2tzICYmIG9wdHMudGlja3MueiB8fCAwO1xuICAgIGNvbnN0IGd6ID0gdmFsdWVPckRlZmF1bHQob3B0cy5ncmlkICYmIG9wdHMuZ3JpZC56LCAtMSk7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCB0aGlzLmRyYXcgIT09IFNjYWxlLnByb3RvdHlwZS5kcmF3KSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogdHosXG4gICAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgICB0aGlzLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBbe1xuICAgICAgejogZ3osXG4gICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICAgICAgdGhpcy5kcmF3R3JpZChjaGFydEFyZWEpO1xuICAgICAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IGd6ICsgMSxcbiAgICAgIGRyYXc6ICgpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogdHosXG4gICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICAgICAgfVxuICAgIH1dO1xuICB9XG4gIGdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpIHtcbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGF4aXNJRCA9IHRoaXMuYXhpcyArICdBeGlzSUQnO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICAgIGlmIChtZXRhW2F4aXNJRF0gPT09IHRoaXMuaWQgJiYgKCF0eXBlIHx8IG1ldGEudHlwZSA9PT0gdHlwZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaW5kZXgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgcmV0dXJuIHRvRm9udChvcHRzLmZvbnQpO1xuICB9XG4gIF9tYXhEaWdpdHMoKSB7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLmxpbmVIZWlnaHQ7XG4gICAgcmV0dXJuICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0KSAvIGZvbnRTaXplO1xuICB9XG59XG5cbmNsYXNzIFR5cGVkUmVnaXN0cnkge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBzY29wZSwgb3ZlcnJpZGUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgdGhpcy5pdGVtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgaXNGb3JUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwodGhpcy50eXBlLnByb3RvdHlwZSwgdHlwZS5wcm90b3R5cGUpO1xuICB9XG4gIHJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpdGVtKTtcbiAgICBsZXQgcGFyZW50U2NvcGU7XG4gICAgaWYgKGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSkge1xuICAgICAgcGFyZW50U2NvcGUgPSB0aGlzLnJlZ2lzdGVyKHByb3RvKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGUgKyAnLicgKyBpZDtcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsYXNzIGRvZXMgbm90IGhhdmUgaWQ6ICcgKyBpdGVtKTtcbiAgICB9XG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuICAgIGl0ZW1zW2lkXSA9IGl0ZW07XG4gICAgcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpO1xuICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICBkZWZhdWx0cy5vdmVycmlkZShpdGVtLmlkLCBpdGVtLm92ZXJyaWRlcyk7XG4gICAgfVxuICAgIHJldHVybiBzY29wZTtcbiAgfVxuICBnZXQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtc1tpZF07XG4gIH1cbiAgdW5yZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGU7XG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICBkZWxldGUgaXRlbXNbaWRdO1xuICAgIH1cbiAgICBpZiAoc2NvcGUgJiYgaWQgaW4gZGVmYXVsdHNbc2NvcGVdKSB7XG4gICAgICBkZWxldGUgZGVmYXVsdHNbc2NvcGVdW2lkXTtcbiAgICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgY29uc3QgaXRlbURlZmF1bHRzID0gbWVyZ2UoT2JqZWN0LmNyZWF0ZShudWxsKSwgW1xuICAgIHBhcmVudFNjb3BlID8gZGVmYXVsdHMuZ2V0KHBhcmVudFNjb3BlKSA6IHt9LFxuICAgIGRlZmF1bHRzLmdldChzY29wZSksXG4gICAgaXRlbS5kZWZhdWx0c1xuICBdKTtcbiAgZGVmYXVsdHMuc2V0KHNjb3BlLCBpdGVtRGVmYXVsdHMpO1xuICBpZiAoaXRlbS5kZWZhdWx0Um91dGVzKSB7XG4gICAgcm91dGVEZWZhdWx0cyhzY29wZSwgaXRlbS5kZWZhdWx0Um91dGVzKTtcbiAgfVxuICBpZiAoaXRlbS5kZXNjcmlwdG9ycykge1xuICAgIGRlZmF1bHRzLmRlc2NyaWJlKHNjb3BlLCBpdGVtLmRlc2NyaXB0b3JzKTtcbiAgfVxufVxuZnVuY3Rpb24gcm91dGVEZWZhdWx0cyhzY29wZSwgcm91dGVzKSB7XG4gIE9iamVjdC5rZXlzKHJvdXRlcykuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgY29uc3QgcHJvcGVydHlQYXJ0cyA9IHByb3BlcnR5LnNwbGl0KCcuJyk7XG4gICAgY29uc3Qgc291cmNlTmFtZSA9IHByb3BlcnR5UGFydHMucG9wKCk7XG4gICAgY29uc3Qgc291cmNlU2NvcGUgPSBbc2NvcGVdLmNvbmNhdChwcm9wZXJ0eVBhcnRzKS5qb2luKCcuJyk7XG4gICAgY29uc3QgcGFydHMgPSByb3V0ZXNbcHJvcGVydHldLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgdGFyZ2V0TmFtZSA9IHBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlID0gcGFydHMuam9pbignLicpO1xuICAgIGRlZmF1bHRzLnJvdXRlKHNvdXJjZVNjb3BlLCBzb3VyY2VOYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pIHtcbiAgcmV0dXJuICdpZCcgaW4gcHJvdG8gJiYgJ2RlZmF1bHRzJyBpbiBwcm90bztcbn1cblxuY2xhc3MgUmVnaXN0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXJzID0gbmV3IFR5cGVkUmVnaXN0cnkoRGF0YXNldENvbnRyb2xsZXIsICdkYXRhc2V0cycsIHRydWUpO1xuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgVHlwZWRSZWdpc3RyeShFbGVtZW50LCAnZWxlbWVudHMnKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBuZXcgVHlwZWRSZWdpc3RyeShPYmplY3QsICdwbHVnaW5zJyk7XG4gICAgdGhpcy5zY2FsZXMgPSBuZXcgVHlwZWRSZWdpc3RyeShTY2FsZSwgJ3NjYWxlcycpO1xuICAgIHRoaXMuX3R5cGVkUmVnaXN0cmllcyA9IFt0aGlzLmNvbnRyb2xsZXJzLCB0aGlzLnNjYWxlcywgdGhpcy5lbGVtZW50c107XG4gIH1cbiAgYWRkKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MpO1xuICB9XG4gIHJlbW92ZSguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MpO1xuICB9XG4gIGFkZENvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG4gIGFkZEVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG4gIGFkZFBsdWdpbnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuICBhZGRTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5zY2FsZXMpO1xuICB9XG4gIGdldENvbnRyb2xsZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmNvbnRyb2xsZXJzLCAnY29udHJvbGxlcicpO1xuICB9XG4gIGdldEVsZW1lbnQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmVsZW1lbnRzLCAnZWxlbWVudCcpO1xuICB9XG4gIGdldFBsdWdpbihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMucGx1Z2lucywgJ3BsdWdpbicpO1xuICB9XG4gIGdldFNjYWxlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5zY2FsZXMsICdzY2FsZScpO1xuICB9XG4gIHJlbW92ZUNvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cbiAgcmVtb3ZlRWxlbWVudHMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuICByZW1vdmVQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuICByZW1vdmVTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cbiAgX2VhY2gobWV0aG9kLCBhcmdzLCB0eXBlZFJlZ2lzdHJ5KSB7XG4gICAgWy4uLmFyZ3NdLmZvckVhY2goYXJnID0+IHtcbiAgICAgIGNvbnN0IHJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGFyZyk7XG4gICAgICBpZiAodHlwZWRSZWdpc3RyeSB8fCByZWcuaXNGb3JUeXBlKGFyZykgfHwgKHJlZyA9PT0gdGhpcy5wbHVnaW5zICYmIGFyZy5pZCkpIHtcbiAgICAgICAgdGhpcy5fZXhlYyhtZXRob2QsIHJlZywgYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhY2goYXJnLCBpdGVtID0+IHtcbiAgICAgICAgICBjb25zdCBpdGVtUmVnID0gdHlwZWRSZWdpc3RyeSB8fCB0aGlzLl9nZXRSZWdpc3RyeUZvclR5cGUoaXRlbSk7XG4gICAgICAgICAgdGhpcy5fZXhlYyhtZXRob2QsIGl0ZW1SZWcsIGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfZXhlYyhtZXRob2QsIHJlZ2lzdHJ5LCBjb21wb25lbnQpIHtcbiAgICBjb25zdCBjYW1lbE1ldGhvZCA9IF9jYXBpdGFsaXplKG1ldGhvZCk7XG4gICAgY2FsbGJhY2soY29tcG9uZW50WydiZWZvcmUnICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTtcbiAgICByZWdpc3RyeVttZXRob2RdKGNvbXBvbmVudCk7XG4gICAgY2FsbGJhY2soY29tcG9uZW50WydhZnRlcicgKyBjYW1lbE1ldGhvZF0sIFtdLCBjb21wb25lbnQpO1xuICB9XG4gIF9nZXRSZWdpc3RyeUZvclR5cGUodHlwZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdHlwZWRSZWdpc3RyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZWcgPSB0aGlzLl90eXBlZFJlZ2lzdHJpZXNbaV07XG4gICAgICBpZiAocmVnLmlzRm9yVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gcmVnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wbHVnaW5zO1xuICB9XG4gIF9nZXQoaWQsIHR5cGVkUmVnaXN0cnksIHR5cGUpIHtcbiAgICBjb25zdCBpdGVtID0gdHlwZWRSZWdpc3RyeS5nZXQoaWQpO1xuICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgaWQgKyAnXCIgaXMgbm90IGEgcmVnaXN0ZXJlZCAnICsgdHlwZSArICcuJyk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9XG59XG52YXIgcmVnaXN0cnkgPSBuZXcgUmVnaXN0cnkoKTtcblxuY2xhc3MgUGx1Z2luU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luaXQgPSBbXTtcbiAgfVxuICBub3RpZnkoY2hhcnQsIGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgIGlmIChob29rID09PSAnYmVmb3JlSW5pdCcpIHtcbiAgICAgIHRoaXMuX2luaXQgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgdHJ1ZSk7XG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICdpbnN0YWxsJyk7XG4gICAgfVxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gZmlsdGVyID8gdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpLmZpbHRlcihmaWx0ZXIpIDogdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpO1xuICAgIGlmIChob29rID09PSAnYWZ0ZXJEZXN0cm95Jykge1xuICAgICAgdGhpcy5fbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgJ3N0b3AnKTtcbiAgICAgIHRoaXMuX25vdGlmeSh0aGlzLl9pbml0LCBjaGFydCwgJ3VuaW5zdGFsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIF9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKSB7XG4gICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBkZXNjcmlwdG9yLnBsdWdpbjtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHBsdWdpbltob29rXTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFtjaGFydCwgYXJncywgZGVzY3JpcHRvci5vcHRpb25zXTtcbiAgICAgIGlmIChjYWxsYmFjayhtZXRob2QsIHBhcmFtcywgcGx1Z2luKSA9PT0gZmFsc2UgJiYgYXJncy5jYW5jZWxhYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYodGhpcy5fY2FjaGUpKSB7XG4gICAgICB0aGlzLl9vbGRDYWNoZSA9IHRoaXMuX2NhY2hlO1xuICAgICAgdGhpcy5fY2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIF9kZXNjcmlwdG9ycyhjaGFydCkge1xuICAgIGlmICh0aGlzLl9jYWNoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICAgIH1cbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQpO1xuICAgIHRoaXMuX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCk7XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9XG4gIF9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgYWxsKSB7XG4gICAgY29uc3QgY29uZmlnID0gY2hhcnQgJiYgY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB2YWx1ZU9yRGVmYXVsdChjb25maWcub3B0aW9ucyAmJiBjb25maWcub3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gICAgY29uc3QgcGx1Z2lucyA9IGFsbFBsdWdpbnMoY29uZmlnKTtcbiAgICByZXR1cm4gb3B0aW9ucyA9PT0gZmFsc2UgJiYgIWFsbCA/IFtdIDogY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHBsdWdpbnMsIG9wdGlvbnMsIGFsbCk7XG4gIH1cbiAgX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCkge1xuICAgIGNvbnN0IHByZXZpb3VzRGVzY3JpcHRvcnMgPSB0aGlzLl9vbGRDYWNoZSB8fCBbXTtcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5wbHVnaW4uaWQgPT09IHkucGx1Z2luLmlkKSk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYocHJldmlvdXNEZXNjcmlwdG9ycywgZGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0b3AnKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihkZXNjcmlwdG9ycywgcHJldmlvdXNEZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RhcnQnKTtcbiAgfVxufVxuZnVuY3Rpb24gYWxsUGx1Z2lucyhjb25maWcpIHtcbiAgY29uc3QgcGx1Z2lucyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocmVnaXN0cnkucGx1Z2lucy5pdGVtcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHBsdWdpbnMucHVzaChyZWdpc3RyeS5nZXRQbHVnaW4oa2V5c1tpXSkpO1xuICB9XG4gIGNvbnN0IGxvY2FsID0gY29uZmlnLnBsdWdpbnMgfHwgW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwbHVnaW4gPSBsb2NhbFtpXTtcbiAgICBpZiAocGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPT09IC0xKSB7XG4gICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBsdWdpbnM7XG59XG5mdW5jdGlvbiBnZXRPcHRzKG9wdGlvbnMsIGFsbCkge1xuICBpZiAoIWFsbCAmJiBvcHRpb25zID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHBsdWdpbnMsIG9wdGlvbnMsIGFsbCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgY29udGV4dCA9IGNoYXJ0LmdldENvbnRleHQoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCBvcHRzID0gZ2V0T3B0cyhvcHRpb25zW2lkXSwgYWxsKTtcbiAgICBpZiAob3B0cyA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIHBsdWdpbixcbiAgICAgIG9wdGlvbnM6IHBsdWdpbk9wdHMoY2hhcnQuY29uZmlnLCBwbHVnaW4sIG9wdHMsIGNvbnRleHQpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBsdWdpbk9wdHMoY29uZmlnLCBwbHVnaW4sIG9wdHMsIGNvbnRleHQpIHtcbiAgY29uc3Qga2V5cyA9IGNvbmZpZy5wbHVnaW5TY29wZUtleXMocGx1Z2luKTtcbiAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3BlcyhvcHRzLCBrZXlzKTtcbiAgcmV0dXJuIGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIFsnJ10sIHtzY3JpcHRhYmxlOiBmYWxzZSwgaW5kZXhhYmxlOiBmYWxzZSwgYWxsS2V5czogdHJ1ZX0pO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucykge1xuICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fTtcbiAgY29uc3QgZGF0YXNldE9wdGlvbnMgPSAob3B0aW9ucy5kYXRhc2V0cyB8fCB7fSlbdHlwZV0gfHwge307XG4gIHJldHVybiBkYXRhc2V0T3B0aW9ucy5pbmRleEF4aXMgfHwgb3B0aW9ucy5pbmRleEF4aXMgfHwgZGF0YXNldERlZmF1bHRzLmluZGV4QXhpcyB8fCAneCc7XG59XG5mdW5jdGlvbiBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGlkLCBpbmRleEF4aXMpIHtcbiAgbGV0IGF4aXMgPSBpZDtcbiAgaWYgKGlkID09PSAnX2luZGV4XycpIHtcbiAgICBheGlzID0gaW5kZXhBeGlzO1xuICB9IGVsc2UgaWYgKGlkID09PSAnX3ZhbHVlXycpIHtcbiAgICBheGlzID0gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG4gIH1cbiAgcmV0dXJuIGF4aXM7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGluZGV4QXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gaW5kZXhBeGlzID8gJ19pbmRleF8nIDogJ192YWx1ZV8nO1xufVxuZnVuY3Rpb24gYXhpc0Zyb21Qb3NpdGlvbihwb3NpdGlvbikge1xuICBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgIHJldHVybiAneCc7XG4gIH1cbiAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICByZXR1cm4gJ3knO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpIHtcbiAgaWYgKGlkID09PSAneCcgfHwgaWQgPT09ICd5Jykge1xuICAgIHJldHVybiBpZDtcbiAgfVxuICByZXR1cm4gc2NhbGVPcHRpb25zLmF4aXMgfHwgYXhpc0Zyb21Qb3NpdGlvbihzY2FsZU9wdGlvbnMucG9zaXRpb24pIHx8IGlkLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hhcnREZWZhdWx0cyA9IG92ZXJyaWRlc1tjb25maWcudHlwZV0gfHwge3NjYWxlczoge319O1xuICBjb25zdCBjb25maWdTY2FsZXMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgY29uc3QgY2hhcnRJbmRleEF4aXMgPSBnZXRJbmRleEF4aXMoY29uZmlnLnR5cGUsIG9wdGlvbnMpO1xuICBjb25zdCBmaXJzdElEcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IHNjYWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIE9iamVjdC5rZXlzKGNvbmZpZ1NjYWxlcykuZm9yRWFjaChpZCA9PiB7XG4gICAgY29uc3Qgc2NhbGVDb25mID0gY29uZmlnU2NhbGVzW2lkXTtcbiAgICBpZiAoIWlzT2JqZWN0KHNjYWxlQ29uZikpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGBJbnZhbGlkIHNjYWxlIGNvbmZpZ3VyYXRpb24gZm9yIHNjYWxlOiAke2lkfWApO1xuICAgIH1cbiAgICBpZiAoc2NhbGVDb25mLl9wcm94eSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihgSWdub3JpbmcgcmVzb2x2ZXIgcGFzc2VkIGFzIG9wdGlvbnMgZm9yIHNjYWxlOiAke2lkfWApO1xuICAgIH1cbiAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVDb25mKTtcbiAgICBjb25zdCBkZWZhdWx0SWQgPSBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGNoYXJ0SW5kZXhBeGlzKTtcbiAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gY2hhcnREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgZmlyc3RJRHNbYXhpc10gPSBmaXJzdElEc1theGlzXSB8fCBpZDtcbiAgICBzY2FsZXNbaWRdID0gbWVyZ2VJZihPYmplY3QuY3JlYXRlKG51bGwpLCBbe2F4aXN9LCBzY2FsZUNvbmYsIGRlZmF1bHRTY2FsZU9wdGlvbnNbYXhpc10sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElkXV0pO1xuICB9KTtcbiAgY29uZmlnLmRhdGEuZGF0YXNldHMuZm9yRWFjaChkYXRhc2V0ID0+IHtcbiAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IGNvbmZpZy50eXBlO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKTtcbiAgICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBvdmVycmlkZXNbdHlwZV0gfHwge307XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGRhdGFzZXREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgT2JqZWN0LmtleXMoZGVmYXVsdFNjYWxlT3B0aW9ucykuZm9yRWFjaChkZWZhdWx0SUQgPT4ge1xuICAgICAgY29uc3QgYXhpcyA9IGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoZGVmYXVsdElELCBpbmRleEF4aXMpO1xuICAgICAgY29uc3QgaWQgPSBkYXRhc2V0W2F4aXMgKyAnQXhpc0lEJ10gfHwgZmlyc3RJRHNbYXhpc10gfHwgYXhpcztcbiAgICAgIHNjYWxlc1tpZF0gPSBzY2FsZXNbaWRdIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBtZXJnZUlmKHNjYWxlc1tpZF0sIFt7YXhpc30sIGNvbmZpZ1NjYWxlc1tpZF0sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElEXV0pO1xuICAgIH0pO1xuICB9KTtcbiAgT2JqZWN0LmtleXMoc2NhbGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSBzY2FsZXNba2V5XTtcbiAgICBtZXJnZUlmKHNjYWxlLCBbZGVmYXVsdHMuc2NhbGVzW3NjYWxlLnR5cGVdLCBkZWZhdWx0cy5zY2FsZV0pO1xuICB9KTtcbiAgcmV0dXJuIHNjYWxlcztcbn1cbmZ1bmN0aW9uIGluaXRPcHRpb25zKGNvbmZpZykge1xuICBjb25zdCBvcHRpb25zID0gY29uZmlnLm9wdGlvbnMgfHwgKGNvbmZpZy5vcHRpb25zID0ge30pO1xuICBvcHRpb25zLnBsdWdpbnMgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgb3B0aW9ucy5zY2FsZXMgPSBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBpbml0RGF0YShkYXRhKSB7XG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuICBkYXRhLmRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cyB8fCBbXTtcbiAgZGF0YS5sYWJlbHMgPSBkYXRhLmxhYmVscyB8fCBbXTtcbiAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIGNvbmZpZy5kYXRhID0gaW5pdERhdGEoY29uZmlnLmRhdGEpO1xuICBpbml0T3B0aW9ucyhjb25maWcpO1xuICByZXR1cm4gY29uZmlnO1xufVxuY29uc3Qga2V5Q2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBrZXlzQ2FjaGVkID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gY2FjaGVkS2V5cyhjYWNoZUtleSwgZ2VuZXJhdGUpIHtcbiAgbGV0IGtleXMgPSBrZXlDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gZ2VuZXJhdGUoKTtcbiAgICBrZXlDYWNoZS5zZXQoY2FjaGVLZXksIGtleXMpO1xuICAgIGtleXNDYWNoZWQuYWRkKGtleXMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuY29uc3QgYWRkSWZGb3VuZCA9IChzZXQsIG9iaiwga2V5KSA9PiB7XG4gIGNvbnN0IG9wdHMgPSByZXNvbHZlT2JqZWN0S2V5KG9iaiwga2V5KTtcbiAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHNldC5hZGQob3B0cyk7XG4gIH1cbn07XG5jbGFzcyBDb25maWcge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLl9jb25maWcgPSBpbml0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fc2NvcGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlID0gbmV3IE1hcCgpO1xuICB9XG4gIGdldCBwbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsYXRmb3JtO1xuICB9XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcudHlwZTtcbiAgfVxuICBzZXQgdHlwZSh0eXBlKSB7XG4gICAgdGhpcy5fY29uZmlnLnR5cGUgPSB0eXBlO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcuZGF0YTtcbiAgfVxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5fY29uZmlnLmRhdGEgPSBpbml0RGF0YShkYXRhKTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLm9wdGlvbnM7XG4gIH1cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuX2NvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBnZXQgcGx1Z2lucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsdWdpbnM7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX2NvbmZpZztcbiAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICBpbml0T3B0aW9ucyhjb25maWcpO1xuICB9XG4gIGNsZWFyQ2FjaGUoKSB7XG4gICAgdGhpcy5fc2NvcGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUuY2xlYXIoKTtcbiAgfVxuICBkYXRhc2V0U2NvcGVLZXlzKGRhdGFzZXRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoZGF0YXNldFR5cGUsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG4gIGRhdGFzZXRBbmltYXRpb25TY29wZUtleXMoZGF0YXNldFR5cGUsIHRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbi4ke3RyYW5zaXRpb259YCxcbiAgICAgICgpID0+IFtcbiAgICAgICAgW1xuICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgICBgdHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAgICcnXG4gICAgICAgIF1cbiAgICAgIF0pO1xuICB9XG4gIGRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKGRhdGFzZXRUeXBlLCBlbGVtZW50VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS0ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0uZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICBgZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG4gIHBsdWdpblNjb3BlS2V5cyhwbHVnaW4pIHtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlO1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke3R5cGV9LXBsdWdpbi0ke2lkfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgcGx1Z2lucy4ke2lkfWAsXG4gICAgICAgIC4uLnBsdWdpbi5hZGRpdGlvbmFsT3B0aW9uU2NvcGVzIHx8IFtdLFxuICAgICAgXV0pO1xuICB9XG4gIF9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKSB7XG4gICAgY29uc3QgX3Njb3BlQ2FjaGUgPSB0aGlzLl9zY29wZUNhY2hlO1xuICAgIGxldCBjYWNoZSA9IF9zY29wZUNhY2hlLmdldChtYWluU2NvcGUpO1xuICAgIGlmICghY2FjaGUgfHwgcmVzZXRDYWNoZSkge1xuICAgICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICBfc2NvcGVDYWNoZS5zZXQobWFpblNjb3BlLCBjYWNoZSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuICBnZXRPcHRpb25TY29wZXMobWFpblNjb3BlLCBrZXlMaXN0cywgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKTtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5TGlzdHMpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlcyA9IG5ldyBTZXQoKTtcbiAgICBrZXlMaXN0cy5mb3JFYWNoKGtleXMgPT4ge1xuICAgICAgaWYgKG1haW5TY29wZSkge1xuICAgICAgICBzY29wZXMuYWRkKG1haW5TY29wZSk7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG1haW5TY29wZSwga2V5KSk7XG4gICAgICB9XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvcHRpb25zLCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSwga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBkZWZhdWx0cywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBkZXNjcmlwdG9ycywga2V5KSk7XG4gICAgfSk7XG4gICAgY29uc3QgYXJyYXkgPSBBcnJheS5mcm9tKHNjb3Blcyk7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXJyYXkucHVzaChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICB9XG4gICAgaWYgKGtleXNDYWNoZWQuaGFzKGtleUxpc3RzKSkge1xuICAgICAgY2FjaGUuc2V0KGtleUxpc3RzLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICBjaGFydE9wdGlvblNjb3BlcygpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuICAgIHJldHVybiBbXG4gICAgICBvcHRpb25zLFxuICAgICAgb3ZlcnJpZGVzW3R5cGVdIHx8IHt9LFxuICAgICAgZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge30sXG4gICAgICB7dHlwZX0sXG4gICAgICBkZWZhdWx0cyxcbiAgICAgIGRlc2NyaXB0b3JzXG4gICAgXTtcbiAgfVxuICByZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHskc2hhcmVkOiB0cnVlfTtcbiAgICBjb25zdCB7cmVzb2x2ZXIsIHN1YlByZWZpeGVzfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIGxldCBvcHRpb25zID0gcmVzb2x2ZXI7XG4gICAgaWYgKG5lZWRDb250ZXh0KHJlc29sdmVyLCBuYW1lcykpIHtcbiAgICAgIHJlc3VsdC4kc2hhcmVkID0gZmFsc2U7XG4gICAgICBjb250ZXh0ID0gaXNGdW5jdGlvbihjb250ZXh0KSA/IGNvbnRleHQoKSA6IGNvbnRleHQ7XG4gICAgICBjb25zdCBzdWJSZXNvbHZlciA9IHRoaXMuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBzdWJQcmVmaXhlcyk7XG4gICAgICBvcHRpb25zID0gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHN1YlJlc29sdmVyKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddLCBkZXNjcmlwdG9yRGVmYXVsdHMpIHtcbiAgICBjb25zdCB7cmVzb2x2ZXJ9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGNvbnRleHQpXG4gICAgICA/IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCB1bmRlZmluZWQsIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgICAgIDogcmVzb2x2ZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJlc29sdmVyKHJlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpIHtcbiAgbGV0IGNhY2hlID0gcmVzb2x2ZXJDYWNoZS5nZXQoc2NvcGVzKTtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHJlc29sdmVyQ2FjaGUuc2V0KHNjb3BlcywgY2FjaGUpO1xuICB9XG4gIGNvbnN0IGNhY2hlS2V5ID0gcHJlZml4ZXMuam9pbigpO1xuICBsZXQgY2FjaGVkID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFjYWNoZWQpIHtcbiAgICBjb25zdCByZXNvbHZlciA9IF9jcmVhdGVSZXNvbHZlcihzY29wZXMsIHByZWZpeGVzKTtcbiAgICBjYWNoZWQgPSB7XG4gICAgICByZXNvbHZlcixcbiAgICAgIHN1YlByZWZpeGVzOiBwcmVmaXhlcy5maWx0ZXIocCA9PiAhcC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdob3ZlcicpKVxuICAgIH07XG4gICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBjYWNoZWQpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG5jb25zdCBoYXNGdW5jdGlvbiA9IHZhbHVlID0+IGlzT2JqZWN0KHZhbHVlKVxuICAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjIHx8IGlzRnVuY3Rpb24odmFsdWVba2V5XSksIGZhbHNlKTtcbmZ1bmN0aW9uIG5lZWRDb250ZXh0KHByb3h5LCBuYW1lcykge1xuICBjb25zdCB7aXNTY3JpcHRhYmxlLCBpc0luZGV4YWJsZX0gPSBfZGVzY3JpcHRvcnMocHJveHkpO1xuICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcbiAgICBjb25zdCBzY3JpcHRhYmxlID0gaXNTY3JpcHRhYmxlKHByb3ApO1xuICAgIGNvbnN0IGluZGV4YWJsZSA9IGlzSW5kZXhhYmxlKHByb3ApO1xuICAgIGNvbnN0IHZhbHVlID0gKGluZGV4YWJsZSB8fCBzY3JpcHRhYmxlKSAmJiBwcm94eVtwcm9wXTtcbiAgICBpZiAoKHNjcmlwdGFibGUgJiYgKGlzRnVuY3Rpb24odmFsdWUpIHx8IGhhc0Z1bmN0aW9uKHZhbHVlKSkpXG4gICAgICB8fCAoaW5kZXhhYmxlICYmIGlzQXJyYXkodmFsdWUpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIHZlcnNpb24gPSBcIjMuNy4wXCI7XG5cbmNvbnN0IEtOT1dOX1BPU0lUSU9OUyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0JywgJ2NoYXJ0QXJlYSddO1xuZnVuY3Rpb24gcG9zaXRpb25Jc0hvcml6b250YWwocG9zaXRpb24sIGF4aXMpIHtcbiAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgKEtOT1dOX1BPU0lUSU9OUy5pbmRleE9mKHBvc2l0aW9uKSA9PT0gLTEgJiYgYXhpcyA9PT0gJ3gnKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmUyTGV2ZWwobDEsIGwyKSB7XG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGFbbDFdID09PSBiW2wxXVxuICAgICAgPyBhW2wyXSAtIGJbbDJdXG4gICAgICA6IGFbbDFdIC0gYltsMV07XG4gIH07XG59XG5mdW5jdGlvbiBvbkFuaW1hdGlvbnNDb21wbGV0ZShjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclJlbmRlcicpO1xuICBjYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Db21wbGV0ZSwgW2NvbnRleHRdLCBjaGFydCk7XG59XG5mdW5jdGlvbiBvbkFuaW1hdGlvblByb2dyZXNzKGNvbnRleHQpIHtcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY2hhcnQub3B0aW9ucy5hbmltYXRpb247XG4gIGNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLCBbY29udGV4dF0sIGNoYXJ0KTtcbn1cbmZ1bmN0aW9uIGdldENhbnZhcyhpdGVtKSB7XG4gIGlmIChfaXNEb21TdXBwb3J0ZWQoKSAmJiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICBpdGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaXRlbSk7XG4gIH0gZWxzZSBpZiAoaXRlbSAmJiBpdGVtLmxlbmd0aCkge1xuICAgIGl0ZW0gPSBpdGVtWzBdO1xuICB9XG4gIGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG4gICAgaXRlbSA9IGl0ZW0uY2FudmFzO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuY29uc3QgaW5zdGFuY2VzID0ge307XG5jb25zdCBnZXRDaGFydCA9IChrZXkpID0+IHtcbiAgY29uc3QgY2FudmFzID0gZ2V0Q2FudmFzKGtleSk7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGluc3RhbmNlcykuZmlsdGVyKChjKSA9PiBjLmNhbnZhcyA9PT0gY2FudmFzKS5wb3AoKTtcbn07XG5mdW5jdGlvbiBtb3ZlTnVtZXJpY0tleXMob2JqLCBzdGFydCwgbW92ZSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IGludEtleSA9ICtrZXk7XG4gICAgaWYgKGludEtleSA+PSBzdGFydCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgIGlmIChtb3ZlID4gMCB8fCBpbnRLZXkgPiBzdGFydCkge1xuICAgICAgICBvYmpbaW50S2V5ICsgbW92ZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVybWluZUxhc3RFdmVudChlLCBsYXN0RXZlbnQsIGluQ2hhcnRBcmVhLCBpc0NsaWNrKSB7XG4gIGlmICghaW5DaGFydEFyZWEgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzQ2xpY2spIHtcbiAgICByZXR1cm4gbGFzdEV2ZW50O1xuICB9XG4gIHJldHVybiBlO1xufVxuY2xhc3MgQ2hhcnQge1xuICBjb25zdHJ1Y3RvcihpdGVtLCB1c2VyQ29uZmlnKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKHVzZXJDb25maWcpO1xuICAgIGNvbnN0IGluaXRpYWxDYW52YXMgPSBnZXRDYW52YXMoaXRlbSk7XG4gICAgY29uc3QgZXhpc3RpbmdDaGFydCA9IGdldENoYXJ0KGluaXRpYWxDYW52YXMpO1xuICAgIGlmIChleGlzdGluZ0NoYXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW52YXMgaXMgYWxyZWFkeSBpbiB1c2UuIENoYXJ0IHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuaWQgKyAnXFwnJyArXG5cdFx0XHRcdCcgbXVzdCBiZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjYW52YXMgY2FuIGJlIHJldXNlZC4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5wbGF0Zm9ybSA9IG5ldyAoY29uZmlnLnBsYXRmb3JtIHx8IF9kZXRlY3RQbGF0Zm9ybShpbml0aWFsQ2FudmFzKSkoKTtcbiAgICB0aGlzLnBsYXRmb3JtLnVwZGF0ZUNvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLnBsYXRmb3JtLmFjcXVpcmVDb250ZXh0KGluaXRpYWxDYW52YXMsIG9wdGlvbnMuYXNwZWN0UmF0aW8pO1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQgJiYgY29udGV4dC5jYW52YXM7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzICYmIGNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXMgJiYgY2FudmFzLndpZHRoO1xuICAgIHRoaXMuaWQgPSB1aWQoKTtcbiAgICB0aGlzLmN0eCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICB0aGlzLl9tZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuX3N0YWNrcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJveGVzID0gW107XG4gICAgdGhpcy5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0QXJlYSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuc2NhbGVzID0ge307XG4gICAgdGhpcy5fcGx1Z2lucyA9IG5ldyBQbHVnaW5TZXJ2aWNlKCk7XG4gICAgdGhpcy4kcHJveGllcyA9IHt9O1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXMgPSB7fTtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZG9SZXNpemUgPSBkZWJvdW5jZShtb2RlID0+IHRoaXMudXBkYXRlKG1vZGUpLCBvcHRpb25zLnJlc2l6ZURlbGF5IHx8IDApO1xuICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XG4gICAgaW5zdGFuY2VzW3RoaXMuaWRdID0gdGhpcztcbiAgICBpZiAoIWNvbnRleHQgfHwgIWNhbnZhcykge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2hhcnQ6IGNhbid0IGFjcXVpcmUgY29udGV4dCBmcm9tIHRoZSBnaXZlbiBpdGVtXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ2NvbXBsZXRlJywgb25BbmltYXRpb25zQ29tcGxldGUpO1xuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAncHJvZ3Jlc3MnLCBvbkFuaW1hdGlvblByb2dyZXNzKTtcbiAgICB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGdldCBhc3BlY3RSYXRpbygpIHtcbiAgICBjb25zdCB7b3B0aW9uczoge2FzcGVjdFJhdGlvLCBtYWludGFpbkFzcGVjdFJhdGlvfSwgd2lkdGgsIGhlaWdodCwgX2FzcGVjdFJhdGlvfSA9IHRoaXM7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKGFzcGVjdFJhdGlvKSkge1xuICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgIH1cbiAgICBpZiAobWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBfYXNwZWN0UmF0aW8pIHtcbiAgICAgIHJldHVybiBfYXNwZWN0UmF0aW87XG4gICAgfVxuICAgIHJldHVybiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IG51bGw7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGE7XG4gIH1cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuY29uZmlnLmRhdGEgPSBkYXRhO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUluaXQnKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldGluYVNjYWxlKHRoaXMsIHRoaXMub3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB9XG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckluaXQnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcigpIHtcbiAgICBjbGVhckNhbnZhcyh0aGlzLmNhbnZhcywgdGhpcy5jdHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgYW5pbWF0b3Iuc3RvcCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0ge3dpZHRoLCBoZWlnaHR9O1xuICAgIH1cbiAgfVxuICBfcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gb3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIHRoaXMuYXNwZWN0UmF0aW87XG4gICAgY29uc3QgbmV3U2l6ZSA9IHRoaXMucGxhdGZvcm0uZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgbmV3UmF0aW8gPSBvcHRpb25zLmRldmljZVBpeGVsUmF0aW8gfHwgdGhpcy5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgY29uc3QgbW9kZSA9IHRoaXMud2lkdGggPyAncmVzaXplJyA6ICdhdHRhY2gnO1xuICAgIHRoaXMud2lkdGggPSBuZXdTaXplLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3U2l6ZS5oZWlnaHQ7XG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIGlmICghcmV0aW5hU2NhbGUodGhpcywgbmV3UmF0aW8sIHRydWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzaXplJywge3NpemU6IG5ld1NpemV9KTtcbiAgICBjYWxsYmFjayhvcHRpb25zLm9uUmVzaXplLCBbdGhpcywgbmV3U2l6ZV0sIHRoaXMpO1xuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICBpZiAodGhpcy5fZG9SZXNpemUobW9kZSkpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZW5zdXJlU2NhbGVzSGF2ZUlEcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNjYWxlc09wdGlvbnMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgICBlYWNoKHNjYWxlc09wdGlvbnMsIChheGlzT3B0aW9ucywgYXhpc0lEKSA9PiB7XG4gICAgICBheGlzT3B0aW9ucy5pZCA9IGF4aXNJRDtcbiAgICB9KTtcbiAgfVxuICBidWlsZE9yVXBkYXRlU2NhbGVzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVPcHRzID0gb3B0aW9ucy5zY2FsZXM7XG4gICAgY29uc3Qgc2NhbGVzID0gdGhpcy5zY2FsZXM7XG4gICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5rZXlzKHNjYWxlcykucmVkdWNlKChvYmosIGlkKSA9PiB7XG4gICAgICBvYmpbaWRdID0gZmFsc2U7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sIHt9KTtcbiAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICBpZiAoc2NhbGVPcHRzKSB7XG4gICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChcbiAgICAgICAgT2JqZWN0LmtleXMoc2NhbGVPcHRzKS5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gc2NhbGVPcHRzW2lkXTtcbiAgICAgICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgICAgICBjb25zdCBpc1JhZGlhbCA9IGF4aXMgPT09ICdyJztcbiAgICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSBheGlzID09PSAneCc7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHNjYWxlT3B0aW9ucyxcbiAgICAgICAgICAgIGRwb3NpdGlvbjogaXNSYWRpYWwgPyAnY2hhcnRBcmVhJyA6IGlzSG9yaXpvbnRhbCA/ICdib3R0b20nIDogJ2xlZnQnLFxuICAgICAgICAgICAgZHR5cGU6IGlzUmFkaWFsID8gJ3JhZGlhbExpbmVhcicgOiBpc0hvcml6b250YWwgPyAnY2F0ZWdvcnknIDogJ2xpbmVhcidcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgZWFjaChpdGVtcywgKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgIGNvbnN0IGlkID0gc2NhbGVPcHRpb25zLmlkO1xuICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICBjb25zdCBzY2FsZVR5cGUgPSB2YWx1ZU9yRGVmYXVsdChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG4gICAgICBpZiAoc2NhbGVPcHRpb25zLnBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb25Jc0hvcml6b250YWwoc2NhbGVPcHRpb25zLnBvc2l0aW9uLCBheGlzKSAhPT0gcG9zaXRpb25Jc0hvcml6b250YWwoaXRlbS5kcG9zaXRpb24pKSB7XG4gICAgICAgIHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9IGl0ZW0uZHBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgdXBkYXRlZFtpZF0gPSB0cnVlO1xuICAgICAgbGV0IHNjYWxlID0gbnVsbDtcbiAgICAgIGlmIChpZCBpbiBzY2FsZXMgJiYgc2NhbGVzW2lkXS50eXBlID09PSBzY2FsZVR5cGUpIHtcbiAgICAgICAgc2NhbGUgPSBzY2FsZXNbaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2NhbGVDbGFzcyA9IHJlZ2lzdHJ5LmdldFNjYWxlKHNjYWxlVHlwZSk7XG4gICAgICAgIHNjYWxlID0gbmV3IHNjYWxlQ2xhc3Moe1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHR5cGU6IHNjYWxlVHlwZSxcbiAgICAgICAgICBjdHg6IHRoaXMuY3R4LFxuICAgICAgICAgIGNoYXJ0OiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBzY2FsZXNbc2NhbGUuaWRdID0gc2NhbGU7XG4gICAgICB9XG4gICAgICBzY2FsZS5pbml0KHNjYWxlT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgZWFjaCh1cGRhdGVkLCAoaGFzVXBkYXRlZCwgaWQpID0+IHtcbiAgICAgIGlmICghaGFzVXBkYXRlZCkge1xuICAgICAgICBkZWxldGUgc2NhbGVzW2lkXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlYWNoKHNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLmNvbmZpZ3VyZSh0aGlzLCBzY2FsZSwgc2NhbGUub3B0aW9ucyk7XG4gICAgICBsYXlvdXRzLmFkZEJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZU1ldGFzZXRzKCkge1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgY29uc3QgbnVtRGF0YSA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtTWV0YSA9IG1ldGFzZXRzLmxlbmd0aDtcbiAgICBtZXRhc2V0cy5zb3J0KChhLCBiKSA9PiBhLmluZGV4IC0gYi5pbmRleCk7XG4gICAgaWYgKG51bU1ldGEgPiBudW1EYXRhKSB7XG4gICAgICBmb3IgKGxldCBpID0gbnVtRGF0YTsgaSA8IG51bU1ldGE7ICsraSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhc2V0cy5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IG1ldGFzZXRzLnNsaWNlKDApLnNvcnQoY29tcGFyZTJMZXZlbCgnb3JkZXInLCAnaW5kZXgnKSk7XG4gIH1cbiAgX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCkge1xuICAgIGNvbnN0IHtfbWV0YXNldHM6IG1ldGFzZXRzLCBkYXRhOiB7ZGF0YXNldHN9fSA9IHRoaXM7XG4gICAgaWYgKG1ldGFzZXRzLmxlbmd0aCA+IGRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIHRoaXMuX3N0YWNrcztcbiAgICB9XG4gICAgbWV0YXNldHMuZm9yRWFjaCgobWV0YSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChkYXRhc2V0cy5maWx0ZXIoeCA9PiB4ID09PSBtZXRhLl9kYXRhc2V0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKSB7XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0cyA9IHRoaXMuZGF0YS5kYXRhc2V0cztcbiAgICBsZXQgaSwgaWxlbjtcbiAgICB0aGlzLl9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0c1tpXTtcbiAgICAgIGxldCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgdGhpcy5jb25maWcudHlwZTtcbiAgICAgIGlmIChtZXRhLnR5cGUgJiYgbWV0YS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhLnR5cGUgPSB0eXBlO1xuICAgICAgbWV0YS5pbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIG1ldGEub3JkZXIgPSBkYXRhc2V0Lm9yZGVyIHx8IDA7XG4gICAgICBtZXRhLmluZGV4ID0gaTtcbiAgICAgIG1ldGEubGFiZWwgPSAnJyArIGRhdGFzZXQubGFiZWw7XG4gICAgICBtZXRhLnZpc2libGUgPSB0aGlzLmlzRGF0YXNldFZpc2libGUoaSk7XG4gICAgICBpZiAobWV0YS5jb250cm9sbGVyKSB7XG4gICAgICAgIG1ldGEuY29udHJvbGxlci51cGRhdGVJbmRleChpKTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLmxpbmtTY2FsZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IENvbnRyb2xsZXJDbGFzcyA9IHJlZ2lzdHJ5LmdldENvbnRyb2xsZXIodHlwZSk7XG4gICAgICAgIGNvbnN0IHtkYXRhc2V0RWxlbWVudFR5cGUsIGRhdGFFbGVtZW50VHlwZX0gPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihDb250cm9sbGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgICAgZGF0YUVsZW1lbnRUeXBlOiByZWdpc3RyeS5nZXRFbGVtZW50KGRhdGFFbGVtZW50VHlwZSksXG4gICAgICAgICAgZGF0YXNldEVsZW1lbnRUeXBlOiBkYXRhc2V0RWxlbWVudFR5cGUgJiYgcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhc2V0RWxlbWVudFR5cGUpXG4gICAgICAgIH0pO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlckNsYXNzKHRoaXMsIGkpO1xuICAgICAgICBuZXdDb250cm9sbGVycy5wdXNoKG1ldGEuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZU1ldGFzZXRzKCk7XG4gICAgcmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xuICB9XG4gIF9yZXNldEVsZW1lbnRzKCkge1xuICAgIGVhY2godGhpcy5kYXRhLmRhdGFzZXRzLCAoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudHMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2V0Jyk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25maWcudXBkYXRlKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhbmltc0Rpc2FibGVkID0gdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gIW9wdGlvbnMuYW5pbWF0aW9uO1xuICAgIHRoaXMuX3VwZGF0ZVNjYWxlcygpO1xuICAgIHRoaXMuX2NoZWNrRXZlbnRCaW5kaW5ncygpO1xuICAgIHRoaXMuX3VwZGF0ZUhpZGRlbkluZGljZXMoKTtcbiAgICB0aGlzLl9wbHVnaW5zLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IHRoaXMuYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFbGVtZW50c1VwZGF0ZScpO1xuICAgIGxldCBtaW5QYWRkaW5nID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHtjb250cm9sbGVyfSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCByZXNldCA9ICFhbmltc0Rpc2FibGVkICYmIG5ld0NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcikgPT09IC0xO1xuICAgICAgY29udHJvbGxlci5idWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXQpO1xuICAgICAgbWluUGFkZGluZyA9IE1hdGgubWF4KCtjb250cm9sbGVyLmdldE1heE92ZXJmbG93KCksIG1pblBhZGRpbmcpO1xuICAgIH1cbiAgICBtaW5QYWRkaW5nID0gdGhpcy5fbWluUGFkZGluZyA9IG9wdGlvbnMubGF5b3V0LmF1dG9QYWRkaW5nID8gbWluUGFkZGluZyA6IDA7XG4gICAgdGhpcy5fdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpO1xuICAgIGlmICghYW5pbXNEaXNhYmxlZCkge1xuICAgICAgZWFjaChuZXdDb250cm9sbGVycywgKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5yZXNldCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZURhdGFzZXRzKG1vZGUpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJVcGRhdGUnLCB7bW9kZX0pO1xuICAgIHRoaXMuX2xheWVycy5zb3J0KGNvbXBhcmUyTGV2ZWwoJ3onLCAnX2lkeCcpKTtcbiAgICBjb25zdCB7X2FjdGl2ZSwgX2xhc3RFdmVudH0gPSB0aGlzO1xuICAgIGlmIChfbGFzdEV2ZW50KSB7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIoX2xhc3RFdmVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChfYWN0aXZlLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoX2FjdGl2ZSwgX2FjdGl2ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgX3VwZGF0ZVNjYWxlcygpIHtcbiAgICBlYWNoKHRoaXMuc2NhbGVzLCAoc2NhbGUpID0+IHtcbiAgICAgIGxheW91dHMucmVtb3ZlQm94KHRoaXMsIHNjYWxlKTtcbiAgICB9KTtcbiAgICB0aGlzLmVuc3VyZVNjYWxlc0hhdmVJRHMoKTtcbiAgICB0aGlzLmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcbiAgfVxuICBfY2hlY2tFdmVudEJpbmRpbmdzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZXhpc3RpbmdFdmVudHMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMuX2xpc3RlbmVycykpO1xuICAgIGNvbnN0IG5ld0V2ZW50cyA9IG5ldyBTZXQob3B0aW9ucy5ldmVudHMpO1xuICAgIGlmICghc2V0c0VxdWFsKGV4aXN0aW5nRXZlbnRzLCBuZXdFdmVudHMpIHx8ICEhdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyAhPT0gb3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgfVxuICB9XG4gIF91cGRhdGVIaWRkZW5JbmRpY2VzKCkge1xuICAgIGNvbnN0IHtfaGlkZGVuSW5kaWNlc30gPSB0aGlzO1xuICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IHttZXRob2QsIHN0YXJ0LCBjb3VudH0gb2YgY2hhbmdlcykge1xuICAgICAgY29uc3QgbW92ZSA9IG1ldGhvZCA9PT0gJ19yZW1vdmVFbGVtZW50cycgPyAtY291bnQgOiBjb3VudDtcbiAgICAgIG1vdmVOdW1lcmljS2V5cyhfaGlkZGVuSW5kaWNlcywgc3RhcnQsIG1vdmUpO1xuICAgIH1cbiAgfVxuICBfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkge1xuICAgIGNvbnN0IF9kYXRhQ2hhbmdlcyA9IHRoaXMuX2RhdGFDaGFuZ2VzO1xuICAgIGlmICghX2RhdGFDaGFuZ2VzIHx8ICFfZGF0YUNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XG4gICAgY29uc3QgZGF0YXNldENvdW50ID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBtYWtlU2V0ID0gKGlkeCkgPT4gbmV3IFNldChcbiAgICAgIF9kYXRhQ2hhbmdlc1xuICAgICAgICAuZmlsdGVyKGMgPT4gY1swXSA9PT0gaWR4KVxuICAgICAgICAubWFwKChjLCBpKSA9PiBpICsgJywnICsgYy5zcGxpY2UoMSkuam9pbignLCcpKVxuICAgICk7XG4gICAgY29uc3QgY2hhbmdlU2V0ID0gbWFrZVNldCgwKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRhdGFzZXRDb3VudDsgaSsrKSB7XG4gICAgICBpZiAoIXNldHNFcXVhbChjaGFuZ2VTZXQsIG1ha2VTZXQoaSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oY2hhbmdlU2V0KVxuICAgICAgLm1hcChjID0+IGMuc3BsaXQoJywnKSlcbiAgICAgIC5tYXAoYSA9PiAoe21ldGhvZDogYVsxXSwgc3RhcnQ6ICthWzJdLCBjb3VudDogK2FbM119KSk7XG4gIH1cbiAgX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlTGF5b3V0Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGF5b3V0cy51cGRhdGUodGhpcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIG1pblBhZGRpbmcpO1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLmNoYXJ0QXJlYTtcbiAgICBjb25zdCBub0FyZWEgPSBhcmVhLndpZHRoIDw9IDAgfHwgYXJlYS5oZWlnaHQgPD0gMDtcbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICBlYWNoKHRoaXMuYm94ZXMsIChib3gpID0+IHtcbiAgICAgIGlmIChub0FyZWEgJiYgYm94LnBvc2l0aW9uID09PSAnY2hhcnRBcmVhJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYm94LmNvbmZpZ3VyZSkge1xuICAgICAgICBib3guY29uZmlndXJlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXllcnMucHVzaCguLi5ib3guX2xheWVycygpKTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9sYXllcnMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGl0ZW0uX2lkeCA9IGluZGV4O1xuICAgIH0pO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJMYXlvdXQnKTtcbiAgfVxuICBfdXBkYXRlRGF0YXNldHMobW9kZSkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzVXBkYXRlJywge21vZGUsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXIuY29uZmlndXJlKCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YXNldChpLCBpc0Z1bmN0aW9uKG1vZGUpID8gbW9kZSh7ZGF0YXNldEluZGV4OiBpfSkgOiBtb2RlKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzVXBkYXRlJywge21vZGV9KTtcbiAgfVxuICBfdXBkYXRlRGF0YXNldChpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgICBjb25zdCBhcmdzID0ge21ldGEsIGluZGV4LCBtb2RlLCBjYW5jZWxhYmxlOiB0cnVlfTtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0VXBkYXRlJywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1ldGEuY29udHJvbGxlci5fdXBkYXRlKG1vZGUpO1xuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0VXBkYXRlJywgYXJncyk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVJlbmRlcicsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhbmltYXRvci5oYXModGhpcykpIHtcbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkICYmICFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICAgIGFuaW1hdG9yLnN0YXJ0KHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRyYXcoKTtcbiAgICAgIG9uQW5pbWF0aW9uc0NvbXBsZXRlKHtjaGFydDogdGhpc30pO1xuICAgIH1cbiAgfVxuICBkcmF3KCkge1xuICAgIGxldCBpO1xuICAgIGlmICh0aGlzLl9yZXNpemVCZWZvcmVEcmF3KSB7XG4gICAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLl9yZXNpemVCZWZvcmVEcmF3O1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY2xlYXIoKTtcbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aCAmJiBsYXllcnNbaV0ueiA8PSAwOyArK2kpIHtcbiAgICAgIGxheWVyc1tpXS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcbiAgICB9XG4gICAgdGhpcy5fZHJhd0RhdGFzZXRzKCk7XG4gICAgZm9yICg7IGkgPCBsYXllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxheWVyc1tpXS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRyYXcnKTtcbiAgfVxuICBfZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX3NvcnRlZE1ldGFzZXRzO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc2V0c1tpXTtcbiAgICAgIGlmICghZmlsdGVyVmlzaWJsZSB8fCBtZXRhLnZpc2libGUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKHRydWUpO1xuICB9XG4gIF9kcmF3RGF0YXNldHMoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRoaXMuX2RyYXdEYXRhc2V0KG1ldGFzZXRzW2ldKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzRHJhdycpO1xuICB9XG4gIF9kcmF3RGF0YXNldChtZXRhKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY2xpcCA9IG1ldGEuX2NsaXA7XG4gICAgY29uc3QgdXNlQ2xpcCA9ICFjbGlwLmRpc2FibGVkO1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLmNoYXJ0QXJlYTtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgbWV0YSxcbiAgICAgIGluZGV4OiBtZXRhLmluZGV4LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH07XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldERyYXcnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHVzZUNsaXApIHtcbiAgICAgIGNsaXBBcmVhKGN0eCwge1xuICAgICAgICBsZWZ0OiBjbGlwLmxlZnQgPT09IGZhbHNlID8gMCA6IGFyZWEubGVmdCAtIGNsaXAubGVmdCxcbiAgICAgICAgcmlnaHQ6IGNsaXAucmlnaHQgPT09IGZhbHNlID8gdGhpcy53aWR0aCA6IGFyZWEucmlnaHQgKyBjbGlwLnJpZ2h0LFxuICAgICAgICB0b3A6IGNsaXAudG9wID09PSBmYWxzZSA/IDAgOiBhcmVhLnRvcCAtIGNsaXAudG9wLFxuICAgICAgICBib3R0b206IGNsaXAuYm90dG9tID09PSBmYWxzZSA/IHRoaXMuaGVpZ2h0IDogYXJlYS5ib3R0b20gKyBjbGlwLmJvdHRvbVxuICAgICAgfSk7XG4gICAgfVxuICAgIG1ldGEuY29udHJvbGxlci5kcmF3KCk7XG4gICAgaWYgKHVzZUNsaXApIHtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXREcmF3JywgYXJncyk7XG4gIH1cbiAgZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBtb2RlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbWV0aG9kID0gSW50ZXJhY3Rpb24ubW9kZXNbbW9kZV07XG4gICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBtZXRob2QodGhpcywgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICBsZXQgbWV0YSA9IG1ldGFzZXRzLmZpbHRlcih4ID0+IHggJiYgeC5fZGF0YXNldCA9PT0gZGF0YXNldCkucG9wKCk7XG4gICAgaWYgKCFtZXRhKSB7XG4gICAgICBtZXRhID0ge1xuICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgZGF0YXNldDogbnVsbCxcbiAgICAgICAgY29udHJvbGxlcjogbnVsbCxcbiAgICAgICAgaGlkZGVuOiBudWxsLFxuICAgICAgICB4QXhpc0lEOiBudWxsLFxuICAgICAgICB5QXhpc0lEOiBudWxsLFxuICAgICAgICBvcmRlcjogZGF0YXNldCAmJiBkYXRhc2V0Lm9yZGVyIHx8IDAsXG4gICAgICAgIGluZGV4OiBkYXRhc2V0SW5kZXgsXG4gICAgICAgIF9kYXRhc2V0OiBkYXRhc2V0LFxuICAgICAgICBfcGFyc2VkOiBbXSxcbiAgICAgICAgX3NvcnRlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBtZXRhc2V0cy5wdXNoKG1ldGEpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YTtcbiAgfVxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8ICh0aGlzLiRjb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsLCB7Y2hhcnQ6IHRoaXMsIHR5cGU6ICdjaGFydCd9KSk7XG4gIH1cbiAgZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkubGVuZ3RoO1xuICB9XG4gIGlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmICghZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIHJldHVybiB0eXBlb2YgbWV0YS5oaWRkZW4gPT09ICdib29sZWFuJyA/ICFtZXRhLmhpZGRlbiA6ICFkYXRhc2V0LmhpZGRlbjtcbiAgfVxuICBzZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIG1ldGEuaGlkZGVuID0gIXZpc2libGU7XG4gIH1cbiAgdG9nZ2xlRGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XSA9ICF0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XTtcbiAgfVxuICBnZXREYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHJldHVybiAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cbiAgX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHZpc2libGUpIHtcbiAgICBjb25zdCBtb2RlID0gdmlzaWJsZSA/ICdzaG93JyA6ICdoaWRlJztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIGNvbnN0IGFuaW1zID0gbWV0YS5jb250cm9sbGVyLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpO1xuICAgIGlmIChkZWZpbmVkKGRhdGFJbmRleCkpIHtcbiAgICAgIG1ldGEuZGF0YVtkYXRhSW5kZXhdLmhpZGRlbiA9ICF2aXNpYmxlO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpO1xuICAgICAgYW5pbXMudXBkYXRlKG1ldGEsIHt2aXNpYmxlfSk7XG4gICAgICB0aGlzLnVwZGF0ZSgoY3R4KSA9PiBjdHguZGF0YXNldEluZGV4ID09PSBkYXRhc2V0SW5kZXggPyBtb2RlIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cbiAgaGlkZShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIGZhbHNlKTtcbiAgfVxuICBzaG93KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdHJ1ZSk7XG4gIH1cbiAgX2Rlc3Ryb3lEYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAobWV0YSAmJiBtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgIG1ldGEuY29udHJvbGxlci5fZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgfVxuICBfc3RvcCgpIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICBhbmltYXRvci5yZW1vdmUodGhpcyk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURlc3Ryb3knKTtcbiAgICBjb25zdCB7Y2FudmFzLCBjdHh9ID0gdGhpcztcbiAgICB0aGlzLl9zdG9wKCk7XG4gICAgdGhpcy5jb25maWcuY2xlYXJDYWNoZSgpO1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICBjbGVhckNhbnZhcyhjYW52YXMsIGN0eCk7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbGVhc2VDb250ZXh0KGN0eCk7XG4gICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICB0aGlzLmN0eCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnZGVzdHJveScpO1xuICAgIGRlbGV0ZSBpbnN0YW5jZXNbdGhpcy5pZF07XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRlc3Ryb3knKTtcbiAgfVxuICB0b0Jhc2U2NEltYWdlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMudG9EYXRhVVJMKC4uLmFyZ3MpO1xuICB9XG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5iaW5kVXNlckV2ZW50cygpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5iaW5kUmVzcG9uc2l2ZUV2ZW50cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgYmluZFVzZXJFdmVudHMoKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG4gICAgY29uc3QgbGlzdGVuZXIgPSAoZSwgeCwgeSkgPT4ge1xuICAgICAgZS5vZmZzZXRYID0geDtcbiAgICAgIGUub2Zmc2V0WSA9IHk7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIoZSk7XG4gICAgfTtcbiAgICBlYWNoKHRoaXMub3B0aW9ucy5ldmVudHMsICh0eXBlKSA9PiBfYWRkKHR5cGUsIGxpc3RlbmVyKSk7XG4gIH1cbiAgYmluZFJlc3BvbnNpdmVFdmVudHMoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnM7XG4gICAgY29uc3QgcGxhdGZvcm0gPSB0aGlzLnBsYXRmb3JtO1xuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcbiAgICBjb25zdCBfcmVtb3ZlID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBpZiAobGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIHBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW3R5cGVdO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbGlzdGVuZXIgPSAod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IGRldGFjaGVkO1xuICAgIGNvbnN0IGF0dGFjaGVkID0gKCkgPT4ge1xuICAgICAgX3JlbW92ZSgnYXR0YWNoJywgYXR0YWNoZWQpO1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgX2FkZCgncmVzaXplJywgbGlzdGVuZXIpO1xuICAgICAgX2FkZCgnZGV0YWNoJywgZGV0YWNoZWQpO1xuICAgIH07XG4gICAgZGV0YWNoZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgICBfcmVtb3ZlKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICB0aGlzLl9zdG9wKCk7XG4gICAgICB0aGlzLl9yZXNpemUoMCwgMCk7XG4gICAgICBfYWRkKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG4gICAgfTtcbiAgICBpZiAocGxhdGZvcm0uaXNBdHRhY2hlZCh0aGlzLmNhbnZhcykpIHtcbiAgICAgIGF0dGFjaGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRldGFjaGVkKCk7XG4gICAgfVxuICB9XG4gIHVuYmluZEV2ZW50cygpIHtcbiAgICBlYWNoKHRoaXMuX2xpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIGVhY2godGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdXBkYXRlSG92ZXJTdHlsZShpdGVtcywgbW9kZSwgZW5hYmxlZCkge1xuICAgIGNvbnN0IHByZWZpeCA9IGVuYWJsZWQgPyAnc2V0JyA6ICdyZW1vdmUnO1xuICAgIGxldCBtZXRhLCBpdGVtLCBpLCBpbGVuO1xuICAgIGlmIChtb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW1zWzBdLmRhdGFzZXRJbmRleCk7XG4gICAgICBtZXRhLmNvbnRyb2xsZXJbJ18nICsgcHJlZml4ICsgJ0RhdGFzZXRIb3ZlclN0eWxlJ10oKTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IGl0ZW0gJiYgdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtLmRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXJbcHJlZml4ICsgJ0hvdmVyU3R5bGUnXShpdGVtLmVsZW1lbnQsIGl0ZW0uZGF0YXNldEluZGV4LCBpdGVtLmluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuICBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cykge1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7ZGF0YXNldEluZGV4LCBpbmRleH0pID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXRhc2V0IGZvdW5kIGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICBlbGVtZW50OiBtZXRhLmRhdGFbaW5kZXhdLFxuICAgICAgICBpbmRleCxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICB9XG4gIH1cbiAgbm90aWZ5UGx1Z2lucyhob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5ub3RpZnkodGhpcywgaG9vaywgYXJncywgZmlsdGVyKTtcbiAgfVxuICBfdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlLCByZXBsYXkpIHtcbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaG92ZXI7XG4gICAgY29uc3QgZGlmZiA9IChhLCBiKSA9PiBhLmZpbHRlcih4ID0+ICFiLnNvbWUoeSA9PiB4LmRhdGFzZXRJbmRleCA9PT0geS5kYXRhc2V0SW5kZXggJiYgeC5pbmRleCA9PT0geS5pbmRleCkpO1xuICAgIGNvbnN0IGRlYWN0aXZhdGVkID0gZGlmZihsYXN0QWN0aXZlLCBhY3RpdmUpO1xuICAgIGNvbnN0IGFjdGl2YXRlZCA9IHJlcGxheSA/IGFjdGl2ZSA6IGRpZmYoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoZGVhY3RpdmF0ZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoZGVhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChhY3RpdmF0ZWQubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIF9ldmVudEhhbmRsZXIoZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgcmVwbGF5LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGluQ2hhcnRBcmVhOiBfaXNQb2ludEluQXJlYShlLCB0aGlzLmNoYXJ0QXJlYSwgdGhpcy5fbWluUGFkZGluZylcbiAgICB9O1xuICAgIGNvbnN0IGV2ZW50RmlsdGVyID0gKHBsdWdpbikgPT4gKHBsdWdpbi5vcHRpb25zLmV2ZW50cyB8fCB0aGlzLm9wdGlvbnMuZXZlbnRzKS5pbmNsdWRlcyhlLm5hdGl2ZS50eXBlKTtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgYXJncy5pbkNoYXJ0QXJlYSk7XG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpO1xuICAgIGlmIChjaGFuZ2VkIHx8IGFyZ3MuY2hhbmdlZCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcbiAgICBjb25zdCB7X2FjdGl2ZTogbGFzdEFjdGl2ZSA9IFtdLCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IHJlcGxheTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgaXNDbGljayA9IF9pc0NsaWNrRXZlbnQoZSk7XG4gICAgY29uc3QgbGFzdEV2ZW50ID0gZGV0ZXJtaW5lTGFzdEV2ZW50KGUsIHRoaXMuX2xhc3RFdmVudCwgaW5DaGFydEFyZWEsIGlzQ2xpY2spO1xuICAgIGlmIChpbkNoYXJ0QXJlYSkge1xuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgIGNhbGxiYWNrKG9wdGlvbnMub25Ib3ZlciwgW2UsIGFjdGl2ZSwgdGhpc10sIHRoaXMpO1xuICAgICAgaWYgKGlzQ2xpY2spIHtcbiAgICAgICAgY2FsbGJhY2sob3B0aW9ucy5vbkNsaWNrLCBbZSwgYWN0aXZlLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoY2hhbmdlZCB8fCByZXBsYXkpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KTtcbiAgICB9XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gbGFzdEV2ZW50O1xuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKCFpbkNoYXJ0QXJlYSkge1xuICAgICAgcmV0dXJuIGxhc3RBY3RpdmU7XG4gICAgfVxuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG59XG5jb25zdCBpbnZhbGlkYXRlUGx1Z2lucyA9ICgpID0+IGVhY2goQ2hhcnQuaW5zdGFuY2VzLCAoY2hhcnQpID0+IGNoYXJ0Ll9wbHVnaW5zLmludmFsaWRhdGUoKSk7XG5jb25zdCBlbnVtZXJhYmxlID0gdHJ1ZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENoYXJ0LCB7XG4gIGRlZmF1bHRzOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogZGVmYXVsdHNcbiAgfSxcbiAgaW5zdGFuY2VzOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogaW5zdGFuY2VzXG4gIH0sXG4gIG92ZXJyaWRlczoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IG92ZXJyaWRlc1xuICB9LFxuICByZWdpc3RyeToge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IHJlZ2lzdHJ5XG4gIH0sXG4gIHZlcnNpb246IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiB2ZXJzaW9uXG4gIH0sXG4gIGdldENoYXJ0OiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogZ2V0Q2hhcnRcbiAgfSxcbiAgcmVnaXN0ZXI6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiAoLi4uaXRlbXMpID0+IHtcbiAgICAgIHJlZ2lzdHJ5LmFkZCguLi5pdGVtcyk7XG4gICAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3Rlcjoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6ICguLi5pdGVtcykgPT4ge1xuICAgICAgcmVnaXN0cnkucmVtb3ZlKC4uLml0ZW1zKTtcbiAgICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gY2xpcEFyYyhjdHgsIGVsZW1lbnQsIGVuZEFuZ2xlKSB7XG4gIGNvbnN0IHtzdGFydEFuZ2xlLCBwaXhlbE1hcmdpbiwgeCwgeSwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzfSA9IGVsZW1lbnQ7XG4gIGxldCBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gb3V0ZXJSYWRpdXM7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luKTtcbiAgaWYgKGlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcbiAgICBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gaW5uZXJSYWRpdXM7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbiwgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBjdHguYXJjKHgsIHksIHBpeGVsTWFyZ2luLCBlbmRBbmdsZSArIEhBTEZfUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiB0b1JhZGl1c0Nvcm5lcnModmFsdWUpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbJ291dGVyU3RhcnQnLCAnb3V0ZXJFbmQnLCAnaW5uZXJTdGFydCcsICdpbm5lckVuZCddKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzJDEoYXJjLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGFuZ2xlRGVsdGEpIHtcbiAgY29uc3QgbyA9IHRvUmFkaXVzQ29ybmVycyhhcmMub3B0aW9ucy5ib3JkZXJSYWRpdXMpO1xuICBjb25zdCBoYWxmVGhpY2tuZXNzID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gMjtcbiAgY29uc3QgaW5uZXJMaW1pdCA9IE1hdGgubWluKGhhbGZUaGlja25lc3MsIGFuZ2xlRGVsdGEgKiBpbm5lclJhZGl1cyAvIDIpO1xuICBjb25zdCBjb21wdXRlT3V0ZXJMaW1pdCA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBvdXRlckFyY0xpbWl0ID0gKG91dGVyUmFkaXVzIC0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgdmFsKSkgKiBhbmdsZURlbHRhIC8gMjtcbiAgICByZXR1cm4gX2xpbWl0VmFsdWUodmFsLCAwLCBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBvdXRlckFyY0xpbWl0KSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgb3V0ZXJTdGFydDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlclN0YXJ0KSxcbiAgICBvdXRlckVuZDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlckVuZCksXG4gICAgaW5uZXJTdGFydDogX2xpbWl0VmFsdWUoby5pbm5lclN0YXJ0LCAwLCBpbm5lckxpbWl0KSxcbiAgICBpbm5lckVuZDogX2xpbWl0VmFsdWUoby5pbm5lckVuZCwgMCwgaW5uZXJMaW1pdCksXG4gIH07XG59XG5mdW5jdGlvbiByVGhldGFUb1hZKHIsIHRoZXRhLCB4LCB5KSB7XG4gIHJldHVybiB7XG4gICAgeDogeCArIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgeTogeSArIHIgKiBNYXRoLnNpbih0aGV0YSksXG4gIH07XG59XG5mdW5jdGlvbiBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmQpIHtcbiAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGU6IHN0YXJ0LCBwaXhlbE1hcmdpbiwgaW5uZXJSYWRpdXM6IGlubmVyUn0gPSBlbGVtZW50O1xuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0IC0gcGl4ZWxNYXJnaW4sIDApO1xuICBjb25zdCBpbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgKyBzcGFjaW5nICsgb2Zmc2V0ICsgcGl4ZWxNYXJnaW4gOiAwO1xuICBsZXQgc3BhY2luZ09mZnNldCA9IDA7XG4gIGNvbnN0IGFscGhhID0gZW5kIC0gc3RhcnQ7XG4gIGlmIChzcGFjaW5nKSB7XG4gICAgY29uc3Qgbm9TcGFjaW5nSW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3Qgbm9TcGFjaW5nT3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyA+IDAgPyBvdXRlclJhZGl1cyAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IGF2Tm9nU3BhY2luZ1JhZGl1cyA9IChub1NwYWNpbmdJbm5lclJhZGl1cyArIG5vU3BhY2luZ091dGVyUmFkaXVzKSAvIDI7XG4gICAgY29uc3QgYWRqdXN0ZWRBbmdsZSA9IGF2Tm9nU3BhY2luZ1JhZGl1cyAhPT0gMCA/IChhbHBoYSAqIGF2Tm9nU3BhY2luZ1JhZGl1cykgLyAoYXZOb2dTcGFjaW5nUmFkaXVzICsgc3BhY2luZykgOiBhbHBoYTtcbiAgICBzcGFjaW5nT2Zmc2V0ID0gKGFscGhhIC0gYWRqdXN0ZWRBbmdsZSkgLyAyO1xuICB9XG4gIGNvbnN0IGJldGEgPSBNYXRoLm1heCgwLjAwMSwgYWxwaGEgKiBvdXRlclJhZGl1cyAtIG9mZnNldCAvIFBJKSAvIG91dGVyUmFkaXVzO1xuICBjb25zdCBhbmdsZU9mZnNldCA9IChhbHBoYSAtIGJldGEpIC8gMjtcbiAgY29uc3Qgc3RhcnRBbmdsZSA9IHN0YXJ0ICsgYW5nbGVPZmZzZXQgKyBzcGFjaW5nT2Zmc2V0O1xuICBjb25zdCBlbmRBbmdsZSA9IGVuZCAtIGFuZ2xlT2Zmc2V0IC0gc3BhY2luZ09mZnNldDtcbiAgY29uc3Qge291dGVyU3RhcnQsIG91dGVyRW5kLCBpbm5lclN0YXJ0LCBpbm5lckVuZH0gPSBwYXJzZUJvcmRlclJhZGl1cyQxKGVsZW1lbnQsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlclN0YXJ0O1xuICBjb25zdCBvdXRlckVuZEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlckVuZDtcbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgb3V0ZXJTdGFydCAvIG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBvdXRlckVuZCAvIG91dGVyRW5kQWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJTdGFydDtcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJFbmQ7XG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIGlubmVyU3RhcnQgLyBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gaW5uZXJFbmQgLyBpbm5lckVuZEFkanVzdGVkUmFkaXVzO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCBvdXRlckVuZEFkanVzdGVkQW5nbGUpO1xuICBpZiAob3V0ZXJFbmQgPiAwKSB7XG4gICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJFbmRBZGp1c3RlZFJhZGl1cywgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlckVuZCwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCBlbmRBbmdsZSArIEhBTEZfUEkpO1xuICB9XG4gIGNvbnN0IHA0ID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBlbmRBbmdsZSwgeCwgeSk7XG4gIGN0eC5saW5lVG8ocDQueCwgcDQueSk7XG4gIGlmIChpbm5lckVuZCA+IDApIHtcbiAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBpbm5lckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyRW5kLCBlbmRBbmdsZSArIEhBTEZfUEksIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSArIE1hdGguUEkpO1xuICB9XG4gIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlIC0gKGlubmVyRW5kIC8gaW5uZXJSYWRpdXMpLCBzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cyksIHRydWUpO1xuICBpZiAoaW5uZXJTdGFydCA+IDApIHtcbiAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lclN0YXJ0LCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSArIE1hdGguUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgfVxuICBjb25zdCBwOCA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBzdGFydEFuZ2xlLCB4LCB5KTtcbiAgY3R4LmxpbmVUbyhwOC54LCBwOC55KTtcbiAgaWYgKG91dGVyU3RhcnQgPiAwKSB7XG4gICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJTdGFydCwgc3RhcnRBbmdsZSAtIEhBTEZfUEksIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG59XG5mdW5jdGlvbiBkcmF3QXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nKSB7XG4gIGNvbnN0IHtmdWxsQ2lyY2xlcywgc3RhcnRBbmdsZSwgY2lyY3VtZmVyZW5jZX0gPSBlbGVtZW50O1xuICBsZXQgZW5kQW5nbGUgPSBlbGVtZW50LmVuZEFuZ2xlO1xuICBpZiAoZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBzdGFydEFuZ2xlICsgVEFVKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGlmICghaXNOYU4oY2lyY3VtZmVyZW5jZSkpIHtcbiAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UgJSBUQVU7XG4gICAgICBpZiAoY2lyY3VtZmVyZW5jZSAlIFRBVSA9PT0gMCkge1xuICAgICAgICBlbmRBbmdsZSArPSBUQVU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlKTtcbiAgY3R4LmZpbGwoKTtcbiAgcmV0dXJuIGVuZEFuZ2xlO1xufVxuZnVuY3Rpb24gZHJhd0Z1bGxDaXJjbGVCb3JkZXJzKGN0eCwgZWxlbWVudCwgaW5uZXIpIHtcbiAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGUsIHBpeGVsTWFyZ2luLCBmdWxsQ2lyY2xlc30gPSBlbGVtZW50O1xuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgLSBwaXhlbE1hcmdpbiwgMCk7XG4gIGNvbnN0IGlubmVyUmFkaXVzID0gZWxlbWVudC5pbm5lclJhZGl1cyArIHBpeGVsTWFyZ2luO1xuICBsZXQgaTtcbiAgaWYgKGlubmVyKSB7XG4gICAgY2xpcEFyYyhjdHgsIGVsZW1lbnQsIHN0YXJ0QW5nbGUgKyBUQVUpO1xuICB9XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgc3RhcnRBbmdsZSArIFRBVSwgc3RhcnRBbmdsZSwgdHJ1ZSk7XG4gIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSwgc3RhcnRBbmdsZSArIFRBVSk7XG4gIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBkcmF3Qm9yZGVyKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSkge1xuICBjb25zdCB7b3B0aW9uc30gPSBlbGVtZW50O1xuICBjb25zdCB7Ym9yZGVyV2lkdGgsIGJvcmRlckpvaW5TdHlsZX0gPSBvcHRpb25zO1xuICBjb25zdCBpbm5lciA9IG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcic7XG4gIGlmICghYm9yZGVyV2lkdGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlubmVyKSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoICogMjtcbiAgICBjdHgubGluZUpvaW4gPSBib3JkZXJKb2luU3R5bGUgfHwgJ3JvdW5kJztcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdiZXZlbCc7XG4gIH1cbiAgaWYgKGVsZW1lbnQuZnVsbENpcmNsZXMpIHtcbiAgICBkcmF3RnVsbENpcmNsZUJvcmRlcnMoY3R4LCBlbGVtZW50LCBpbm5lcik7XG4gIH1cbiAgaWYgKGlubmVyKSB7XG4gICAgY2xpcEFyYyhjdHgsIGVsZW1lbnQsIGVuZEFuZ2xlKTtcbiAgfVxuICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSk7XG4gIGN0eC5zdHJva2UoKTtcbn1cbmNsYXNzIEFyY0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaXJjdW1mZXJlbmNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuZEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBpeGVsTWFyZ2luID0gMDtcbiAgICB0aGlzLmZ1bGxDaXJjbGVzID0gMDtcbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG4gIGluUmFuZ2UoY2hhcnRYLCBjaGFydFksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBwb2ludCA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge2FuZ2xlLCBkaXN0YW5jZX0gPSBnZXRBbmdsZUZyb21Qb2ludChwb2ludCwge3g6IGNoYXJ0WCwgeTogY2hhcnRZfSk7XG4gICAgY29uc3Qge3N0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGNpcmN1bWZlcmVuY2V9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAnZW5kQW5nbGUnLFxuICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICdvdXRlclJhZGl1cycsXG4gICAgICAnY2lyY3VtZmVyZW5jZSdcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCByQWRqdXN0ID0gdGhpcy5vcHRpb25zLnNwYWNpbmcgLyAyO1xuICAgIGNvbnN0IF9jaXJjdW1mZXJlbmNlID0gdmFsdWVPckRlZmF1bHQoY2lyY3VtZmVyZW5jZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBiZXR3ZWVuQW5nbGVzID0gX2NpcmN1bWZlcmVuY2UgPj0gVEFVIHx8IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICBjb25zdCB3aXRoaW5SYWRpdXMgPSBfaXNCZXR3ZWVuKGRpc3RhbmNlLCBpbm5lclJhZGl1cyArIHJBZGp1c3QsIG91dGVyUmFkaXVzICsgckFkanVzdCk7XG4gICAgcmV0dXJuIChiZXR3ZWVuQW5nbGVzICYmIHdpdGhpblJhZGl1cyk7XG4gIH1cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3gnLFxuICAgICAgJ3knLFxuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnLFxuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHtvZmZzZXQsIHNwYWNpbmd9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGhhbGZBbmdsZSA9IChzdGFydEFuZ2xlICsgZW5kQW5nbGUpIC8gMjtcbiAgICBjb25zdCBoYWxmUmFkaXVzID0gKGlubmVyUmFkaXVzICsgb3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0KSAvIDI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhoYWxmQW5nbGUpICogaGFsZlJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihoYWxmQW5nbGUpICogaGFsZlJhZGl1c1xuICAgIH07XG4gIH1cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gKG9wdGlvbnMub2Zmc2V0IHx8IDApIC8gMjtcbiAgICBjb25zdCBzcGFjaW5nID0gKG9wdGlvbnMuc3BhY2luZyB8fCAwKSAvIDI7XG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IChvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInKSA/IDAuMzMgOiAwO1xuICAgIHRoaXMuZnVsbENpcmNsZXMgPSBjaXJjdW1mZXJlbmNlID4gVEFVID8gTWF0aC5mbG9vcihjaXJjdW1mZXJlbmNlIC8gVEFVKSA6IDA7XG4gICAgaWYgKGNpcmN1bWZlcmVuY2UgPT09IDAgfHwgdGhpcy5pbm5lclJhZGl1cyA8IDAgfHwgdGhpcy5vdXRlclJhZGl1cyA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBsZXQgcmFkaXVzT2Zmc2V0ID0gMDtcbiAgICBpZiAob2Zmc2V0KSB7XG4gICAgICByYWRpdXNPZmZzZXQgPSBvZmZzZXQgLyAyO1xuICAgICAgY29uc3QgaGFsZkFuZ2xlID0gKHRoaXMuc3RhcnRBbmdsZSArIHRoaXMuZW5kQW5nbGUpIC8gMjtcbiAgICAgIGN0eC50cmFuc2xhdGUoTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIHJhZGl1c09mZnNldCwgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIHJhZGl1c09mZnNldCk7XG4gICAgICBpZiAodGhpcy5jaXJjdW1mZXJlbmNlID49IFBJKSB7XG4gICAgICAgIHJhZGl1c09mZnNldCA9IG9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY29uc3QgZW5kQW5nbGUgPSBkcmF3QXJjKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nKTtcbiAgICBkcmF3Qm9yZGVyKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuQXJjRWxlbWVudC5pZCA9ICdhcmMnO1xuQXJjRWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyQWxpZ246ICdjZW50ZXInLFxuICBib3JkZXJDb2xvcjogJyNmZmYnLFxuICBib3JkZXJKb2luU3R5bGU6IHVuZGVmaW5lZCxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBib3JkZXJXaWR0aDogMixcbiAgb2Zmc2V0OiAwLFxuICBzcGFjaW5nOiAwLFxuICBhbmdsZTogdW5kZWZpbmVkLFxufTtcbkFyY0VsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJ1xufTtcblxuZnVuY3Rpb24gc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzdHlsZSA9IG9wdGlvbnMpIHtcbiAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDYXBTdHlsZSwgb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSk7XG4gIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoLCBvcHRpb25zLmJvcmRlckRhc2gpKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaE9mZnNldCwgb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0KTtcbiAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVySm9pblN0eWxlLCBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSk7XG4gIGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNvbG9yLCBvcHRpb25zLmJvcmRlckNvbG9yKTtcbn1cbmZ1bmN0aW9uIGxpbmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQpIHtcbiAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuZnVuY3Rpb24gZ2V0TGluZU1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRMaW5lVG87XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckN1cnZlVG87XG4gIH1cbiAgcmV0dXJuIGxpbmVUbztcbn1cbmZ1bmN0aW9uIHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zID0ge30pIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7c3RhcnQ6IHBhcmFtc1N0YXJ0ID0gMCwgZW5kOiBwYXJhbXNFbmQgPSBjb3VudCAtIDF9ID0gcGFyYW1zO1xuICBjb25zdCB7c3RhcnQ6IHNlZ21lbnRTdGFydCwgZW5kOiBzZWdtZW50RW5kfSA9IHNlZ21lbnQ7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgocGFyYW1zU3RhcnQsIHNlZ21lbnRTdGFydCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHBhcmFtc0VuZCwgc2VnbWVudEVuZCk7XG4gIGNvbnN0IG91dHNpZGUgPSBwYXJhbXNTdGFydCA8IHNlZ21lbnRTdGFydCAmJiBwYXJhbXNFbmQgPCBzZWdtZW50U3RhcnQgfHwgcGFyYW1zU3RhcnQgPiBzZWdtZW50RW5kICYmIHBhcmFtc0VuZCA+IHNlZ21lbnRFbmQ7XG4gIHJldHVybiB7XG4gICAgY291bnQsXG4gICAgc3RhcnQsXG4gICAgbG9vcDogc2VnbWVudC5sb29wLFxuICAgIGlsZW46IGVuZCA8IHN0YXJ0ICYmICFvdXRzaWRlID8gY291bnQgKyBlbmQgLSBzdGFydCA6IGVuZCAtIHN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiBwYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCB7cG9pbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGxvb3AsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICBjb25zdCBsaW5lTWV0aG9kID0gZ2V0TGluZU1ldGhvZChvcHRpb25zKTtcbiAgbGV0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBpLCBwb2ludCwgcHJldjtcbiAgZm9yIChpID0gMDsgaSA8PSBpbGVuOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpIDogaSkpICUgY291bnRdO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKG1vdmUpIHtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBtb3ZlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICB9XG4gICAgcHJldiA9IHBvaW50O1xuICB9XG4gIGlmIChsb29wKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIDogMCkpICUgY291bnRdO1xuICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgfVxuICByZXR1cm4gISFsb29wO1xufVxuZnVuY3Rpb24gZmFzdFBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3Qge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCBwcmV2WCwgbWluWSwgbWF4WSwgbGFzdFk7XG4gIGNvbnN0IHBvaW50SW5kZXggPSAoaW5kZXgpID0+IChzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGluZGV4IDogaW5kZXgpKSAlIGNvdW50O1xuICBjb25zdCBkcmF3WCA9ICgpID0+IHtcbiAgICBpZiAobWluWSAhPT0gbWF4WSkge1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtYXhZKTtcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWluWSk7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIGxhc3RZKTtcbiAgICB9XG4gIH07XG4gIGlmIChtb3ZlKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleCgwKV07XG4gICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoaSldO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgeCA9IHBvaW50Lng7XG4gICAgY29uc3QgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG4gICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICB9XG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyB4KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3WCgpO1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICB9XG4gICAgbGFzdFkgPSB5O1xuICB9XG4gIGRyYXdYKCk7XG59XG5mdW5jdGlvbiBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKSB7XG4gIGNvbnN0IG9wdHMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzLmJvcmRlckRhc2ggJiYgb3B0cy5ib3JkZXJEYXNoLmxlbmd0aDtcbiAgY29uc3QgdXNlRmFzdFBhdGggPSAhbGluZS5fZGVjaW1hdGVkICYmICFsaW5lLl9sb29wICYmICFvcHRzLnRlbnNpb24gJiYgb3B0cy5jdWJpY0ludGVycG9sYXRpb25Nb2RlICE9PSAnbW9ub3RvbmUnICYmICFvcHRzLnN0ZXBwZWQgJiYgIWJvcmRlckRhc2g7XG4gIHJldHVybiB1c2VGYXN0UGF0aCA/IGZhc3RQYXRoU2VnbWVudCA6IHBhdGhTZWdtZW50O1xufVxuZnVuY3Rpb24gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgcmV0dXJuIF9zdGVwcGVkSW50ZXJwb2xhdGlvbjtcbiAgfVxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVySW50ZXJwb2xhdGlvbjtcbiAgfVxuICByZXR1cm4gX3BvaW50SW5MaW5lO1xufVxuZnVuY3Rpb24gc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBsZXQgcGF0aCA9IGxpbmUuX3BhdGg7XG4gIGlmICghcGF0aCkge1xuICAgIHBhdGggPSBsaW5lLl9wYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgIGlmIChsaW5lLnBhdGgocGF0aCwgc3RhcnQsIGNvdW50KSkge1xuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cbiAgc2V0U3R5bGUoY3R4LCBsaW5lLm9wdGlvbnMpO1xuICBjdHguc3Ryb2tlKHBhdGgpO1xufVxuZnVuY3Rpb24gc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCB7c2VnbWVudHMsIG9wdGlvbnN9ID0gbGluZTtcbiAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHNlZ21lbnQuc3R5bGUpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoc2VnbWVudE1ldGhvZChjdHgsIGxpbmUsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuY29uc3QgdXNlUGF0aDJEID0gdHlwZW9mIFBhdGgyRCA9PT0gJ2Z1bmN0aW9uJztcbmZ1bmN0aW9uIGRyYXcoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgaWYgKHVzZVBhdGgyRCAmJiAhbGluZS5vcHRpb25zLnNlZ21lbnQpIHtcbiAgICBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfSBlbHNlIHtcbiAgICBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfVxufVxuY2xhc3MgTGluZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmFuaW1hdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2hhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mdWxsTG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zZWdtZW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kZWNpbWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YXNldEluZGV4ID0gdW5kZWZpbmVkO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlQ29udHJvbFBvaW50cyhjaGFydEFyZWEsIGluZGV4QXhpcykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSAmJiAhb3B0aW9ucy5zdGVwcGVkICYmICF0aGlzLl9wb2ludHNVcGRhdGVkKSB7XG4gICAgICBjb25zdCBsb29wID0gb3B0aW9ucy5zcGFuR2FwcyA/IHRoaXMuX2xvb3AgOiB0aGlzLl9mdWxsTG9vcDtcbiAgICAgIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKHRoaXMuX3BvaW50cywgb3B0aW9ucywgY2hhcnRBcmVhLCBsb29wLCBpbmRleEF4aXMpO1xuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHNldCBwb2ludHMocG9pbnRzKSB7XG4gICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9zZWdtZW50cztcbiAgICBkZWxldGUgdGhpcy5fcGF0aDtcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IHBvaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xuICB9XG4gIGdldCBzZWdtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudHMgfHwgKHRoaXMuX3NlZ21lbnRzID0gX2NvbXB1dGVTZWdtZW50cyh0aGlzLCB0aGlzLm9wdGlvbnMuc2VnbWVudCkpO1xuICB9XG4gIGZpcnN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoICYmIHBvaW50c1tzZWdtZW50c1swXS5zdGFydF07XG4gIH1cbiAgbGFzdCgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3QgY291bnQgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGNvdW50ICYmIHBvaW50c1tzZWdtZW50c1tjb3VudCAtIDFdLmVuZF07XG4gIH1cbiAgaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBzZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRoaXMsIHtwcm9wZXJ0eSwgc3RhcnQ6IHZhbHVlLCBlbmQ6IHZhbHVlfSk7XG4gICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgX2ludGVycG9sYXRlID0gX2dldEludGVycG9sYXRpb25NZXRob2Qob3B0aW9ucyk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gc2VnbWVudHNbaV07XG4gICAgICBjb25zdCBwMSA9IHBvaW50c1tzdGFydF07XG4gICAgICBjb25zdCBwMiA9IHBvaW50c1tlbmRdO1xuICAgICAgaWYgKHAxID09PSBwMikge1xuICAgICAgICByZXN1bHQucHVzaChwMSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdCA9IE1hdGguYWJzKCh2YWx1ZSAtIHAxW3Byb3BlcnR5XSkgLyAocDJbcHJvcGVydHldIC0gcDFbcHJvcGVydHldKSk7XG4gICAgICBjb25zdCBpbnRlcnBvbGF0ZWQgPSBfaW50ZXJwb2xhdGUocDEsIHAyLCB0LCBvcHRpb25zLnN0ZXBwZWQpO1xuICAgICAgaW50ZXJwb2xhdGVkW3Byb3BlcnR5XSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICAgIHJlc3VsdC5wdXNoKGludGVycG9sYXRlZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAxID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICB9XG4gIHBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwgcGFyYW1zKSB7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgIHJldHVybiBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwgcGFyYW1zKTtcbiAgfVxuICBwYXRoKGN0eCwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICBsZXQgbG9vcCA9IHRoaXMuX2xvb3A7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIGNvdW50ID0gY291bnQgfHwgKHRoaXMucG9pbnRzLmxlbmd0aCAtIHN0YXJ0KTtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgIGxvb3AgJj0gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pO1xuICAgIH1cbiAgICByZXR1cm4gISFsb29wO1xuICB9XG4gIGRyYXcoY3R4LCBjaGFydEFyZWEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHMgfHwgW107XG4gICAgaWYgKHBvaW50cy5sZW5ndGggJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGRyYXcoY3R4LCB0aGlzLCBzdGFydCwgY291bnQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5pbWF0ZWQpIHtcbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5MaW5lRWxlbWVudC5pZCA9ICdsaW5lJztcbkxpbmVFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJDYXBTdHlsZTogJ2J1dHQnLFxuICBib3JkZXJEYXNoOiBbXSxcbiAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgYm9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxuICBib3JkZXJXaWR0aDogMyxcbiAgY2FwQmV6aWVyUG9pbnRzOiB0cnVlLFxuICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiAnZGVmYXVsdCcsXG4gIGZpbGw6IGZhbHNlLFxuICBzcGFuR2FwczogZmFsc2UsXG4gIHN0ZXBwZWQ6IGZhbHNlLFxuICB0ZW5zaW9uOiAwLFxufTtcbkxpbmVFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG59O1xuTGluZUVsZW1lbnQuZGVzY3JpcHRvcnMgPSB7XG4gIF9zY3JpcHRhYmxlOiB0cnVlLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICdmaWxsJyxcbn07XG5cbmZ1bmN0aW9uIGluUmFuZ2UkMShlbCwgcG9zLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBlbC5vcHRpb25zO1xuICBjb25zdCB7W2F4aXNdOiB2YWx1ZX0gPSBlbC5nZXRQcm9wcyhbYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICByZXR1cm4gKE1hdGguYWJzKHBvcyAtIHZhbHVlKSA8IG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5oaXRSYWRpdXMpO1xufVxuY2xhc3MgUG9pbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFyc2VkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2tpcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0b3AgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiAoKE1hdGgucG93KG1vdXNlWCAtIHgsIDIpICsgTWF0aC5wb3cobW91c2VZIC0geSwgMikpIDwgTWF0aC5wb3cob3B0aW9ucy5oaXRSYWRpdXMgKyBvcHRpb25zLnJhZGl1cywgMikpO1xuICB9XG4gIGluWFJhbmdlKG1vdXNlWCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlJDEodGhpcywgbW91c2VYLCAneCcsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlJDEodGhpcywgbW91c2VZLCAneScsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX07XG4gIH1cbiAgc2l6ZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGxldCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCAwO1xuICAgIHJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cywgcmFkaXVzICYmIG9wdGlvbnMuaG92ZXJSYWRpdXMgfHwgMCk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSByYWRpdXMgJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIHJldHVybiAocmFkaXVzICsgYm9yZGVyV2lkdGgpICogMjtcbiAgfVxuICBkcmF3KGN0eCwgYXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHRoaXMuc2tpcCB8fCBvcHRpb25zLnJhZGl1cyA8IDAuMSB8fCAhX2lzUG9pbnRJbkFyZWEodGhpcywgYXJlYSwgdGhpcy5zaXplKG9wdGlvbnMpIC8gMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgZHJhd1BvaW50KGN0eCwgb3B0aW9ucywgdGhpcy54LCB0aGlzLnkpO1xuICB9XG4gIGdldFJhbmdlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5oaXRSYWRpdXM7XG4gIH1cbn1cblBvaW50RWxlbWVudC5pZCA9ICdwb2ludCc7XG5Qb2ludEVsZW1lbnQuZGVmYXVsdHMgPSB7XG4gIGJvcmRlcldpZHRoOiAxLFxuICBoaXRSYWRpdXM6IDEsXG4gIGhvdmVyQm9yZGVyV2lkdGg6IDEsXG4gIGhvdmVyUmFkaXVzOiA0LFxuICBwb2ludFN0eWxlOiAnY2lyY2xlJyxcbiAgcmFkaXVzOiAzLFxuICByb3RhdGlvbjogMFxufTtcblBvaW50RWxlbWVudC5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xufTtcblxuZnVuY3Rpb24gZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCB7eCwgeSwgYmFzZSwgd2lkdGgsIGhlaWdodH0gPSBiYXIuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIGxldCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIGhhbGY7XG4gIGlmIChiYXIuaG9yaXpvbnRhbCkge1xuICAgIGhhbGYgPSBoZWlnaHQgLyAyO1xuICAgIGxlZnQgPSBNYXRoLm1pbih4LCBiYXNlKTtcbiAgICByaWdodCA9IE1hdGgubWF4KHgsIGJhc2UpO1xuICAgIHRvcCA9IHkgLSBoYWxmO1xuICAgIGJvdHRvbSA9IHkgKyBoYWxmO1xuICB9IGVsc2Uge1xuICAgIGhhbGYgPSB3aWR0aCAvIDI7XG4gICAgbGVmdCA9IHggLSBoYWxmO1xuICAgIHJpZ2h0ID0geCArIGhhbGY7XG4gICAgdG9wID0gTWF0aC5taW4oeSwgYmFzZSk7XG4gICAgYm90dG9tID0gTWF0aC5tYXgoeSwgYmFzZSk7XG4gIH1cbiAgcmV0dXJuIHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219O1xufVxuZnVuY3Rpb24gc2tpcE9yTGltaXQoc2tpcCwgdmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBza2lwID8gMCA6IF9saW1pdFZhbHVlKHZhbHVlLCBtaW4sIG1heCk7XG59XG5mdW5jdGlvbiBwYXJzZUJvcmRlcldpZHRoKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlcldpZHRoO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IG8gPSB0b1RSQkwodmFsdWUpO1xuICByZXR1cm4ge1xuICAgIHQ6IHNraXBPckxpbWl0KHNraXAudG9wLCBvLnRvcCwgMCwgbWF4SCksXG4gICAgcjogc2tpcE9yTGltaXQoc2tpcC5yaWdodCwgby5yaWdodCwgMCwgbWF4VyksXG4gICAgYjogc2tpcE9yTGltaXQoc2tpcC5ib3R0b20sIG8uYm90dG9tLCAwLCBtYXhIKSxcbiAgICBsOiBza2lwT3JMaW1pdChza2lwLmxlZnQsIG8ubGVmdCwgMCwgbWF4VylcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB7ZW5hYmxlQm9yZGVyUmFkaXVzfSA9IGJhci5nZXRQcm9wcyhbJ2VuYWJsZUJvcmRlclJhZGl1cyddKTtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJSYWRpdXM7XG4gIGNvbnN0IG8gPSB0b1RSQkxDb3JuZXJzKHZhbHVlKTtcbiAgY29uc3QgbWF4UiA9IE1hdGgubWluKG1heFcsIG1heEgpO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IGVuYWJsZUJvcmRlciA9IGVuYWJsZUJvcmRlclJhZGl1cyB8fCBpc09iamVjdCh2YWx1ZSk7XG4gIHJldHVybiB7XG4gICAgdG9wTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLmxlZnQsIG8udG9wTGVmdCwgMCwgbWF4UiksXG4gICAgdG9wUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5yaWdodCwgby50b3BSaWdodCwgMCwgbWF4UiksXG4gICAgYm90dG9tTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLmxlZnQsIG8uYm90dG9tTGVmdCwgMCwgbWF4UiksXG4gICAgYm90dG9tUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5yaWdodCwgby5ib3R0b21SaWdodCwgMCwgbWF4UilcbiAgfTtcbn1cbmZ1bmN0aW9uIGJvdW5kaW5nUmVjdHMoYmFyKSB7XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJhckJvdW5kcyhiYXIpO1xuICBjb25zdCB3aWR0aCA9IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xuICBjb25zdCBoZWlnaHQgPSBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcDtcbiAgY29uc3QgYm9yZGVyID0gcGFyc2VCb3JkZXJXaWR0aChiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gIGNvbnN0IHJhZGl1cyA9IHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgcmV0dXJuIHtcbiAgICBvdXRlcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQsXG4gICAgICB5OiBib3VuZHMudG9wLFxuICAgICAgdzogd2lkdGgsXG4gICAgICBoOiBoZWlnaHQsXG4gICAgICByYWRpdXNcbiAgICB9LFxuICAgIGlubmVyOiB7XG4gICAgICB4OiBib3VuZHMubGVmdCArIGJvcmRlci5sLFxuICAgICAgeTogYm91bmRzLnRvcCArIGJvcmRlci50LFxuICAgICAgdzogd2lkdGggLSBib3JkZXIubCAtIGJvcmRlci5yLFxuICAgICAgaDogaGVpZ2h0IC0gYm9yZGVyLnQgLSBib3JkZXIuYixcbiAgICAgIHJhZGl1czoge1xuICAgICAgICB0b3BMZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wTGVmdCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIubCkpLFxuICAgICAgICB0b3BSaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcFJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5yKSksXG4gICAgICAgIGJvdHRvbUxlZnQ6IE1hdGgubWF4KDAsIHJhZGl1cy5ib3R0b21MZWZ0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5sKSksXG4gICAgICAgIGJvdHRvbVJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tUmlnaHQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLnIpKSxcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpblJhbmdlKGJhciwgeCwgeSwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBza2lwWCA9IHggPT09IG51bGw7XG4gIGNvbnN0IHNraXBZID0geSA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcEJvdGggPSBza2lwWCAmJiBza2lwWTtcbiAgY29uc3QgYm91bmRzID0gYmFyICYmICFza2lwQm90aCAmJiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgcmV0dXJuIGJvdW5kc1xuXHRcdCYmIChza2lwWCB8fCBfaXNCZXR3ZWVuKHgsIGJvdW5kcy5sZWZ0LCBib3VuZHMucmlnaHQpKVxuXHRcdCYmIChza2lwWSB8fCBfaXNCZXR3ZWVuKHksIGJvdW5kcy50b3AsIGJvdW5kcy5ib3R0b20pKTtcbn1cbmZ1bmN0aW9uIGhhc1JhZGl1cyhyYWRpdXMpIHtcbiAgcmV0dXJuIHJhZGl1cy50b3BMZWZ0IHx8IHJhZGl1cy50b3BSaWdodCB8fCByYWRpdXMuYm90dG9tTGVmdCB8fCByYWRpdXMuYm90dG9tUmlnaHQ7XG59XG5mdW5jdGlvbiBhZGROb3JtYWxSZWN0UGF0aChjdHgsIHJlY3QpIHtcbiAgY3R4LnJlY3QocmVjdC54LCByZWN0LnksIHJlY3QudywgcmVjdC5oKTtcbn1cbmZ1bmN0aW9uIGluZmxhdGVSZWN0KHJlY3QsIGFtb3VudCwgcmVmUmVjdCA9IHt9KSB7XG4gIGNvbnN0IHggPSByZWN0LnggIT09IHJlZlJlY3QueCA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB5ID0gcmVjdC55ICE9PSByZWZSZWN0LnkgPyAtYW1vdW50IDogMDtcbiAgY29uc3QgdyA9IChyZWN0LnggKyByZWN0LncgIT09IHJlZlJlY3QueCArIHJlZlJlY3QudyA/IGFtb3VudCA6IDApIC0geDtcbiAgY29uc3QgaCA9IChyZWN0LnkgKyByZWN0LmggIT09IHJlZlJlY3QueSArIHJlZlJlY3QuaCA/IGFtb3VudCA6IDApIC0geTtcbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LnggKyB4LFxuICAgIHk6IHJlY3QueSArIHksXG4gICAgdzogcmVjdC53ICsgdyxcbiAgICBoOiByZWN0LmggKyBoLFxuICAgIHJhZGl1czogcmVjdC5yYWRpdXNcbiAgfTtcbn1cbmNsYXNzIEJhckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ob3Jpem9udGFsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFzZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5mbGF0ZUFtb3VudCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qge2luZmxhdGVBbW91bnQsIG9wdGlvbnM6IHtib3JkZXJDb2xvciwgYmFja2dyb3VuZENvbG9yfX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpbm5lciwgb3V0ZXJ9ID0gYm91bmRpbmdSZWN0cyh0aGlzKTtcbiAgICBjb25zdCBhZGRSZWN0UGF0aCA9IGhhc1JhZGl1cyhvdXRlci5yYWRpdXMpID8gYWRkUm91bmRlZFJlY3RQYXRoIDogYWRkTm9ybWFsUmVjdFBhdGg7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAob3V0ZXIudyAhPT0gaW5uZXIudyB8fCBvdXRlci5oICE9PSBpbm5lci5oKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KG91dGVyLCBpbmZsYXRlQW1vdW50LCBpbm5lcikpO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIC1pbmZsYXRlQW1vdW50LCBvdXRlcikpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGwoJ2V2ZW5vZGQnKTtcbiAgICB9XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIGluZmxhdGVBbW91bnQpKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5maWxsKCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGluWFJhbmdlKG1vdXNlWCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbnVsbCwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgaW5ZUmFuZ2UobW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbnVsbCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHksIGJhc2UsIGhvcml6b250YWx9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ2hvcml6b250YWwnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyAoeCArIGJhc2UpIC8gMiA6IHgsXG4gICAgICB5OiBob3Jpem9udGFsID8geSA6ICh5ICsgYmFzZSkgLyAyXG4gICAgfTtcbiAgfVxuICBnZXRSYW5nZShheGlzKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd4JyA/IHRoaXMud2lkdGggLyAyIDogdGhpcy5oZWlnaHQgLyAyO1xuICB9XG59XG5CYXJFbGVtZW50LmlkID0gJ2Jhcic7XG5CYXJFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJTa2lwcGVkOiAnc3RhcnQnLFxuICBib3JkZXJXaWR0aDogMCxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBpbmZsYXRlQW1vdW50OiAnYXV0bycsXG4gIHBvaW50U3R5bGU6IHVuZGVmaW5lZFxufTtcbkJhckVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbn07XG5cbnZhciBlbGVtZW50cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkFyY0VsZW1lbnQ6IEFyY0VsZW1lbnQsXG5MaW5lRWxlbWVudDogTGluZUVsZW1lbnQsXG5Qb2ludEVsZW1lbnQ6IFBvaW50RWxlbWVudCxcbkJhckVsZW1lbnQ6IEJhckVsZW1lbnRcbn0pO1xuXG5mdW5jdGlvbiBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNhbXBsZXMgPSBvcHRpb25zLnNhbXBsZXMgfHwgYXZhaWxhYmxlV2lkdGg7XG4gIGlmIChzYW1wbGVzID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgY291bnQpO1xuICB9XG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuICBjb25zdCBidWNrZXRXaWR0aCA9IChjb3VudCAtIDIpIC8gKHNhbXBsZXMgLSAyKTtcbiAgbGV0IHNhbXBsZWRJbmRleCA9IDA7XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG4gIGxldCBhID0gc3RhcnQ7XG4gIGxldCBpLCBtYXhBcmVhUG9pbnQsIG1heEFyZWEsIGFyZWEsIG5leHRBO1xuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVthXTtcbiAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMgLSAyOyBpKyspIHtcbiAgICBsZXQgYXZnWCA9IDA7XG4gICAgbGV0IGF2Z1kgPSAwO1xuICAgIGxldCBqO1xuICAgIGNvbnN0IGF2Z1JhbmdlU3RhcnQgPSBNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VFbmQgPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMikgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUxlbmd0aCA9IGF2Z1JhbmdlRW5kIC0gYXZnUmFuZ2VTdGFydDtcbiAgICBmb3IgKGogPSBhdmdSYW5nZVN0YXJ0OyBqIDwgYXZnUmFuZ2VFbmQ7IGorKykge1xuICAgICAgYXZnWCArPSBkYXRhW2pdLng7XG4gICAgICBhdmdZICs9IGRhdGFbal0ueTtcbiAgICB9XG4gICAgYXZnWCAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICBhdmdZIC89IGF2Z1JhbmdlTGVuZ3RoO1xuICAgIGNvbnN0IHJhbmdlT2ZmcyA9IE1hdGguZmxvb3IoaSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCByYW5nZVRvID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3Qge3g6IHBvaW50QXgsIHk6IHBvaW50QXl9ID0gZGF0YVthXTtcbiAgICBtYXhBcmVhID0gYXJlYSA9IC0xO1xuICAgIGZvciAoaiA9IHJhbmdlT2ZmczsgaiA8IHJhbmdlVG87IGorKykge1xuICAgICAgYXJlYSA9IDAuNSAqIE1hdGguYWJzKFxuICAgICAgICAocG9pbnRBeCAtIGF2Z1gpICogKGRhdGFbal0ueSAtIHBvaW50QXkpIC1cbiAgICAgICAgKHBvaW50QXggLSBkYXRhW2pdLngpICogKGF2Z1kgLSBwb2ludEF5KVxuICAgICAgKTtcbiAgICAgIGlmIChhcmVhID4gbWF4QXJlYSkge1xuICAgICAgICBtYXhBcmVhID0gYXJlYTtcbiAgICAgICAgbWF4QXJlYVBvaW50ID0gZGF0YVtqXTtcbiAgICAgICAgbmV4dEEgPSBqO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gbWF4QXJlYVBvaW50O1xuICAgIGEgPSBuZXh0QTtcbiAgfVxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVtlbmRJbmRleF07XG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5mdW5jdGlvbiBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpIHtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCB4LCB5LCBwcmV2WCwgbWluSW5kZXgsIG1heEluZGV4LCBzdGFydEluZGV4LCBtaW5ZLCBtYXhZO1xuICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcbiAgY29uc3QgeE1pbiA9IGRhdGFbc3RhcnRdLng7XG4gIGNvbnN0IHhNYXggPSBkYXRhW2VuZEluZGV4XS54O1xuICBjb25zdCBkeCA9IHhNYXggLSB4TWluO1xuICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgIHBvaW50ID0gZGF0YVtpXTtcbiAgICB4ID0gKHBvaW50LnggLSB4TWluKSAvIGR4ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG4gICAgaWYgKHRydW5jWCA9PT0gcHJldlgpIHtcbiAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgICAgbWluSW5kZXggPSBpO1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgICAgbWF4SW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgcG9pbnQueCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGFzdEluZGV4ID0gaSAtIDE7XG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobWluSW5kZXgpICYmICFpc051bGxPclVuZGVmKG1heEluZGV4KSkge1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDEgPSBNYXRoLm1pbihtaW5JbmRleCwgbWF4SW5kZXgpO1xuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDIgPSBNYXRoLm1heChtaW5JbmRleCwgbWF4SW5kZXgpO1xuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MSAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDFdLFxuICAgICAgICAgICAgeDogYXZnWCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MiAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDJdLFxuICAgICAgICAgICAgeDogYXZnWFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA+IDAgJiYgbGFzdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XG4gICAgICAgIGRlY2ltYXRlZC5wdXNoKGRhdGFbbGFzdEluZGV4XSk7XG4gICAgICB9XG4gICAgICBkZWNpbWF0ZWQucHVzaChwb2ludCk7XG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgICBtaW5JbmRleCA9IG1heEluZGV4ID0gc3RhcnRJbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCkge1xuICBpZiAoZGF0YXNldC5fZGVjaW1hdGVkKSB7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuX2RhdGE7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBkZWxldGUgZGF0YXNldC5fZGF0YTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7dmFsdWU6IGRhdGF9KTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KSB7XG4gIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCkgPT4ge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZChtZXRhLCBwb2ludHMpIHtcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudDtcbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtaW4pLmxvLCAwLCBwb2ludENvdW50IC0gMSk7XG4gIH1cbiAgaWYgKG1heERlZmluZWQpIHtcbiAgICBjb3VudCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtYXgpLmhpICsgMSwgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxudmFyIHBsdWdpbl9kZWNpbWF0aW9uID0ge1xuICBpZDogJ2RlY2ltYXRpb24nLFxuICBkZWZhdWx0czoge1xuICAgIGFsZ29yaXRobTogJ21pbi1tYXgnLFxuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICB9LFxuICBiZWZvcmVFbGVtZW50c1VwZGF0ZTogKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gY2hhcnQud2lkdGg7XG4gICAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtfZGF0YSwgaW5kZXhBeGlzfSA9IGRhdGFzZXQ7XG4gICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBfZGF0YSB8fCBkYXRhc2V0LmRhdGE7XG4gICAgICBpZiAocmVzb2x2ZShbaW5kZXhBeGlzLCBjaGFydC5vcHRpb25zLmluZGV4QXhpc10pID09PSAneScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGEudHlwZSAhPT0gJ2xpbmUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHhBeGlzID0gY2hhcnQuc2NhbGVzW21ldGEueEF4aXNJRF07XG4gICAgICBpZiAoeEF4aXMudHlwZSAhPT0gJ2xpbmVhcicgJiYgeEF4aXMudHlwZSAhPT0gJ3RpbWUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFydC5vcHRpb25zLnBhcnNpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHtzdGFydCwgY291bnR9ID0gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgZGF0YSk7XG4gICAgICBjb25zdCB0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCB8fCA0ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgICBpZiAoY291bnQgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYoX2RhdGEpKSB7XG4gICAgICAgIGRhdGFzZXQuX2RhdGEgPSBkYXRhO1xuICAgICAgICBkZWxldGUgZGF0YXNldC5kYXRhO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWNpbWF0ZWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsZXQgZGVjaW1hdGVkO1xuICAgICAgc3dpdGNoIChvcHRpb25zLmFsZ29yaXRobSkge1xuICAgICAgY2FzZSAnbHR0Yic6XG4gICAgICAgIGRlY2ltYXRlZCA9IGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pbi1tYXgnOlxuICAgICAgICBkZWNpbWF0ZWQgPSBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVjaW1hdGlvbiBhbGdvcml0aG0gJyR7b3B0aW9ucy5hbGdvcml0aG19J2ApO1xuICAgICAgfVxuICAgICAgZGF0YXNldC5fZGVjaW1hdGVkID0gZGVjaW1hdGVkO1xuICAgIH0pO1xuICB9LFxuICBkZXN0cm95KGNoYXJ0KSB7XG4gICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGluZGV4KSB7XG4gIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gIGNvbnN0IHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuICByZXR1cm4gdmlzaWJsZSA/IG1ldGEuZGF0YXNldCA6IG51bGw7XG59XG5mdW5jdGlvbiBwYXJzZUZpbGxPcHRpb24obGluZSkge1xuICBjb25zdCBvcHRpb25zID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gb3B0aW9ucy5maWxsO1xuICBsZXQgZmlsbCA9IHZhbHVlT3JEZWZhdWx0KGZpbGxPcHRpb24gJiYgZmlsbE9wdGlvbi50YXJnZXQsIGZpbGxPcHRpb24pO1xuICBpZiAoZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZmlsbCA9ICEhb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gIH1cbiAgaWYgKGZpbGwgPT09IGZhbHNlIHx8IGZpbGwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbGwgPT09IHRydWUpIHtcbiAgICByZXR1cm4gJ29yaWdpbic7XG4gIH1cbiAgcmV0dXJuIGZpbGw7XG59XG5mdW5jdGlvbiBkZWNvZGVGaWxsKGxpbmUsIGluZGV4LCBjb3VudCkge1xuICBjb25zdCBmaWxsID0gcGFyc2VGaWxsT3B0aW9uKGxpbmUpO1xuICBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICByZXR1cm4gaXNOYU4oZmlsbC52YWx1ZSkgPyBmYWxzZSA6IGZpbGw7XG4gIH1cbiAgbGV0IHRhcmdldCA9IHBhcnNlRmxvYXQoZmlsbCk7XG4gIGlmIChpc051bWJlckZpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG4gICAgaWYgKGZpbGxbMF0gPT09ICctJyB8fCBmaWxsWzBdID09PSAnKycpIHtcbiAgICAgIHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAodGFyZ2V0ID09PSBpbmRleCB8fCB0YXJnZXQgPCAwIHx8IHRhcmdldCA+PSBjb3VudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHJldHVybiBbJ29yaWdpbicsICdzdGFydCcsICdlbmQnLCAnc3RhY2snLCAnc2hhcGUnXS5pbmRleE9mKGZpbGwpID49IDAgJiYgZmlsbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlID0ge30sIGZpbGx9ID0gc291cmNlO1xuICBsZXQgdGFyZ2V0ID0gbnVsbDtcbiAgbGV0IGhvcml6b250YWw7XG4gIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG4gICAgdGFyZ2V0ID0gc2NhbGUuYm90dG9tO1xuICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG4gICAgdGFyZ2V0ID0gc2NhbGUudG9wO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgdGFyZ2V0ID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShmaWxsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUGl4ZWwpIHtcbiAgICB0YXJnZXQgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgfVxuICBpZiAoaXNOdW1iZXJGaW5pdGUodGFyZ2V0KSkge1xuICAgIGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/IHRhcmdldCA6IG51bGwsXG4gICAgICB5OiBob3Jpem9udGFsID8gbnVsbCA6IHRhcmdldFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5jbGFzcyBzaW1wbGVBcmMge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy54ID0gb3B0cy54O1xuICAgIHRoaXMueSA9IG9wdHMueTtcbiAgICB0aGlzLnJhZGl1cyA9IG9wdHMucmFkaXVzO1xuICB9XG4gIHBhdGhTZWdtZW50KGN0eCwgYm91bmRzLCBvcHRzKSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGJvdW5kcyA9IGJvdW5kcyB8fCB7c3RhcnQ6IDAsIGVuZDogVEFVfTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgYm91bmRzLmVuZCwgYm91bmRzLnN0YXJ0LCB0cnVlKTtcbiAgICByZXR1cm4gIW9wdHMuYm91bmRzO1xuICB9XG4gIGludGVycG9sYXRlKHBvaW50KSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGNvbnN0IGFuZ2xlID0gcG9pbnQuYW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlLCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3Qgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnM7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLmdldExhYmVscygpLmxlbmd0aDtcbiAgY29uc3QgdGFyZ2V0ID0gW107XG4gIGNvbnN0IHN0YXJ0ID0gb3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWF4IDogc2NhbGUubWluO1xuICBjb25zdCBlbmQgPSBvcHRpb25zLnJldmVyc2UgPyBzY2FsZS5taW4gOiBzY2FsZS5tYXg7XG4gIGxldCBpLCBjZW50ZXIsIHZhbHVlO1xuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHZhbHVlID0gc3RhcnQ7XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICB2YWx1ZSA9IGVuZDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHZhbHVlID0gZmlsbC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHNjYWxlLmdldEJhc2VWYWx1ZSgpO1xuICB9XG4gIGlmIChvcHRpb25zLmdyaWQuY2lyY3VsYXIpIHtcbiAgICBjZW50ZXIgPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoMCwgc3RhcnQpO1xuICAgIHJldHVybiBuZXcgc2ltcGxlQXJjKHtcbiAgICAgIHg6IGNlbnRlci54LFxuICAgICAgeTogY2VudGVyLnksXG4gICAgICByYWRpdXM6IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKVxuICAgIH0pO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHRhcmdldC5wdXNoKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB2YWx1ZSkpO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHNjYWxlID0gc291cmNlLnNjYWxlIHx8IHt9O1xuICBpZiAoc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSk7XG4gIH1cbiAgcmV0dXJuIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpO1xufVxuZnVuY3Rpb24gZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKSB7XG4gIGZvciAoO2VuZCA+IHN0YXJ0OyBlbmQtLSkge1xuICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2VuZF07XG4gICAgaWYgKCFpc05hTihwb2ludC54KSAmJiAhaXNOYU4ocG9pbnQueSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5kO1xufVxuZnVuY3Rpb24gcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGNvbnN0IHt4ID0gbnVsbCwgeSA9IG51bGx9ID0gYm91bmRhcnkgfHwge307XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGxpbmUuc2VnbWVudHMuZm9yRWFjaCgoe3N0YXJ0LCBlbmR9KSA9PiB7XG4gICAgZW5kID0gZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgbGluZVBvaW50cyk7XG4gICAgY29uc3QgZmlyc3QgPSBsaW5lUG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBsYXN0ID0gbGluZVBvaW50c1tlbmRdO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICBwb2ludHMucHVzaCh7eDogZmlyc3QueCwgeX0pO1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGxhc3QueCwgeX0pO1xuICAgIH0gZWxzZSBpZiAoeCAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3gsIHk6IGZpcnN0Lnl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBsYXN0Lnl9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcG9pbnRzO1xufVxuZnVuY3Rpb24gYnVpbGRTdGFja0xpbmUoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgaW5kZXgsIGxpbmV9ID0gc291cmNlO1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBzb3VyY2VQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgbGluZXNCZWxvdyA9IGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KTtcbiAgbGluZXNCZWxvdy5wdXNoKGNyZWF0ZUJvdW5kYXJ5TGluZSh7eDogbnVsbCwgeTogc2NhbGUuYm90dG9tfSwgbGluZSkpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGZvciAobGV0IGogPSBzZWdtZW50LnN0YXJ0OyBqIDw9IHNlZ21lbnQuZW5kOyBqKyspIHtcbiAgICAgIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnRzW2pdLCBsaW5lc0JlbG93KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBMaW5lRWxlbWVudCh7cG9pbnRzLCBvcHRpb25zOiB7fX0pO1xufVxuZnVuY3Rpb24gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpIHtcbiAgY29uc3QgYmVsb3cgPSBbXTtcbiAgY29uc3QgbWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygnbGluZScpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgIGlmIChtZXRhLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghbWV0YS5oaWRkZW4pIHtcbiAgICAgIGJlbG93LnVuc2hpZnQobWV0YS5kYXRhc2V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJlbG93O1xufVxuZnVuY3Rpb24gYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludCwgbGluZXNCZWxvdykge1xuICBjb25zdCBwb3N0cG9uZWQgPSBbXTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lc0JlbG93Lmxlbmd0aDsgaisrKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzQmVsb3dbal07XG4gICAgY29uc3Qge2ZpcnN0LCBsYXN0LCBwb2ludH0gPSBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsICd4Jyk7XG4gICAgaWYgKCFwb2ludCB8fCAoZmlyc3QgJiYgbGFzdCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIHBvc3Rwb25lZC51bnNoaWZ0KHBvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwb2ludHMucHVzaCguLi5wb3N0cG9uZWQpO1xufVxuZnVuY3Rpb24gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBwb2ludCA9IGxpbmUuaW50ZXJwb2xhdGUoc291cmNlUG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKCFwb2ludCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCBwb2ludFZhbHVlID0gcG9pbnRbcHJvcGVydHldO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgbGV0IGZpcnN0ID0gZmFsc2U7XG4gIGxldCBsYXN0ID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgY29uc3QgZmlyc3RWYWx1ZSA9IGxpbmVQb2ludHNbc2VnbWVudC5zdGFydF1bcHJvcGVydHldO1xuICAgIGNvbnN0IGxhc3RWYWx1ZSA9IGxpbmVQb2ludHNbc2VnbWVudC5lbmRdW3Byb3BlcnR5XTtcbiAgICBpZiAoX2lzQmV0d2Vlbihwb2ludFZhbHVlLCBmaXJzdFZhbHVlLCBsYXN0VmFsdWUpKSB7XG4gICAgICBmaXJzdCA9IHBvaW50VmFsdWUgPT09IGZpcnN0VmFsdWU7XG4gICAgICBsYXN0ID0gcG9pbnRWYWx1ZSA9PT0gbGFzdFZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7Zmlyc3QsIGxhc3QsIHBvaW50fTtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldChzb3VyY2UpIHtcbiAgY29uc3Qge2NoYXJ0LCBmaWxsLCBsaW5lfSA9IHNvdXJjZTtcbiAgaWYgKGlzTnVtYmVyRmluaXRlKGZpbGwpKSB7XG4gICAgcmV0dXJuIGdldExpbmVCeUluZGV4KGNoYXJ0LCBmaWxsKTtcbiAgfVxuICBpZiAoZmlsbCA9PT0gJ3N0YWNrJykge1xuICAgIHJldHVybiBidWlsZFN0YWNrTGluZShzb3VyY2UpO1xuICB9XG4gIGlmIChmaWxsID09PSAnc2hhcGUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgYm91bmRhcnkgPSBjb21wdXRlQm91bmRhcnkoc291cmNlKTtcbiAgaWYgKGJvdW5kYXJ5IGluc3RhbmNlb2Ygc2ltcGxlQXJjKSB7XG4gICAgcmV0dXJuIGJvdW5kYXJ5O1xuICB9XG4gIHJldHVybiBjcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpO1xufVxuZnVuY3Rpb24gY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGxldCBwb2ludHMgPSBbXTtcbiAgbGV0IF9sb29wID0gZmFsc2U7XG4gIGlmIChpc0FycmF5KGJvdW5kYXJ5KSkge1xuICAgIF9sb29wID0gdHJ1ZTtcbiAgICBwb2ludHMgPSBib3VuZGFyeTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSBwb2ludHNGcm9tU2VnbWVudHMoYm91bmRhcnksIGxpbmUpO1xuICB9XG4gIHJldHVybiBwb2ludHMubGVuZ3RoID8gbmV3IExpbmVFbGVtZW50KHtcbiAgICBwb2ludHMsXG4gICAgb3B0aW9uczoge3RlbnNpb246IDB9LFxuICAgIF9sb29wLFxuICAgIF9mdWxsTG9vcDogX2xvb3BcbiAgfSkgOiBudWxsO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG4gIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICBsZXQgZmlsbCA9IHNvdXJjZS5maWxsO1xuICBjb25zdCB2aXNpdGVkID0gW2luZGV4XTtcbiAgbGV0IHRhcmdldDtcbiAgaWYgKCFwcm9wYWdhdGUpIHtcbiAgICByZXR1cm4gZmlsbDtcbiAgfVxuICB3aGlsZSAoZmlsbCAhPT0gZmFsc2UgJiYgdmlzaXRlZC5pbmRleE9mKGZpbGwpID09PSAtMSkge1xuICAgIGlmICghaXNOdW1iZXJGaW5pdGUoZmlsbCkpIHtcbiAgICAgIHJldHVybiBmaWxsO1xuICAgIH1cbiAgICB0YXJnZXQgPSBzb3VyY2VzW2ZpbGxdO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0YXJnZXQudmlzaWJsZSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuICAgIHZpc2l0ZWQucHVzaChmaWxsKTtcbiAgICBmaWxsID0gdGFyZ2V0LmZpbGw7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gX2NsaXAoY3R4LCB0YXJnZXQsIGNsaXBZKSB7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgdGFyZ2V0LnBhdGgoY3R4KTtcbiAgY3R4LmxpbmVUbyh0YXJnZXQubGFzdCgpLngsIGNsaXBZKTtcbiAgY3R4LmxpbmVUbyh0YXJnZXQuZmlyc3QoKS54LCBjbGlwWSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cbmZ1bmN0aW9uIGdldEJvdW5kcyhwcm9wZXJ0eSwgZmlyc3QsIGxhc3QsIGxvb3ApIHtcbiAgaWYgKGxvb3ApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHN0YXJ0ID0gZmlyc3RbcHJvcGVydHldO1xuICBsZXQgZW5kID0gbGFzdFtwcm9wZXJ0eV07XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ2FuZ2xlJykge1xuICAgIHN0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgICBlbmQgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgfVxuICByZXR1cm4ge3Byb3BlcnR5LCBzdGFydCwgZW5kfTtcbn1cbmZ1bmN0aW9uIF9nZXRFZGdlKGEsIGIsIHByb3AsIGZuKSB7XG4gIGlmIChhICYmIGIpIHtcbiAgICByZXR1cm4gZm4oYVtwcm9wXSwgYltwcm9wXSk7XG4gIH1cbiAgcmV0dXJuIGEgPyBhW3Byb3BdIDogYiA/IGJbcHJvcF0gOiAwO1xufVxuZnVuY3Rpb24gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgdHBvaW50cyA9IHRhcmdldC5wb2ludHM7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGxldCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGVuZCA9IGZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyk7XG4gICAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzKHByb3BlcnR5LCBwb2ludHNbc3RhcnRdLCBwb2ludHNbZW5kXSwgc2VnbWVudC5sb29wKTtcbiAgICBpZiAoIXRhcmdldC5zZWdtZW50cykge1xuICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgIHNvdXJjZTogc2VnbWVudCxcbiAgICAgICAgdGFyZ2V0OiBib3VuZHMsXG4gICAgICAgIHN0YXJ0OiBwb2ludHNbc3RhcnRdLFxuICAgICAgICBlbmQ6IHBvaW50c1tlbmRdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRTZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRhcmdldCwgYm91bmRzKTtcbiAgICBmb3IgKGNvbnN0IHRndCBvZiB0YXJnZXRTZWdtZW50cykge1xuICAgICAgY29uc3Qgc3ViQm91bmRzID0gZ2V0Qm91bmRzKHByb3BlcnR5LCB0cG9pbnRzW3RndC5zdGFydF0sIHRwb2ludHNbdGd0LmVuZF0sIHRndC5sb29wKTtcbiAgICAgIGNvbnN0IGZpbGxTb3VyY2VzID0gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIHN1YkJvdW5kcyk7XG4gICAgICBmb3IgKGNvbnN0IGZpbGxTb3VyY2Ugb2YgZmlsbFNvdXJjZXMpIHtcbiAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgc291cmNlOiBmaWxsU291cmNlLFxuICAgICAgICAgIHRhcmdldDogdGd0LFxuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ3N0YXJ0JywgTWF0aC5tYXgpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnZW5kJywgTWF0aC5taW4pXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxuZnVuY3Rpb24gY2xpcEJvdW5kcyhjdHgsIHNjYWxlLCBib3VuZHMpIHtcbiAgY29uc3Qge3RvcCwgYm90dG9tfSA9IHNjYWxlLmNoYXJ0LmNoYXJ0QXJlYTtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydCwgZW5kfSA9IGJvdW5kcyB8fCB7fTtcbiAgaWYgKHByb3BlcnR5ID09PSAneCcpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LnJlY3Qoc3RhcnQsIHRvcCwgZW5kIC0gc3RhcnQsIGJvdHRvbSAtIHRvcCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgfVxufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBwb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgaW50ZXJwb2xhdGVkUG9pbnQgPSB0YXJnZXQuaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKGludGVycG9sYXRlZFBvaW50KSB7XG4gICAgY3R4LmxpbmVUbyhpbnRlcnBvbGF0ZWRQb2ludC54LCBpbnRlcnBvbGF0ZWRQb2ludC55KTtcbiAgfVxufVxuZnVuY3Rpb24gX2ZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgcHJvcGVydHksIGNvbG9yLCBzY2FsZX0gPSBjZmc7XG4gIGNvbnN0IHNlZ21lbnRzID0gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpO1xuICBmb3IgKGNvbnN0IHtzb3VyY2U6IHNyYywgdGFyZ2V0OiB0Z3QsIHN0YXJ0LCBlbmR9IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3Qge3N0eWxlOiB7YmFja2dyb3VuZENvbG9yID0gY29sb3J9ID0ge319ID0gc3JjO1xuICAgIGNvbnN0IG5vdFNoYXBlID0gdGFyZ2V0ICE9PSB0cnVlO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIG5vdFNoYXBlICYmIGdldEJvdW5kcyhwcm9wZXJ0eSwgc3RhcnQsIGVuZCkpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjb25zdCBsaW5lTG9vcCA9ICEhbGluZS5wYXRoU2VnbWVudChjdHgsIHNyYyk7XG4gICAgbGV0IGxvb3A7XG4gICAgaWYgKG5vdFNoYXBlKSB7XG4gICAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBlbmQsIHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldExvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHRndCwge21vdmU6IGxpbmVMb29wLCByZXZlcnNlOiB0cnVlfSk7XG4gICAgICBsb29wID0gbGluZUxvb3AgJiYgdGFyZ2V0TG9vcDtcbiAgICAgIGlmICghbG9vcCkge1xuICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHN0YXJ0LCBwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbChsb29wID8gJ2V2ZW5vZGQnIDogJ25vbnplcm8nKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG5mdW5jdGlvbiBkb0ZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZX0gPSBjZmc7XG4gIGNvbnN0IHByb3BlcnR5ID0gbGluZS5fbG9vcCA/ICdhbmdsZScgOiBjZmcuYXhpcztcbiAgY3R4LnNhdmUoKTtcbiAgaWYgKHByb3BlcnR5ID09PSAneCcgJiYgYmVsb3cgIT09IGFib3ZlKSB7XG4gICAgX2NsaXAoY3R4LCB0YXJnZXQsIGFyZWEudG9wKTtcbiAgICBfZmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGNvbG9yOiBhYm92ZSwgc2NhbGUsIHByb3BlcnR5fSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIF9jbGlwKGN0eCwgdGFyZ2V0LCBhcmVhLmJvdHRvbSk7XG4gIH1cbiAgX2ZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYmVsb3csIHNjYWxlLCBwcm9wZXJ0eX0pO1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gZHJhd2ZpbGwoY3R4LCBzb3VyY2UsIGFyZWEpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KHNvdXJjZSk7XG4gIGNvbnN0IHtsaW5lLCBzY2FsZSwgYXhpc30gPSBzb3VyY2U7XG4gIGNvbnN0IGxpbmVPcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gbGluZU9wdHMuZmlsbDtcbiAgY29uc3QgY29sb3IgPSBsaW5lT3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gIGNvbnN0IHthYm92ZSA9IGNvbG9yLCBiZWxvdyA9IGNvbG9yfSA9IGZpbGxPcHRpb24gfHwge307XG4gIGlmICh0YXJnZXQgJiYgbGluZS5wb2ludHMubGVuZ3RoKSB7XG4gICAgY2xpcEFyZWEoY3R4LCBhcmVhKTtcbiAgICBkb0ZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBhYm92ZSwgYmVsb3csIGFyZWEsIHNjYWxlLCBheGlzfSk7XG4gICAgdW5jbGlwQXJlYShjdHgpO1xuICB9XG59XG52YXIgcGx1Z2luX2ZpbGxlciA9IHtcbiAgaWQ6ICdmaWxsZXInLFxuICBhZnRlckRhdGFzZXRzVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvdW50ID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDtcbiAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgbGV0IG1ldGEsIGksIGxpbmUsIHNvdXJjZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICAgIHNvdXJjZSA9IG51bGw7XG4gICAgICBpZiAobGluZSAmJiBsaW5lLm9wdGlvbnMgJiYgbGluZSBpbnN0YW5jZW9mIExpbmVFbGVtZW50KSB7XG4gICAgICAgIHNvdXJjZSA9IHtcbiAgICAgICAgICB2aXNpYmxlOiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIGZpbGw6IGRlY29kZUZpbGwobGluZSwgaSwgY291bnQpLFxuICAgICAgICAgIGNoYXJ0LFxuICAgICAgICAgIGF4aXM6IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmluZGV4QXhpcyxcbiAgICAgICAgICBzY2FsZTogbWV0YS52U2NhbGUsXG4gICAgICAgICAgbGluZSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIG1ldGEuJGZpbGxlciA9IHNvdXJjZTtcbiAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgc291cmNlID0gc291cmNlc1tpXTtcbiAgICAgIGlmICghc291cmNlIHx8IHNvdXJjZS5maWxsID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZS5maWxsID0gcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpLCBvcHRpb25zLnByb3BhZ2F0ZSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGRyYXcgPSBvcHRpb25zLmRyYXdUaW1lID09PSAnYmVmb3JlRHJhdyc7XG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZS5saW5lLnVwZGF0ZUNvbnRyb2xQb2ludHMoYXJlYSwgc291cmNlLmF4aXMpO1xuICAgICAgaWYgKGRyYXcpIHtcbiAgICAgICAgZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGF0YXNldHNEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldHNEcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGRyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGF0YXNldERyYXcoY2hhcnQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBhcmdzLm1ldGEuJGZpbGxlcjtcbiAgICBpZiAoIXNvdXJjZSB8fCBzb3VyY2UuZmlsbCA9PT0gZmFsc2UgfHwgb3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXREcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBwcm9wYWdhdGU6IHRydWUsXG4gICAgZHJhd1RpbWU6ICdiZWZvcmVEYXRhc2V0RHJhdydcbiAgfVxufTtcblxuY29uc3QgZ2V0Qm94U2l6ZSA9IChsYWJlbE9wdHMsIGZvbnRTaXplKSA9PiB7XG4gIGxldCB7Ym94SGVpZ2h0ID0gZm9udFNpemUsIGJveFdpZHRoID0gZm9udFNpemV9ID0gbGFiZWxPcHRzO1xuICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICBib3hIZWlnaHQgPSBNYXRoLm1pbihib3hIZWlnaHQsIGZvbnRTaXplKTtcbiAgICBib3hXaWR0aCA9IE1hdGgubWluKGJveFdpZHRoLCBmb250U2l6ZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBib3hXaWR0aCxcbiAgICBib3hIZWlnaHQsXG4gICAgaXRlbUhlaWdodDogTWF0aC5tYXgoZm9udFNpemUsIGJveEhlaWdodClcbiAgfTtcbn07XG5jb25zdCBpdGVtc0VxdWFsID0gKGEsIGIpID0+IGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLmRhdGFzZXRJbmRleCA9PT0gYi5kYXRhc2V0SW5kZXggJiYgYS5pbmRleCA9PT0gYi5pbmRleDtcbmNsYXNzIExlZ2VuZCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2FkZGVkID0gZmFsc2U7XG4gICAgdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gbnVsbDtcbiAgICB0aGlzLmRvdWdobnV0TW9kZSA9IGZhbHNlO1xuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMubGVnZW5kSXRlbXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2x1bW5TaXplcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxpbmVXaWR0aHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21hcmdpbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zO1xuICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuYnVpbGRMYWJlbHMoKTtcbiAgICB0aGlzLmZpdCgpO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5fbWFyZ2lucy5sZWZ0O1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IHRoaXMuX21hcmdpbnMudG9wO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG4gIH1cbiAgYnVpbGRMYWJlbHMoKSB7XG4gICAgY29uc3QgbGFiZWxPcHRzID0gdGhpcy5vcHRpb25zLmxhYmVscyB8fCB7fTtcbiAgICBsZXQgbGVnZW5kSXRlbXMgPSBjYWxsYmFjayhsYWJlbE9wdHMuZ2VuZXJhdGVMYWJlbHMsIFt0aGlzLmNoYXJ0XSwgdGhpcykgfHwgW107XG4gICAgaWYgKGxhYmVsT3B0cy5maWx0ZXIpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuZmlsdGVyKChpdGVtKSA9PiBsYWJlbE9wdHMuZmlsdGVyKGl0ZW0sIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGFiZWxPcHRzLnNvcnQpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuc29ydCgoYSwgYikgPT4gbGFiZWxPcHRzLnNvcnQoYSwgYiwgdGhpcy5jaGFydC5kYXRhKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgbGVnZW5kSXRlbXMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XG4gIH1cbiAgZml0KCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjdHh9ID0gdGhpcztcbiAgICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxPcHRzID0gb3B0aW9ucy5sYWJlbHM7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2JveFdpZHRoLCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB3aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICBoZWlnaHQgPSB0aGlzLl9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgd2lkdGggPSB0aGlzLl9maXRDb2xzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfVxuICAgIHRoaXMud2lkdGggPSBNYXRoLm1pbih3aWR0aCwgb3B0aW9ucy5tYXhXaWR0aCB8fCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWluKGhlaWdodCwgb3B0aW9ucy5tYXhIZWlnaHQgfHwgdGhpcy5tYXhIZWlnaHQpO1xuICB9XG4gIF9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhXaWR0aCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGxpbmVXaWR0aHMgPSB0aGlzLmxpbmVXaWR0aHMgPSBbMF07XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIGxldCB0b3RhbEhlaWdodCA9IHRpdGxlSGVpZ2h0O1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGxldCByb3cgPSAtMTtcbiAgICBsZXQgdG9wID0gLWxpbmVIZWlnaHQ7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBpZiAoaSA9PT0gMCB8fCBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKyBpdGVtV2lkdGggKyAyICogcGFkZGluZyA+IG1heFdpZHRoKSB7XG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAoaSA+IDAgPyAwIDogMSldID0gMDtcbiAgICAgICAgdG9wICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdDogMCwgdG9wLCByb3csIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG4gICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKz0gaXRlbVdpZHRoICsgcGFkZGluZztcbiAgICB9KTtcbiAgICByZXR1cm4gdG90YWxIZWlnaHQ7XG4gIH1cbiAgX2ZpdENvbHModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkge1xuICAgIGNvbnN0IHtjdHgsIG1heEhlaWdodCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIGNvbnN0IGNvbHVtblNpemVzID0gdGhpcy5jb2x1bW5TaXplcyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodExpbWl0ID0gbWF4SGVpZ2h0IC0gdGl0bGVIZWlnaHQ7XG4gICAgbGV0IHRvdGFsV2lkdGggPSBwYWRkaW5nO1xuICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSAwO1xuICAgIGxldCBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcbiAgICBsZXQgbGVmdCA9IDA7XG4gICAgbGV0IGNvbCA9IDA7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjb25zdCBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBpZiAoaSA+IDAgJiYgY3VycmVudENvbEhlaWdodCArIGl0ZW1IZWlnaHQgKyAyICogcGFkZGluZyA+IGhlaWdodExpbWl0KSB7XG4gICAgICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7XG4gICAgICAgIGxlZnQgKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sKys7XG4gICAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuICAgICAgfVxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdCwgdG9wOiBjdXJyZW50Q29sSGVpZ2h0LCBjb2wsIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG4gICAgICBjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XG4gICAgICBjdXJyZW50Q29sSGVpZ2h0ICs9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIH0pO1xuICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xuICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pO1xuICAgIHJldHVybiB0b3RhbFdpZHRoO1xuICB9XG4gIGFkanVzdEhpdEJveGVzKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7bGVnZW5kSGl0Qm94ZXM6IGhpdGJveGVzLCBvcHRpb25zOiB7YWxpZ24sIGxhYmVsczoge3BhZGRpbmd9LCBydGx9fSA9IHRoaXM7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGxldCByb3cgPSAwO1xuICAgICAgbGV0IGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgIGZvciAoY29uc3QgaGl0Ym94IG9mIGhpdGJveGVzKSB7XG4gICAgICAgIGlmIChyb3cgIT09IGhpdGJveC5yb3cpIHtcbiAgICAgICAgICByb3cgPSBoaXRib3gucm93O1xuICAgICAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgICAgfVxuICAgICAgICBoaXRib3gudG9wICs9IHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICBsZWZ0ICs9IGhpdGJveC53aWR0aCArIHBhZGRpbmc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjb2wgPSAwO1xuICAgICAgbGV0IHRvcCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2NvbF0uaGVpZ2h0KTtcbiAgICAgIGZvciAoY29uc3QgaGl0Ym94IG9mIGhpdGJveGVzKSB7XG4gICAgICAgIGlmIChoaXRib3guY29sICE9PSBjb2wpIHtcbiAgICAgICAgICBjb2wgPSBoaXRib3guY29sO1xuICAgICAgICAgIHRvcCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2NvbF0uaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBoaXRib3gudG9wID0gdG9wO1xuICAgICAgICBoaXRib3gubGVmdCArPSB0aGlzLmxlZnQgKyBwYWRkaW5nO1xuICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGhpdGJveC5sZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgdG9wICs9IGhpdGJveC5oZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc0hvcml6b250YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgfVxuICBkcmF3KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjbGlwQXJlYShjdHgsIHRoaXMpO1xuICAgICAgdGhpcy5fZHJhdygpO1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuICBfZHJhdygpIHtcbiAgICBjb25zdCB7b3B0aW9uczogb3B0cywgY29sdW1uU2l6ZXMsIGxpbmVXaWR0aHMsIGN0eH0gPSB0aGlzO1xuICAgIGNvbnN0IHthbGlnbiwgbGFiZWxzOiBsYWJlbE9wdHN9ID0gb3B0cztcbiAgICBjb25zdCBkZWZhdWx0Q29sb3IgPSBkZWZhdWx0cy5jb2xvcjtcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdHMucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XG4gICAgY29uc3Qge2NvbG9yOiBmb250Q29sb3IsIHBhZGRpbmd9ID0gbGFiZWxPcHRzO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gZm9udFNpemUgLyAyO1xuICAgIGxldCBjdXJzb3I7XG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbignbGVmdCcpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHgubGluZVdpZHRoID0gMC41O1xuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcbiAgICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodCwgaXRlbUhlaWdodH0gPSBnZXRCb3hTaXplKGxhYmVsT3B0cywgZm9udFNpemUpO1xuICAgIGNvbnN0IGRyYXdMZWdlbmRCb3ggPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICBpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDAgfHwgaXNOYU4oYm94SGVpZ2h0KSB8fCBib3hIZWlnaHQgPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVXaWR0aCwgMSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5maWxsU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUNhcCwgJ2J1dHQnKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIDApO1xuICAgICAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lSm9pbiwgJ21pdGVyJyk7XG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZGVmYXVsdENvbG9yKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoLCBbXSkpO1xuICAgICAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgICAgIGNvbnN0IGRyYXdPcHRpb25zID0ge1xuICAgICAgICAgIHJhZGl1czogYm94V2lkdGggKiBNYXRoLlNRUlQyIC8gMixcbiAgICAgICAgICBwb2ludFN0eWxlOiBsZWdlbmRJdGVtLnBvaW50U3R5bGUsXG4gICAgICAgICAgcm90YXRpb246IGxlZ2VuZEl0ZW0ucm90YXRpb24sXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IGxpbmVXaWR0aFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLnhQbHVzKHgsIGJveFdpZHRoIC8gMik7XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSB5ICsgaGFsZkZvbnRTaXplO1xuICAgICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB5Qm94VG9wID0geSArIE1hdGgubWF4KChmb250U2l6ZSAtIGJveEhlaWdodCkgLyAyLCAwKTtcbiAgICAgICAgY29uc3QgeEJveExlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cih4LCBib3hXaWR0aCk7XG4gICAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGVnZW5kSXRlbS5ib3JkZXJSYWRpdXMpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgICAgeDogeEJveExlZnQsXG4gICAgICAgICAgICB5OiB5Qm94VG9wLFxuICAgICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgucmVjdCh4Qm94TGVmdCwgeUJveFRvcCwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCAhPT0gMCkge1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxlZ2VuZEl0ZW0udGV4dCwgeCwgeSArIChpdGVtSGVpZ2h0IC8gMiksIGxhYmVsRm9udCwge1xuICAgICAgICBzdHJpa2V0aHJvdWdoOiBsZWdlbmRJdGVtLmhpZGRlbixcbiAgICAgICAgdGV4dEFsaWduOiBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduKVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbMF0pLFxuICAgICAgICB5OiB0aGlzLnRvcCArIHBhZGRpbmcgKyB0aXRsZUhlaWdodCxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiB0aGlzLmxlZnQgKyBwYWRkaW5nLFxuICAgICAgICB5OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbMF0uaGVpZ2h0KSxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9XG4gICAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yIHx8IGZvbnRDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvciB8fCBmb250Q29sb3I7XG4gICAgICBjb25zdCB0ZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24gfHwgKGxlZ2VuZEl0ZW0udGV4dEFsaWduID0gbGFiZWxPcHRzLnRleHRBbGlnbikpO1xuICAgICAgY29uc3Qgd2lkdGggPSBib3hXaWR0aCArIGhhbGZGb250U2l6ZSArIHRleHRXaWR0aDtcbiAgICAgIGxldCB4ID0gY3Vyc29yLng7XG4gICAgICBsZXQgeSA9IGN1cnNvci55O1xuICAgICAgcnRsSGVscGVyLnNldFdpZHRoKHRoaXMud2lkdGgpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaSA+IDAgJiYgeCArIHdpZHRoICsgcGFkZGluZyA+IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICB5ID0gY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICAgIHggPSBjdXJzb3IueCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1tjdXJzb3IubGluZV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGkgPiAwICYmIHkgKyBsaW5lSGVpZ2h0ID4gdGhpcy5ib3R0b20pIHtcbiAgICAgICAgeCA9IGN1cnNvci54ID0geCArIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS53aWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgIHkgPSBjdXJzb3IueSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0uaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlYWxYID0gcnRsSGVscGVyLngoeCk7XG4gICAgICBkcmF3TGVnZW5kQm94KHJlYWxYLCB5LCBsZWdlbmRJdGVtKTtcbiAgICAgIHggPSBfdGV4dFgodGV4dEFsaWduLCB4ICsgYm94V2lkdGggKyBoYWxmRm9udFNpemUsIGlzSG9yaXpvbnRhbCA/IHggKyB3aWR0aCA6IHRoaXMucmlnaHQsIG9wdHMucnRsKTtcbiAgICAgIGZpbGxUZXh0KHJ0bEhlbHBlci54KHgpLCB5LCBsZWdlbmRJdGVtKTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgY3Vyc29yLnggKz0gd2lkdGggKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN0b3JlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcbiAgfVxuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aXRsZU9wdHMgPSBvcHRzLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcbiAgICBpZiAoIXRpdGxlT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aXRsZU9wdHMucG9zaXRpb247XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gdGl0bGVGb250LnNpemUgLyAyO1xuICAgIGNvbnN0IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplID0gdGl0bGVQYWRkaW5nLnRvcCArIGhhbGZGb250U2l6ZTtcbiAgICBsZXQgeTtcbiAgICBsZXQgbGVmdCA9IHRoaXMubGVmdDtcbiAgICBsZXQgbWF4V2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KC4uLnRoaXMubGluZVdpZHRocyk7XG4gICAgICB5ID0gdGhpcy50b3AgKyB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZTtcbiAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCBsZWZ0LCB0aGlzLnJpZ2h0IC0gbWF4V2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXhIZWlnaHQgPSB0aGlzLmNvbHVtblNpemVzLnJlZHVjZSgoYWNjLCBzaXplKSA9PiBNYXRoLm1heChhY2MsIHNpemUuaGVpZ2h0KSwgMCk7XG4gICAgICB5ID0gdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgKyBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCB0aGlzLnRvcCwgdGhpcy5ib3R0b20gLSBtYXhIZWlnaHQgLSBvcHRzLmxhYmVscy5wYWRkaW5nIC0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCkpO1xuICAgIH1cbiAgICBjb25zdCB4ID0gX2FsaWduU3RhcnRFbmQocG9zaXRpb24sIGxlZnQsIGxlZnQgKyBtYXhXaWR0aCk7XG4gICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oX3RvTGVmdFJpZ2h0Q2VudGVyKHBvc2l0aW9uKSk7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZmlsbFN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGVPcHRzLnRleHQsIHgsIHksIHRpdGxlRm9udCk7XG4gIH1cbiAgX2NvbXB1dGVUaXRsZUhlaWdodCgpIHtcbiAgICBjb25zdCB0aXRsZU9wdHMgPSB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuICAgIHJldHVybiB0aXRsZU9wdHMuZGlzcGxheSA/IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVQYWRkaW5nLmhlaWdodCA6IDA7XG4gIH1cbiAgX2dldExlZ2VuZEl0ZW1BdCh4LCB5KSB7XG4gICAgbGV0IGksIGhpdEJveCwgbGg7XG4gICAgaWYgKF9pc0JldHdlZW4oeCwgdGhpcy5sZWZ0LCB0aGlzLnJpZ2h0KVxuICAgICAgJiYgX2lzQmV0d2Vlbih5LCB0aGlzLnRvcCwgdGhpcy5ib3R0b20pKSB7XG4gICAgICBsaCA9IHRoaXMubGVnZW5kSGl0Qm94ZXM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaGl0Qm94ID0gbGhbaV07XG4gICAgICAgIGlmIChfaXNCZXR3ZWVuKHgsIGhpdEJveC5sZWZ0LCBoaXRCb3gubGVmdCArIGhpdEJveC53aWR0aClcbiAgICAgICAgICAmJiBfaXNCZXR3ZWVuKHksIGhpdEJveC50b3AsIGhpdEJveC50b3AgKyBoaXRCb3guaGVpZ2h0KSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxlZ2VuZEl0ZW1zW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghaXNMaXN0ZW5lZChlLnR5cGUsIG9wdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gdGhpcy5fZ2V0TGVnZW5kSXRlbUF0KGUueCwgZS55KTtcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLl9ob3ZlcmVkSXRlbTtcbiAgICAgIGNvbnN0IHNhbWVJdGVtID0gaXRlbXNFcXVhbChwcmV2aW91cywgaG92ZXJlZEl0ZW0pO1xuICAgICAgaWYgKHByZXZpb3VzICYmICFzYW1lSXRlbSkge1xuICAgICAgICBjYWxsYmFjayhvcHRzLm9uTGVhdmUsIFtlLCBwcmV2aW91cywgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5faG92ZXJlZEl0ZW0gPSBob3ZlcmVkSXRlbTtcbiAgICAgIGlmIChob3ZlcmVkSXRlbSAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbGJhY2sob3B0cy5vbkhvdmVyLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtKSB7XG4gICAgICBjYWxsYmFjayhvcHRzLm9uQ2xpY2ssIFtlLCBob3ZlcmVkSXRlbSwgdGhpc10sIHRoaXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNMaXN0ZW5lZCh0eXBlLCBvcHRzKSB7XG4gIGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJyAmJiAob3B0cy5vbkhvdmVyIHx8IG9wdHMub25MZWF2ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAob3B0cy5vbkNsaWNrICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdtb3VzZXVwJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgcGx1Z2luX2xlZ2VuZCA9IHtcbiAgaWQ6ICdsZWdlbmQnLFxuICBfZWxlbWVudDogTGVnZW5kLFxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQgPSBuZXcgTGVnZW5kKHtjdHg6IGNoYXJ0LmN0eCwgb3B0aW9ucywgY2hhcnR9KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBjaGFydC5sZWdlbmQpO1xuICAgIGRlbGV0ZSBjaGFydC5sZWdlbmQ7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGVnZW5kLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuICBhZnRlclVwZGF0ZShjaGFydCkge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsZWdlbmQuYnVpbGRMYWJlbHMoKTtcbiAgICBsZWdlbmQuYWRqdXN0SGl0Qm94ZXMoKTtcbiAgfSxcbiAgYWZ0ZXJFdmVudChjaGFydCwgYXJncykge1xuICAgIGlmICghYXJncy5yZXBsYXkpIHtcbiAgICAgIGNoYXJ0LmxlZ2VuZC5oYW5kbGVFdmVudChhcmdzLmV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHJldmVyc2U6IGZhbHNlLFxuICAgIHdlaWdodDogMTAwMCxcbiAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgY29uc3QgaW5kZXggPSBsZWdlbmRJdGVtLmRhdGFzZXRJbmRleDtcbiAgICAgIGNvbnN0IGNpID0gbGVnZW5kLmNoYXJ0O1xuICAgICAgaWYgKGNpLmlzRGF0YXNldFZpc2libGUoaW5kZXgpKSB7XG4gICAgICAgIGNpLmhpZGUoaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaS5zaG93KGluZGV4KTtcbiAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uSG92ZXI6IG51bGwsXG4gICAgb25MZWF2ZTogbnVsbCxcbiAgICBsYWJlbHM6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGJveFdpZHRoOiA0MCxcbiAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgY29uc3QgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuICAgICAgICBjb25zdCB7bGFiZWxzOiB7dXNlUG9pbnRTdHlsZSwgcG9pbnRTdHlsZSwgdGV4dEFsaWduLCBjb2xvcn19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgIHJldHVybiBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKCkubWFwKChtZXRhKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodXNlUG9pbnRTdHlsZSA/IDAgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdG9QYWRkaW5nKHN0eWxlLmJvcmRlcldpZHRoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogZGF0YXNldHNbbWV0YS5pbmRleF0ubGFiZWwsXG4gICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICBoaWRkZW46ICFtZXRhLnZpc2libGUsXG4gICAgICAgICAgICBsaW5lQ2FwOiBzdHlsZS5ib3JkZXJDYXBTdHlsZSxcbiAgICAgICAgICAgIGxpbmVEYXNoOiBzdHlsZS5ib3JkZXJEYXNoLFxuICAgICAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgICBsaW5lSm9pbjogc3R5bGUuYm9yZGVySm9pblN0eWxlLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAoYm9yZGVyV2lkdGgud2lkdGggKyBib3JkZXJXaWR0aC5oZWlnaHQpIC8gNCxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUgfHwgc3R5bGUucG9pbnRTdHlsZSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBzdHlsZS5yb3RhdGlvbixcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduIHx8IHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgICAgIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGl0bGU6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICAgICAgdGV4dDogJycsXG4gICAgfVxuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgICBsYWJlbHM6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIVsnZ2VuZXJhdGVMYWJlbHMnLCAnZmlsdGVyJywgJ3NvcnQnXS5pbmNsdWRlcyhuYW1lKSxcbiAgICB9XG4gIH0sXG59O1xuXG5jbGFzcyBUaXRsZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMuX3BhZGRpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIHRoaXMubGVmdCA9IDA7XG4gICAgdGhpcy50b3AgPSAwO1xuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSB0aGlzLnJpZ2h0ID0gdGhpcy5ib3R0b20gPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLndpZHRoID0gdGhpcy5yaWdodCA9IG1heFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5ib3R0b20gPSBtYXhIZWlnaHQ7XG4gICAgY29uc3QgbGluZUNvdW50ID0gaXNBcnJheShvcHRzLnRleHQpID8gb3B0cy50ZXh0Lmxlbmd0aCA6IDE7XG4gICAgdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzLnBhZGRpbmcpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbGluZUNvdW50ICogdG9Gb250KG9wdHMuZm9udCkubGluZUhlaWdodCArIHRoaXMuX3BhZGRpbmcuaGVpZ2h0O1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRleHRTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGV4dFNpemU7XG4gICAgfVxuICB9XG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgcmV0dXJuIHBvcyA9PT0gJ3RvcCcgfHwgcG9zID09PSAnYm90dG9tJztcbiAgfVxuICBfZHJhd0FyZ3Mob2Zmc2V0KSB7XG4gICAgY29uc3Qge3RvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IGFsaWduID0gb3B0aW9ucy5hbGlnbjtcbiAgICBsZXQgcm90YXRpb24gPSAwO1xuICAgIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG4gICAgICB0aXRsZVkgPSB0b3AgKyBvZmZzZXQ7XG4gICAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICB0aXRsZVggPSBsZWZ0ICsgb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogLTAuNTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpdGxlWCA9IHJpZ2h0IC0gb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdG9wLCBib3R0b20pO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogMC41O1xuICAgICAgfVxuICAgICAgbWF4V2lkdGggPSBib3R0b20gLSB0b3A7XG4gICAgfVxuICAgIHJldHVybiB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn07XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZvbnRPcHRzID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGZvbnRPcHRzLmxpbmVIZWlnaHQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gbGluZUhlaWdodCAvIDIgKyB0aGlzLl9wYWRkaW5nLnRvcDtcbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aGlzLl9kcmF3QXJncyhvZmZzZXQpO1xuICAgIHJlbmRlclRleHQoY3R4LCBvcHRzLnRleHQsIDAsIDAsIGZvbnRPcHRzLCB7XG4gICAgICBjb2xvcjogb3B0cy5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IF90b0xlZnRSaWdodENlbnRlcihvcHRzLmFsaWduKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVGl0bGUoY2hhcnQsIHRpdGxlT3B0cykge1xuICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgY3R4OiBjaGFydC5jdHgsXG4gICAgb3B0aW9uczogdGl0bGVPcHRzLFxuICAgIGNoYXJ0XG4gIH0pO1xuICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIHRpdGxlT3B0cyk7XG4gIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gIGNoYXJ0LnRpdGxlQmxvY2sgPSB0aXRsZTtcbn1cbnZhciBwbHVnaW5fdGl0bGUgPSB7XG4gIGlkOiAndGl0bGUnLFxuICBfZWxlbWVudDogVGl0bGUsXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNyZWF0ZVRpdGxlKGNoYXJ0LCBvcHRpb25zKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IHRpdGxlQmxvY2sgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCB0aXRsZUJsb2NrKTtcbiAgICBkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDEwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDIwMDBcbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuXG5jb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xudmFyIHBsdWdpbl9zdWJ0aXRsZSA9IHtcbiAgaWQ6ICdzdWJ0aXRsZScsXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICAgIGN0eDogY2hhcnQuY3R4LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNoYXJ0XG4gICAgfSk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICAgIG1hcC5zZXQoY2hhcnQsIHRpdGxlKTtcbiAgfSxcbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBtYXAuZ2V0KGNoYXJ0KSk7XG4gICAgbWFwLmRlbGV0ZShjaGFydCk7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG1hcC5nZXQoY2hhcnQpO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ25vcm1hbCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDE1MDBcbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuXG5jb25zdCBwb3NpdGlvbmVycyA9IHtcbiAgYXZlcmFnZShpdGVtcykge1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBpLCBsZW47XG4gICAgbGV0IHggPSAwO1xuICAgIGxldCB5ID0gMDtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBwb3MgPSBlbC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgICAgeCArPSBwb3MueDtcbiAgICAgICAgeSArPSBwb3MueTtcbiAgICAgICAgKytjb3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggLyBjb3VudCxcbiAgICAgIHk6IHkgLyBjb3VudFxuICAgIH07XG4gIH0sXG4gIG5lYXJlc3QoaXRlbXMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgeCA9IGV2ZW50UG9zaXRpb24ueDtcbiAgICBsZXQgeSA9IGV2ZW50UG9zaXRpb24ueTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IGksIGxlbiwgbmVhcmVzdEVsZW1lbnQ7XG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGVsLmdldENlbnRlclBvaW50KCk7XG4gICAgICAgIGNvbnN0IGQgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoZXZlbnRQb3NpdGlvbiwgY2VudGVyKTtcbiAgICAgICAgaWYgKGQgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZDtcbiAgICAgICAgICBuZWFyZXN0RWxlbWVudCA9IGVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZWFyZXN0RWxlbWVudCkge1xuICAgICAgY29uc3QgdHAgPSBuZWFyZXN0RWxlbWVudC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgIHggPSB0cC54O1xuICAgICAgeSA9IHRwLnk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG4gIGlmICh0b1B1c2gpIHtcbiAgICBpZiAoaXNBcnJheSh0b1B1c2gpKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlLnB1c2godG9QdXNoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2U7XG59XG5mdW5jdGlvbiBzcGxpdE5ld2xpbmVzKHN0cikge1xuICBpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcEl0ZW0oY2hhcnQsIGl0ZW0pIHtcbiAgY29uc3Qge2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9ID0gaXRlbTtcbiAgY29uc3QgY29udHJvbGxlciA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgY29uc3Qge2xhYmVsLCB2YWx1ZX0gPSBjb250cm9sbGVyLmdldExhYmVsQW5kVmFsdWUoaW5kZXgpO1xuICByZXR1cm4ge1xuICAgIGNoYXJ0LFxuICAgIGxhYmVsLFxuICAgIHBhcnNlZDogY29udHJvbGxlci5nZXRQYXJzZWQoaW5kZXgpLFxuICAgIHJhdzogY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdLFxuICAgIGZvcm1hdHRlZFZhbHVlOiB2YWx1ZSxcbiAgICBkYXRhc2V0OiBjb250cm9sbGVyLmdldERhdGFzZXQoKSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIGRhdGFzZXRJbmRleCxcbiAgICBlbGVtZW50XG4gIH07XG59XG5mdW5jdGlvbiBnZXRUb29sdGlwU2l6ZSh0b29sdGlwLCBvcHRpb25zKSB7XG4gIGNvbnN0IGN0eCA9IHRvb2x0aXAuY2hhcnQuY3R4O1xuICBjb25zdCB7Ym9keSwgZm9vdGVyLCB0aXRsZX0gPSB0b29sdGlwO1xuICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodH0gPSBvcHRpb25zO1xuICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgY29uc3QgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xuICBjb25zdCB0aXRsZUxpbmVDb3VudCA9IHRpdGxlLmxlbmd0aDtcbiAgY29uc3QgZm9vdGVyTGluZUNvdW50ID0gZm9vdGVyLmxlbmd0aDtcbiAgY29uc3QgYm9keUxpbmVJdGVtQ291bnQgPSBib2R5Lmxlbmd0aDtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBsZXQgaGVpZ2h0ID0gcGFkZGluZy5oZWlnaHQ7XG4gIGxldCB3aWR0aCA9IDA7XG4gIGxldCBjb21iaW5lZEJvZHlMZW5ndGggPSBib2R5LnJlZHVjZSgoY291bnQsIGJvZHlJdGVtKSA9PiBjb3VudCArIGJvZHlJdGVtLmJlZm9yZS5sZW5ndGggKyBib2R5SXRlbS5saW5lcy5sZW5ndGggKyBib2R5SXRlbS5hZnRlci5sZW5ndGgsIDApO1xuICBjb21iaW5lZEJvZHlMZW5ndGggKz0gdG9vbHRpcC5iZWZvcmVCb2R5Lmxlbmd0aCArIHRvb2x0aXAuYWZ0ZXJCb2R5Lmxlbmd0aDtcbiAgaWYgKHRpdGxlTGluZUNvdW50KSB7XG4gICAgaGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ICogdGl0bGVGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKHRpdGxlTGluZUNvdW50IC0gMSkgKiBvcHRpb25zLnRpdGxlU3BhY2luZ1xuXHRcdFx0KyBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tO1xuICB9XG4gIGlmIChjb21iaW5lZEJvZHlMZW5ndGgpIHtcbiAgICBjb25zdCBib2R5TGluZUhlaWdodCA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IE1hdGgubWF4KGJveEhlaWdodCwgYm9keUZvbnQubGluZUhlaWdodCkgOiBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGhlaWdodCArPSBib2R5TGluZUl0ZW1Db3VudCAqIGJvZHlMaW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSBib2R5TGluZUl0ZW1Db3VudCkgKiBib2R5Rm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSAxKSAqIG9wdGlvbnMuYm9keVNwYWNpbmc7XG4gIH1cbiAgaWYgKGZvb3RlckxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcFxuXHRcdFx0KyBmb290ZXJMaW5lQ291bnQgKiBmb290ZXJGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKGZvb3RlckxpbmVDb3VudCAtIDEpICogb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICB9XG4gIGxldCB3aWR0aFBhZGRpbmcgPSAwO1xuICBjb25zdCBtYXhMaW5lV2lkdGggPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoICsgd2lkdGhQYWRkaW5nKTtcbiAgfTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAudGl0bGUsIG1heExpbmVXaWR0aCk7XG4gIGN0eC5mb250ID0gYm9keUZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAuYmVmb3JlQm9keS5jb25jYXQodG9vbHRpcC5hZnRlckJvZHkpLCBtYXhMaW5lV2lkdGgpO1xuICB3aWR0aFBhZGRpbmcgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyAoYm94V2lkdGggKyAyICsgb3B0aW9ucy5ib3hQYWRkaW5nKSA6IDA7XG4gIGVhY2goYm9keSwgKGJvZHlJdGVtKSA9PiB7XG4gICAgZWFjaChib2R5SXRlbS5iZWZvcmUsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5saW5lcywgbWF4TGluZVdpZHRoKTtcbiAgICBlYWNoKGJvZHlJdGVtLmFmdGVyLCBtYXhMaW5lV2lkdGgpO1xuICB9KTtcbiAgd2lkdGhQYWRkaW5nID0gMDtcbiAgY3R4LmZvbnQgPSBmb290ZXJGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmZvb3RlciwgbWF4TGluZVdpZHRoKTtcbiAgY3R4LnJlc3RvcmUoKTtcbiAgd2lkdGggKz0gcGFkZGluZy53aWR0aDtcbiAgcmV0dXJuIHt3aWR0aCwgaGVpZ2h0fTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSkge1xuICBjb25zdCB7eSwgaGVpZ2h0fSA9IHNpemU7XG4gIGlmICh5IDwgaGVpZ2h0IC8gMikge1xuICAgIHJldHVybiAndG9wJztcbiAgfSBlbHNlIGlmICh5ID4gKGNoYXJ0LmhlaWdodCAtIGhlaWdodCAvIDIpKSB7XG4gICAgcmV0dXJuICdib3R0b20nO1xuICB9XG4gIHJldHVybiAnY2VudGVyJztcbn1cbmZ1bmN0aW9uIGRvZXNOb3RGaXRXaXRoQWxpZ24oeEFsaWduLCBjaGFydCwgb3B0aW9ucywgc2l6ZSkge1xuICBjb25zdCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgY29uc3QgY2FyZXQgPSBvcHRpb25zLmNhcmV0U2l6ZSArIG9wdGlvbnMuY2FyZXRQYWRkaW5nO1xuICBpZiAoeEFsaWduID09PSAnbGVmdCcgJiYgeCArIHdpZHRoICsgY2FyZXQgPiBjaGFydC53aWR0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcgJiYgeCAtIHdpZHRoIC0gY2FyZXQgPCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCB7d2lkdGg6IGNoYXJ0V2lkdGgsIGNoYXJ0QXJlYToge2xlZnQsIHJpZ2h0fX0gPSBjaGFydDtcbiAgbGV0IHhBbGlnbiA9ICdjZW50ZXInO1xuICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgIHhBbGlnbiA9IHggPD0gKGxlZnQgKyByaWdodCkgLyAyID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgfSBlbHNlIGlmICh4IDw9IHdpZHRoIC8gMikge1xuICAgIHhBbGlnbiA9ICdsZWZ0JztcbiAgfSBlbHNlIGlmICh4ID49IGNoYXJ0V2lkdGggLSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAncmlnaHQnO1xuICB9XG4gIGlmIChkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpKSB7XG4gICAgeEFsaWduID0gJ2NlbnRlcic7XG4gIH1cbiAgcmV0dXJuIHhBbGlnbjtcbn1cbmZ1bmN0aW9uIGRldGVybWluZUFsaWdubWVudChjaGFydCwgb3B0aW9ucywgc2l6ZSkge1xuICBjb25zdCB5QWxpZ24gPSBzaXplLnlBbGlnbiB8fCBvcHRpb25zLnlBbGlnbiB8fCBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpO1xuICByZXR1cm4ge1xuICAgIHhBbGlnbjogc2l6ZS54QWxpZ24gfHwgb3B0aW9ucy54QWxpZ24gfHwgZGV0ZXJtaW5lWEFsaWduKGNoYXJ0LCBvcHRpb25zLCBzaXplLCB5QWxpZ24pLFxuICAgIHlBbGlnblxuICB9O1xufVxuZnVuY3Rpb24gYWxpZ25YKHNpemUsIHhBbGlnbikge1xuICBsZXQge3gsIHdpZHRofSA9IHNpemU7XG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHdpZHRoO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3aWR0aCAvIDIpO1xuICB9XG4gIHJldHVybiB4O1xufVxuZnVuY3Rpb24gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpIHtcbiAgbGV0IHt5LCBoZWlnaHR9ID0gc2l6ZTtcbiAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICB5ICs9IHBhZGRpbmdBbmRTaXplO1xuICB9IGVsc2UgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICB5IC09IGhlaWdodCArIHBhZGRpbmdBbmRTaXplO1xuICB9IGVsc2Uge1xuICAgIHkgLT0gKGhlaWdodCAvIDIpO1xuICB9XG4gIHJldHVybiB5O1xufVxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHNpemUsIGFsaWdubWVudCwgY2hhcnQpIHtcbiAgY29uc3Qge2NhcmV0U2l6ZSwgY2FyZXRQYWRkaW5nLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IGFsaWdubWVudDtcbiAgY29uc3QgcGFkZGluZ0FuZFNpemUgPSBjYXJldFNpemUgKyBjYXJldFBhZGRpbmc7XG4gIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhjb3JuZXJSYWRpdXMpO1xuICBsZXQgeCA9IGFsaWduWChzaXplLCB4QWxpZ24pO1xuICBjb25zdCB5ID0gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpO1xuICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgeCArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgeCAtPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICB4IC09IE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgY2FyZXRTaXplO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggKz0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSArIGNhcmV0U2l6ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IF9saW1pdFZhbHVlKHgsIDAsIGNoYXJ0LndpZHRoIC0gc2l6ZS53aWR0aCksXG4gICAgeTogX2xpbWl0VmFsdWUoeSwgMCwgY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRBbGlnbmVkWCh0b29sdGlwLCBhbGlnbiwgb3B0aW9ucykge1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcidcbiAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLyAyXG4gICAgOiBhbGlnbiA9PT0gJ3JpZ2h0J1xuICAgICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC0gcGFkZGluZy5yaWdodFxuICAgICAgOiB0b29sdGlwLnggKyBwYWRkaW5nLmxlZnQ7XG59XG5mdW5jdGlvbiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhjYWxsYmFjaykge1xuICByZXR1cm4gcHVzaE9yQ29uY2F0KFtdLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwQ29udGV4dChwYXJlbnQsIHRvb2x0aXAsIHRvb2x0aXBJdGVtcykge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICB0b29sdGlwLFxuICAgIHRvb2x0aXBJdGVtcyxcbiAgICB0eXBlOiAndG9vbHRpcCdcbiAgfSk7XG59XG5mdW5jdGlvbiBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpIHtcbiAgY29uc3Qgb3ZlcnJpZGUgPSBjb250ZXh0ICYmIGNvbnRleHQuZGF0YXNldCAmJiBjb250ZXh0LmRhdGFzZXQudG9vbHRpcCAmJiBjb250ZXh0LmRhdGFzZXQudG9vbHRpcC5jYWxsYmFja3M7XG4gIHJldHVybiBvdmVycmlkZSA/IGNhbGxiYWNrcy5vdmVycmlkZShvdmVycmlkZSkgOiBjYWxsYmFja3M7XG59XG5jbGFzcyBUb29sdGlwIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcGFjaXR5ID0gMDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSBbXTtcbiAgICB0aGlzLiRhbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydCB8fCBjb25maWcuX2NoYXJ0O1xuICAgIHRoaXMuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aXRsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJlZm9yZUJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm9vdGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueEFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueUFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0aWFsaXplKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuICBfcmVzb2x2ZUFuaW1hdGlvbnMoKSB7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVkQW5pbWF0aW9ucztcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBvcHRzID0gb3B0aW9ucy5lbmFibGVkICYmIGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICYmIG9wdGlvbnMuYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnModGhpcy5jaGFydCwgb3B0cyk7XG4gICAgaWYgKG9wdHMuX2NhY2hlYWJsZSkge1xuICAgICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IE9iamVjdC5mcmVlemUoYW5pbWF0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHxcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlVG9vbHRpcENvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMsIHRoaXMuX3Rvb2x0aXBJdGVtcykpO1xuICB9XG4gIGdldFRpdGxlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYmVmb3JlVGl0bGUgPSBjYWxsYmFja3MuYmVmb3JlVGl0bGUuYXBwbHkodGhpcywgW2NvbnRleHRdKTtcbiAgICBjb25zdCB0aXRsZSA9IGNhbGxiYWNrcy50aXRsZS5hcHBseSh0aGlzLCBbY29udGV4dF0pO1xuICAgIGNvbnN0IGFmdGVyVGl0bGUgPSBjYWxsYmFja3MuYWZ0ZXJUaXRsZS5hcHBseSh0aGlzLCBbY29udGV4dF0pO1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG4gIGdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKG9wdGlvbnMuY2FsbGJhY2tzLmJlZm9yZUJvZHkuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pKTtcbiAgfVxuICBnZXRCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5SXRlbXMgPSBbXTtcbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGJvZHlJdGVtID0ge1xuICAgICAgICBiZWZvcmU6IFtdLFxuICAgICAgICBsaW5lczogW10sXG4gICAgICAgIGFmdGVyOiBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYmVmb3JlLCBzcGxpdE5ld2xpbmVzKHNjb3BlZC5iZWZvcmVMYWJlbC5jYWxsKHRoaXMsIGNvbnRleHQpKSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0ubGluZXMsIHNjb3BlZC5sYWJlbC5jYWxsKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5hZnRlciwgc3BsaXROZXdsaW5lcyhzY29wZWQuYWZ0ZXJMYWJlbC5jYWxsKHRoaXMsIGNvbnRleHQpKSk7XG4gICAgICBib2R5SXRlbXMucHVzaChib2R5SXRlbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvZHlJdGVtcztcbiAgfVxuICBnZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKG9wdGlvbnMuY2FsbGJhY2tzLmFmdGVyQm9keS5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSkpO1xuICB9XG4gIGdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYmVmb3JlRm9vdGVyID0gY2FsbGJhY2tzLmJlZm9yZUZvb3Rlci5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSk7XG4gICAgY29uc3QgZm9vdGVyID0gY2FsbGJhY2tzLmZvb3Rlci5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSk7XG4gICAgY29uc3QgYWZ0ZXJGb290ZXIgPSBjYWxsYmFja3MuYWZ0ZXJGb290ZXIuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pO1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZUZvb3RlcikpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGZvb3RlcikpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyRm9vdGVyKSk7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG4gIF9jcmVhdGVJdGVtcyhvcHRpb25zKSB7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgY29uc3QgbGFiZWxDb2xvcnMgPSBbXTtcbiAgICBjb25zdCBsYWJlbFBvaW50U3R5bGVzID0gW107XG4gICAgY29uc3QgbGFiZWxUZXh0Q29sb3JzID0gW107XG4gICAgbGV0IHRvb2x0aXBJdGVtcyA9IFtdO1xuICAgIGxldCBpLCBsZW47XG4gICAgZm9yIChpID0gMCwgbGVuID0gYWN0aXZlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0b29sdGlwSXRlbXMucHVzaChjcmVhdGVUb29sdGlwSXRlbSh0aGlzLmNoYXJ0LCBhY3RpdmVbaV0pKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuZmlsdGVyKChlbGVtZW50LCBpbmRleCwgYXJyYXkpID0+IG9wdGlvbnMuZmlsdGVyKGVsZW1lbnQsIGluZGV4LCBhcnJheSwgZGF0YSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pdGVtU29ydCkge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLnNvcnQoKGEsIGIpID0+IG9wdGlvbnMuaXRlbVNvcnQoYSwgYiwgZGF0YSkpO1xuICAgIH1cbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKG9wdGlvbnMuY2FsbGJhY2tzLCBjb250ZXh0KTtcbiAgICAgIGxhYmVsQ29sb3JzLnB1c2goc2NvcGVkLmxhYmVsQ29sb3IuY2FsbCh0aGlzLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFBvaW50U3R5bGVzLnB1c2goc2NvcGVkLmxhYmVsUG9pbnRTdHlsZS5jYWxsKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIGxhYmVsVGV4dENvbG9ycy5wdXNoKHNjb3BlZC5sYWJlbFRleHRDb2xvci5jYWxsKHRoaXMsIGNvbnRleHQpKTtcbiAgICB9KTtcbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gbGFiZWxDb2xvcnM7XG4gICAgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gbGFiZWxQb2ludFN0eWxlcztcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IGxhYmVsVGV4dENvbG9ycztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB0b29sdGlwSXRlbXM7XG4gICAgcmV0dXJuIHRvb2x0aXBJdGVtcztcbiAgfVxuICB1cGRhdGUoY2hhbmdlZCwgcmVwbGF5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgbGV0IHByb3BlcnRpZXM7XG4gICAgbGV0IHRvb2x0aXBJdGVtcyA9IFtdO1xuICAgIGlmICghYWN0aXZlLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMub3BhY2l0eSAhPT0gMCkge1xuICAgICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0aGlzLl9jcmVhdGVJdGVtcyhvcHRpb25zKTtcbiAgICAgIHRoaXMudGl0bGUgPSB0aGlzLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJlZm9yZUJvZHkgPSB0aGlzLmdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYm9keSA9IHRoaXMuZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5hZnRlckJvZHkgPSB0aGlzLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5mb290ZXIgPSB0aGlzLmdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCBzaXplKTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudCh0aGlzLmNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgYmFja2dyb3VuZFBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCB0aGlzLmNoYXJ0KTtcbiAgICAgIHRoaXMueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcbiAgICAgIHRoaXMueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcbiAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHg6IGJhY2tncm91bmRQb2ludC54LFxuICAgICAgICB5OiBiYWNrZ3JvdW5kUG9pbnQueSxcbiAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgICAgIGNhcmV0WDogcG9zaXRpb24ueCxcbiAgICAgICAgY2FyZXRZOiBwb3NpdGlvbi55XG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXM7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcHJvcGVydGllcyk7XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkICYmIG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgIG9wdGlvbnMuZXh0ZXJuYWwuY2FsbCh0aGlzLCB7Y2hhcnQ6IHRoaXMuY2hhcnQsIHRvb2x0aXA6IHRoaXMsIHJlcGxheX0pO1xuICAgIH1cbiAgfVxuICBkcmF3Q2FyZXQodG9vbHRpcFBvaW50LCBjdHgsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gdGhpcy5nZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucyk7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngxLCBjYXJldFBvc2l0aW9uLnkxKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDIsIGNhcmV0UG9zaXRpb24ueTIpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MywgY2FyZXRQb3NpdGlvbi55Myk7XG4gIH1cbiAgZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7Y2FyZXRTaXplLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcbiAgICBjb25zdCB7eDogcHRYLCB5OiBwdFl9ID0gdG9vbHRpcFBvaW50O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHNpemU7XG4gICAgbGV0IHgxLCB4MiwgeDMsIHkxLCB5MiwgeTM7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHkyID0gcHRZICsgKGhlaWdodCAvIDIpO1xuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHgxID0gcHRYO1xuICAgICAgICB4MiA9IHgxIC0gY2FyZXRTaXplO1xuICAgICAgICB5MSA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgICB5MyA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDEgPSBwdFggKyB3aWR0aDtcbiAgICAgICAgeDIgPSB4MSArIGNhcmV0U2l6ZTtcbiAgICAgICAgeTEgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgIH1cbiAgICAgIHgzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MiA9IHB0WCArIE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgKGNhcmV0U2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB4MiA9IHB0WCArIHdpZHRoIC0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0gdGhpcy5jYXJldFg7XG4gICAgICB9XG4gICAgICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgICAgICB5MSA9IHB0WTtcbiAgICAgICAgeTIgPSB5MSAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeDEgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkxID0gcHRZICsgaGVpZ2h0O1xuICAgICAgICB5MiA9IHkxICsgY2FyZXRTaXplO1xuICAgICAgICB4MSA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgICB4MyA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgfVxuICAgICAgeTMgPSB5MTtcbiAgICB9XG4gICAgcmV0dXJuIHt4MSwgeDIsIHgzLCB5MSwgeTIsIHkzfTtcbiAgfVxuICBkcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy50aXRsZTtcbiAgICBjb25zdCBsZW5ndGggPSB0aXRsZS5sZW5ndGg7XG4gICAgbGV0IHRpdGxlRm9udCwgdGl0bGVTcGFjaW5nLCBpO1xuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy50aXRsZUFsaWduLCBvcHRpb25zKTtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMudGl0bGVBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICAgICAgdGl0bGVTcGFjaW5nID0gb3B0aW9ucy50aXRsZVNwYWNpbmc7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy50aXRsZUNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0aXRsZVtpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyB0aXRsZUZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICBwdC55ICs9IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVTcGFjaW5nO1xuICAgICAgICBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIHB0LnkgKz0gb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbSAtIHRpdGxlU3BhY2luZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gdGhpcy5sYWJlbENvbG9yc1tpXTtcbiAgICBjb25zdCBsYWJlbFBvaW50U3R5bGUgPSB0aGlzLmxhYmVsUG9pbnRTdHlsZXNbaV07XG4gICAgY29uc3Qge2JveEhlaWdodCwgYm94V2lkdGgsIGJveFBhZGRpbmd9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICBjb25zdCBjb2xvclggPSBnZXRBbGlnbmVkWCh0aGlzLCAnbGVmdCcsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJ0bENvbG9yWCA9IHJ0bEhlbHBlci54KGNvbG9yWCk7XG4gICAgY29uc3QgeU9mZlNldCA9IGJveEhlaWdodCA8IGJvZHlGb250LmxpbmVIZWlnaHQgPyAoYm9keUZvbnQubGluZUhlaWdodCAtIGJveEhlaWdodCkgLyAyIDogMDtcbiAgICBjb25zdCBjb2xvclkgPSBwdC55ICsgeU9mZlNldDtcbiAgICBpZiAob3B0aW9ucy51c2VQb2ludFN0eWxlKSB7XG4gICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgcmFkaXVzOiBNYXRoLm1pbihib3hXaWR0aCwgYm94SGVpZ2h0KSAvIDIsXG4gICAgICAgIHBvaW50U3R5bGU6IGxhYmVsUG9pbnRTdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICByb3RhdGlvbjogbGFiZWxQb2ludFN0eWxlLnJvdGF0aW9uLFxuICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNlbnRlclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJveFdpZHRoKSArIGJveFdpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGNlbnRlclkgPSBjb2xvclkgKyBib3hIZWlnaHQgLyAyO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9ycy5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9ycy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBsYWJlbENvbG9ycy5ib3JkZXJXaWR0aCB8fCAxO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvcnMuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2gobGFiZWxDb2xvcnMuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBsYWJlbENvbG9ycy5ib3JkZXJEYXNoT2Zmc2V0IHx8IDA7XG4gICAgICBjb25zdCBvdXRlclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJveFdpZHRoIC0gYm94UGFkZGluZyk7XG4gICAgICBjb25zdCBpbm5lclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueFBsdXMocnRsQ29sb3JYLCAxKSwgYm94V2lkdGggLSBib3hQYWRkaW5nIC0gMik7XG4gICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxhYmVsQ29sb3JzLmJvcmRlclJhZGl1cyk7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IG91dGVyWCxcbiAgICAgICAgICB5OiBjb2xvclksXG4gICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICB4OiBpbm5lclgsXG4gICAgICAgICAgeTogY29sb3JZICsgMSxcbiAgICAgICAgICB3OiBib3hXaWR0aCAtIDIsXG4gICAgICAgICAgaDogYm94SGVpZ2h0IC0gMixcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICAgIGN0eC5maWxsUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIGN0eC5zdHJva2VSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KGlubmVyWCwgY29sb3JZICsgMSwgYm94V2lkdGggLSAyLCBib3hIZWlnaHQgLSAyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW2ldO1xuICB9XG4gIGRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Ym9keX0gPSB0aGlzO1xuICAgIGNvbnN0IHtib2R5U3BhY2luZywgYm9keUFsaWduLCBkaXNwbGF5Q29sb3JzLCBib3hIZWlnaHQsIGJveFdpZHRoLCBib3hQYWRkaW5nfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgbGV0IGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBsZXQgeExpbmVQYWRkaW5nID0gMDtcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGZpbGxMaW5lT2ZUZXh0ID0gZnVuY3Rpb24obGluZSkge1xuICAgICAgY3R4LmZpbGxUZXh0KGxpbmUsIHJ0bEhlbHBlci54KHB0LnggKyB4TGluZVBhZGRpbmcpLCBwdC55ICsgYm9keUxpbmVIZWlnaHQgLyAyKTtcbiAgICAgIHB0LnkgKz0gYm9keUxpbmVIZWlnaHQgKyBib2R5U3BhY2luZztcbiAgICB9O1xuICAgIGNvbnN0IGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uID0gcnRsSGVscGVyLnRleHRBbGlnbihib2R5QWxpZ24pO1xuICAgIGxldCBib2R5SXRlbSwgdGV4dENvbG9yLCBsaW5lcywgaSwgaiwgaWxlbiwgamxlbjtcbiAgICBjdHgudGV4dEFsaWduID0gYm9keUFsaWduO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcbiAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24sIG9wdGlvbnMpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJvZHlDb2xvcjtcbiAgICBlYWNoKHRoaXMuYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuICAgIHhMaW5lUGFkZGluZyA9IGRpc3BsYXlDb2xvcnMgJiYgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gIT09ICdyaWdodCdcbiAgICAgID8gYm9keUFsaWduID09PSAnY2VudGVyJyA/IChib3hXaWR0aCAvIDIgKyBib3hQYWRkaW5nKSA6IChib3hXaWR0aCArIDIgKyBib3hQYWRkaW5nKVxuICAgICAgOiAwO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBib2R5Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgYm9keUl0ZW0gPSBib2R5W2ldO1xuICAgICAgdGV4dENvbG9yID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGV4dENvbG9yO1xuICAgICAgZWFjaChib2R5SXRlbS5iZWZvcmUsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICAgIGxpbmVzID0gYm9keUl0ZW0ubGluZXM7XG4gICAgICBpZiAoZGlzcGxheUNvbG9ycyAmJiBsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucyk7XG4gICAgICAgIGJvZHlMaW5lSGVpZ2h0ID0gTWF0aC5tYXgoYm9keUZvbnQubGluZUhlaWdodCwgYm94SGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsaW5lcy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgZmlsbExpbmVPZlRleHQobGluZXNbal0pO1xuICAgICAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgICBlYWNoKGJvZHlJdGVtLmFmdGVyLCBmaWxsTGluZU9mVGV4dCk7XG4gICAgfVxuICAgIHhMaW5lUGFkZGluZyA9IDA7XG4gICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGVhY2godGhpcy5hZnRlckJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICBwdC55IC09IGJvZHlTcGFjaW5nO1xuICB9XG4gIGRyYXdGb290ZXIocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZvb3RlciA9IHRoaXMuZm9vdGVyO1xuICAgIGNvbnN0IGxlbmd0aCA9IGZvb3Rlci5sZW5ndGg7XG4gICAgbGV0IGZvb3RlckZvbnQsIGk7XG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBvcHRpb25zLmZvb3RlckFsaWduLCBvcHRpb25zKTtcbiAgICAgIHB0LnkgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3A7XG4gICAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihvcHRpb25zLmZvb3RlckFsaWduKTtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZvb3RlckNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSBmb290ZXJGb250LnN0cmluZztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjdHguZmlsbFRleHQoZm9vdGVyW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIGZvb3RlckZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICBwdC55ICs9IGZvb3RlckZvbnQubGluZUhlaWdodCArIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7eCwgeX0gPSBwdDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0b29sdGlwU2l6ZTtcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMob3B0aW9ucy5jb3JuZXJSYWRpdXMpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHggKyB0b3BMZWZ0LCB5KTtcbiAgICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHRvcFJpZ2h0LCB5KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHRvcFJpZ2h0KTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSBib3R0b21SaWdodCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSBib3R0b21SaWdodCwgeSArIGhlaWdodCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgYm90dG9tTGVmdCwgeSArIGhlaWdodCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIGJvdHRvbUxlZnQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCwgeSArIHRvcExlZnQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyB0b3BMZWZ0LCB5KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gIH1cbiAgX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltWCA9IGFuaW1zICYmIGFuaW1zLng7XG4gICAgY29uc3QgYW5pbVkgPSBhbmltcyAmJiBhbmltcy55O1xuICAgIGlmIChhbmltWCB8fCBhbmltWSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIHRoaXMuX2FjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgdGhpcy5fc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBwb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgY2hhcnQpO1xuICAgICAgaWYgKGFuaW1YLl90byAhPT0gcG9pbnQueCB8fCBhbmltWS5fdG8gIT09IHBvaW50LnkpIHtcbiAgICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICAgIHRoaXMud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNhcmV0WCA9IHBvc2l0aW9uLng7XG4gICAgICAgIHRoaXMuY2FyZXRZID0gcG9zaXRpb24ueTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcG9pbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgbGV0IG9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKTtcbiAgICBjb25zdCB0b29sdGlwU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgcHQgPSB7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnlcbiAgICB9O1xuICAgIG9wYWNpdHkgPSBNYXRoLmFicyhvcGFjaXR5KSA8IDFlLTMgPyAwIDogb3BhY2l0eTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gICAgY29uc3QgaGFzVG9vbHRpcENvbnRlbnQgPSB0aGlzLnRpdGxlLmxlbmd0aCB8fCB0aGlzLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHRoaXMuYm9keS5sZW5ndGggfHwgdGhpcy5hZnRlckJvZHkubGVuZ3RoIHx8IHRoaXMuZm9vdGVyLmxlbmd0aDtcbiAgICBpZiAob3B0aW9ucy5lbmFibGVkICYmIGhhc1Rvb2x0aXBDb250ZW50KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgICAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKGN0eCwgb3B0aW9ucy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgIHB0LnkgKz0gcGFkZGluZy50b3A7XG4gICAgICB0aGlzLmRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmRyYXdGb290ZXIocHQsIGN0eCwgb3B0aW9ucyk7XG4gICAgICByZXN0b3JlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGlmICghbWV0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGEgZGF0YXNldCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBldmVudFBvc2l0aW9uKTtcbiAgICBpZiAoY2hhbmdlZCB8fCBwb3NpdGlvbkNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSBldmVudFBvc2l0aW9uO1xuICAgICAgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlKHRydWUpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVFdmVudChlLCByZXBsYXksIGluQ2hhcnRBcmVhID0gdHJ1ZSkge1xuICAgIGlmIChyZXBsYXkgJiYgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9IGZhbHNlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKTtcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKTtcbiAgICBjb25zdCBjaGFuZ2VkID0gcmVwbGF5IHx8ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpIHx8IHBvc2l0aW9uQ2hhbmdlZDtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCB8fCBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogZS54LFxuICAgICAgICAgIHk6IGUueVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZSh0cnVlLCByZXBsYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICByZXR1cm4gbGFzdEFjdGl2ZTtcbiAgICB9XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG9wdGlvbnMubW9kZSwgb3B0aW9ucywgcmVwbGF5KTtcbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICBhY3RpdmUucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlO1xuICB9XG4gIF9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKSB7XG4gICAgY29uc3Qge2NhcmV0WCwgY2FyZXRZLCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgZSk7XG4gICAgcmV0dXJuIHBvc2l0aW9uICE9PSBmYWxzZSAmJiAoY2FyZXRYICE9PSBwb3NpdGlvbi54IHx8IGNhcmV0WSAhPT0gcG9zaXRpb24ueSk7XG4gIH1cbn1cblRvb2x0aXAucG9zaXRpb25lcnMgPSBwb3NpdGlvbmVycztcbnZhciBwbHVnaW5fdG9vbHRpcCA9IHtcbiAgaWQ6ICd0b29sdGlwJyxcbiAgX2VsZW1lbnQ6IFRvb2x0aXAsXG4gIHBvc2l0aW9uZXJzLFxuICBhZnRlckluaXQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAgPSBuZXcgVG9vbHRpcCh7Y2hhcnQsIG9wdGlvbnN9KTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcbiAgcmVzZXQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG4gIGFmdGVyRHJhdyhjaGFydCkge1xuICAgIGNvbnN0IHRvb2x0aXAgPSBjaGFydC50b29sdGlwO1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICB0b29sdGlwXG4gICAgfTtcbiAgICBpZiAoY2hhcnQubm90aWZ5UGx1Z2lucygnYmVmb3JlVG9vbHRpcERyYXcnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRvb2x0aXApIHtcbiAgICAgIHRvb2x0aXAuZHJhdyhjaGFydC5jdHgpO1xuICAgIH1cbiAgICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclRvb2x0aXBEcmF3JywgYXJncyk7XG4gIH0sXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IGFyZ3MucmVwbGF5O1xuICAgICAgaWYgKGNoYXJ0LnRvb2x0aXAuaGFuZGxlRXZlbnQoYXJncy5ldmVudCwgdXNlRmluYWxQb3NpdGlvbiwgYXJncy5pbkNoYXJ0QXJlYSkpIHtcbiAgICAgICAgYXJncy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBleHRlcm5hbDogbnVsbCxcbiAgICBwb3NpdGlvbjogJ2F2ZXJhZ2UnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG4gICAgdGl0bGVDb2xvcjogJyNmZmYnLFxuICAgIHRpdGxlRm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICB0aXRsZVNwYWNpbmc6IDIsXG4gICAgdGl0bGVNYXJnaW5Cb3R0b206IDYsXG4gICAgdGl0bGVBbGlnbjogJ2xlZnQnLFxuICAgIGJvZHlDb2xvcjogJyNmZmYnLFxuICAgIGJvZHlTcGFjaW5nOiAyLFxuICAgIGJvZHlGb250OiB7XG4gICAgfSxcbiAgICBib2R5QWxpZ246ICdsZWZ0JyxcbiAgICBmb290ZXJDb2xvcjogJyNmZmYnLFxuICAgIGZvb3RlclNwYWNpbmc6IDIsXG4gICAgZm9vdGVyTWFyZ2luVG9wOiA2LFxuICAgIGZvb3RlckZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZm9vdGVyQWxpZ246ICdsZWZ0JyxcbiAgICBwYWRkaW5nOiA2LFxuICAgIGNhcmV0UGFkZGluZzogMixcbiAgICBjYXJldFNpemU6IDUsXG4gICAgY29ybmVyUmFkaXVzOiA2LFxuICAgIGJveEhlaWdodDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIGJveFdpZHRoOiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXG4gICAgbXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgZGlzcGxheUNvbG9yczogdHJ1ZSxcbiAgICBib3hQYWRkaW5nOiAwLFxuICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwLFxuICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCcsICdjYXJldFgnLCAnY2FyZXRZJ10sXG4gICAgICB9LFxuICAgICAgb3BhY2l0eToge1xuICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICBkdXJhdGlvbjogMjAwXG4gICAgICB9XG4gICAgfSxcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIGJlZm9yZVRpdGxlOiBub29wLFxuICAgICAgdGl0bGUodG9vbHRpcEl0ZW1zKSB7XG4gICAgICAgIGlmICh0b29sdGlwSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XG4gICAgICAgICAgY29uc3QgbGFiZWxzID0gaXRlbS5jaGFydC5kYXRhLmxhYmVscztcbiAgICAgICAgICBjb25zdCBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5sYWJlbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxhYmVsQ291bnQgPiAwICYmIGl0ZW0uZGF0YUluZGV4IDwgbGFiZWxDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsc1tpdGVtLmRhdGFJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0sXG4gICAgICBhZnRlclRpdGxlOiBub29wLFxuICAgICAgYmVmb3JlQm9keTogbm9vcCxcbiAgICAgIGJlZm9yZUxhYmVsOiBub29wLFxuICAgICAgbGFiZWwodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgICAgICByZXR1cm4gdG9vbHRpcEl0ZW0ubGFiZWwgKyAnOiAnICsgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWUgfHwgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhYmVsID0gdG9vbHRpcEl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgbGFiZWwgKz0gJzogJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICAgICAgbGFiZWwgKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgfSxcbiAgICAgIGxhYmVsQ29sb3IodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodG9vbHRpcEl0ZW0uZGF0YUluZGV4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgICAgICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGxhYmVsVGV4dENvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJvZHlDb2xvcjtcbiAgICAgIH0sXG4gICAgICBsYWJlbFBvaW50U3R5bGUodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodG9vbHRpcEl0ZW0uZGF0YUluZGV4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG4gICAgICAgICAgcm90YXRpb246IG9wdGlvbnMucm90YXRpb24sXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgYWZ0ZXJMYWJlbDogbm9vcCxcbiAgICAgIGFmdGVyQm9keTogbm9vcCxcbiAgICAgIGJlZm9yZUZvb3Rlcjogbm9vcCxcbiAgICAgIGZvb3Rlcjogbm9vcCxcbiAgICAgIGFmdGVyRm9vdGVyOiBub29wXG4gICAgfVxuICB9LFxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgYm9keUZvbnQ6ICdmb250JyxcbiAgICBmb290ZXJGb250OiAnZm9udCcsXG4gICAgdGl0bGVGb250OiAnZm9udCdcbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgIT09ICdpdGVtU29ydCcgJiYgbmFtZSAhPT0gJ2V4dGVybmFsJyxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBfZmFsbGJhY2s6IGZhbHNlXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBfZmFsbGJhY2s6ICdhbmltYXRpb24nXG4gICAgfVxuICB9LFxuICBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzOiBbJ2ludGVyYWN0aW9uJ11cbn07XG5cbnZhciBwbHVnaW5zID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuRGVjaW1hdGlvbjogcGx1Z2luX2RlY2ltYXRpb24sXG5GaWxsZXI6IHBsdWdpbl9maWxsZXIsXG5MZWdlbmQ6IHBsdWdpbl9sZWdlbmQsXG5TdWJUaXRsZTogcGx1Z2luX3N1YnRpdGxlLFxuVGl0bGU6IHBsdWdpbl90aXRsZSxcblRvb2x0aXA6IHBsdWdpbl90b29sdGlwXG59KTtcblxuY29uc3QgYWRkSWZTdHJpbmcgPSAobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscykgPT4ge1xuICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICBpbmRleCA9IGxhYmVscy5wdXNoKHJhdykgLSAxO1xuICAgIGFkZGVkTGFiZWxzLnVuc2hpZnQoe2luZGV4LCBsYWJlbDogcmF3fSk7XG4gIH0gZWxzZSBpZiAoaXNOYU4ocmF3KSkge1xuICAgIGluZGV4ID0gbnVsbDtcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59O1xuZnVuY3Rpb24gZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscykge1xuICBjb25zdCBmaXJzdCA9IGxhYmVscy5pbmRleE9mKHJhdyk7XG4gIGlmIChmaXJzdCA9PT0gLTEpIHtcbiAgICByZXR1cm4gYWRkSWZTdHJpbmcobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscyk7XG4gIH1cbiAgY29uc3QgbGFzdCA9IGxhYmVscy5sYXN0SW5kZXhPZihyYXcpO1xuICByZXR1cm4gZmlyc3QgIT09IGxhc3QgPyBpbmRleCA6IGZpcnN0O1xufVxuY29uc3QgdmFsaWRJbmRleCA9IChpbmRleCwgbWF4KSA9PiBpbmRleCA9PT0gbnVsbCA/IG51bGwgOiBfbGltaXRWYWx1ZShNYXRoLnJvdW5kKGluZGV4KSwgMCwgbWF4KTtcbmNsYXNzIENhdGVnb3J5U2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICB9XG4gIGluaXQoc2NhbGVPcHRpb25zKSB7XG4gICAgY29uc3QgYWRkZWQgPSB0aGlzLl9hZGRlZExhYmVscztcbiAgICBpZiAoYWRkZWQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgICAgZm9yIChjb25zdCB7aW5kZXgsIGxhYmVsfSBvZiBhZGRlZCkge1xuICAgICAgICBpZiAobGFiZWxzW2luZGV4XSA9PT0gbGFiZWwpIHtcbiAgICAgICAgICBsYWJlbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgICB9XG4gICAgc3VwZXIuaW5pdChzY2FsZU9wdGlvbnMpO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBpbmRleCA9IGlzRmluaXRlKGluZGV4KSAmJiBsYWJlbHNbaW5kZXhdID09PSByYXcgPyBpbmRleFxuICAgICAgOiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgdmFsdWVPckRlZmF1bHQoaW5kZXgsIHJhdyksIHRoaXMuX2FkZGVkTGFiZWxzKTtcbiAgICByZXR1cm4gdmFsaWRJbmRleChpbmRleCwgbGFiZWxzLmxlbmd0aCAtIDEpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgbWF4ID0gdGhpcy5nZXRMYWJlbHMoKS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub3B0aW9ucy5vZmZzZXQ7XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICBsZXQgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBsYWJlbHMgPSAobWluID09PSAwICYmIG1heCA9PT0gbGFiZWxzLmxlbmd0aCAtIDEpID8gbGFiZWxzIDogbGFiZWxzLnNsaWNlKG1pbiwgbWF4ICsgMSk7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IE1hdGgubWF4KGxhYmVscy5sZW5ndGggLSAob2Zmc2V0ID8gMCA6IDEpLCAxKTtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdGhpcy5taW4gLSAob2Zmc2V0ID8gMC41IDogMCk7XG4gICAgZm9yIChsZXQgdmFsdWUgPSBtaW47IHZhbHVlIDw9IG1heDsgdmFsdWUrKykge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWV9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGlmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDwgbGFiZWxzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGxhYmVsc1t2YWx1ZV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG4gICAgaWYgKCF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gIXRoaXMuX3JldmVyc2VQaXhlbHM7XG4gICAgfVxuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tO1xuICB9XG59XG5DYXRlZ29yeVNjYWxlLmlkID0gJ2NhdGVnb3J5JztcbkNhdGVnb3J5U2NhbGUuZGVmYXVsdHMgPSB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IENhdGVnb3J5U2NhbGUucHJvdG90eXBlLmdldExhYmVsRm9yVmFsdWVcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyQxKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgY29uc3QgTUlOX1NQQUNJTkcgPSAxZS0xNDtcbiAgY29uc3Qge2JvdW5kcywgc3RlcCwgbWluLCBtYXgsIHByZWNpc2lvbiwgY291bnQsIG1heFRpY2tzLCBtYXhEaWdpdHMsIGluY2x1ZGVCb3VuZHN9ID0gZ2VuZXJhdGlvbk9wdGlvbnM7XG4gIGNvbnN0IHVuaXQgPSBzdGVwIHx8IDE7XG4gIGNvbnN0IG1heFNwYWNlcyA9IG1heFRpY2tzIC0gMTtcbiAgY29uc3Qge21pbjogcm1pbiwgbWF4OiBybWF4fSA9IGRhdGFSYW5nZTtcbiAgY29uc3QgbWluRGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1pbik7XG4gIGNvbnN0IG1heERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtYXgpO1xuICBjb25zdCBjb3VudERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihjb3VudCk7XG4gIGNvbnN0IG1pblNwYWNpbmcgPSAocm1heCAtIHJtaW4pIC8gKG1heERpZ2l0cyArIDEpO1xuICBsZXQgc3BhY2luZyA9IG5pY2VOdW0oKHJtYXggLSBybWluKSAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgbGV0IGZhY3RvciwgbmljZU1pbiwgbmljZU1heCwgbnVtU3BhY2VzO1xuICBpZiAoc3BhY2luZyA8IE1JTl9TUEFDSU5HICYmICFtaW5EZWZpbmVkICYmICFtYXhEZWZpbmVkKSB7XG4gICAgcmV0dXJuIFt7dmFsdWU6IHJtaW59LCB7dmFsdWU6IHJtYXh9XTtcbiAgfVxuICBudW1TcGFjZXMgPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpIC0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZyk7XG4gIGlmIChudW1TcGFjZXMgPiBtYXhTcGFjZXMpIHtcbiAgICBzcGFjaW5nID0gbmljZU51bShudW1TcGFjZXMgKiBzcGFjaW5nIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICB9XG4gIGlmICghaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pKSB7XG4gICAgZmFjdG9yID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgfVxuICBpZiAoYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgbmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgICBuaWNlTWF4ID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gIH0gZWxzZSB7XG4gICAgbmljZU1pbiA9IHJtaW47XG4gICAgbmljZU1heCA9IHJtYXg7XG4gIH1cbiAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCAmJiBzdGVwICYmIGFsbW9zdFdob2xlKChtYXggLSBtaW4pIC8gc3RlcCwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChNYXRoLm1pbigobWF4IC0gbWluKSAvIHNwYWNpbmcsIG1heFRpY2tzKSk7XG4gICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gbnVtU3BhY2VzO1xuICAgIG5pY2VNaW4gPSBtaW47XG4gICAgbmljZU1heCA9IG1heDtcbiAgfSBlbHNlIGlmIChjb3VudERlZmluZWQpIHtcbiAgICBuaWNlTWluID0gbWluRGVmaW5lZCA/IG1pbiA6IG5pY2VNaW47XG4gICAgbmljZU1heCA9IG1heERlZmluZWQgPyBtYXggOiBuaWNlTWF4O1xuICAgIG51bVNwYWNlcyA9IGNvdW50IC0gMTtcbiAgICBzcGFjaW5nID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIG51bVNwYWNlcztcbiAgfSBlbHNlIHtcbiAgICBudW1TcGFjZXMgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gc3BhY2luZztcbiAgICBpZiAoYWxtb3N0RXF1YWxzKG51bVNwYWNlcywgTWF0aC5yb3VuZChudW1TcGFjZXMpLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQobnVtU3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKG51bVNwYWNlcyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRlY2ltYWxQbGFjZXMgPSBNYXRoLm1heChcbiAgICBfZGVjaW1hbFBsYWNlcyhzcGFjaW5nKSxcbiAgICBfZGVjaW1hbFBsYWNlcyhuaWNlTWluKVxuICApO1xuICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pID8gZGVjaW1hbFBsYWNlcyA6IHByZWNpc2lvbik7XG4gIG5pY2VNaW4gPSBNYXRoLnJvdW5kKG5pY2VNaW4gKiBmYWN0b3IpIC8gZmFjdG9yO1xuICBuaWNlTWF4ID0gTWF0aC5yb3VuZChuaWNlTWF4ICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgbGV0IGogPSAwO1xuICBpZiAobWluRGVmaW5lZCkge1xuICAgIGlmIChpbmNsdWRlQm91bmRzICYmIG5pY2VNaW4gIT09IG1pbikge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWU6IG1pbn0pO1xuICAgICAgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgICAgaWYgKGFsbW9zdEVxdWFscyhNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3RvciwgbWluLCByZWxhdGl2ZUxhYmVsU2l6ZShtaW4sIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgaisrO1xuICAgIH1cbiAgfVxuICBmb3IgKDsgaiA8IG51bVNwYWNlczsgKytqKSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yfSk7XG4gIH1cbiAgaWYgKG1heERlZmluZWQgJiYgaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWF4ICE9PSBtYXgpIHtcbiAgICBpZiAodGlja3MubGVuZ3RoICYmIGFsbW9zdEVxdWFscyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSwgbWF4LCByZWxhdGl2ZUxhYmVsU2l6ZShtYXgsIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlID0gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWF4fSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFtYXhEZWZpbmVkIHx8IG5pY2VNYXggPT09IG1heCkge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBuaWNlTWF4fSk7XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuZnVuY3Rpb24gcmVsYXRpdmVMYWJlbFNpemUodmFsdWUsIG1pblNwYWNpbmcsIHtob3Jpem9udGFsLCBtaW5Sb3RhdGlvbn0pIHtcbiAgY29uc3QgcmFkID0gdG9SYWRpYW5zKG1pblJvdGF0aW9uKTtcbiAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKHJhZCkgOiBNYXRoLmNvcyhyYWQpKSB8fCAwLjAwMTtcbiAgY29uc3QgbGVuZ3RoID0gMC43NSAqIG1pblNwYWNpbmcgKiAoJycgKyB2YWx1ZSkubGVuZ3RoO1xuICByZXR1cm4gTWF0aC5taW4obWluU3BhY2luZyAvIHJhdGlvLCBsZW5ndGgpO1xufVxuY2xhc3MgTGluZWFyU2NhbGVCYXNlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9lbmRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgodHlwZW9mIHJhdyA9PT0gJ251bWJlcicgfHwgcmF3IGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhaXNGaW5pdGUoK3JhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gK3JhdztcbiAgfVxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHtiZWdpbkF0WmVyb30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcbiAgICBjb25zdCBzZXRNYXggPSB2ID0+IChtYXggPSBtYXhEZWZpbmVkID8gbWF4IDogdik7XG4gICAgaWYgKGJlZ2luQXRaZXJvKSB7XG4gICAgICBjb25zdCBtaW5TaWduID0gc2lnbihtaW4pO1xuICAgICAgY29uc3QgbWF4U2lnbiA9IHNpZ24obWF4KTtcbiAgICAgIGlmIChtaW5TaWduIDwgMCAmJiBtYXhTaWduIDwgMCkge1xuICAgICAgICBzZXRNYXgoMCk7XG4gICAgICB9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XG4gICAgICAgIHNldE1pbigwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gMTtcbiAgICAgIGlmIChtYXggPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgbWluIDw9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGguYWJzKG1heCAqIDAuMDUpO1xuICAgICAgfVxuICAgICAgc2V0TWF4KG1heCArIG9mZnNldCk7XG4gICAgICBpZiAoIWJlZ2luQXRaZXJvKSB7XG4gICAgICAgIHNldE1pbihtaW4gLSBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuICBnZXRUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgbGV0IHttYXhUaWNrc0xpbWl0LCBzdGVwU2l6ZX0gPSB0aWNrT3B0cztcbiAgICBsZXQgbWF4VGlja3M7XG4gICAgaWYgKHN0ZXBTaXplKSB7XG4gICAgICBtYXhUaWNrcyA9IE1hdGguY2VpbCh0aGlzLm1heCAvIHN0ZXBTaXplKSAtIE1hdGguZmxvb3IodGhpcy5taW4gLyBzdGVwU2l6ZSkgKyAxO1xuICAgICAgaWYgKG1heFRpY2tzID4gMTAwMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYHNjYWxlcy4ke3RoaXMuaWR9LnRpY2tzLnN0ZXBTaXplOiAke3N0ZXBTaXplfSB3b3VsZCByZXN1bHQgZ2VuZXJhdGluZyB1cCB0byAke21heFRpY2tzfSB0aWNrcy4gTGltaXRpbmcgdG8gMTAwMC5gKTtcbiAgICAgICAgbWF4VGlja3MgPSAxMDAwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhUaWNrcyA9IHRoaXMuY29tcHV0ZVRpY2tMaW1pdCgpO1xuICAgICAgbWF4VGlja3NMaW1pdCA9IG1heFRpY2tzTGltaXQgfHwgMTE7XG4gICAgfVxuICAgIGlmIChtYXhUaWNrc0xpbWl0KSB7XG4gICAgICBtYXhUaWNrcyA9IE1hdGgubWluKG1heFRpY2tzTGltaXQsIG1heFRpY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heFRpY2tzO1xuICB9XG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuICAgIGxldCBtYXhUaWNrcyA9IHRoaXMuZ2V0VGlja0xpbWl0KCk7XG4gICAgbWF4VGlja3MgPSBNYXRoLm1heCgyLCBtYXhUaWNrcyk7XG4gICAgY29uc3QgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XG4gICAgICBtYXhUaWNrcyxcbiAgICAgIGJvdW5kczogb3B0cy5ib3VuZHMsXG4gICAgICBtaW46IG9wdHMubWluLFxuICAgICAgbWF4OiBvcHRzLm1heCxcbiAgICAgIHByZWNpc2lvbjogdGlja09wdHMucHJlY2lzaW9uLFxuICAgICAgc3RlcDogdGlja09wdHMuc3RlcFNpemUsXG4gICAgICBjb3VudDogdGlja09wdHMuY291bnQsXG4gICAgICBtYXhEaWdpdHM6IHRoaXMuX21heERpZ2l0cygpLFxuICAgICAgaG9yaXpvbnRhbDogdGhpcy5pc0hvcml6b250YWwoKSxcbiAgICAgIG1pblJvdGF0aW9uOiB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwLFxuICAgICAgaW5jbHVkZUJvdW5kczogdGlja09wdHMuaW5jbHVkZUJvdW5kcyAhPT0gZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGRhdGFSYW5nZSA9IHRoaXMuX3JhbmdlIHx8IHRoaXM7XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzJDEobnVtZXJpY0dlbmVyYXRvck9wdGlvbnMsIGRhdGFSYW5nZSk7XG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBsZXQgc3RhcnQgPSB0aGlzLm1pbjtcbiAgICBsZXQgZW5kID0gdGhpcy5tYXg7XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSAoZW5kIC0gc3RhcnQpIC8gTWF0aC5tYXgodGlja3MubGVuZ3RoIC0gMSwgMSkgLyAyO1xuICAgICAgc3RhcnQgLT0gb2Zmc2V0O1xuICAgICAgZW5kICs9IG9mZnNldDtcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHN0YXJ0O1xuICAgIHRoaXMuX2VuZFZhbHVlID0gZW5kO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBlbmQgLSBzdGFydDtcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih2YWx1ZSwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gIH1cbn1cblxuY2xhc3MgTGluZWFyU2NhbGUgZXh0ZW5kcyBMaW5lYXJTY2FsZUJhc2Uge1xuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcbiAgICB0aGlzLm1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgPyBtaW4gOiAwO1xuICAgIHRoaXMubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSA/IG1heCA6IDE7XG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCBob3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCBsZW5ndGggPSBob3Jpem9udGFsID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy50aWNrcy5taW5Sb3RhdGlvbik7XG4gICAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKG1pblJvdGF0aW9uKSA6IE1hdGguY29zKG1pblJvdGF0aW9uKSkgfHwgMC4wMDE7XG4gICAgY29uc3QgdGlja0ZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApO1xuICAgIHJldHVybiBNYXRoLmNlaWwobGVuZ3RoIC8gTWF0aC5taW4oNDAsIHRpY2tGb250LmxpbmVIZWlnaHQgLyByYXRpbykpO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2U7XG4gIH1cbn1cbkxpbmVhclNjYWxlLmlkID0gJ2xpbmVhcic7XG5MaW5lYXJTY2FsZS5kZWZhdWx0cyA9IHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzTWFqb3IodGlja1ZhbCkge1xuICBjb25zdCByZW1haW4gPSB0aWNrVmFsIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWwpKSkpO1xuICByZXR1cm4gcmVtYWluID09PSAxO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG4gIGNvbnN0IGVuZEV4cCA9IE1hdGguZmxvb3IobG9nMTAoZGF0YVJhbmdlLm1heCkpO1xuICBjb25zdCBlbmRTaWduaWZpY2FuZCA9IE1hdGguY2VpbChkYXRhUmFuZ2UubWF4IC8gTWF0aC5wb3coMTAsIGVuZEV4cCkpO1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBsZXQgdGlja1ZhbCA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5taW4sIE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5taW4pKSkpO1xuICBsZXQgZXhwID0gTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsKSk7XG4gIGxldCBzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IodGlja1ZhbCAvIE1hdGgucG93KDEwLCBleHApKTtcbiAgbGV0IHByZWNpc2lvbiA9IGV4cCA8IDAgPyBNYXRoLnBvdygxMCwgTWF0aC5hYnMoZXhwKSkgOiAxO1xuICBkbyB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IHRpY2tWYWwsIG1ham9yOiBpc01ham9yKHRpY2tWYWwpfSk7XG4gICAgKytzaWduaWZpY2FuZDtcbiAgICBpZiAoc2lnbmlmaWNhbmQgPT09IDEwKSB7XG4gICAgICBzaWduaWZpY2FuZCA9IDE7XG4gICAgICArK2V4cDtcbiAgICAgIHByZWNpc2lvbiA9IGV4cCA+PSAwID8gMSA6IHByZWNpc2lvbjtcbiAgICB9XG4gICAgdGlja1ZhbCA9IE1hdGgucm91bmQoc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gIH0gd2hpbGUgKGV4cCA8IGVuZEV4cCB8fCAoZXhwID09PSBlbmRFeHAgJiYgc2lnbmlmaWNhbmQgPCBlbmRTaWduaWZpY2FuZCkpO1xuICBjb25zdCBsYXN0VGljayA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIHRpY2tWYWwpO1xuICB0aWNrcy5wdXNoKHt2YWx1ZTogbGFzdFRpY2ssIG1ham9yOiBpc01ham9yKHRpY2tWYWwpfSk7XG4gIHJldHVybiB0aWNrcztcbn1cbmNsYXNzIExvZ2FyaXRobWljU2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUucGFyc2UuYXBwbHkodGhpcywgW3JhdywgaW5kZXhdKTtcbiAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGlzTnVtYmVyRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+IDAgPyB2YWx1ZSA6IG51bGw7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgdGhpcy5taW4gPSBpc051bWJlckZpbml0ZShtaW4pID8gTWF0aC5tYXgoMCwgbWluKSA6IG51bGw7XG4gICAgdGhpcy5tYXggPSBpc051bWJlckZpbml0ZShtYXgpID8gTWF0aC5tYXgoMCwgbWF4KSA6IG51bGw7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5iZWdpbkF0WmVybykge1xuICAgICAgdGhpcy5femVybyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IG1pbiA9IHRoaXMubWluO1xuICAgIGxldCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuICAgIGNvbnN0IGV4cCA9ICh2LCBtKSA9PiBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh2KSkgKyBtKTtcbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGlmIChtaW4gPD0gMCkge1xuICAgICAgICBzZXRNaW4oMSk7XG4gICAgICAgIHNldE1heCgxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRNaW4oZXhwKG1pbiwgLTEpKTtcbiAgICAgICAgc2V0TWF4KGV4cChtYXgsICsxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaW4gPD0gMCkge1xuICAgICAgc2V0TWluKGV4cChtYXgsIC0xKSk7XG4gICAgfVxuICAgIGlmIChtYXggPD0gMCkge1xuICAgICAgc2V0TWF4KGV4cChtaW4sICsxKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl96ZXJvICYmIHRoaXMubWluICE9PSB0aGlzLl9zdWdnZXN0ZWRNaW4gJiYgbWluID09PSBleHAodGhpcy5taW4sIDApKSB7XG4gICAgICBzZXRNaW4oZXhwKG1pbiwgLTEpKTtcbiAgICB9XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGdlbmVyYXRpb25PcHRpb25zID0ge1xuICAgICAgbWluOiB0aGlzLl91c2VyTWluLFxuICAgICAgbWF4OiB0aGlzLl91c2VyTWF4XG4gICAgfTtcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIHRoaXMpO1xuICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICB9XG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWF4O1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgPyAnMCdcbiAgICAgIDogZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLm1pbjtcbiAgICBzdXBlci5jb25maWd1cmUoKTtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gbG9nMTAoc3RhcnQpO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBsb2cxMCh0aGlzLm1heCkgLSBsb2cxMChzdGFydCk7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMubWluO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwodmFsdWUgPT09IHRoaXMubWluXG4gICAgICA/IDBcbiAgICAgIDogKGxvZzEwKHZhbHVlKSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCk7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLl9zdGFydFZhbHVlICsgZGVjaW1hbCAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG59XG5Mb2dhcml0aG1pY1NjYWxlLmlkID0gJ2xvZ2FyaXRobWljJztcbkxvZ2FyaXRobWljU2NhbGUuZGVmYXVsdHMgPSB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWMsXG4gICAgbWFqb3I6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcbiAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgb3B0cy5kaXNwbGF5KSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmcpO1xuICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250ICYmIHRpY2tPcHRzLmZvbnQuc2l6ZSwgZGVmYXVsdHMuZm9udC5zaXplKSArIHBhZGRpbmcuaGVpZ2h0O1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gbWVhc3VyZUxhYmVsU2l6ZShjdHgsIGZvbnQsIGxhYmVsKSB7XG4gIGxhYmVsID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbCA6IFtsYWJlbF07XG4gIHJldHVybiB7XG4gICAgdzogX2xvbmdlc3RUZXh0KGN0eCwgZm9udC5zdHJpbmcsIGxhYmVsKSxcbiAgICBoOiBsYWJlbC5sZW5ndGggKiBmb250LmxpbmVIZWlnaHRcbiAgfTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9zLCBzaXplLCBtaW4sIG1heCkge1xuICBpZiAoYW5nbGUgPT09IG1pbiB8fCBhbmdsZSA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSAoc2l6ZSAvIDIpLFxuICAgICAgZW5kOiBwb3MgKyAoc2l6ZSAvIDIpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChhbmdsZSA8IG1pbiB8fCBhbmdsZSA+IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gc2l6ZSxcbiAgICAgIGVuZDogcG9zXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBwb3MsXG4gICAgZW5kOiBwb3MgKyBzaXplXG4gIH07XG59XG5mdW5jdGlvbiBmaXRXaXRoUG9pbnRMYWJlbHMoc2NhbGUpIHtcbiAgY29uc3Qgb3JpZyA9IHtcbiAgICBsOiBzY2FsZS5sZWZ0ICsgc2NhbGUuX3BhZGRpbmcubGVmdCxcbiAgICByOiBzY2FsZS5yaWdodCAtIHNjYWxlLl9wYWRkaW5nLnJpZ2h0LFxuICAgIHQ6IHNjYWxlLnRvcCArIHNjYWxlLl9wYWRkaW5nLnRvcCxcbiAgICBiOiBzY2FsZS5ib3R0b20gLSBzY2FsZS5fcGFkZGluZy5ib3R0b21cbiAgfTtcbiAgY29uc3QgbGltaXRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZyk7XG4gIGNvbnN0IGxhYmVsU2l6ZXMgPSBbXTtcbiAgY29uc3QgcGFkZGluZyA9IFtdO1xuICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgY29uc3QgcG9pbnRMYWJlbE9wdHMgPSBzY2FsZS5vcHRpb25zLnBvaW50TGFiZWxzO1xuICBjb25zdCBhZGRpdGlvbmFsQW5nbGUgPSBwb2ludExhYmVsT3B0cy5jZW50ZXJQb2ludExhYmVscyA/IFBJIC8gdmFsdWVDb3VudCA6IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgY29uc3Qgb3B0cyA9IHBvaW50TGFiZWxPcHRzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIHBhZGRpbmdbaV0gPSBvcHRzLnBhZGRpbmc7XG4gICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgc2NhbGUuZHJhd2luZ0FyZWEgKyBwYWRkaW5nW2ldLCBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShzY2FsZS5jdHgsIHBsRm9udCwgc2NhbGUuX3BvaW50TGFiZWxzW2ldKTtcbiAgICBsYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XG4gICAgY29uc3QgYW5nbGVSYWRpYW5zID0gX25vcm1hbGl6ZUFuZ2xlKHNjYWxlLmdldEluZGV4QW5nbGUoaSkgKyBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yb3VuZCh0b0RlZ3JlZXMoYW5nbGVSYWRpYW5zKSk7XG4gICAgY29uc3QgaExpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi54LCB0ZXh0U2l6ZS53LCAwLCAxODApO1xuICAgIGNvbnN0IHZMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueSwgdGV4dFNpemUuaCwgOTAsIDI3MCk7XG4gICAgdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGVSYWRpYW5zLCBoTGltaXRzLCB2TGltaXRzKTtcbiAgfVxuICBzY2FsZS5zZXRDZW50ZXJQb2ludChcbiAgICBvcmlnLmwgLSBsaW1pdHMubCxcbiAgICBsaW1pdHMuciAtIG9yaWcucixcbiAgICBvcmlnLnQgLSBsaW1pdHMudCxcbiAgICBsaW1pdHMuYiAtIG9yaWcuYlxuICApO1xuICBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zID0gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpO1xufVxuZnVuY3Rpb24gdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGUsIGhMaW1pdHMsIHZMaW1pdHMpIHtcbiAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4oYW5nbGUpKTtcbiAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpKTtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmIChoTGltaXRzLnN0YXJ0IDwgb3JpZy5sKSB7XG4gICAgeCA9IChvcmlnLmwgLSBoTGltaXRzLnN0YXJ0KSAvIHNpbjtcbiAgICBsaW1pdHMubCA9IE1hdGgubWluKGxpbWl0cy5sLCBvcmlnLmwgLSB4KTtcbiAgfSBlbHNlIGlmIChoTGltaXRzLmVuZCA+IG9yaWcucikge1xuICAgIHggPSAoaExpbWl0cy5lbmQgLSBvcmlnLnIpIC8gc2luO1xuICAgIGxpbWl0cy5yID0gTWF0aC5tYXgobGltaXRzLnIsIG9yaWcuciArIHgpO1xuICB9XG4gIGlmICh2TGltaXRzLnN0YXJ0IDwgb3JpZy50KSB7XG4gICAgeSA9IChvcmlnLnQgLSB2TGltaXRzLnN0YXJ0KSAvIGNvcztcbiAgICBsaW1pdHMudCA9IE1hdGgubWluKGxpbWl0cy50LCBvcmlnLnQgLSB5KTtcbiAgfSBlbHNlIGlmICh2TGltaXRzLmVuZCA+IG9yaWcuYikge1xuICAgIHkgPSAodkxpbWl0cy5lbmQgLSBvcmlnLmIpIC8gY29zO1xuICAgIGxpbWl0cy5iID0gTWF0aC5tYXgobGltaXRzLmIsIG9yaWcuYiArIHkpO1xuICB9XG59XG5mdW5jdGlvbiBidWlsZFBvaW50TGFiZWxJdGVtcyhzY2FsZSwgbGFiZWxTaXplcywgcGFkZGluZykge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgY29uc3Qgb3B0cyA9IHNjYWxlLm9wdGlvbnM7XG4gIGNvbnN0IGV4dHJhID0gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIC8gMjtcbiAgY29uc3Qgb3V0ZXJEaXN0YW5jZSA9IHNjYWxlLmRyYXdpbmdBcmVhO1xuICBjb25zdCBhZGRpdGlvbmFsQW5nbGUgPSBvcHRzLnBvaW50TGFiZWxzLmNlbnRlclBvaW50TGFiZWxzID8gUEkgLyB2YWx1ZUNvdW50IDogMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBjb25zdCBwb2ludExhYmVsUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIG91dGVyRGlzdGFuY2UgKyBleHRyYSArIHBhZGRpbmdbaV0sIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhfbm9ybWFsaXplQW5nbGUocG9pbnRMYWJlbFBvc2l0aW9uLmFuZ2xlICsgSEFMRl9QSSkpKTtcbiAgICBjb25zdCBzaXplID0gbGFiZWxTaXplc1tpXTtcbiAgICBjb25zdCB5ID0geUZvckFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi55LCBzaXplLmgsIGFuZ2xlKTtcbiAgICBjb25zdCB0ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSk7XG4gICAgY29uc3QgbGVmdCA9IGxlZnRGb3JUZXh0QWxpZ24ocG9pbnRMYWJlbFBvc2l0aW9uLngsIHNpemUudywgdGV4dEFsaWduKTtcbiAgICBpdGVtcy5wdXNoKHtcbiAgICAgIHg6IHBvaW50TGFiZWxQb3NpdGlvbi54LFxuICAgICAgeSxcbiAgICAgIHRleHRBbGlnbixcbiAgICAgIGxlZnQsXG4gICAgICB0b3A6IHksXG4gICAgICByaWdodDogbGVmdCArIHNpemUudyxcbiAgICAgIGJvdHRvbTogeSArIHNpemUuaFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gMCB8fCBhbmdsZSA9PT0gMTgwKSB7XG4gICAgcmV0dXJuICdjZW50ZXInO1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgMTgwKSB7XG4gICAgcmV0dXJuICdsZWZ0JztcbiAgfVxuICByZXR1cm4gJ3JpZ2h0Jztcbn1cbmZ1bmN0aW9uIGxlZnRGb3JUZXh0QWxpZ24oeCwgdywgYWxpZ24pIHtcbiAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3O1xuICB9IGVsc2UgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHcgLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIHlGb3JBbmdsZSh5LCBoLCBhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcbiAgICB5IC09IChoIC8gMik7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPiAyNzAgfHwgYW5nbGUgPCA5MCkge1xuICAgIHkgLT0gaDtcbiAgfVxuICByZXR1cm4geTtcbn1cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9pbnRMYWJlbHN9fSA9IHNjYWxlO1xuICBmb3IgKGxldCBpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qgb3B0c0F0SW5kZXggPSBwb2ludExhYmVscy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBjb25zdCBwbEZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgY29uc3Qge3gsIHksIHRleHRBbGlnbiwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IHNjYWxlLl9wb2ludExhYmVsSXRlbXNbaV07XG4gICAgY29uc3Qge2JhY2tkcm9wQ29sb3J9ID0gb3B0c0F0SW5kZXg7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKGJhY2tkcm9wQ29sb3IpKSB7XG4gICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2Ryb3BDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdChsZWZ0IC0gcGFkZGluZy5sZWZ0LCB0b3AgLSBwYWRkaW5nLnRvcCwgcmlnaHQgLSBsZWZ0ICsgcGFkZGluZy53aWR0aCwgYm90dG9tIC0gdG9wICsgcGFkZGluZy5oZWlnaHQpO1xuICAgIH1cbiAgICByZW5kZXJUZXh0KFxuICAgICAgY3R4LFxuICAgICAgc2NhbGUuX3BvaW50TGFiZWxzW2ldLFxuICAgICAgeCxcbiAgICAgIHkgKyAocGxGb250LmxpbmVIZWlnaHQgLyAyKSxcbiAgICAgIHBsRm9udCxcbiAgICAgIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgICAgfVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IHtjdHh9ID0gc2NhbGU7XG4gIGlmIChjaXJjdWxhcikge1xuICAgIGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBUQVUpO1xuICB9IGVsc2Uge1xuICAgIGxldCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbigwLCByYWRpdXMpO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCByYWRpdXMpO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGxhYmVsQ291bnQpIHtcbiAgY29uc3QgY3R4ID0gc2NhbGUuY3R4O1xuICBjb25zdCBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcbiAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gZ3JpZExpbmVPcHRzO1xuICBpZiAoKCFjaXJjdWxhciAmJiAhbGFiZWxDb3VudCkgfHwgIWNvbG9yIHx8ICFsaW5lV2lkdGggfHwgcmFkaXVzIDwgMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjdHguc2F2ZSgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgY3R4LnNldExpbmVEYXNoKGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZ3JpZExpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQ7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5zdHJva2UoKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHBhcmVudCwgaW5kZXgsIGxhYmVsKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGxhYmVsLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICdwb2ludExhYmVsJ1xuICB9KTtcbn1cbmNsYXNzIFJhZGlhbExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcbiAgICB0aGlzLnhDZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSBbXTtcbiAgICB0aGlzLl9wb2ludExhYmVsSXRlbXMgPSBbXTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpIC8gMik7XG4gICAgY29uc3QgdyA9IHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoIC0gcGFkZGluZy53aWR0aDtcbiAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0O1xuICAgIHRoaXMueENlbnRlciA9IE1hdGguZmxvb3IodGhpcy5sZWZ0ICsgdyAvIDIgKyBwYWRkaW5nLmxlZnQpO1xuICAgIHRoaXMueUNlbnRlciA9IE1hdGguZmxvb3IodGhpcy50b3AgKyBoIC8gMiArIHBhZGRpbmcudG9wKTtcbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gTWF0aC5mbG9vcihNYXRoLm1pbih3LCBoKSAvIDIpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KGZhbHNlKTtcbiAgICB0aGlzLm1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiAwO1xuICAgIHRoaXMubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSAmJiAhaXNOYU4obWF4KSA/IG1heCA6IDA7XG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZHJhd2luZ0FyZWEgLyBnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSk7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5nZW5lcmF0ZVRpY2tMYWJlbHMuY2FsbCh0aGlzLCB0aWNrcyk7XG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSB0aGlzLmdldExhYmVscygpXG4gICAgICAubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjYWxsYmFjayh0aGlzLm9wdGlvbnMucG9pbnRMYWJlbHMuY2FsbGJhY2ssIFt2YWx1ZSwgaW5kZXhdLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsIHx8IGxhYmVsID09PSAwID8gbGFiZWwgOiAnJztcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKCh2LCBpKSA9PiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpKTtcbiAgfVxuICBmaXQoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAob3B0cy5kaXNwbGF5ICYmIG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuICAgICAgZml0V2l0aFBvaW50TGFiZWxzKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENlbnRlclBvaW50KDAsIDAsIDAsIDApO1xuICAgIH1cbiAgfVxuICBzZXRDZW50ZXJQb2ludChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkge1xuICAgIHRoaXMueENlbnRlciArPSBNYXRoLmZsb29yKChsZWZ0TW92ZW1lbnQgLSByaWdodE1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMueUNlbnRlciArPSBNYXRoLmZsb29yKCh0b3BNb3ZlbWVudCAtIGJvdHRvbU1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgLT0gTWF0aC5taW4odGhpcy5kcmF3aW5nQXJlYSAvIDIsIE1hdGgubWF4KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSk7XG4gIH1cbiAgZ2V0SW5kZXhBbmdsZShpbmRleCkge1xuICAgIGNvbnN0IGFuZ2xlTXVsdGlwbGllciA9IFRBVSAvICh0aGlzLl9wb2ludExhYmVscy5sZW5ndGggfHwgMSk7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMub3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XG4gICAgcmV0dXJuIF9ub3JtYWxpemVBbmdsZShpbmRleCAqIGFuZ2xlTXVsdGlwbGllciArIHRvUmFkaWFucyhzdGFydEFuZ2xlKSk7XG4gIH1cbiAgZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IHNjYWxpbmdGYWN0b3IgPSB0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgcmV0dXJuICh0aGlzLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XG4gICAgfVxuICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1pbikgKiBzY2FsaW5nRmFjdG9yO1xuICB9XG4gIGdldFZhbHVlRm9yRGlzdGFuY2VGcm9tQ2VudGVyKGRpc3RhbmNlKSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYoZGlzdGFuY2UpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZWREaXN0YW5jZSA9IGRpc3RhbmNlIC8gKHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbikpO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmV2ZXJzZSA/IHRoaXMubWF4IC0gc2NhbGVkRGlzdGFuY2UgOiB0aGlzLm1pbiArIHNjYWxlZERpc3RhbmNlO1xuICB9XG4gIGdldFBvaW50TGFiZWxDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgcG9pbnRMYWJlbHMgPSB0aGlzLl9wb2ludExhYmVscyB8fCBbXTtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHBvaW50TGFiZWxzLmxlbmd0aCkge1xuICAgICAgY29uc3QgcG9pbnRMYWJlbCA9IHBvaW50TGFiZWxzW2luZGV4XTtcbiAgICAgIHJldHVybiBjcmVhdGVQb2ludExhYmVsQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIHBvaW50TGFiZWwpO1xuICAgIH1cbiAgfVxuICBnZXRQb2ludFBvc2l0aW9uKGluZGV4LCBkaXN0YW5jZUZyb21DZW50ZXIsIGFkZGl0aW9uYWxBbmdsZSA9IDApIHtcbiAgICBjb25zdCBhbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZShpbmRleCkgLSBIQUxGX1BJICsgYWRkaXRpb25hbEFuZ2xlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmNvcyhhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyB0aGlzLnhDZW50ZXIsXG4gICAgICB5OiBNYXRoLnNpbihhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyB0aGlzLnlDZW50ZXIsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cbiAgZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcbiAgfVxuICBnZXRCYXNlUG9zaXRpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXggfHwgMCwgdGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gIH1cbiAgZ2V0UG9pbnRMYWJlbFBvc2l0aW9uKGluZGV4KSB7XG4gICAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSB0aGlzLl9wb2ludExhYmVsSXRlbXNbaW5kZXhdO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0LFxuICAgICAgdG9wLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgfTtcbiAgfVxuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7YmFja2dyb3VuZENvbG9yLCBncmlkOiB7Y2lyY3VsYXJ9fSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBwYXRoUmFkaXVzTGluZSh0aGlzLCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuX2VuZFZhbHVlKSwgY2lyY3VsYXIsIHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGRyYXdHcmlkKCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge2FuZ2xlTGluZXMsIGdyaWR9ID0gb3B0cztcbiAgICBjb25zdCBsYWJlbENvdW50ID0gdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICAgIGxldCBpLCBvZmZzZXQsIHBvc2l0aW9uO1xuICAgIGlmIChvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGRyYXdQb2ludExhYmVscyh0aGlzLCBsYWJlbENvdW50KTtcbiAgICB9XG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRpY2sudmFsdWUpO1xuICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCAtIDEpKTtcbiAgICAgICAgICBkcmF3UmFkaXVzTGluZSh0aGlzLCBvcHRzQXRJbmRleCwgb2Zmc2V0LCBsYWJlbENvdW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChhbmdsZUxpbmVzLmRpc3BsYXkpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBmb3IgKGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBhbmdsZUxpbmVzLnNldENvbnRleHQodGhpcy5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgICAgIGNvbnN0IHtjb2xvciwgbGluZVdpZHRofSA9IG9wdHNBdEluZGV4O1xuICAgICAgICBpZiAoIWxpbmVXaWR0aCB8fCAhY29sb3IpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKG9wdHNBdEluZGV4LmJvcmRlckRhc2gpO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC5ib3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKG9wdHMudGlja3MucmV2ZXJzZSA/IHRoaXMubWluIDogdGhpcy5tYXgpO1xuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpLCBvZmZzZXQpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8odGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgICAgICBjdHgubGluZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBkcmF3Qm9yZGVyKCkge31cbiAgZHJhd0xhYmVscygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcbiAgICBpZiAoIXRpY2tPcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZSgwKTtcbiAgICBsZXQgb2Zmc2V0LCB3aWR0aDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2xhdGUodGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgIGN0eC5yb3RhdGUoc3RhcnRBbmdsZSk7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICB0aGlzLnRpY2tzLmZvckVhY2goKHRpY2ssIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW5kZXggPT09IDAgJiYgIW9wdHMucmV2ZXJzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IHRpY2tPcHRzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICBjb25zdCB0aWNrRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy50aWNrc1tpbmRleF0udmFsdWUpO1xuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgICB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aWNrLmxhYmVsKS53aWR0aDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3I7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgIC13aWR0aCAvIDIgLSBwYWRkaW5nLmxlZnQsXG4gICAgICAgICAgLW9mZnNldCAtIHRpY2tGb250LnNpemUgLyAyIC0gcGFkZGluZy50b3AsXG4gICAgICAgICAgd2lkdGggKyBwYWRkaW5nLndpZHRoLFxuICAgICAgICAgIHRpY2tGb250LnNpemUgKyBwYWRkaW5nLmhlaWdodFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmVuZGVyVGV4dChjdHgsIHRpY2subGFiZWwsIDAsIC1vZmZzZXQsIHRpY2tGb250LCB7XG4gICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5jb2xvcixcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgZHJhd1RpdGxlKCkge31cbn1cblJhZGlhbExpbmVhclNjYWxlLmlkID0gJ3JhZGlhbExpbmVhcic7XG5SYWRpYWxMaW5lYXJTY2FsZS5kZWZhdWx0cyA9IHtcbiAgZGlzcGxheTogdHJ1ZSxcbiAgYW5pbWF0ZTogdHJ1ZSxcbiAgcG9zaXRpb246ICdjaGFydEFyZWEnLFxuICBhbmdsZUxpbmVzOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBsaW5lV2lkdGg6IDEsXG4gICAgYm9yZGVyRGFzaDogW10sXG4gICAgYm9yZGVyRGFzaE9mZnNldDogMC4wXG4gIH0sXG4gIGdyaWQ6IHtcbiAgICBjaXJjdWxhcjogZmFsc2VcbiAgfSxcbiAgc3RhcnRBbmdsZTogMCxcbiAgdGlja3M6IHtcbiAgICBzaG93TGFiZWxCYWNrZHJvcDogdHJ1ZSxcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gIH0sXG4gIHBvaW50TGFiZWxzOiB7XG4gICAgYmFja2Ryb3BDb2xvcjogdW5kZWZpbmVkLFxuICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHNpemU6IDEwXG4gICAgfSxcbiAgICBjYWxsYmFjayhsYWJlbCkge1xuICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH0sXG4gICAgcGFkZGluZzogNSxcbiAgICBjZW50ZXJQb2ludExhYmVsczogZmFsc2VcbiAgfVxufTtcblJhZGlhbExpbmVhclNjYWxlLmRlZmF1bHRSb3V0ZXMgPSB7XG4gICdhbmdsZUxpbmVzLmNvbG9yJzogJ2JvcmRlckNvbG9yJyxcbiAgJ3BvaW50TGFiZWxzLmNvbG9yJzogJ2NvbG9yJyxcbiAgJ3RpY2tzLmNvbG9yJzogJ2NvbG9yJ1xufTtcblJhZGlhbExpbmVhclNjYWxlLmRlc2NyaXB0b3JzID0ge1xuICBhbmdsZUxpbmVzOiB7XG4gICAgX2ZhbGxiYWNrOiAnZ3JpZCdcbiAgfVxufTtcblxuY29uc3QgSU5URVJWQUxTID0ge1xuICBtaWxsaXNlY29uZDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMSwgc3RlcHM6IDEwMDB9LFxuICBzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEwMDAsIHN0ZXBzOiA2MH0sXG4gIG1pbnV0ZToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogNjAwMDAsIHN0ZXBzOiA2MH0sXG4gIGhvdXI6IHtjb21tb246IHRydWUsIHNpemU6IDM2MDAwMDAsIHN0ZXBzOiAyNH0sXG4gIGRheToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogODY0MDAwMDAsIHN0ZXBzOiAzMH0sXG4gIHdlZWs6IHtjb21tb246IGZhbHNlLCBzaXplOiA2MDQ4MDAwMDAsIHN0ZXBzOiA0fSxcbiAgbW9udGg6IHtjb21tb246IHRydWUsIHNpemU6IDIuNjI4ZTksIHN0ZXBzOiAxMn0sXG4gIHF1YXJ0ZXI6IHtjb21tb246IGZhbHNlLCBzaXplOiA3Ljg4NGU5LCBzdGVwczogNH0sXG4gIHllYXI6IHtjb21tb246IHRydWUsIHNpemU6IDMuMTU0ZTEwfVxufTtcbmNvbnN0IFVOSVRTID0gKE9iamVjdC5rZXlzKElOVEVSVkFMUykpO1xuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuZnVuY3Rpb24gcGFyc2Uoc2NhbGUsIGlucHV0KSB7XG4gIGlmIChpc051bGxPclVuZGVmKGlucHV0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3Qge3BhcnNlciwgcm91bmQsIGlzb1dlZWtkYXl9ID0gc2NhbGUuX3BhcnNlT3B0cztcbiAgbGV0IHZhbHVlID0gaW5wdXQ7XG4gIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSBwYXJzZXIodmFsdWUpO1xuICB9XG4gIGlmICghaXNOdW1iZXJGaW5pdGUodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB0eXBlb2YgcGFyc2VyID09PSAnc3RyaW5nJ1xuICAgICAgPyBhZGFwdGVyLnBhcnNlKHZhbHVlLCBwYXJzZXIpXG4gICAgICA6IGFkYXB0ZXIucGFyc2UodmFsdWUpO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChyb3VuZCkge1xuICAgIHZhbHVlID0gcm91bmQgPT09ICd3ZWVrJyAmJiAoaXNOdW1iZXIoaXNvV2Vla2RheSkgfHwgaXNvV2Vla2RheSA9PT0gdHJ1ZSlcbiAgICAgID8gYWRhcHRlci5zdGFydE9mKHZhbHVlLCAnaXNvV2VlaycsIGlzb1dlZWtkYXkpXG4gICAgICA6IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgcm91bmQpO1xuICB9XG4gIHJldHVybiArdmFsdWU7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKG1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xuICBjb25zdCBpbGVuID0gVU5JVFMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpIHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IElOVEVSVkFMU1tVTklUU1tpXV07XG4gICAgY29uc3QgZmFjdG9yID0gaW50ZXJ2YWwuc3RlcHMgPyBpbnRlcnZhbC5zdGVwcyA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIGlmIChpbnRlcnZhbC5jb21tb24gJiYgTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKGZhY3RvciAqIGludGVydmFsLnNpemUpKSA8PSBjYXBhY2l0eSkge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gVU5JVFNbaWxlbiAtIDFdO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcoc2NhbGUsIG51bVRpY2tzLCBtaW5Vbml0LCBtaW4sIG1heCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMubGVuZ3RoIC0gMTsgaSA+PSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpLS0pIHtcbiAgICBjb25zdCB1bml0ID0gVU5JVFNbaV07XG4gICAgaWYgKElOVEVSVkFMU1t1bml0XS5jb21tb24gJiYgc2NhbGUuX2FkYXB0ZXIuZGlmZihtYXgsIG1pbiwgdW5pdCkgPj0gbnVtVGlja3MgLSAxKSB7XG4gICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFVOSVRTW21pblVuaXQgPyBVTklUUy5pbmRleE9mKG1pblVuaXQpIDogMF07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVNYWpvclVuaXQodW5pdCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZih1bml0KSArIDEsIGlsZW4gPSBVTklUUy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpZiAoSU5URVJWQUxTW1VOSVRTW2ldXS5jb21tb24pIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpIHtcbiAgaWYgKCF0aW1lc3RhbXBzKSB7XG4gICAgdGlja3NbdGltZV0gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgY29uc3Qge2xvLCBoaX0gPSBfbG9va3VwKHRpbWVzdGFtcHMsIHRpbWUpO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHRpbWVzdGFtcHNbbG9dID49IHRpbWUgPyB0aW1lc3RhbXBzW2xvXSA6IHRpbWVzdGFtcHNbaGldO1xuICAgIHRpY2tzW3RpbWVzdGFtcF0gPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YodGlja3NbMF0udmFsdWUsIG1ham9yVW5pdCk7XG4gIGNvbnN0IGxhc3QgPSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgbGV0IG1ham9yLCBpbmRleDtcbiAgZm9yIChtYWpvciA9IGZpcnN0OyBtYWpvciA8PSBsYXN0OyBtYWpvciA9ICthZGFwdGVyLmFkZChtYWpvciwgMSwgbWFqb3JVbml0KSkge1xuICAgIGluZGV4ID0gbWFwW21ham9yXTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGlja3NbaW5kZXhdLm1ham9yID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuZnVuY3Rpb24gdGlja3NGcm9tVGltZXN0YW1wcyhzY2FsZSwgdmFsdWVzLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgY29uc3QgbWFwID0ge307XG4gIGNvbnN0IGlsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICBsZXQgaSwgdmFsdWU7XG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICBtYXBbdmFsdWVdID0gaTtcbiAgICB0aWNrcy5wdXNoKHtcbiAgICAgIHZhbHVlLFxuICAgICAgbWFqb3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIChpbGVuID09PSAwIHx8ICFtYWpvclVuaXQpID8gdGlja3MgOiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpO1xufVxuY2xhc3MgVGltZVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuICAgIHRoaXMuX3VuaXQgPSAnZGF5JztcbiAgICB0aGlzLl9tYWpvclVuaXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IHt9O1xuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdChzY2FsZU9wdHMsIG9wdHMpIHtcbiAgICBjb25zdCB0aW1lID0gc2NhbGVPcHRzLnRpbWUgfHwgKHNjYWxlT3B0cy50aW1lID0ge30pO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyID0gbmV3IGFkYXB0ZXJzLl9kYXRlKHNjYWxlT3B0cy5hZGFwdGVycy5kYXRlKTtcbiAgICBtZXJnZUlmKHRpbWUuZGlzcGxheUZvcm1hdHMsIGFkYXB0ZXIuZm9ybWF0cygpKTtcbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB7XG4gICAgICBwYXJzZXI6IHRpbWUucGFyc2VyLFxuICAgICAgcm91bmQ6IHRpbWUucm91bmQsXG4gICAgICBpc29XZWVrZGF5OiB0aW1lLmlzb1dlZWtkYXlcbiAgICB9O1xuICAgIHN1cGVyLmluaXQoc2NhbGVPcHRzKTtcbiAgICB0aGlzLl9ub3JtYWxpemVkID0gb3B0cy5ub3JtYWxpemVkO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAocmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2UodGhpcywgcmF3KTtcbiAgfVxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgc3VwZXIuYmVmb3JlTGF5b3V0KCk7XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgdW5pdCA9IG9wdGlvbnMudGltZS51bml0IHx8ICdkYXknO1xuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgZnVuY3Rpb24gX2FwcGx5Qm91bmRzKGJvdW5kcykge1xuICAgICAgaWYgKCFtaW5EZWZpbmVkICYmICFpc05hTihib3VuZHMubWluKSkge1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGJvdW5kcy5taW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkICYmICFpc05hTihib3VuZHMubWF4KSkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGJvdW5kcy5tYXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW1pbkRlZmluZWQgfHwgIW1heERlZmluZWQpIHtcbiAgICAgIF9hcHBseUJvdW5kcyh0aGlzLl9nZXRMYWJlbEJvdW5kcygpKTtcbiAgICAgIGlmIChvcHRpb25zLmJvdW5kcyAhPT0gJ3RpY2tzJyB8fCBvcHRpb25zLnRpY2tzLnNvdXJjZSAhPT0gJ2xhYmVscycpIHtcbiAgICAgICAgX2FwcGx5Qm91bmRzKHRoaXMuZ2V0TWluTWF4KGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIG1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiArYWRhcHRlci5zdGFydE9mKERhdGUubm93KCksIHVuaXQpO1xuICAgIG1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiArYWRhcHRlci5lbmRPZihEYXRlLm5vdygpLCB1bml0KSArIDE7XG4gICAgdGhpcy5taW4gPSBNYXRoLm1pbihtaW4sIG1heCAtIDEpO1xuICAgIHRoaXMubWF4ID0gTWF0aC5tYXgobWluICsgMSwgbWF4KTtcbiAgfVxuICBfZ2V0TGFiZWxCb3VuZHMoKSB7XG4gICAgY29uc3QgYXJyID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBsZXQgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICAgIG1pbiA9IGFyclswXTtcbiAgICAgIG1heCA9IGFyclthcnIubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiB7bWluLCBtYXh9O1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRpY2tPcHRzLnNvdXJjZSA9PT0gJ2xhYmVscycgPyB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpIDogdGhpcy5fZ2VuZXJhdGUoKTtcbiAgICBpZiAob3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubWluID0gdGhpcy5fdXNlck1pbiB8fCB0aW1lc3RhbXBzWzBdO1xuICAgICAgdGhpcy5tYXggPSB0aGlzLl91c2VyTWF4IHx8IHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3QgdGlja3MgPSBfZmlsdGVyQmV0d2Vlbih0aW1lc3RhbXBzLCBtaW4sIG1heCk7XG4gICAgdGhpcy5fdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgKHRpY2tPcHRzLmF1dG9Ta2lwXG4gICAgICA/IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpXG4gICAgICA6IGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHRoaXMsIHRpY2tzLmxlbmd0aCwgdGltZU9wdHMubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4KSk7XG4gICAgdGhpcy5fbWFqb3JVbml0ID0gIXRpY2tPcHRzLm1ham9yLmVuYWJsZWQgfHwgdGhpcy5fdW5pdCA9PT0gJ3llYXInID8gdW5kZWZpbmVkXG4gICAgICA6IGRldGVybWluZU1ham9yVW5pdCh0aGlzLl91bml0KTtcbiAgICB0aGlzLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgdGlja3MsIHRoaXMuX21ham9yVW5pdCk7XG4gIH1cbiAgaW5pdE9mZnNldHModGltZXN0YW1wcykge1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IDA7XG4gICAgbGV0IGZpcnN0LCBsYXN0O1xuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0ICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICBmaXJzdCA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbMF0pO1xuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gMSAtIGZpcnN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSAodGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1sxXSkgLSBmaXJzdCkgLyAyO1xuICAgICAgfVxuICAgICAgbGFzdCA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZW5kID0gbGFzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IChsYXN0IC0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDJdKSkgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsaW1pdCA9IHRpbWVzdGFtcHMubGVuZ3RoIDwgMyA/IDAuNSA6IDAuMjU7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShzdGFydCwgMCwgbGltaXQpO1xuICAgIGVuZCA9IF9saW1pdFZhbHVlKGVuZCwgMCwgbGltaXQpO1xuICAgIHRoaXMuX29mZnNldHMgPSB7c3RhcnQsIGVuZCwgZmFjdG9yOiAxIC8gKHN0YXJ0ICsgMSArIGVuZCl9O1xuICB9XG4gIF9nZW5lcmF0ZSgpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IG1pbm9yID0gdGltZU9wdHMudW5pdCB8fCBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIG1pbiwgbWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpO1xuICAgIGNvbnN0IHN0ZXBTaXplID0gdmFsdWVPckRlZmF1bHQodGltZU9wdHMuc3RlcFNpemUsIDEpO1xuICAgIGNvbnN0IHdlZWtkYXkgPSBtaW5vciA9PT0gJ3dlZWsnID8gdGltZU9wdHMuaXNvV2Vla2RheSA6IGZhbHNlO1xuICAgIGNvbnN0IGhhc1dlZWtkYXkgPSBpc051bWJlcih3ZWVrZGF5KSB8fCB3ZWVrZGF5ID09PSB0cnVlO1xuICAgIGNvbnN0IHRpY2tzID0ge307XG4gICAgbGV0IGZpcnN0ID0gbWluO1xuICAgIGxldCB0aW1lLCBjb3VudDtcbiAgICBpZiAoaGFzV2Vla2RheSkge1xuICAgICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCAnaXNvV2VlaycsIHdlZWtkYXkpO1xuICAgIH1cbiAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsIGhhc1dlZWtkYXkgPyAnZGF5JyA6IG1pbm9yKTtcbiAgICBpZiAoYWRhcHRlci5kaWZmKG1heCwgbWluLCBtaW5vcikgPiAxMDAwMDAgKiBzdGVwU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1pbiArICcgYW5kICcgKyBtYXggKyAnIGFyZSB0b28gZmFyIGFwYXJ0IHdpdGggc3RlcFNpemUgb2YgJyArIHN0ZXBTaXplICsgJyAnICsgbWlub3IpO1xuICAgIH1cbiAgICBjb25zdCB0aW1lc3RhbXBzID0gb3B0aW9ucy50aWNrcy5zb3VyY2UgPT09ICdkYXRhJyAmJiB0aGlzLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgZm9yICh0aW1lID0gZmlyc3QsIGNvdW50ID0gMDsgdGltZSA8IG1heDsgdGltZSA9ICthZGFwdGVyLmFkZCh0aW1lLCBzdGVwU2l6ZSwgbWlub3IpLCBjb3VudCsrKSB7XG4gICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICB9XG4gICAgaWYgKHRpbWUgPT09IG1heCB8fCBvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyB8fCBjb3VudCA9PT0gMSkge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aWNrcykuc29ydCgoYSwgYikgPT4gYSAtIGIpLm1hcCh4ID0+ICt4KTtcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgdGltZU9wdHMgPSB0aGlzLm9wdGlvbnMudGltZTtcbiAgICBpZiAodGltZU9wdHMudG9vbHRpcEZvcm1hdCkge1xuICAgICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy50b29sdGlwRm9ybWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cy5kYXRldGltZSk7XG4gIH1cbiAgX3RpY2tGb3JtYXRGdW5jdGlvbih0aW1lLCBpbmRleCwgdGlja3MsIGZvcm1hdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCB1bml0ID0gdGhpcy5fdW5pdDtcbiAgICBjb25zdCBtYWpvclVuaXQgPSB0aGlzLl9tYWpvclVuaXQ7XG4gICAgY29uc3QgbWlub3JGb3JtYXQgPSB1bml0ICYmIGZvcm1hdHNbdW5pdF07XG4gICAgY29uc3QgbWFqb3JGb3JtYXQgPSBtYWpvclVuaXQgJiYgZm9ybWF0c1ttYWpvclVuaXRdO1xuICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpbmRleF07XG4gICAgY29uc3QgbWFqb3IgPSBtYWpvclVuaXQgJiYgbWFqb3JGb3JtYXQgJiYgdGljayAmJiB0aWNrLm1ham9yO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5fYWRhcHRlci5mb3JtYXQodGltZSwgZm9ybWF0IHx8IChtYWpvciA/IG1ham9yRm9ybWF0IDogbWlub3JGb3JtYXQpKTtcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBvcHRpb25zLnRpY2tzLmNhbGxiYWNrO1xuICAgIHJldHVybiBmb3JtYXR0ZXIgPyBjYWxsYmFjayhmb3JtYXR0ZXIsIFtsYWJlbCwgaW5kZXgsIHRpY2tzXSwgdGhpcykgOiBsYWJlbDtcbiAgfVxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBsZXQgaSwgaWxlbiwgdGljaztcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKHRpY2sudmFsdWUsIGksIHRpY2tzKTtcbiAgICB9XG4gIH1cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKChvZmZzZXRzLnN0YXJ0ICsgcG9zKSAqIG9mZnNldHMuZmFjdG9yKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gdGhpcy5taW4gKyBwb3MgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cbiAgX2dldExhYmVsU2l6ZShsYWJlbCkge1xuICAgIGNvbnN0IHRpY2tzT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aWNrTGFiZWxXaWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgICBjb25zdCBhbmdsZSA9IHRvUmFkaWFucyh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGlja3NPcHRzLm1heFJvdGF0aW9uIDogdGlja3NPcHRzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBjb25zdCBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBjb25zdCB0aWNrRm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLnNpemU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHc6ICh0aWNrTGFiZWxXaWR0aCAqIGNvc1JvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBzaW5Sb3RhdGlvbiksXG4gICAgICBoOiAodGlja0xhYmVsV2lkdGggKiBzaW5Sb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogY29zUm90YXRpb24pXG4gICAgfTtcbiAgfVxuICBfZ2V0TGFiZWxDYXBhY2l0eShleGFtcGxlVGltZSkge1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgY29uc3QgZGlzcGxheUZvcm1hdHMgPSB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCBmb3JtYXQgPSBkaXNwbGF5Rm9ybWF0c1t0aW1lT3B0cy51bml0XSB8fCBkaXNwbGF5Rm9ybWF0cy5taWxsaXNlY29uZDtcbiAgICBjb25zdCBleGFtcGxlTGFiZWwgPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24oZXhhbXBsZVRpbWUsIDAsIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgW2V4YW1wbGVUaW1lXSwgdGhpcy5fbWFqb3JVbml0KSwgZm9ybWF0KTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0TGFiZWxTaXplKGV4YW1wbGVMYWJlbCk7XG4gICAgY29uc3QgY2FwYWNpdHkgPSBNYXRoLmZsb29yKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIC8gc2l6ZS53IDogdGhpcy5oZWlnaHQgLyBzaXplLmgpIC0gMTtcbiAgICByZXR1cm4gY2FwYWNpdHkgPiAwID8gY2FwYWNpdHkgOiAxO1xuICB9XG4gIGdldERhdGFUaW1lc3RhbXBzKCkge1xuICAgIGxldCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuZGF0YSB8fCBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICBpZiAodGhpcy5fbm9ybWFsaXplZCAmJiBtZXRhcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAodGhpcy5fY2FjaGUuZGF0YSA9IG1ldGFzWzBdLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpKTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGltZXN0YW1wcyA9IHRpbWVzdGFtcHMuY29uY2F0KG1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG4gIGdldExhYmVsVGltZXN0YW1wcygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUubGFiZWxzIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMucHVzaChwYXJzZSh0aGlzLCBsYWJlbHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5sYWJlbHMgPSB0aGlzLl9ub3JtYWxpemVkID8gdGltZXN0YW1wcyA6IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuICBub3JtYWxpemUodmFsdWVzKSB7XG4gICAgcmV0dXJuIF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydChzb3J0ZXIpKTtcbiAgfVxufVxuVGltZVNjYWxlLmlkID0gJ3RpbWUnO1xuVGltZVNjYWxlLmRlZmF1bHRzID0ge1xuICBib3VuZHM6ICdkYXRhJyxcbiAgYWRhcHRlcnM6IHt9LFxuICB0aW1lOiB7XG4gICAgcGFyc2VyOiBmYWxzZSxcbiAgICB1bml0OiBmYWxzZSxcbiAgICByb3VuZDogZmFsc2UsXG4gICAgaXNvV2Vla2RheTogZmFsc2UsXG4gICAgbWluVW5pdDogJ21pbGxpc2Vjb25kJyxcbiAgICBkaXNwbGF5Rm9ybWF0czoge31cbiAgfSxcbiAgdGlja3M6IHtcbiAgICBzb3VyY2U6ICdhdXRvJyxcbiAgICBtYWpvcjoge1xuICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKHRhYmxlLCB2YWwsIHJldmVyc2UpIHtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZTb3VyY2UsIG5leHRTb3VyY2UsIHByZXZUYXJnZXQsIG5leHRUYXJnZXQ7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgaWYgKHZhbCA+PSB0YWJsZVtsb10ucG9zICYmIHZhbCA8PSB0YWJsZVtoaV0ucG9zKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICdwb3MnLCB2YWwpKTtcbiAgICB9XG4gICAgKHtwb3M6IHByZXZTb3VyY2UsIHRpbWU6IHByZXZUYXJnZXR9ID0gdGFibGVbbG9dKTtcbiAgICAoe3BvczogbmV4dFNvdXJjZSwgdGltZTogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnRpbWUgJiYgdmFsIDw9IHRhYmxlW2hpXS50aW1lKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICd0aW1lJywgdmFsKSk7XG4gICAgfVxuICAgICh7dGltZTogcHJldlNvdXJjZSwgcG9zOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHt0aW1lOiBuZXh0U291cmNlLCBwb3M6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfVxuICBjb25zdCBzcGFuID0gbmV4dFNvdXJjZSAtIHByZXZTb3VyY2U7XG4gIHJldHVybiBzcGFuID8gcHJldlRhcmdldCArIChuZXh0VGFyZ2V0IC0gcHJldlRhcmdldCkgKiAodmFsIC0gcHJldlNvdXJjZSkgLyBzcGFuIDogcHJldlRhcmdldDtcbn1cbmNsYXNzIFRpbWVTZXJpZXNTY2FsZSBleHRlbmRzIFRpbWVTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuX3RhYmxlID0gW107XG4gICAgdGhpcy5fbWluUG9zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdE9mZnNldHMoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpO1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5fdGFibGUgPSB0aGlzLmJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcyk7XG4gICAgdGhpcy5fbWluUG9zID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWluKTtcbiAgICB0aGlzLl90YWJsZVJhbmdlID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWF4KSAtIHRoaXMuX21pblBvcztcbiAgICBzdXBlci5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcbiAgfVxuICBidWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IHRhYmxlID0gW107XG4gICAgbGV0IGksIGlsZW4sIHByZXYsIGN1cnIsIG5leHQ7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjdXJyID0gdGltZXN0YW1wc1tpXTtcbiAgICAgIGlmIChjdXJyID49IG1pbiAmJiBjdXJyIDw9IG1heCkge1xuICAgICAgICBpdGVtcy5wdXNoKGN1cnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3RpbWU6IG1pbiwgcG9zOiAwfSxcbiAgICAgICAge3RpbWU6IG1heCwgcG9zOiAxfVxuICAgICAgXTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgbmV4dCA9IGl0ZW1zW2kgKyAxXTtcbiAgICAgIHByZXYgPSBpdGVtc1tpIC0gMV07XG4gICAgICBjdXJyID0gaXRlbXNbaV07XG4gICAgICBpZiAoTWF0aC5yb3VuZCgobmV4dCArIHByZXYpIC8gMikgIT09IGN1cnIpIHtcbiAgICAgICAgdGFibGUucHVzaCh7dGltZTogY3VyciwgcG9zOiBpIC8gKGlsZW4gLSAxKX0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFibGU7XG4gIH1cbiAgX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpIHtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmFsbCB8fCBbXTtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggJiYgbGFiZWwubGVuZ3RoKSB7XG4gICAgICB0aW1lc3RhbXBzID0gdGhpcy5ub3JtYWxpemUoZGF0YS5jb25jYXQobGFiZWwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZXN0YW1wcyA9IGRhdGEubGVuZ3RoID8gZGF0YSA6IGxhYmVsO1xuICAgIH1cbiAgICB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuYWxsID0gdGltZXN0YW1wcztcbiAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgfVxuICBnZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gKGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCB2YWx1ZSkgLSB0aGlzLl9taW5Qb3MpIC8gdGhpcy5fdGFibGVSYW5nZTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCBkZWNpbWFsICogdGhpcy5fdGFibGVSYW5nZSArIHRoaXMuX21pblBvcywgdHJ1ZSk7XG4gIH1cbn1cblRpbWVTZXJpZXNTY2FsZS5pZCA9ICd0aW1lc2VyaWVzJztcblRpbWVTZXJpZXNTY2FsZS5kZWZhdWx0cyA9IFRpbWVTY2FsZS5kZWZhdWx0cztcblxudmFyIHNjYWxlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkNhdGVnb3J5U2NhbGU6IENhdGVnb3J5U2NhbGUsXG5MaW5lYXJTY2FsZTogTGluZWFyU2NhbGUsXG5Mb2dhcml0aG1pY1NjYWxlOiBMb2dhcml0aG1pY1NjYWxlLFxuUmFkaWFsTGluZWFyU2NhbGU6IFJhZGlhbExpbmVhclNjYWxlLFxuVGltZVNjYWxlOiBUaW1lU2NhbGUsXG5UaW1lU2VyaWVzU2NhbGU6IFRpbWVTZXJpZXNTY2FsZVxufSk7XG5cbmNvbnN0IHJlZ2lzdGVyYWJsZXMgPSBbXG4gIGNvbnRyb2xsZXJzLFxuICBlbGVtZW50cyxcbiAgcGx1Z2lucyxcbiAgc2NhbGVzLFxuXTtcblxuZXhwb3J0IHsgQW5pbWF0aW9uLCBBbmltYXRpb25zLCBBcmNFbGVtZW50LCBCYXJDb250cm9sbGVyLCBCYXJFbGVtZW50LCBCYXNlUGxhdGZvcm0sIEJhc2ljUGxhdGZvcm0sIEJ1YmJsZUNvbnRyb2xsZXIsIENhdGVnb3J5U2NhbGUsIENoYXJ0LCBEYXRhc2V0Q29udHJvbGxlciwgcGx1Z2luX2RlY2ltYXRpb24gYXMgRGVjaW1hdGlvbiwgRG9tUGxhdGZvcm0sIERvdWdobnV0Q29udHJvbGxlciwgRWxlbWVudCwgcGx1Z2luX2ZpbGxlciBhcyBGaWxsZXIsIEludGVyYWN0aW9uLCBwbHVnaW5fbGVnZW5kIGFzIExlZ2VuZCwgTGluZUNvbnRyb2xsZXIsIExpbmVFbGVtZW50LCBMaW5lYXJTY2FsZSwgTG9nYXJpdGhtaWNTY2FsZSwgUGllQ29udHJvbGxlciwgUG9pbnRFbGVtZW50LCBQb2xhckFyZWFDb250cm9sbGVyLCBSYWRhckNvbnRyb2xsZXIsIFJhZGlhbExpbmVhclNjYWxlLCBTY2FsZSwgU2NhdHRlckNvbnRyb2xsZXIsIHBsdWdpbl9zdWJ0aXRsZSBhcyBTdWJUaXRsZSwgVGlja3MsIFRpbWVTY2FsZSwgVGltZVNlcmllc1NjYWxlLCBwbHVnaW5fdGl0bGUgYXMgVGl0bGUsIHBsdWdpbl90b29sdGlwIGFzIFRvb2x0aXAsIGFkYXB0ZXJzIGFzIF9hZGFwdGVycywgX2RldGVjdFBsYXRmb3JtLCBhbmltYXRvciwgY29udHJvbGxlcnMsIGVsZW1lbnRzLCBsYXlvdXRzLCBwbHVnaW5zLCByZWdpc3RlcmFibGVzLCByZWdpc3RyeSwgc2NhbGVzIH07XG4iLCAiPHNjcmlwdD5cbiAgaW1wb3J0IHtvbk1vdW50LCBhZnRlclVwZGF0ZSwgb25EZXN0cm95fSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQge2NsZWFufSBmcm9tICcuL3V0aWxzJztcbiAgaW1wb3J0IHtDaGFydCwgcmVnaXN0ZXJhYmxlc30gZnJvbSAnY2hhcnQuanMvZGlzdC9jaGFydC5lc20nO1xuICBDaGFydC5yZWdpc3RlciguLi5yZWdpc3RlcmFibGVzKTtcblxuICAvLyAgRXhwZWN0ZWQgZGF0YVxuICBleHBvcnQgbGV0IGRhdGEgPSB7XG4gICAgbGFiZWxzOiBbXSxcbiAgICBkYXRhc2V0czogW1xuICAgICAge2RhdGE6IFtdfVxuICAgIF0sXG4gICAgeU1hcmtlcnM6IHt9LFxuICAgIHlSZWdpb25zOiBbXSxcbiAgfTtcbiAgZXhwb3J0IGxldCB0eXBlID0gJ2xpbmUnO1xuICBleHBvcnQgbGV0IG9wdGlvbnMgPSB7fTtcbiAgZXhwb3J0IGxldCBwbHVnaW5zID0gW107XG4gIGxldCBjaGFydCA9IG51bGw7XG4gIGxldCBjaGFydFJlZjtcbiAgbGV0IHByb3BzID0gY2xlYW4oJCRwcm9wcywgW1wiZGF0YVwiLCBcInR5cGVcIiwgXCJvcHRpb25zXCIsIFwicGx1Z2luc1wiXSk7XG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIGNoYXJ0ID0gbmV3IENoYXJ0KGNoYXJ0UmVmLCB7XG4gICAgICB0eXBlLFxuICAgICAgZGF0YSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBwbHVnaW5zXG4gICAgfSk7XG4gIH0pO1xuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgaWYgKCFjaGFydCkgcmV0dXJuO1xuXG4gICAgY2hhcnQuZGF0YSA9IGRhdGE7XG4gICAgY2hhcnQudHlwZSA9IHR5cGU7XG4gICAgY2hhcnQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgY2hhcnQucGx1Z2lucyA9IHBsdWdpbnM7XG4gICAgY2hhcnQudXBkYXRlKClcbiAgfSk7XG5cbiAgb25EZXN0cm95KCgpID0+IHtcbiAgICBjaGFydCA9IG51bGw7XG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjxjYW52YXMgYmluZDp0aGlzPXtjaGFydFJlZn0gey4uLnByb3BzfT48L2NhbnZhcz5cbiIsICI8c2NyaXB0PlxuICBpbXBvcnQgQmFzZSBmcm9tICcuL0Jhc2Uuc3ZlbHRlJztcbjwvc2NyaXB0PlxuPEJhc2Ugey4uLiQkcHJvcHN9IHR5cGU9XCJzY2F0dGVyXCIgLz5cbiIsICI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxyXG5cdGltcG9ydCB7IERhdGVUaW1lIH0gZnJvbSBcImx1eG9uXCI7XHJcblxyXG5cdGV4cG9ydCBsZXQgY29sb3VyOiBzdHJpbmc7XHJcblx0ZXhwb3J0IGxldCBzdGFydERhdGU6IERhdGVUaW1lO1xyXG5cdGV4cG9ydCBsZXQgZW5kRGF0ZTogRGF0ZVRpbWU7XHJcblx0ZXhwb3J0IGxldCBkbk9ubHk6IGJvb2xlYW47XHJcblxyXG5cdGNvbnN0IG1pbkRhdGVTdHI6IHN0cmluZyA9IHN0YXJ0RGF0ZS50b0lTT0RhdGUoKTtcclxuXHRjb25zdCBtYXhEYXRlU3RyOiBzdHJpbmcgPSBlbmREYXRlLnRvSVNPRGF0ZSgpO1xyXG48L3NjcmlwdD5cclxuXHJcbjxpbnB1dCB0eXBlPVwiY29sb3JcIiBiaW5kOnZhbHVlPXtjb2xvdXJ9IC8+XHJcbjxsYWJlbFxyXG5cdD5EYXRlIFJhbmdlPGlucHV0XHJcblx0XHR0eXBlPVwiY2hlY2tib3hcIlxyXG5cdFx0Y2hlY2tlZD17ZG5Pbmx5fVxyXG5cdFx0b246Y2hhbmdlPXsoKSA9PiAoZG5Pbmx5ID0gIWRuT25seSl9XHJcblx0Lz48L2xhYmVsXHJcbj5cclxueyNpZiBkbk9ubHl9XHJcblx0PGxhYmVsPlxyXG5cdFx0U3RhcnRcclxuXHRcdDxpbnB1dFxyXG5cdFx0XHR0eXBlPVwiZGF0ZVwiXHJcblx0XHRcdHZhbHVlPXttaW5EYXRlU3RyfVxyXG5cdFx0XHRtaW49e21pbkRhdGVTdHJ9XHJcblx0XHRcdG1heD17bWF4RGF0ZVN0cn1cclxuXHRcdFx0b246Y2hhbmdlPXsoZSkgPT4gKHN0YXJ0RGF0ZSA9IERhdGVUaW1lLmZyb21JU08oZS50YXJnZXQudmFsdWUpKX1cclxuXHRcdC8+XHJcblx0PC9sYWJlbD5cclxuXHQ8bGFiZWw+XHJcblx0XHRFbmRcclxuXHRcdDxpbnB1dFxyXG5cdFx0XHR0eXBlPVwiZGF0ZVwiXHJcblx0XHRcdHZhbHVlPXttYXhEYXRlU3RyfVxyXG5cdFx0XHRtaW49e21pbkRhdGVTdHJ9XHJcblx0XHRcdG1heD17bWF4RGF0ZVN0cn1cclxuXHRcdFx0b246Y2hhbmdlPXsoZSkgPT4gKGVuZERhdGUgPSBEYXRlVGltZS5mcm9tSVNPKGUudGFyZ2V0LnZhbHVlKSl9XHJcblx0XHQvPlxyXG5cdDwvbGFiZWw+XHJcbnsvaWZ9XHJcbiIsICJpbXBvcnQgeyBTZXR0aW5ncyB9IGZyb20gXCIuL2ludGVyZmFjZXNcIjtcclxuaW1wb3J0IHsgcm91bmROdW1iZXIgfSBmcm9tIFwiLi91dGlsc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IENPUlJFTEFUSU9OX1ZJRVcgPSBcImNvcnJlbGF0aW9uLXZpZXdcIjtcclxuZXhwb3J0IGNvbnN0IENPUlJFTEFUSU9OX1JFUE9SVF9WSUVXID0gXCJjb3JyZWxhdGlvbi1yZXBvcnQtdmlld1wiO1xyXG5cclxuLyoqIE51bWJlciBvZiBkZWNpbWFscyBwbGFjZXMgdG8gcm91bmQgdG8sIGJ5IGRlZmF1bHQuXHJcbiAqXHJcbiAqIFVzZWQgYXMgYSBkZWZhdWx0IGluIHtAbGluayByb3VuZE51bWJlcn0uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgREVDSU1BTFMgPSA0O1xyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFNldHRpbmdzID0ge1xyXG5cdGZpZWxkc1RvQ2hlY2s6IFtdLFxyXG5cdGZpZWxkc1RvSWdub3JlRm9yQ29ycnM6IFtdLFxyXG5cdGZpZWxkTGlzdHM6IFtdLFxyXG5cdGRhdGVGb3JtYXQ6IFwiWVlZWS1NTS1ERFwiLFxyXG5cdGRlZmF1bHRTYXZlUGF0aDogXCIvXCIsXHJcblx0bnVsbFZhbHVlOiBcIm51bGxcIixcclxuXHR1bmRlZmluZWRWYWx1ZTogXCJ1bmRlZmluZWRcIixcclxuXHRhZGRGaWxlRGF0YTogZmFsc2UsXHJcblx0YWRkTm90ZUNvbnRlbnQ6IGZhbHNlLFxyXG59O1xyXG5cclxuLyoqIEdyYWJzIGFsbCB3aWtpbGlua3Mgb3V0IG9mIGEgc3RyaW5nICovXHJcbmV4cG9ydCBjb25zdCBzcGxpdExpbmtzUmVnZXggPSBuZXcgUmVnRXhwKC9cXFtcXFsoLio/KVxcXVxcXS9nKTtcclxuLyoqIFJldHVybnMgb25seSB0aGUgbm90ZSBuYW1lIGZyb20gYSB3aWtpbGluayAqL1xyXG5leHBvcnQgY29uc3QgZHJvcEhlYWRlck9yQWxpYXMgPSBuZXcgUmVnRXhwKC9cXFtcXFsoW14jfF0qKVxcXVxcXS8pO1xyXG4iLCAiaW1wb3J0IHsgSXRlbVZpZXcsIFdvcmtzcGFjZUxlYWYgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHsgYWRkRmVhdGhlckljb24gfSBmcm9tIFwib2JzaWRpYW4tY29tbXVuaXR5LWxpYlwiO1xyXG5pbXBvcnQgQ29ycmVsYXRpb25zUmVwb3J0IGZyb20gXCIuL0NvbXBvbmVudHMvQ29ycmVsYXRpb25zUmVwb3J0LnN2ZWx0ZVwiO1xyXG5pbXBvcnQgeyBDT1JSRUxBVElPTl9SRVBPUlRfVklFVyB9IGZyb20gXCIuL2NvbnN0XCI7XHJcbmltcG9ydCB7IGJ1aWxkQWxsQ29ycmVsYXRpb25zIH0gZnJvbSBcIi4vY29ycmVsYXRpb25VdGlsc1wiO1xyXG5pbXBvcnQgeyBQcmludGFibGVDb3JyZWxhdGlvbiB9IGZyb20gXCIuL2ludGVyZmFjZXNcIjtcclxuaW1wb3J0IHR5cGUgRGF0YUFuYWx5c2lzUGx1Z2luIGZyb20gXCIuL21haW5cIjtcclxuaW1wb3J0IHtcclxuXHRBTExfRklFTERTLFxyXG5cdGJ1aWxkRHJvcGRvd25PcHRpb25zRnJvbUNvcnJzLFxyXG5cdGJ1aWxkUHJpbnRhYmxlQ29ycnMsXHJcblx0Z2V0UmVwb3J0Q29ycnMsXHJcblx0dG9wM05lZ2F0aXZlQ29ycnMsXHJcblx0dG9wM1Bvc2l0aXZlQ29ycnMsXHJcbn0gZnJvbSBcIi4vcmVwb3J0Vmlld1V0aWxzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb3JyZWxhdGlvblZpZXcgZXh0ZW5kcyBJdGVtVmlldyB7XHJcblx0cGx1Z2luOiBEYXRhQW5hbHlzaXNQbHVnaW47XHJcblx0dmlldzogQ29ycmVsYXRpb25zUmVwb3J0O1xyXG5cclxuXHRtYXRyaXhROiBib29sZWFuO1xyXG5cdGxvd2VyOiBudW1iZXI7XHJcblx0bWVkaXVtOiBudW1iZXI7XHJcblx0bWF4OiBudW1iZXI7XHJcblx0bWluOiBudW1iZXI7XHJcblx0c2hvd1N0YW5kYXJkczogYm9vbGVhbjtcclxuXHRzaG93VG9wUG9zOiBib29sZWFuO1xyXG5cdHNob3dUb3BOZWc6IGJvb2xlYW47XHJcblx0c2hvd1N0cm9uZzogYm9vbGVhbjtcclxuXHRzaG93TWVkaXVtOiBib29sZWFuO1xyXG5cdHNob3dXZWFrOiBib29sZWFuO1xyXG5cdG1pbk46IG51bWJlcjtcclxuXHRjb3Jyc1RvU2hvdzogUHJpbnRhYmxlQ29ycmVsYXRpb25bXTtcclxuXHR0b3BQb3MzOiBQcmludGFibGVDb3JyZWxhdGlvbltdO1xyXG5cdHRvcE5lZzM6IFByaW50YWJsZUNvcnJlbGF0aW9uW107XHJcblx0c2VsZWN0ZWRGaWVsZDogc3RyaW5nO1xyXG5cdGZpZWxkT3B0aW9uczogc3RyaW5nW107XHJcblxyXG5cdGNvbnN0cnVjdG9yKGxlYWY6IFdvcmtzcGFjZUxlYWYsIHBsdWdpbjogRGF0YUFuYWx5c2lzUGx1Z2luKSB7XHJcblx0XHRzdXBlcihsZWFmKTtcclxuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG5cdFx0dGhpcy5sb3dlciA9IDAuNTtcclxuXHRcdHRoaXMubWVkaXVtID0gMC43NTtcclxuXHRcdHRoaXMubWF4ID0gOTk5OTtcclxuXHRcdHRoaXMubWluID0gLTk5OTk7XHJcblx0XHR0aGlzLnNob3dTdGFuZGFyZHMgPSB0cnVlO1xyXG5cdFx0dGhpcy5zaG93VG9wUG9zID0gdHJ1ZTtcclxuXHRcdHRoaXMuc2hvd1RvcE5lZyA9IHRydWU7XHJcblx0XHR0aGlzLnNob3dTdHJvbmcgPSB0cnVlO1xyXG5cdFx0dGhpcy5zaG93TWVkaXVtID0gdHJ1ZTtcclxuXHRcdHRoaXMuc2hvd1dlYWsgPSBmYWxzZTtcclxuXHRcdHRoaXMubWluTiA9IDE7XHJcblx0XHR0aGlzLmNvcnJzVG9TaG93ID0gW107XHJcblx0XHR0aGlzLnRvcFBvczMgPSBbXTtcclxuXHRcdHRoaXMudG9wTmVnMyA9IFtdO1xyXG5cdFx0dGhpcy5zZWxlY3RlZEZpZWxkID0gQUxMX0ZJRUxEUztcclxuXHRcdHRoaXMuZmllbGRPcHRpb25zID0gW0FMTF9GSUVMRFNdO1xyXG5cdFx0dGhpcy5jYWxjdWxhdGVSZXBvcnQoKTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIG9ubG9hZCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdHN1cGVyLm9ubG9hZCgpO1xyXG5cdH1cclxuXHJcblx0Z2V0Vmlld1R5cGUoKSB7XHJcblx0XHRyZXR1cm4gQ09SUkVMQVRJT05fUkVQT1JUX1ZJRVc7XHJcblx0fVxyXG5cdGdldERpc3BsYXlUZXh0KCkge1xyXG5cdFx0cmV0dXJuIFwiQ29ycmVsYXRpb25zIFZpZXdcIjtcclxuXHR9XHJcblxyXG5cdGljb24gPSBhZGRGZWF0aGVySWNvbihcInRyZW5kaW5nLXVwXCIpIGFzIHN0cmluZztcclxuXHJcblx0Y2FsY3VsYXRlUmVwb3J0ID0gKCkgPT4ge1xyXG5cdFx0dmFyIGRyb3Bkb3duQ29ycnMgPSBidWlsZFByaW50YWJsZUNvcnJzKHRoaXMucGx1Z2luLmluZGV4LmNvcnJzKVxyXG5cdFx0dGhpcy5jb3Jyc1RvU2hvdyA9IGdldFJlcG9ydENvcnJzKFxyXG5cdFx0XHRkcm9wZG93bkNvcnJzLFxyXG5cdFx0XHR0aGlzLnNlbGVjdGVkRmllbGQsXHJcblx0XHRcdHRoaXMubWF4LFxyXG5cdFx0XHR0aGlzLm1pblxyXG5cdFx0KTtcclxuXHRcdHRoaXMudG9wUG9zMyA9IHRvcDNQb3NpdGl2ZUNvcnJzKHRoaXMuY29ycnNUb1Nob3cpO1xyXG5cdFx0dGhpcy50b3BOZWczID0gdG9wM05lZ2F0aXZlQ29ycnModGhpcy5jb3Jyc1RvU2hvdyk7XHJcblx0XHR0aGlzLmZpZWxkT3B0aW9ucyA9IFtBTExfRklFTERTLCAuLi5idWlsZERyb3Bkb3duT3B0aW9uc0Zyb21Db3Jycyhkcm9wZG93bkNvcnJzKV1cclxuXHR9O1xyXG5cclxuXHRhc3luYyBvbk9wZW4oKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRhd2FpdCB0aGlzLmRyYXcoKTtcclxuXHR9XHJcblxyXG5cdG9uQ2xvc2UoKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHR0aGlzLnZpZXc/LiRkZXN0cm95KCk7XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcblx0fVxyXG5cclxuXHRhc3luYyBkcmF3KCk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgeyBjb250ZW50RWwsIHBsdWdpbiB9ID0gdGhpcztcclxuXHJcblx0XHRjb250ZW50RWwuZW1wdHkoKTtcclxuXHRcdGNvbnRlbnRFbC5hZGRDbGFzcyhcIkRBLWNvcnItdmlld1wiKTtcclxuXHJcblx0XHRjb250ZW50RWwuY3JlYXRlRWwoXHJcblx0XHRcdFwiYnV0dG9uXCIsXHJcblx0XHRcdHsgdGV4dDogXCJcdTIxQkJcIiwgYXR0cjogeyBcImFyaWEtbGFiZWxcIjogXCJSZWZyZXNoIEluZGV4ICYgUmVkcmF3XCIgfSB9LFxyXG5cdFx0XHQoYnV0KSA9PiB7XHJcblx0XHRcdFx0YnV0Lm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XHJcblx0XHRcdFx0XHRhd2FpdCBwbHVnaW4ucmVmcmVzaEluZGV4KCk7XHJcblx0XHRcdFx0XHRwbHVnaW4uaW5kZXguY29ycnMgPSBidWlsZEFsbENvcnJlbGF0aW9ucyhcclxuXHRcdFx0XHRcdFx0cGx1Z2luLmluZGV4LmRhdGEsXHJcblx0XHRcdFx0XHRcdHBsdWdpbi5zZXR0aW5ncy5maWVsZHNUb0NoZWNrLFxyXG5cdFx0XHRcdFx0XHRwbHVnaW4uc2V0dGluZ3MuZmllbGRzVG9JZ25vcmVGb3JDb3Jyc1xyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdHRoaXMuY2FsY3VsYXRlUmVwb3J0KCk7XHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLmRyYXcoKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblx0XHQpO1xyXG5cclxuXHRcdG5ldyBDb3JyZWxhdGlvbnNSZXBvcnQoeyB0YXJnZXQ6IGNvbnRlbnRFbCwgcHJvcHM6IHsgdmlldzogdGhpcyB9IH0pO1xyXG5cdH1cclxufVxyXG4iLCAiaW1wb3J0IHsgTWVudSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgeyBhZGRGZWF0aGVySWNvbiB9IGZyb20gXCJvYnNpZGlhbi1jb21tdW5pdHktbGliXCI7XHJcbmltcG9ydCB7IENoYXJ0TW9kYWwgfSBmcm9tIFwiLi9DaGFydE1vZGFsXCI7XHJcbmltcG9ydCB7IERFQ0lNQUxTIH0gZnJvbSBcIi4vY29uc3RcIjtcclxuaW1wb3J0IERhdGFBbmFseXNpc1BsdWdpbiBmcm9tIFwiLi9tYWluXCI7XHJcbmltcG9ydCB7IFN0YXRzTW9kYWwgfSBmcm9tIFwiLi9TdGF0c01vZGFsXCI7XHJcblxyXG4vKipcclxuICogU3BsaXQgYSBzdHJpbmcgYnkgYSBkZWxpbWl0ZXIgYW5kIHRyaW0gdGhlIHJlc3VsdGluZyBzdHJpbmdzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGRzIC0gVGhlIHN0cmluZyB0byBzcGxpdFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NwbGl0PVwiLFwiXSAtIFRoZSBzdHJpbmcgdG8gc3BsaXQgdGhlIGZpZWxkcyBvbi5cclxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBzcGxpdEFuZFRyaW0gPSAoZmllbGRzOiBzdHJpbmcsIHNwbGl0OiBzdHJpbmcgPSBcIixcIik6IHN0cmluZ1tdID0+IHtcclxuXHRpZiAoZmllbGRzID09PSBcIlwiKSByZXR1cm4gW107XHJcblx0ZWxzZSByZXR1cm4gZmllbGRzLnNwbGl0KHNwbGl0KS5tYXAoKHN0cikgPT4gc3RyLnRyaW0oKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogTWFrZSBhIGZsYXQgYXJyYXkgb3V0IG9mIHRoZSBpbnB1dC5cclxuICogQHBhcmFtIHtUIHwgVFtdfSBpbnB1dCAtIFRoZSBpbnB1dCB0byBmbGF0dGVuLlxyXG4gKiBAcmV0dXJucyBUaGUgYXJyYXkgb2YgdGhlIGlucHV0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1ha2VBcnIgPSA8VD4oaW5wdXQ6IFQgfCBUW10pID0+IFtpbnB1dF0uZmxhdCgpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBmaWVsZCBuYW1lIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIG9yaWdpbmFsIGZpZWxkIG5hbWUgd2l0aCB0aGUgc3ViIGZpZWxkIG5hbWUuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCAtIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBiZSBtb2RpZmllZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3ViIC0gdGhlIG5hbWUgb2YgdGhlIHN1Yi1maWVsZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2Nvbm5lY3Rvcj1cIi5cIl0gLSB0aGUgc3RyaW5nIHRvIHVzZSB0byBqb2luIHRoZSBmaWVsZCBhbmQgc3ViXHJcbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcgYFwiZmllbGQuc3ViXCJgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWFrZVN1YiA9IChmaWVsZDogc3RyaW5nLCBzdWI6IHN0cmluZywgY29ubmVjdG9yID0gXCIuXCIpID0+XHJcblx0ZmllbGQgKyBjb25uZWN0b3IgKyBzdWI7XHJcblxyXG4vKipcclxuICogSWYgdGhlIHN0cmluZyBpcyBgXCJ1bmRlZmluZWRcImAsIHJldHVybiBgdW5kZWZpbmVkYC4gSWYgdGhlIHN0cmluZyBpcyBgXCJudWxsXCJgLCByZXR1cm4gYG51bGxgLiBPdGhlcndpc2UsXHJcbnJldHVybiBgc3RyYC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gY29udmVydFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkIHwgbnVsbCB8IHN0cmluZ31cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb051bGxPclVuZGVmaW5lZChcclxuXHRzdHI6IHN0cmluZ1xyXG4pOiB1bmRlZmluZWQgfCBudWxsIHwgc3RyaW5nIHtcclxuXHRpZiAoc3RyID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gdW5kZWZpbmVkO1xyXG5cdGVsc2UgaWYgKHN0ciA9PT0gXCJudWxsXCIpIHJldHVybiBudWxsO1xyXG5cdGVsc2UgcmV0dXJuIHN0cjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIHR3byBhcnJheXMsIHJldHVybiB0aGUgZWxlbWVudHMgdGhhdCBhcmUgY29tbW9uIHRvIGJvdGguXHJcbiAqXHJcbiAqIEFuIGVsZW1lbnQgaXMgY29tbW9uIHRvIGJvdGggaWYgdGhlIHZhbHVlIGF0IHRoYXQgaW5kZXggaXMgIT09IHVuZGVmaW5lZCBpbiBib3RoIGFycmF5cy5cclxuICogQHBhcmFtIHthcnJheXR5cGV9IEEgLSBUaGUgZmlyc3QgYXJyYXkuXHJcbiAqIEBwYXJhbSB7YXJyYXl0eXBlfSBCIC0gVGhlIGFycmF5IG9mIHZhbHVlcyB0byBiZSBjb21wYXJlZCBhZ2FpbnN0XHJcbiAqIEByZXR1cm5zIHtbVFtdLCBUW11dfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5T3ZlcmxhcDxUPihBOiBUW10sIEI6IFRbXSk6IFtUW10sIFRbXV0ge1xyXG5cdGlmIChBLmxlbmd0aCAhPT0gQi5sZW5ndGgpIHJldHVybiBbW10sIFtdXTtcclxuXHJcblx0Y29uc3QgaUEgPSBBLmZpbHRlcigoYSkgPT4gYSAhPT0gdW5kZWZpbmVkKS5tYXAoKGEsIGkpID0+IGkpO1xyXG5cdGNvbnN0IGlCID0gQi5maWx0ZXIoKGIpID0+IGIgIT09IHVuZGVmaW5lZCkubWFwKChiLCBpKSA9PiBpKTtcclxuXHRjb25zdCBpT3ZlcmxhcCA9IGlBLmZpbHRlcigoaSkgPT4gaUIuaW5jbHVkZXMoaSkpO1xyXG5cclxuXHRjb25zdCBhT3ZlcmxhcCA9IEEuZmlsdGVyKChhLCBpKSA9PiBpT3ZlcmxhcC5pbmNsdWRlcyhpKSk7XHJcblx0Y29uc3QgYk92ZXJsYXAgPSBCLmZpbHRlcigoYiwgaSkgPT4gaU92ZXJsYXAuaW5jbHVkZXMoaSkpO1xyXG5cclxuXHRyZXR1cm4gW2FPdmVybGFwLCBiT3ZlcmxhcF07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGtlYmFiIGNhc2UuIFtTb3VyY2VdKGh0dHBzOi8vd3d3LmdlZWtzZm9yZ2Vla3Mub3JnL2hvdy10by1jb252ZXJ0LWEtc3RyaW5nLWludG8ta2ViYWItY2FzZS11c2luZy1qYXZhc2NyaXB0LylcclxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdG9LZWJhYkNhc2UgPSAoaW5wdXQ6IHN0cmluZyk6IHN0cmluZyA9PlxyXG5cdGlucHV0XHJcblx0XHQucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgXCIkMS0kMlwiKVxyXG5cdFx0LnJlcGxhY2UoL1tcXHNfXSsvZywgXCItXCIpXHJcblx0XHQudG9Mb3dlckNhc2UoKTtcclxuXHJcbi8qKlxyXG4gKiBSb3VuZCBhIG51bWJlciB0byBhIGdpdmVuIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSAtIFRoZSBudW1iZXIgdG8gcm91bmQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVjPURFQ0lNQUxTXSAtIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gcm91bmQgdG8uIERlZmF1bHQgdG8ge0BsaW5rIERFQ0lNQUxTfS5cclxuICogQHJldHVybnMge251bWJlcn0gVGhlIHJvdW5kZWQgbnVtYmVyLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJvdW5kTnVtYmVyID0gKG51bTogbnVtYmVyLCBkZWM6IG51bWJlciA9IERFQ0lNQUxTKTogbnVtYmVyID0+XHJcblx0TWF0aC5yb3VuZChudW0gKiBNYXRoLnBvdygxMCwgZGVjKSkgLyBNYXRoLnBvdygxMCwgZGVjKTtcclxuXHJcbi8qKlxyXG4gKiBUcnkgdG8gcGFyc2UgdGhlIGlucHV0IGFzIGEgbnVtYmVyLCByZXR1cm5pbmcgdGhlIGlucHV0IGlmIGl0IGZhaWxzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgLSBUaGUgc3RyaW5nIHRvIHBhcnNlXHJcbiAqIEByZXR1cm5zIHtzdHJpbmcgfCBudW1iZXJ9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdHJ5UGFyc2VOdW1iZXIgPSAoaW5wdXQ6IHN0cmluZyk6IG51bWJlciB8IHN0cmluZyA9PiB7XHJcblx0Y29uc3QgbnVtID0gTnVtYmVyLnBhcnNlRmxvYXQoaW5wdXQpO1xyXG5cdHJldHVybiBpc05hTihudW0pID8gaW5wdXQgOiBudW07XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWVudUZvckNoYXJ0TlN0YXRzTW9kYWwoXHJcblx0ZXZlbnQ6IE1vdXNlRXZlbnQsXHJcblx0cGx1Z2luOiBEYXRhQW5hbHlzaXNQbHVnaW5cclxuKSB7XHJcblx0Y29uc3QgeyBhcHAgfSA9IHBsdWdpbjtcclxuXHRjb25zdCBtZW51ID0gbmV3IE1lbnUoYXBwKTtcclxuXHRjb25zdCB0YXJnZXQgPSA8SFRNTEVsZW1lbnQ+ZXZlbnQudGFyZ2V0O1xyXG5cdGNvbnN0IHBhcmVudEVsZW1lbnQgPSA8SFRNTFRhYmxlUm93RWxlbWVudD50YXJnZXQucGFyZW50RWxlbWVudDtcclxuXHJcblx0Y29uc3QgY2xpY2tlZENlbGwgPSB0cnlQYXJzZU51bWJlcih0YXJnZXQuaW5uZXJUZXh0KTtcclxuXHJcblx0Y29uc3Qgcm93ID0gQXJyYXkuZnJvbShwYXJlbnRFbGVtZW50LmNlbGxzKS5tYXAoXHJcblx0XHQoZWw6IEhUTUxUYWJsZUNlbGxFbGVtZW50KSA9PiB0cnlQYXJzZU51bWJlcihlbC50ZXh0Q29udGVudClcclxuXHQpIGFzIFtzdHJpbmcsIHN0cmluZywgbnVtYmVyXTtcclxuXHJcblx0bWVudS5hZGRJdGVtKChpdGVtKSA9PlxyXG5cdFx0aXRlbVxyXG5cdFx0XHQuc2V0VGl0bGUoXCJPcGVuIENoYXJ0IE1vZGFsXCIpXHJcblx0XHRcdC5zZXRJY29uKDxzdHJpbmc+YWRkRmVhdGhlckljb24oXCJiYXItY2hhcnQtMlwiKSlcclxuXHRcdFx0Lm9uQ2xpY2soKCkgPT4ge1xyXG5cdFx0XHRcdG5ldyBDaGFydE1vZGFsKGFwcCwgcGx1Z2luLCByb3dbMF0sIHJvd1sxXSkub3BlbigpO1xyXG5cdFx0XHR9KVxyXG5cdCk7XHJcblx0aWYgKHR5cGVvZiBjbGlja2VkQ2VsbCA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0bWVudS5hZGRJdGVtKChpdGVtKSA9PlxyXG5cdFx0XHRpdGVtXHJcblx0XHRcdFx0LnNldFRpdGxlKFwiT3BlbiBTdGF0cyBNb2RhbFwiKVxyXG5cdFx0XHRcdC5zZXRJY29uKDxzdHJpbmc+YWRkRmVhdGhlckljb24oXCJncmlkXCIpKVxyXG5cdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcclxuXHRcdFx0XHRcdG5ldyBTdGF0c01vZGFsKGFwcCwgcGx1Z2luLCBjbGlja2VkQ2VsbCkub3BlbigpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHQpO1xyXG5cdH1cclxuXHRtZW51LnNob3dBdE1vdXNlRXZlbnQoZXZlbnQpO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZHJvcFdpa2kgPSAoc3RyOiBzdHJpbmcpID0+XHJcblx0c3RyLnN0YXJ0c1dpdGgoXCJbW1wiKSAmJiBzdHIuZW5kc1dpdGgoXCJdXVwiKSA/IHN0ci5zbGljZSgyLCAtMikgOiBzdHI7XHJcbiIsICJpbXBvcnQgeyBBcHAsIE1vZGFsIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCBTdGF0cyBmcm9tIFwiLi9Db21wb25lbnRzL1N0YXRzLnN2ZWx0ZVwiO1xyXG5pbXBvcnQgdHlwZSBEYXRhQW5hbHlzaXNQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFN0YXRzTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XHJcblx0cGx1Z2luOiBEYXRhQW5hbHlzaXNQbHVnaW47XHJcblx0bW9kYWw6IFN0YXRzTW9kYWw7XHJcblx0ZjE6IHN0cmluZztcclxuXHJcblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogRGF0YUFuYWx5c2lzUGx1Z2luLCBmMSA9IFwiXCIpIHtcclxuXHRcdHN1cGVyKGFwcCk7XHJcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuXHRcdHRoaXMubW9kYWwgPSB0aGlzO1xyXG5cdFx0dGhpcy5mMSA9IGYxO1xyXG5cdH1cclxuXHJcblx0b25PcGVuKCkge1xyXG5cdFx0Y29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcblx0XHRjb250ZW50RWwuZW1wdHkoKTtcclxuXHJcblx0XHRuZXcgU3RhdHMoe1xyXG5cdFx0XHR0YXJnZXQ6IGNvbnRlbnRFbCxcclxuXHRcdFx0cHJvcHM6IHtcclxuXHRcdFx0XHRtb2RhbDogdGhpcyxcclxuXHRcdFx0fSxcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0b25DbG9zZSgpIHtcclxuXHRcdHRoaXMuY29udGVudEVsLmVtcHR5KCk7XHJcblx0fVxyXG59XHJcbiIsICI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxyXG5cdGltcG9ydCB7IGdldE1lYW4sIGdldE1lZGlhbiwgZ2V0TW9kZSwgZ2V0U3RkRGV2IH0gZnJvbSBcIi4uL2FuYWx5c2VzXCI7XHJcblx0aW1wb3J0IHsgU3RhdHNNb2RhbCB9IGZyb20gXCIuLi9TdGF0c01vZGFsXCI7XHJcblx0aW1wb3J0IHsgcm91bmROdW1iZXIgfSBmcm9tIFwiLi4vdXRpbHNcIjtcclxuXHJcblx0ZXhwb3J0IGxldCBtb2RhbDogU3RhdHNNb2RhbDtcclxuXHJcblx0Y29uc3QgeyBhcHAsIHBsdWdpbiB9ID0gbW9kYWw7XHJcblx0Y29uc3QgeyBpbmRleCwgc2V0dGluZ3MgfSA9IHBsdWdpbjtcclxuXHRjb25zdCB7IGZpZWxkc1RvQ2hlY2sgfSA9IHNldHRpbmdzO1xyXG5cclxuXHRsZXQgeyBmMSB9ID0gbW9kYWw7XHJcblxyXG5cdGNvbnN0IHVwZGF0ZURhdGEgPSAoZmllbGQ6IHN0cmluZykgPT5cclxuXHRcdGluZGV4LmRhdGFcclxuXHRcdFx0Lm1hcCgoZCkgPT4gZFtmaWVsZF0pXHJcblx0XHRcdC5maWx0ZXIoKGQpID0+IGQgIT09IHVuZGVmaW5lZCAmJiBkICE9PSBudWxsKTtcclxuXHJcblx0JDogZGF0YSA9IHVwZGF0ZURhdGEoZjEpO1xyXG5cdCQ6IG4gPSBkYXRhLmxlbmd0aDtcclxuXHQkOiBtZWFuID0gZ2V0TWVhbihkYXRhKTtcclxuXHQkOiBtZWRpYW4gPSBnZXRNZWRpYW4oZGF0YSk7XHJcblx0JDogbW9kZSA9IGdldE1vZGUoZGF0YSk7XHJcblx0JDogc3RkID0gZ2V0U3RkRGV2KGRhdGEpO1xyXG5cclxuXHQkOiBzdGF0cyA9IFtcclxuXHRcdG4gPyBbXCJuXCIsIG5dIDogbnVsbCxcclxuXHRcdG1lYW4gPyBbXCJNZWFuXCIsIHJvdW5kTnVtYmVyKG1lYW4pXSA6IG51bGwsXHJcblx0XHRtZWRpYW4gPyBbXCJNZWRpYW5cIiwgcm91bmROdW1iZXIobWVkaWFuKV0gOiBudWxsLFxyXG5cdFx0W1wiTW9kZVwiLCBtb2RlXSxcclxuXHRcdHN0ZCA/IFtcIlN0ZCBEZXYuXCIsIHJvdW5kTnVtYmVyKHN0ZCldIDogbnVsbCxcclxuXHRdO1xyXG48L3NjcmlwdD5cclxuXHJcbjxkYXRhbGlzdCBpZD1cImZpZWxkc1wiPlxyXG5cdHsjZWFjaCBmaWVsZHNUb0NoZWNrIGFzIGZpZWxkfVxyXG5cdFx0PG9wdGlvbiB2YWx1ZT17ZmllbGR9IC8+XHJcblx0ey9lYWNofVxyXG48L2RhdGFsaXN0PlxyXG48bGFiZWwgZm9yPVwiZmllbGRzXCI+XHJcblx0RmllbGQ6XHJcblx0PGlucHV0IGJpbmQ6dmFsdWU9e2YxfSBsaXN0PVwiZmllbGRzXCIgLz5cclxuPC9sYWJlbD5cclxuXHJcbjx0YWJsZT5cclxuXHQ8dGhlYWQ+XHJcblx0XHQ8dHI+XHJcblx0XHRcdDx0aD5TdGF0PC90aD5cclxuXHRcdFx0PHRoPlZhbHVlPC90aD5cclxuXHRcdDwvdHI+XHJcblx0PC90aGVhZD5cclxuXHR7I2VhY2ggc3RhdHMgYXMgc3RhdH1cclxuXHRcdHsjaWYgc3RhdH1cclxuXHRcdFx0PHRyPlxyXG5cdFx0XHRcdDx0ZD57c3RhdFswXX08L3RkPlxyXG5cdFx0XHRcdDx0ZD57c3RhdFsxXX08L3RkPlxyXG5cdFx0XHQ8L3RyPlxyXG5cdFx0ey9pZn1cclxuXHR7L2VhY2h9XHJcbjwvdGFibGU+XHJcblxyXG48c3R5bGU+XHJcblx0dGFibGUge1xyXG5cdFx0bWFyZ2luLXRvcDogNXB4O1xyXG5cdFx0Ym9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcclxuXHR9XHJcblx0dGgsXHJcblx0dGQge1xyXG5cdFx0Ym9yZGVyOiAxcHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpO1xyXG5cdH1cclxuXHR0ZCB7XHJcblx0XHRwYWRkaW5nOiAwLjJyZW0gMC41cmVtO1xyXG5cdH1cclxuXHR0ZDpmaXJzdC1jaGlsZCB7XHJcblx0XHR0ZXh0LWFsaWduOiByaWdodDtcclxuXHR9XHJcbjwvc3R5bGU+XHJcbiIsICJpbXBvcnQgeyBQcmludGFibGVDb3JyZWxhdGlvbiwgQ29ycmVsYXRpb25zIH0gZnJvbSBcIi4vaW50ZXJmYWNlc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IEFMTF9GSUVMRFMgPSBcIkFsbCBGaWVsZHNcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBidWlsZFByaW50YWJsZUNvcnJzID0gKFxyXG5cdGNvcnJzOiBDb3JyZWxhdGlvbnNcclxuKTogUHJpbnRhYmxlQ29ycmVsYXRpb25bXSA9PiB7XHJcblx0aWYgKGNvcnJzID09PSB1bmRlZmluZWQpIHJldHVybiBbXTtcclxuXHRjb25zdCBmaWVsZHMgPSBPYmplY3Qua2V5cyhjb3Jycyk7XHJcblx0cmV0dXJuIGZpZWxkc1xyXG5cdFx0Lm1hcCgoZmllbGRBKSA9PiB7XHJcblx0XHRcdGNvbnN0IGNvcnJlbGF0ZWRGaWVsZHMgPSBPYmplY3Qua2V5cyhjb3Jyc1tmaWVsZEFdKTtcclxuXHRcdFx0cmV0dXJuIGNvcnJlbGF0ZWRGaWVsZHMubWFwKChmaWVsZEIpID0+IHtcclxuXHRcdFx0XHRyZXR1cm4geyBmaWVsZEEsIGZpZWxkQiwgaW5mbzogY29ycnNbZmllbGRBXVtmaWVsZEJdIH07XHJcblx0XHRcdH0pO1xyXG5cdFx0fSlcclxuXHRcdC5mbGF0KCk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0UmVwb3J0Q29ycnMgPSAoXHJcblx0cHJpbnRhYmxlQ29ycnM6IFByaW50YWJsZUNvcnJlbGF0aW9uW10sXHJcblx0c2VsZWN0ZWRGaWVsZDogc3RyaW5nLFxyXG5cdG1heDogbnVtYmVyLFxyXG5cdG1pbjogbnVtYmVyXHJcbik6IFByaW50YWJsZUNvcnJlbGF0aW9uW10gPT4ge1xyXG5cdGNvbnN0IGNvcnJzVG9TaG93ID0gcHJpbnRhYmxlQ29ycnNcclxuXHRcdC5maWx0ZXIoKGl0ZW0pID0+IHtcclxuXHRcdFx0Y29uc3QgeyBpbmZvLCBmaWVsZEEsIGZpZWxkQiB9ID0gaXRlbTtcclxuXHRcdFx0Y29uc3QgZmllbGRTZWxlY3RlZCA9XHJcblx0XHRcdFx0c2VsZWN0ZWRGaWVsZCA9PSBBTExfRklFTERTIHx8XHJcblx0XHRcdFx0ZmllbGRBID09IHNlbGVjdGVkRmllbGQgfHxcclxuXHRcdFx0XHRmaWVsZEIgPT0gc2VsZWN0ZWRGaWVsZDtcclxuXHRcdFx0cmV0dXJuIChcclxuXHRcdFx0XHRpbmZvICYmXHJcblx0XHRcdFx0ZmllbGRTZWxlY3RlZCAmJlxyXG5cdFx0XHRcdGluZm8uY29yciAhPT0gTmFOICYmXHJcblx0XHRcdFx0aW5mby5jb3JyIDw9IG1heCAmJlxyXG5cdFx0XHRcdGluZm8uY29yciA+PSBtaW5cclxuXHRcdFx0KTtcclxuXHRcdH0pXHJcblx0XHQuc29ydCgoYSwgYikgPT4gYi5pbmZvLmNvcnIgLSBhLmluZm8uY29ycik7XHJcblxyXG5cdHJldHVybiBjb3Jyc1RvU2hvdztcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBidWlsZERyb3Bkb3duT3B0aW9uc0Zyb21Db3JycyA9IChcclxuXHRwcmludGFibGVDb3JyczogUHJpbnRhYmxlQ29ycmVsYXRpb25bXVxyXG4pOiBzdHJpbmdbXSA9PiB7XHJcblx0Y29uc3QgZmllbGRPcHRpb25zID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcblx0cHJpbnRhYmxlQ29ycnMuZm9yRWFjaCgoY29ycjogUHJpbnRhYmxlQ29ycmVsYXRpb24pID0+IHtcclxuXHRcdGZpZWxkT3B0aW9ucy5hZGQoY29yci5maWVsZEEpO1xyXG5cdFx0ZmllbGRPcHRpb25zLmFkZChjb3JyLmZpZWxkQik7XHJcblx0fSk7XHJcblx0Y29uc3QgcmVzdWx0cyA9IEFycmF5LmZyb20oZmllbGRPcHRpb25zKTtcclxuXHRyZXR1cm4gcmVzdWx0cy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHRvcDNQb3NpdGl2ZUNvcnJzID0gKFxyXG5cdGNvcnJlbGF0aW9uczogUHJpbnRhYmxlQ29ycmVsYXRpb25bXSxcclxuXHRzb3J0ZWQ6IGJvb2xlYW4gPSB0cnVlXHJcbik6IFByaW50YWJsZUNvcnJlbGF0aW9uW10gPT4ge1xyXG5cdGlmICghc29ydGVkKSBjb3JyZWxhdGlvbnMuc29ydCgoYSwgYikgPT4gYi5pbmZvLmNvcnIgLSBhLmluZm8uY29ycik7XHJcblx0cmV0dXJuIGNvcnJlbGF0aW9ucy5zbGljZSgwLCAzKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB0b3AzTmVnYXRpdmVDb3JycyA9IChcclxuXHRjb3JyZWxhdGlvbnM6IFByaW50YWJsZUNvcnJlbGF0aW9uW10sXHJcblx0c29ydGVkOiBib29sZWFuID0gdHJ1ZVxyXG4pOiBQcmludGFibGVDb3JyZWxhdGlvbltdID0+IHtcclxuXHRpZiAoIXNvcnRlZCkgY29ycmVsYXRpb25zLnNvcnQoKGEsIGIpID0+IGIuaW5mby5jb3JyIC0gYS5pbmZvLmNvcnIpO1xyXG5cdHJldHVybiBjb3JyZWxhdGlvbnMuc2xpY2UoLTMpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFyaWFOID0gKG46IG51bWJlcikgPT4gKG4gPyBcIm46IFwiICsgbi50b0ZpeGVkKCkgOiBcIlwiKTtcclxuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XHJcblx0aW1wb3J0IHsgbWVudUZvckNoYXJ0TlN0YXRzTW9kYWwsIHJvdW5kTnVtYmVyIH0gZnJvbSBcIi4uL3V0aWxzXCI7XHJcblx0aW1wb3J0IENvcnJlbGF0aW9uc1JlcG9ydFZpZXcgZnJvbSBcIi4uL0NvcnJlbGF0aW9uc1JlcG9ydFZpZXdcIjtcclxuXHRpbXBvcnQgeyBhcmlhTiB9IGZyb20gXCIuLi9yZXBvcnRWaWV3VXRpbHNcIjtcclxuXHJcblx0ZXhwb3J0IGxldCB2aWV3OiBDb3JyZWxhdGlvbnNSZXBvcnRWaWV3O1xyXG5cdGV4cG9ydCBsZXQgY3JpdGVyaWE6IChjb3JyOiBudW1iZXIpID0+IGJvb2xlYW47XHJcblxyXG5cdGNvbnN0IHsgcGx1Z2luIH0gPSB2aWV3O1xyXG48L3NjcmlwdD5cclxuXHJcbjx0Ym9keT5cclxuXHR7I2VhY2ggdmlldy5jb3Jyc1RvU2hvdyBhcyB7IGZpZWxkQSwgZmllbGRCLCBpbmZvOiB7IGNvcnIsIG4gfSB9fVxyXG5cdFx0eyNpZiBjcml0ZXJpYShjb3JyKSAmJiBuID49IHZpZXcubWluTn1cclxuXHRcdFx0PHRyXHJcblx0XHRcdFx0YXJpYS1sYWJlbD17YXJpYU4obil9XHJcblx0XHRcdFx0b246Y29udGV4dG1lbnU9eyhlKSA9PiBtZW51Rm9yQ2hhcnROU3RhdHNNb2RhbChlLCBwbHVnaW4pfVxyXG5cdFx0XHQ+XHJcblx0XHRcdFx0PHRkPntmaWVsZEF9PC90ZD5cclxuXHRcdFx0XHQ8dGQ+e2ZpZWxkQn08L3RkPlxyXG5cdFx0XHRcdDx0ZD57cm91bmROdW1iZXIoY29ycil9PC90ZD5cclxuXHRcdFx0PC90cj5cclxuXHRcdHsvaWZ9XHJcblx0ey9lYWNofVxyXG48L3Rib2R5PlxyXG4iLCAiPHRoZWFkPlxyXG5cdDx0cj5cclxuXHRcdDx0aD5GaWVsZCAxPC90aD5cclxuXHRcdDx0aD5GaWVsZCAyPC90aD5cclxuXHRcdDx0aD5Db3JyZWxhdGlvbjwvdGg+XHJcblx0PC90cj5cclxuPC90aGVhZD5cclxuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XHJcblx0aW1wb3J0IHsgUHJpbnRhYmxlQ29ycmVsYXRpb24gfSBmcm9tIFwic3JjL2ludGVyZmFjZXNcIjtcclxuXHRpbXBvcnQgeyBtZW51Rm9yQ2hhcnROU3RhdHNNb2RhbCB9IGZyb20gXCJzcmMvdXRpbHNcIjtcclxuXHRpbXBvcnQgQ29ycmVsYXRpb25zUmVwb3J0VmlldyBmcm9tIFwiLi4vQ29ycmVsYXRpb25zUmVwb3J0Vmlld1wiO1xyXG5cdGltcG9ydCB7IGFyaWFOIH0gZnJvbSBcIi4uL3JlcG9ydFZpZXdVdGlsc1wiO1xyXG5cclxuXHRleHBvcnQgbGV0IHZpZXc6IENvcnJlbGF0aW9uc1JlcG9ydFZpZXc7XHJcblx0ZXhwb3J0IGxldCB0b3AzOiBQcmludGFibGVDb3JyZWxhdGlvbltdO1xyXG4gICAgXHJcblx0Y29uc3QgeyBwbHVnaW4gfSA9IHZpZXc7XHJcbjwvc2NyaXB0PlxyXG5cclxueyNlYWNoIHRvcDMgYXMgeyBmaWVsZEEsIGZpZWxkQiwgaW5mbzogeyBjb3JyLCBuIH0gfX1cclxuXHQ8dHJcclxuXHRcdGFyaWEtbGFiZWw9e2FyaWFOKG4pfVxyXG5cdFx0b246Y29udGV4dG1lbnU9eyhlKSA9PiBtZW51Rm9yQ2hhcnROU3RhdHNNb2RhbChlLCBwbHVnaW4pfVxyXG5cdD5cclxuXHRcdDx0ZD57ZmllbGRBfTwvdGQ+XHJcblx0XHQ8dGQ+e2ZpZWxkQn08L3RkPlxyXG5cdFx0PHRkPntjb3JyLnRvRml4ZWQoNCl9PC90ZD5cclxuXHQ8L3RyPlxyXG57L2VhY2h9XHJcbiIsICI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxyXG5cdGltcG9ydCBDb3JyZWxhdGlvbnNSZXBvcnRWaWV3IGZyb20gXCIuLi9Db3JyZWxhdGlvbnNSZXBvcnRWaWV3XCI7XHJcblx0aW1wb3J0IEJvZHkgZnJvbSBcIi4vQ29yclRhYmxlQm9keS5zdmVsdGVcIjtcclxuXHRpbXBvcnQgSGVhZGVyIGZyb20gXCIuL0NvcnJUYWJsZUhlYWRlci5zdmVsdGVcIjtcclxuXHRpbXBvcnQgVG9wMyBmcm9tIFwiLi9Db3JyVGFibGVUb3AzLnN2ZWx0ZVwiO1xyXG5cclxuXHRleHBvcnQgbGV0IHZpZXc6IENvcnJlbGF0aW9uc1JlcG9ydFZpZXc7XHJcblxyXG5cdGNvbnN0IGdldEJ1dHRvblRleHQgPSAoc2hvdzogYm9vbGVhbikgPT4gKHNob3cgPyBcIlx1MjE5M1wiIDogXCJcdTIxOTFcIik7XHJcblx0Y29uc3QgYXJpYVNob3dUZXh0ID0gKHNob3c6IGJvb2xlYW4pID0+XHJcblx0XHRzaG93ID8gXCJIaWRlIHNlY3Rpb25cIiA6IFwiU2hvdyBzZWN0aW9uXCI7XHJcblxyXG5cdGNvbnN0IGRpc3BsYXlTdWJmaWVsZCA9IChmaWVsZDogc3RyaW5nKSA9PiBmaWVsZC5zcGxpdChcIi5cIikubGFzdCgpO1xyXG48L3NjcmlwdD5cclxuXHJcbjxkaXYgY2xhc3M9XCJjb21wb25lbnRcIj5cclxuXHQ8aDE+Q29ycmVsYXRpb25zIFJlcG9ydDwvaDE+XHJcblx0eyNrZXkgdmlldy5maWVsZE9wdGlvbnN9XHJcblx0XHQ8c2VsZWN0XHJcblx0XHRcdGNsYXNzPVwiZHJvcGRvd25cIlxyXG5cdFx0XHRiaW5kOnZhbHVlPXt2aWV3LnNlbGVjdGVkRmllbGR9XHJcblx0XHRcdG9uOmNoYW5nZT17dmlldy5jYWxjdWxhdGVSZXBvcnR9XHJcblx0XHQ+XHJcblx0XHRcdHsjZWFjaCB2aWV3LmZpZWxkT3B0aW9ucyBhcyBmaWVsZH1cclxuXHRcdFx0XHQ8b3B0aW9uIHZhbHVlPXtmaWVsZH0+XHJcblx0XHRcdFx0XHR7ZGlzcGxheVN1YmZpZWxkKGZpZWxkKX1cclxuXHRcdFx0XHQ8L29wdGlvbj5cclxuXHRcdFx0ey9lYWNofVxyXG5cdFx0PC9zZWxlY3Q+XHJcblx0ey9rZXl9XHJcblxyXG5cdHsja2V5IHZpZXcuc2VsZWN0ZWRGaWVsZH1cclxuXHRcdDxoMz5cclxuXHRcdFx0U3RhbmRhcmRzOlxyXG5cdFx0XHQ8YnV0dG9uXHJcblx0XHRcdFx0b246Y2xpY2s9eygpID0+ICh2aWV3LnNob3dTdGFuZGFyZHMgPSAhdmlldy5zaG93U3RhbmRhcmRzKX1cclxuXHRcdFx0XHRhcmlhLWxhYmVsPXthcmlhU2hvd1RleHQodmlldy5zaG93U3RhbmRhcmRzKX1cclxuXHRcdFx0PlxyXG5cdFx0XHRcdHtnZXRCdXR0b25UZXh0KHZpZXcuc2hvd1N0YW5kYXJkcyl9XHJcblx0XHRcdDwvYnV0dG9uPlxyXG5cdFx0PC9oMz5cclxuXHRcdHsjaWYgdmlldy5zaG93U3RhbmRhcmRzfVxyXG5cdFx0XHQ8ZGl2IGNsYXNzPVwic3RhbmRhcmRcIj5cclxuXHRcdFx0XHQ8c3Ryb25nPk1heDogPC9zdHJvbmc+XHJcblx0XHRcdFx0PGlucHV0XHJcblx0XHRcdFx0XHR0eXBlPVwibnVtYmVyXCJcclxuXHRcdFx0XHRcdHZhbHVlPXt2aWV3Lm1heH1cclxuXHRcdFx0XHRcdG9uOmNoYW5nZT17KGUpID0+IHtcclxuXHRcdFx0XHRcdFx0dmlldy5tYXggPSBwYXJzZUZsb2F0KGUudGFyZ2V0LnZhbHVlKTtcclxuXHRcdFx0XHRcdFx0dmlldy5jYWxjdWxhdGVSZXBvcnQoKTtcclxuXHRcdFx0XHRcdH19XHJcblx0XHRcdFx0Lz5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHRcdDxkaXYgY2xhc3M9XCJzdGFuZGFyZFwiPlxyXG5cdFx0XHRcdDxzdHJvbmc+TWluOiA8L3N0cm9uZz5cclxuXHRcdFx0XHQ8aW5wdXRcclxuXHRcdFx0XHRcdHR5cGU9XCJudW1iZXJcIlxyXG5cdFx0XHRcdFx0dmFsdWU9e3ZpZXcubWlufVxyXG5cdFx0XHRcdFx0b246Y2hhbmdlPXsoZSkgPT4ge1xyXG5cdFx0XHRcdFx0XHR2aWV3Lm1pbiA9IHBhcnNlRmxvYXQoZS50YXJnZXQudmFsdWUpO1xyXG5cdFx0XHRcdFx0XHR2aWV3LmNhbGN1bGF0ZVJlcG9ydCgpO1xyXG5cdFx0XHRcdFx0fX1cclxuXHRcdFx0XHQvPlxyXG5cdFx0XHQ8L2Rpdj5cclxuXHRcdFx0PGRpdiBjbGFzcz1cInN0YW5kYXJkXCI+XHJcblx0XHRcdFx0PHN0cm9uZz5TdHJvbmc6IDwvc3Ryb25nPntcInxyfCA+PSBcIn08aW5wdXRcclxuXHRcdFx0XHRcdHR5cGU9XCJudW1iZXJcIlxyXG5cdFx0XHRcdFx0dmFsdWU9e3ZpZXcubWVkaXVtfVxyXG5cdFx0XHRcdFx0b246Y2hhbmdlPXsoZSkgPT4ge1xyXG5cdFx0XHRcdFx0XHR2aWV3Lm1lZGl1bSA9IHBhcnNlRmxvYXQoZS50YXJnZXQudmFsdWUpO1xyXG5cdFx0XHRcdFx0XHR2aWV3LmNhbGN1bGF0ZVJlcG9ydCgpO1xyXG5cdFx0XHRcdFx0fX1cclxuXHRcdFx0XHQvPlxyXG5cdFx0XHQ8L2Rpdj5cclxuXHRcdFx0PGRpdiBjbGFzcz1cInN0YW5kYXJkXCI+XHJcblx0XHRcdFx0PHN0cm9uZz5NZWRpdW06IDwvc3Ryb25nPlxyXG5cdFx0XHRcdHt2aWV3Lmxvd2VyICsgXCIgPCB8cnwgPCBcIiArIHZpZXcubWVkaXVtfVxyXG5cdFx0XHQ8L2Rpdj5cclxuXHRcdFx0PGRpdiBjbGFzcz1cInN0YW5kYXJkXCI+XHJcblx0XHRcdFx0PHN0cm9uZz5XZWFrL05vOiA8L3N0cm9uZz57XCJ8cnwgPTwgXCJ9PGlucHV0XHJcblx0XHRcdFx0XHR0eXBlPVwibnVtYmVyXCJcclxuXHRcdFx0XHRcdHZhbHVlPXt2aWV3Lmxvd2VyfVxyXG5cdFx0XHRcdFx0b246Y2hhbmdlPXsoZSkgPT4ge1xyXG5cdFx0XHRcdFx0XHR2aWV3Lmxvd2VyID0gcGFyc2VGbG9hdChlLnRhcmdldC52YWx1ZSk7XHJcblx0XHRcdFx0XHRcdHZpZXcuY2FsY3VsYXRlUmVwb3J0KCk7XHJcblx0XHRcdFx0XHR9fVxyXG5cdFx0XHRcdC8+XHJcblx0XHRcdDwvZGl2PlxyXG5cdFx0XHQ8ZGl2IGNsYXNzPVwic3RhbmRhcmRcIj5cclxuXHRcdFx0XHQ8c3Ryb25nPk1pbiBzYW1wbGUgc2l6ZTogPC9zdHJvbmc+XHJcblx0XHRcdFx0e1wibiA+PSBcIn08aW5wdXRcclxuXHRcdFx0XHRcdHR5cGU9XCJudW1iZXJcIlxyXG5cdFx0XHRcdFx0dmFsdWU9e3ZpZXcubWluTn1cclxuXHRcdFx0XHRcdG9uOmNoYW5nZT17KGUpID0+IHtcclxuXHRcdFx0XHRcdFx0dmlldy5taW5OID0gcGFyc2VGbG9hdChlLnRhcmdldC52YWx1ZSk7XHJcblx0XHRcdFx0XHRcdHZpZXcuY2FsY3VsYXRlUmVwb3J0KCk7XHJcblx0XHRcdFx0XHR9fVxyXG5cdFx0XHRcdC8+XHJcblx0XHRcdDwvZGl2PlxyXG5cdFx0ey9pZn1cclxuXHJcblx0XHR7I2tleSB2aWV3Lm1heH1cclxuXHRcdFx0PGgzPlxyXG5cdFx0XHRcdFRvcCAzIFBvc2l0aXZlIENvcnJlbGF0aW9uc1xyXG5cdFx0XHRcdDxidXR0b25cclxuXHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiAodmlldy5zaG93VG9wUG9zID0gIXZpZXcuc2hvd1RvcFBvcyl9XHJcblx0XHRcdFx0XHRhcmlhLWxhYmVsPXthcmlhU2hvd1RleHQodmlldy5zaG93VG9wUG9zKX1cclxuXHRcdFx0XHQ+XHJcblx0XHRcdFx0XHR7Z2V0QnV0dG9uVGV4dCh2aWV3LnNob3dUb3BQb3MpfVxyXG5cdFx0XHRcdDwvYnV0dG9uPlxyXG5cdFx0XHQ8L2gzPlxyXG5cdFx0XHR7I2lmIHZpZXcuc2hvd1RvcFBvc31cclxuXHRcdFx0XHQ8dGFibGUgY2xhc3M9XCJtYXJrZG93bi1wcmV2aWV3LXZpZXdcIj5cclxuXHRcdFx0XHRcdDxIZWFkZXIgLz5cclxuXHRcdFx0XHRcdDxUb3AzIHt2aWV3fSB0b3AzPXt2aWV3LnRvcFBvczN9IC8+XHJcblx0XHRcdFx0PC90YWJsZT5cclxuXHRcdFx0ey9pZn1cclxuXHJcblx0XHRcdHsja2V5IHZpZXcubWlufVxyXG5cdFx0XHRcdDxoMz5cclxuXHRcdFx0XHRcdFRvcCAzIE5lZ2F0aXZlIENvcnJlbGF0aW9uc1xyXG5cdFx0XHRcdFx0PGJ1dHRvblxyXG5cdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4gKHZpZXcuc2hvd1RvcE5lZyA9ICF2aWV3LnNob3dUb3BOZWcpfVxyXG5cdFx0XHRcdFx0XHRhcmlhLWxhYmVsPXthcmlhU2hvd1RleHQodmlldy5zaG93VG9wTmVnKX1cclxuXHRcdFx0XHRcdD5cclxuXHRcdFx0XHRcdFx0e2dldEJ1dHRvblRleHQodmlldy5zaG93VG9wTmVnKX1cclxuXHRcdFx0XHRcdDwvYnV0dG9uPlxyXG5cdFx0XHRcdDwvaDM+XHJcblx0XHRcdFx0eyNpZiB2aWV3LnNob3dUb3BOZWd9XHJcblx0XHRcdFx0XHQ8dGFibGUgY2xhc3M9XCJtYXJrZG93bi1wcmV2aWV3LXZpZXdcIj5cclxuXHRcdFx0XHRcdFx0PEhlYWRlciAvPlxyXG5cdFx0XHRcdFx0XHQ8VG9wMyB7dmlld30gdG9wMz17dmlldy50b3BOZWczfSAvPlxyXG5cdFx0XHRcdFx0PC90YWJsZT5cclxuXHRcdFx0XHR7L2lmfVxyXG5cclxuXHRcdFx0XHR7I2tleSBbdmlldy5sb3dlciwgdmlldy5tZWRpdW1dfVxyXG5cdFx0XHRcdFx0PGgzPlxyXG5cdFx0XHRcdFx0XHRTdHJvbmdseSBDb3JyZWxhdGVkXHJcblx0XHRcdFx0XHRcdDxidXR0b25cclxuXHRcdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT5cclxuXHRcdFx0XHRcdFx0XHRcdCh2aWV3LnNob3dTdHJvbmcgPSAhdmlldy5zaG93U3Ryb25nKX1cclxuXHRcdFx0XHRcdFx0XHRhcmlhLWxhYmVsPXthcmlhU2hvd1RleHQodmlldy5zaG93U3Ryb25nKX1cclxuXHRcdFx0XHRcdFx0PlxyXG5cdFx0XHRcdFx0XHRcdHtnZXRCdXR0b25UZXh0KHZpZXcuc2hvd1N0cm9uZyl9XHJcblx0XHRcdFx0XHRcdDwvYnV0dG9uPlxyXG5cdFx0XHRcdFx0PC9oMz5cclxuXHRcdFx0XHRcdHsjaWYgdmlldy5zaG93U3Ryb25nfVxyXG5cdFx0XHRcdFx0XHQ8dGFibGUgY2xhc3M9XCJtYXJrZG93bi1wcmV2aWV3LXZpZXdcIj5cclxuXHRcdFx0XHRcdFx0XHQ8SGVhZGVyIC8+XHJcblx0XHRcdFx0XHRcdFx0PEJvZHlcclxuXHRcdFx0XHRcdFx0XHRcdHt2aWV3fVxyXG5cdFx0XHRcdFx0XHRcdFx0Y3JpdGVyaWE9eyhjb3JyKSA9PlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRNYXRoLmFicyhjb3JyKSA+PSB2aWV3Lm1lZGl1bX1cclxuXHRcdFx0XHRcdFx0XHQvPlxyXG5cdFx0XHRcdFx0XHQ8L3RhYmxlPlxyXG5cdFx0XHRcdFx0ey9pZn1cclxuXHJcblx0XHRcdFx0XHQ8aDM+XHJcblx0XHRcdFx0XHRcdFNvbWV3aGF0IENvcnJlbGF0ZWRcclxuXHRcdFx0XHRcdFx0PGJ1dHRvblxyXG5cdFx0XHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PlxyXG5cdFx0XHRcdFx0XHRcdFx0KHZpZXcuc2hvd01lZGl1bSA9ICF2aWV3LnNob3dNZWRpdW0pfVxyXG5cdFx0XHRcdFx0XHRcdGFyaWEtbGFiZWw9e2FyaWFTaG93VGV4dCh2aWV3LnNob3dNZWRpdW0pfVxyXG5cdFx0XHRcdFx0XHQ+XHJcblx0XHRcdFx0XHRcdFx0e2dldEJ1dHRvblRleHQodmlldy5zaG93TWVkaXVtKX1cclxuXHRcdFx0XHRcdFx0PC9idXR0b24+XHJcblx0XHRcdFx0XHQ8L2gzPlxyXG5cdFx0XHRcdFx0eyNpZiB2aWV3LnNob3dNZWRpdW19XHJcblx0XHRcdFx0XHRcdDx0YWJsZSBjbGFzcz1cIm1hcmtkb3duLXByZXZpZXctdmlld1wiPlxyXG5cdFx0XHRcdFx0XHRcdDxIZWFkZXIgLz5cclxuXHRcdFx0XHRcdFx0XHQ8Qm9keVxyXG5cdFx0XHRcdFx0XHRcdFx0e3ZpZXd9XHJcblx0XHRcdFx0XHRcdFx0XHRjcml0ZXJpYT17KGNvcnIpID0+XHJcblx0XHRcdFx0XHRcdFx0XHRcdE1hdGguYWJzKGNvcnIpIDwgdmlldy5tZWRpdW0gJiZcclxuXHRcdFx0XHRcdFx0XHRcdFx0TWF0aC5hYnMoY29ycikgPiB2aWV3Lmxvd2VyfVxyXG5cdFx0XHRcdFx0XHRcdC8+XHJcblx0XHRcdFx0XHRcdDwvdGFibGU+XHJcblx0XHRcdFx0XHR7L2lmfVxyXG5cclxuXHRcdFx0XHRcdDxoMz5cclxuXHRcdFx0XHRcdFx0V2Vha2x5L05vdCBDb3JyZWxhdGVkXHJcblx0XHRcdFx0XHRcdDxidXR0b25cclxuXHRcdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4gKHZpZXcuc2hvd1dlYWsgPSAhdmlldy5zaG93V2Vhayl9XHJcblx0XHRcdFx0XHRcdFx0YXJpYS1sYWJlbD17YXJpYVNob3dUZXh0KHZpZXcuc2hvd1dlYWspfVxyXG5cdFx0XHRcdFx0XHQ+XHJcblx0XHRcdFx0XHRcdFx0e2dldEJ1dHRvblRleHQodmlldy5zaG93V2Vhayl9XHJcblx0XHRcdFx0XHRcdDwvYnV0dG9uPlxyXG5cdFx0XHRcdFx0PC9oMz5cclxuXHRcdFx0XHRcdHsjaWYgdmlldy5zaG93V2Vha31cclxuXHRcdFx0XHRcdFx0PHRhYmxlIGNsYXNzPVwibWFya2Rvd24tcHJldmlldy12aWV3XCI+XHJcblx0XHRcdFx0XHRcdFx0PEhlYWRlciAvPlxyXG5cdFx0XHRcdFx0XHRcdDxCb2R5XHJcblx0XHRcdFx0XHRcdFx0XHR7dmlld31cclxuXHRcdFx0XHRcdFx0XHRcdGNyaXRlcmlhPXsoY29ycikgPT4gTWF0aC5hYnMoY29ycikgPCB2aWV3Lmxvd2VyfVxyXG5cdFx0XHRcdFx0XHRcdC8+XHJcblx0XHRcdFx0XHRcdDwvdGFibGU+XHJcblx0XHRcdFx0XHR7L2lmfVxyXG5cdFx0XHRcdHsva2V5fVxyXG5cdFx0XHR7L2tleX1cclxuXHRcdHsva2V5fVxyXG5cdHsva2V5fVxyXG48L2Rpdj5cclxuXHJcbjxzdHlsZT5cclxuXHRkaXYuY29tcG9uZW50IHtcclxuXHRcdHBhZGRpbmc6IDVweDtcclxuXHR9XHJcblxyXG5cdGRpdi5zdGFuZGFyZCB7XHJcblx0XHRwYWRkaW5nOiAzcHg7XHJcblx0fVxyXG5cclxuXHR0YWJsZSB7XHJcblx0XHRib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xyXG5cdFx0b3ZlcmZsb3c6IGF1dG87XHJcblx0fVxyXG5cdHRhYmxlLFxyXG5cdHRhYmxlIHRyLFxyXG5cdHRhYmxlIHRkIHtcclxuXHRcdGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItYm9yZGVyKTtcclxuXHR9XHJcbjwvc3R5bGU+XHJcbiIsICJpbXBvcnQgeyBnZXRQZWFyc29uQ29ycmVsYXRpb24sIGdldFBvaW50QmlzZXJpYWxDb3JyZWxhdGlvbiB9IGZyb20gXCIuL2FuYWx5c2VzXCI7XHJcbmltcG9ydCB7IENvcnJlbGF0aW9ucywgRGF0YVR5cGUgfSBmcm9tIFwiLi9pbnRlcmZhY2VzXCI7XHJcbmltcG9ydCB7IERhdGVUaW1lIH0gZnJvbSBcImx1eG9uXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlPdmVybGFwPFQ+KEE6IFRbXSwgQjogVFtdKTogW1RbXSwgVFtdXSB7XHJcblx0Y29uc3QgaUE6IG51bWJlcltdID0gW107XHJcblx0QS5mb3JFYWNoKChhLCBpKSA9PiB7XHJcblx0XHRpZiAoYSAhPT0gdW5kZWZpbmVkKSBpQS5wdXNoKGkpO1xyXG5cdH0pO1xyXG5cdGNvbnN0IGlCOiBudW1iZXJbXSA9IFtdO1xyXG5cdEIuZm9yRWFjaCgoYiwgaSkgPT4ge1xyXG5cdFx0aWYgKGIgIT09IHVuZGVmaW5lZCkgaUIucHVzaChpKTtcclxuXHR9KTtcclxuXHJcblx0Y29uc3QgYU92ZXJsYXAgPSBBLmZpbHRlcigoYSwgaSkgPT4gaUEuaW5jbHVkZXMoaSkgJiYgaUIuaW5jbHVkZXMoaSkpO1xyXG5cdGNvbnN0IGJPdmVybGFwID0gQi5maWx0ZXIoKGIsIGkpID0+IGlBLmluY2x1ZGVzKGkpICYmIGlCLmluY2x1ZGVzKGkpKTtcclxuXHJcblx0aWYgKCFhT3ZlcmxhcC5sZW5ndGggfHwgIWJPdmVybGFwLmxlbmd0aCkgcmV0dXJuIFtbXSwgW11dO1xyXG5cdHJldHVybiBbYU92ZXJsYXAsIGJPdmVybGFwXTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGluZmVyVHlwZSA9IChcclxuXHR4czogKHN0cmluZyB8IG51bWJlcilbXVxyXG4pOiBcInN0cmluZ1wiIHwgXCJudW1iZXJcIiB8IFwib2JqZWN0XCIgfCBcInVuZGVmaW5lZFwiID0+IHtcclxuXHRjb25zdCBkZWZpbmVkcyA9IHhzLmZpbHRlcigoeCkgPT4geCk7XHJcblx0Y29uc3QgdHlwZXMgPSBkZWZpbmVkcy5tYXAoKHgpID0+IHR5cGVvZiB4KTtcclxuXHRpZiAoIWRlZmluZWRzLmxlbmd0aCkgcmV0dXJuIFwidW5kZWZpbmVkXCI7XHJcblx0Y29uc3QgdGhyZXNoID0gZGVmaW5lZHMubGVuZ3RoIC8gMjtcclxuXHJcblx0aWYgKHR5cGVzLmZpbHRlcigoeCkgPT4geCA9PT0gXCJudW1iZXJcIikubGVuZ3RoID49IHRocmVzaCkgcmV0dXJuIFwibnVtYmVyXCI7XHJcblx0ZWxzZSBpZiAodHlwZXMuZmlsdGVyKCh4KSA9PiB4ID09PSBcInN0cmluZ1wiKS5sZW5ndGggPj0gdGhyZXNoKVxyXG5cdFx0cmV0dXJuIFwic3RyaW5nXCI7XHJcblx0ZWxzZSByZXR1cm4gXCJvYmplY3RcIjtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzcGxpdEFuZFRyaW0gPSAoZmllbGRzOiBzdHJpbmcpOiBzdHJpbmdbXSA9PiB7XHJcblx0aWYgKGZpZWxkcyA9PT0gXCJcIikgcmV0dXJuIFtdO1xyXG5cdGVsc2UgcmV0dXJuIGZpZWxkcy5zcGxpdChcIixcIikubWFwKChzdHIpID0+IHN0ci50cmltKCkpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldElubmVyVmFsdWUgPSAodmFsdWU6IGFueSkgPT4ge1xyXG5cdGNvbnN0IHVucHJveGllZCA9IHVucHJveHkodmFsdWUpO1xyXG5cdGlmICh1bnByb3hpZWQubGVuZ3RoID09PSAxKSB7XHJcblx0XHRpZiAodHlwZW9mIHVucHJveGllZFswXSA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRsZXQgbGlzdCA9IHVucHJveGllZFswXTtcclxuXHRcdFx0aWYgKGxpc3Quc3RhcnRzV2l0aChcIltcIikgJiYgbGlzdC5lbmRzV2l0aChcIl1cIikpIHtcclxuXHRcdFx0XHRsaXN0ID0gbGlzdC5zbGljZSgxLCAtMSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y29uc3Qgc3BsaXRzID0gc3BsaXRBbmRUcmltKGxpc3QpLm1hcCgoaXRlbSkgPT4ge1xyXG5cdFx0XHRcdGlmIChpdGVtLnN0YXJ0c1dpdGgoYFwiYCkgJiYgaXRlbS5lbmRzV2l0aChgXCJgKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGl0ZW0uc2xpY2UoMSwgLTEpO1xyXG5cdFx0XHRcdH0gZWxzZSByZXR1cm4gaXRlbTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGlmIChzcGxpdHMubGVuZ3RoID09PSAxKSByZXR1cm4gc3BsaXRzWzBdO1xyXG5cdFx0XHRlbHNlIHJldHVybiBzcGxpdHM7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAodW5wcm94aWVkWzBdLnR5cGUgPT09IFwiZmlsZVwiKSB7XHJcblx0XHRcdFx0cmV0dXJuIHVucHJveGllZFswXS5wYXRoO1xyXG5cdFx0XHR9IGVsc2UgcmV0dXJuIHVucHJveGllZFswXTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0aWYgKHVucHJveGllZFswXS50eXBlID09PSBcImZpbGVcIikge1xyXG5cdFx0XHRyZXR1cm4gdW5wcm94aWVkLm1hcCgobGluaykgPT4gbGluay5wYXRoKTtcclxuXHRcdH0gZWxzZSByZXR1cm4gdW5wcm94aWVkO1xyXG5cdH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1bnByb3h5ID0gKGl0ZW06IGFueSk6IERhdGFUeXBlW10gPT4ge1xyXG5cdGNvbnN0IHVucHJveGllZCA9IFtdO1xyXG5cclxuXHRjb25zdCBxdWV1ZSA9IFtpdGVtXTtcclxuXHR3aGlsZSAocXVldWUubGVuZ3RoKSB7XHJcblx0XHRjb25zdCBjdXJySXRlbSA9IHF1ZXVlLnNoaWZ0KCk7XHJcblx0XHQvLyBcIlByb3h5XCIgZm9yIGNoZWNraW5nIGlmIGBjdXJySXRlbWAgaXMgYSBwcm94eVxyXG5cdFx0aWYgKHR5cGVvZiBjdXJySXRlbS5kZWZhdWx0Q29tcGFyYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRcdGNvbnN0IHBvc3NpYmxlVW5wcm94aWVkID0gT2JqZWN0LmFzc2lnbih7fSwgY3Vyckl0ZW0pO1xyXG5cdFx0XHRjb25zdCB7IHZhbHVlcyB9ID0gcG9zc2libGVVbnByb3hpZWQ7XHJcblx0XHRcdGlmICh2YWx1ZXMpIHF1ZXVlLnB1c2goLi4udmFsdWVzKTtcclxuXHRcdFx0ZWxzZSB1bnByb3hpZWQucHVzaChwb3NzaWJsZVVucHJveGllZCk7XHJcblx0XHR9IGVsc2UgdW5wcm94aWVkLnB1c2goY3Vyckl0ZW0pO1xyXG5cdH1cclxuXHRyZXR1cm4gdW5wcm94aWVkO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHByb2Nlc3NQYWdlcyA9IChcclxuXHRwYWdlczogeyBbZmllbGQ6IHN0cmluZ106IGFueSB9W10sXHJcblx0ZmllbGRzVG9DaGVjazogc3RyaW5nW11cclxuKTogeyBwYWdlczogeyBbZmllbGQ6IHN0cmluZ106IGFueSB9W107IGRhdGVzOiBEYXRlVGltZVtdIH0gPT4ge1xyXG5cdGNvbnN0IGRhdGVzOiBEYXRlVGltZVtdID0gW107XHJcblx0cGFnZXMuZm9yRWFjaCgocGFnZSkgPT4ge1xyXG5cdFx0Y29uc3QgcG90ZW50aWFsRGF0ZSA9IERhdGVUaW1lLmZyb21JU08ocGFnZS5maWxlLm5hbWUpO1xyXG5cdFx0aWYgKHBvdGVudGlhbERhdGUuaXNWYWxpZCkgZGF0ZXMucHVzaChwb3RlbnRpYWxEYXRlKTtcclxuXHJcblx0XHRmaWVsZHNUb0NoZWNrLmZvckVhY2goKGZpZWxkKSA9PiB7XHJcblx0XHRcdGNvbnN0IHZhbHVlID0gcGFnZVtmaWVsZF07XHJcblx0XHRcdGlmICh2YWx1ZSkge1xyXG5cdFx0XHRcdHBhZ2VbXCJoYXNGaWVsZHNPZkludGVyZXN0XCJdID0gdHJ1ZTtcclxuXHRcdFx0XHRwYWdlW2ZpZWxkXSA9IGdldElubmVyVmFsdWUodmFsdWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHBhZ2VzOiBwYWdlcy5maWx0ZXIoKHBhZ2UpID0+IHBhZ2UuaGFzRmllbGRzT2ZJbnRlcmVzdCksXHJcblx0XHRkYXRlczogZGF0ZXMsXHJcblx0fTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBwb3NzaWJsZSBwYWlycyBvZiBzdHJpbmdzIGluIHRoZSBhcnJheS5cclxuICpcclxuICogQXZvaWRzIGRpYWdvbmFscy5cclxuICogQHBhcmFtIHtzdHJpbmdbXX0gaXRlbXMgLSBUaGUgYXJyYXkgb2Ygc3RyaW5ncyB0byBwYWlyLlxyXG4gKiBAcmV0dXJucyBBIGxpc3Qgb2YgYWxsIHBhaXJzIG9mIGl0ZW1zIGZyb20gdGhlIGxpc3QuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNvbnN0IGJ1aWxkQWxsUGFpcnMgPSAoXHJcblx0aXRlbXM6IHN0cmluZ1tdLFxyXG5cdHNvcnRlZFNraXBQYWlyczogc3RyaW5nW11bXSxcclxuXHRzb3J0ZWQ6IGJvb2xlYW4gPSBmYWxzZVxyXG4pOiBzdHJpbmdbXVtdID0+IHtcclxuXHRpZiAoIXNvcnRlZCkgaXRlbXMuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcclxuXHJcblx0Y29uc3Qgc3RyaW5naWZpZWRTb3J0ZWRTa2lwUGFpcnMgPSBzb3J0ZWRTa2lwUGFpcnMubWFwKCh2YWx1ZSkgPT5cclxuXHRcdHZhbHVlLnRvU3RyaW5nKClcclxuXHQpO1xyXG5cclxuXHRsZXQgcmVzdWx0cyA9IFtdO1xyXG5cclxuXHRmb3IgKGxldCBvdXRlckluZGV4ID0gMDsgb3V0ZXJJbmRleCA8IGl0ZW1zLmxlbmd0aDsgb3V0ZXJJbmRleCsrKSB7XHJcblx0XHRsZXQgZmlyc3QgPSBpdGVtc1tvdXRlckluZGV4XTtcclxuXHRcdGZvciAoXHJcblx0XHRcdC8vIFNraXAgdGhlIGRpYWdvbmFsXHJcblx0XHRcdGxldCBpbm5lckluZGV4ID0gb3V0ZXJJbmRleCArIDE7XHJcblx0XHRcdGlubmVySW5kZXggPCBpdGVtcy5sZW5ndGg7XHJcblx0XHRcdGlubmVySW5kZXgrK1xyXG5cdFx0KSB7XHJcblx0XHRcdGNvbnN0IHBhaXIgPSBbZmlyc3QsIGl0ZW1zW2lubmVySW5kZXhdXTtcclxuXHRcdFx0aWYgKCFzdHJpbmdpZmllZFNvcnRlZFNraXBQYWlycy5pbmNsdWRlcyhwYWlyLnRvU3RyaW5nKCkpKSB7XHJcblx0XHRcdFx0cmVzdWx0cy5wdXNoKFtmaXJzdCwgaXRlbXNbaW5uZXJJbmRleF1dKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmVzdWx0cztcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBidWlsZEFsbERhdGFCeUZpZWxkc1RvQ2hlY2sgPSAoXHJcblx0ZGF0YTogeyBbZmllbGQ6IHN0cmluZ106IERhdGFUeXBlIH1bXSxcclxuXHRmaWVsZHNUb0NoZWNrOiBzdHJpbmdbXVxyXG4pOiB7IFtmaWVsZDogc3RyaW5nXTogRGF0YVR5cGVbXSB9ID0+IHtcclxuXHRjb25zdCBkYXRhQnlGaWVsZDogeyBbZmllbGQ6IHN0cmluZ106IERhdGFUeXBlW10gfSA9IHt9O1xyXG5cdGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzVG9DaGVjaykge1xyXG5cdFx0ZGF0YUJ5RmllbGRbZmllbGRdID0gZGF0YS5tYXAoKHBhZ2UpID0+IHBhZ2VbZmllbGRdKTtcclxuXHR9XHJcblx0cmV0dXJuIGRhdGFCeUZpZWxkO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGJ1aWxkQWxsQ29ycmVsYXRpb25zID0gKFxyXG5cdGRhdGE6IHsgW2ZpZWxkOiBzdHJpbmddOiBEYXRhVHlwZSB9W10sXHJcblx0ZmllbGRzVG9DaGVjazogc3RyaW5nW10sXHJcblx0cGFpcnNUb1NraXA6IHN0cmluZ1tdW10sXHJcblx0ZGVidWdNb2RlOiBib29sZWFuID0gZmFsc2VcclxuKTogQ29ycmVsYXRpb25zID0+IHtcclxuXHQvLyBBbHBoYWJldGl6ZSBmaWVsZHNUb0NoZWNrIGxpc3QuIFRoaXMgbWFrZXMgaXQgZWFzaWVyIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGNvcnJlbGF0aW9uIHBhaXJzLlxyXG5cdGZpZWxkc1RvQ2hlY2suc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcclxuXHJcblx0Ly8gQWxwaGFiZXRpemUgc2tpcCBwYWlycy4gVGhpcyBhbGxvd3MgdXMgdG8gZWFzaWx5IHJlbW92ZSBwYWlycyBmcm9tIHRoZSBmdXR1cmUgY29ycmVsYXRpb24gcGFpciBsaXN0LlxyXG5cdGNvbnN0IGFscGhhYmV0aXplZFNraXBQYWlyczogc3RyaW5nW11bXSA9IFtdO1xyXG5cdGZvciAoY29uc3Qgc2tpcFBhaXIgb2YgcGFpcnNUb1NraXApIHtcclxuXHRcdHNraXBQYWlyLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XHJcblx0XHRhbHBoYWJldGl6ZWRTa2lwUGFpcnMucHVzaChza2lwUGFpcik7XHJcblx0fVxyXG5cclxuXHRjb25zdCBjb3JyczogQ29ycmVsYXRpb25zID0ge307XHJcblx0Y29uc3QgZGF0YUJ5RmllbGQgPSBidWlsZEFsbERhdGFCeUZpZWxkc1RvQ2hlY2soZGF0YSwgZmllbGRzVG9DaGVjayk7XHJcblxyXG5cdC8vIEJ1aWxkIGFsbCBjb3JyZWxhdGlvbiBwYWlycy4gRmlsdGVyIG91dCBhbnkgb2YgdGhlIHNraXAgcGFpcnMuXHJcblx0bGV0IHBhaXJzID0gYnVpbGRBbGxQYWlycyhmaWVsZHNUb0NoZWNrLCBhbHBoYWJldGl6ZWRTa2lwUGFpcnMsIHRydWUpO1xyXG5cclxuXHRmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcclxuXHRcdGNvbnN0IFtmaWVsZEEsIGZpZWxkQl0gPSBwYWlyO1xyXG5cdFx0Y29uc3QgZmllbGRBRGF0YSA9IGRhdGFCeUZpZWxkW2ZpZWxkQV07XHJcblx0XHRjb25zdCBmaWVsZEJEYXRhID0gZGF0YUJ5RmllbGRbZmllbGRCXTtcclxuXHJcblx0XHRidWlsZENvcnJlbGF0aW9uKGZpZWxkQSwgZmllbGRCLCBmaWVsZEFEYXRhLCBmaWVsZEJEYXRhLCBjb3Jycyk7XHJcblx0fVxyXG5cclxuXHRpZiAoZGVidWdNb2RlKSBjb25zb2xlLmxvZyh7IGNvcnJzIH0pO1xyXG5cdHJldHVybiBjb3JycztcclxufTtcclxuXHJcbmNvbnN0IGJ1aWxkQ29ycmVsYXRpb25OdW1iZXJBbmRPYmplY3QgPSAoXHJcblx0bnVtYmVyRmllbGQ6IHN0cmluZyxcclxuXHRudW1iZXJGaWVsZERhdGE6IERhdGFUeXBlW10sXHJcblx0b2JqZWN0RmllbGQ6IHN0cmluZyxcclxuXHRvYmplY3RGaWVsZERhdGE6IERhdGFUeXBlW10sXHJcblx0Y29ycnM6IENvcnJlbGF0aW9uc1xyXG4pOiBDb3JyZWxhdGlvbnMgPT4ge1xyXG5cdGlmICghY29ycnNbbnVtYmVyRmllbGRdKSB7XHJcblx0XHRjb3Jyc1tudW1iZXJGaWVsZF0gPSB7fTtcclxuXHR9XHJcblxyXG5cdGNvbnN0IG9BID0gbnVtYmVyRmllbGREYXRhLmZpbHRlcigoYSkgPT4gYSk7XHJcblx0Y29uc3Qgb0IgPSAob2JqZWN0RmllbGREYXRhIGFzIHN0cmluZ1tdW10pLmZpbHRlcihcclxuXHRcdChiLCBpKSA9PiBudW1iZXJGaWVsZERhdGFbaV0gIT09IHVuZGVmaW5lZFxyXG5cdCk7XHJcblxyXG5cdGNvbnN0IHVuaXF1ZVN0cnMgPSBbLi4ubmV3IFNldChvQi5mbGF0KCkpXS5maWx0ZXIoXHJcblx0XHQoc3RyKSA9PiB0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiXHJcblx0KTtcclxuXHR1bmlxdWVTdHJzLmZvckVhY2goKHN1YkYpID0+IHtcclxuXHRcdGNvbnN0IHN1YkEgPSBvQTtcclxuXHRcdGNvbnN0IHN1YkIgPSBvQi5tYXAoKGIpID0+IChiICYmIGIuaW5jbHVkZXMoc3ViRikgPyAxIDogMCkpO1xyXG5cdFx0Y29uc3QgY29yciA9IGdldFBvaW50QmlzZXJpYWxDb3JyZWxhdGlvbihzdWJCLCBzdWJBKTtcclxuXHRcdGNvcnJzW251bWJlckZpZWxkXVtvYmplY3RGaWVsZCArIFwiLlwiICsgc3ViRl0gPSBjb3JyXHJcblx0XHRcdD8geyBjb3JyLCBuOiBzdWJBLmxlbmd0aCB9XHJcblx0XHRcdDogbnVsbDtcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIGNvcnJzO1xyXG59O1xyXG5cclxuY29uc3QgYnVpbGRDb3JyZWxhdGlvbk51bWJlckFuZFN0cmluZyA9IChcclxuXHRzdHJpbmdGaWVsZDogc3RyaW5nLFxyXG5cdHN0cmluZ0ZpZWxkRGF0YTogRGF0YVR5cGVbXSxcclxuXHRudW1iZXJGaWVsZDogc3RyaW5nLFxyXG5cdG51bWJlckZpZWxkRGF0YTogRGF0YVR5cGVbXSxcclxuXHRjb3JyczogQ29ycmVsYXRpb25zXHJcbik6IENvcnJlbGF0aW9ucyA9PiB7XHJcblx0aWYgKCFjb3Jyc1tudW1iZXJGaWVsZF0pIHtcclxuXHRcdGNvcnJzW251bWJlckZpZWxkXSA9IHt9O1xyXG5cdH1cclxuXHJcblx0Y29uc3Qgb0EgPSBudW1iZXJGaWVsZERhdGEuZmlsdGVyKChhOiBhbnkpID0+IGEpO1xyXG5cdGNvbnN0IG9CID0gc3RyaW5nRmllbGREYXRhXHJcblx0XHQuZmlsdGVyKChiLCBpKSA9PiBudW1iZXJGaWVsZERhdGFbaV0gIT09IHVuZGVmaW5lZClcclxuXHRcdC5tYXAoKGIpID0+IGIgPz8gMCk7XHJcblxyXG5cdGNvbnN0IHVuaXF1ZVN0cnMgPSBbLi4ubmV3IFNldChvQildLmZpbHRlcihcclxuXHRcdChzdHIpID0+IHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCJcclxuXHQpO1xyXG5cdHVuaXF1ZVN0cnMuZm9yRWFjaCgoc3ViRikgPT4ge1xyXG5cdFx0Y29uc3Qgc3ViQSA9IG9BO1xyXG5cdFx0Y29uc3Qgc3ViQiA9IG9CLm1hcCgoYikgPT4gKGIgPT09IHN1YkYgPyAxIDogMCkpO1xyXG5cclxuXHRcdGNvbnN0IGNvcnIgPSBnZXRQb2ludEJpc2VyaWFsQ29ycmVsYXRpb24oc3ViQiwgc3ViQSk7XHJcblx0XHRjb3Jyc1tudW1iZXJGaWVsZF1bc3RyaW5nRmllbGQgKyBcIi5cIiArIHN1YkZdID0gY29yclxyXG5cdFx0XHQ/IHsgY29yciwgbjogc3ViQS5sZW5ndGggfVxyXG5cdFx0XHQ6IG51bGw7XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBjb3JycztcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBidWlsZENvcnJlbGF0aW9uID0gKFxyXG5cdGZpZWxkQTogc3RyaW5nLFxyXG5cdGZpZWxkQjogc3RyaW5nLFxyXG5cdGZpZWxkQURhdGE6IERhdGFUeXBlW10sXHJcblx0ZmllbGRCRGF0YTogRGF0YVR5cGVbXSxcclxuXHRjb3JyczogQ29ycmVsYXRpb25zXHJcbik6IENvcnJlbGF0aW9ucyA9PiB7XHJcblx0aWYgKGZpZWxkQSA9PSBmaWVsZEIpIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdGlmICghY29ycnNbZmllbGRBXSkgY29ycnNbZmllbGRBXSA9IHt9O1xyXG5cclxuXHRjb25zdCBmaWVsZEFUeXBlID0gaW5mZXJUeXBlKGZpZWxkQURhdGEpO1xyXG5cdGNvbnN0IGZpZWxkQlR5cGUgPSBpbmZlclR5cGUoZmllbGRCRGF0YSk7XHJcblxyXG5cdGlmIChmaWVsZEFUeXBlID09PSBcIm51bWJlclwiICYmIGZpZWxkQlR5cGUgPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdGNvbnN0IFtvQSwgb0JdID0gYXJyYXlPdmVybGFwKGZpZWxkQURhdGEsIGZpZWxkQkRhdGEpO1xyXG5cdFx0Y29uc3QgY29yciA9IGdldFBlYXJzb25Db3JyZWxhdGlvbihvQSwgb0IpO1xyXG5cdFx0Y29ycnNbZmllbGRBXVtmaWVsZEJdID0gY29yciA/IHsgY29yciwgbjogb0EubGVuZ3RoIH0gOiBudWxsO1xyXG5cdH0gZWxzZSBpZiAoZmllbGRBVHlwZSA9PT0gXCJudW1iZXJcIiAmJiBmaWVsZEJUeXBlID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRjb3JycyA9IGJ1aWxkQ29ycmVsYXRpb25OdW1iZXJBbmRTdHJpbmcoXHJcblx0XHRcdGZpZWxkQixcclxuXHRcdFx0ZmllbGRCRGF0YSxcclxuXHRcdFx0ZmllbGRBLFxyXG5cdFx0XHRmaWVsZEFEYXRhLFxyXG5cdFx0XHRjb3Jyc1xyXG5cdFx0KTtcclxuXHR9IGVsc2UgaWYgKGZpZWxkQVR5cGUgPT09IFwibnVtYmVyXCIgJiYgZmllbGRCVHlwZSA9PT0gXCJvYmplY3RcIikge1xyXG5cdFx0Y29ycnMgPSBidWlsZENvcnJlbGF0aW9uTnVtYmVyQW5kT2JqZWN0KFxyXG5cdFx0XHRmaWVsZEEsXHJcblx0XHRcdGZpZWxkQURhdGEsXHJcblx0XHRcdGZpZWxkQixcclxuXHRcdFx0ZmllbGRCRGF0YSxcclxuXHRcdFx0Y29ycnNcclxuXHRcdCk7XHJcblx0fSBlbHNlIGlmIChmaWVsZEFUeXBlID09PSBcInN0cmluZ1wiICYmIGZpZWxkQlR5cGUgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdGNvcnJzW2ZpZWxkQV1bZmllbGRCXSA9IG51bGw7XHJcblx0fSBlbHNlIGlmIChmaWVsZEFUeXBlID09PSBcInN0cmluZ1wiICYmIGZpZWxkQlR5cGUgPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdGNvcnJzID0gYnVpbGRDb3JyZWxhdGlvbk51bWJlckFuZFN0cmluZyhcclxuXHRcdFx0ZmllbGRBLFxyXG5cdFx0XHRmaWVsZEFEYXRhLFxyXG5cdFx0XHRmaWVsZEIsXHJcblx0XHRcdGZpZWxkQkRhdGEsXHJcblx0XHRcdGNvcnJzXHJcblx0XHQpO1xyXG5cdH0gZWxzZSBpZiAoZmllbGRBVHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBmaWVsZEJUeXBlID09PSBcIm9iamVjdFwiKSB7XHJcblx0XHRjb3Jyc1tmaWVsZEFdW2ZpZWxkQl0gPSBudWxsO1xyXG5cdH0gZWxzZSBpZiAoZmllbGRBVHlwZSA9PT0gXCJvYmplY3RcIiAmJiBmaWVsZEJUeXBlID09PSBcIm9iamVjdFwiKSB7XHJcblx0XHRjb3Jyc1tmaWVsZEFdW2ZpZWxkQl0gPSBudWxsO1xyXG5cdH0gZWxzZSBpZiAoZmllbGRBVHlwZSA9PT0gXCJvYmplY3RcIiAmJiBmaWVsZEJUeXBlID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRjb3JycyA9IGJ1aWxkQ29ycmVsYXRpb25OdW1iZXJBbmRPYmplY3QoXHJcblx0XHRcdGZpZWxkQixcclxuXHRcdFx0ZmllbGRCRGF0YSxcclxuXHRcdFx0ZmllbGRBLFxyXG5cdFx0XHRmaWVsZEFEYXRhLFxyXG5cdFx0XHRjb3Jyc1xyXG5cdFx0KTtcclxuXHR9IGVsc2UgaWYgKGZpZWxkQVR5cGUgPT09IFwib2JqZWN0XCIgJiYgZmllbGRCVHlwZSA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0Y29ycnNbZmllbGRBXVtmaWVsZEJdID0gbnVsbDtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjb3JycztcclxufTtcclxuIiwgImltcG9ydCB7IEl0ZW1WaWV3LCBXb3Jrc3BhY2VMZWFmIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7IGFkZEZlYXRoZXJJY29uIH0gZnJvbSBcIm9ic2lkaWFuLWNvbW11bml0eS1saWJcIjtcclxuaW1wb3J0IENvcnJlbGF0aW9ucyBmcm9tIFwiLi9Db21wb25lbnRzL0NvcnJlbGF0aW9ucy5zdmVsdGVcIjtcclxuaW1wb3J0IHsgQ09SUkVMQVRJT05fVklFVyB9IGZyb20gXCIuL2NvbnN0XCI7XHJcbmltcG9ydCB7IGJ1aWxkQWxsQ29ycmVsYXRpb25zIH0gZnJvbSBcIi4vY29ycmVsYXRpb25VdGlsc1wiO1xyXG5pbXBvcnQgdHlwZSBEYXRhQW5hbHlzaXNQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29ycmVsYXRpb25WaWV3IGV4dGVuZHMgSXRlbVZpZXcge1xyXG5cdHBsdWdpbjogRGF0YUFuYWx5c2lzUGx1Z2luO1xyXG5cdHZpZXc6IENvcnJlbGF0aW9ucztcclxuXHRtYXRyaXhROiBib29sZWFuO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihsZWFmOiBXb3Jrc3BhY2VMZWFmLCBwbHVnaW46IERhdGFBbmFseXNpc1BsdWdpbikge1xyXG5cdFx0c3VwZXIobGVhZik7XHJcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuXHR9XHJcblxyXG5cdGFzeW5jIG9ubG9hZCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdHN1cGVyLm9ubG9hZCgpO1xyXG5cdH1cclxuXHJcblx0Z2V0Vmlld1R5cGUoKSB7XHJcblx0XHRyZXR1cm4gQ09SUkVMQVRJT05fVklFVztcclxuXHR9XHJcblx0Z2V0RGlzcGxheVRleHQoKSB7XHJcblx0XHRyZXR1cm4gXCJDb3JyZWxhdGlvbnMgVmlld1wiO1xyXG5cdH1cclxuXHJcblx0aWNvbiA9IDxzdHJpbmc+YWRkRmVhdGhlckljb24oXCJ0cmVuZGluZy11cFwiKTtcclxuXHJcblx0YXN5bmMgb25PcGVuKCk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0YXdhaXQgdGhpcy5kcmF3KCk7XHJcblx0fVxyXG5cclxuXHRvbkNsb3NlKCk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0dGhpcy52aWV3Py4kZGVzdHJveSgpO1xyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgZHJhdygpOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdGNvbnN0IHsgY29udGVudEVsLCBwbHVnaW4gfSA9IHRoaXM7XHJcblxyXG5cdFx0Y29udGVudEVsLmVtcHR5KCk7XHJcblx0XHRjb250ZW50RWwuYWRkQ2xhc3MoXCJEQS1jb3JyLXZpZXdcIik7XHJcblxyXG5cdFx0Y29udGVudEVsLmNyZWF0ZUVsKFxyXG5cdFx0XHRcImJ1dHRvblwiLFxyXG5cdFx0XHR7IHRleHQ6IFwiXHUyMUJCXCIsIGF0dHI6IHsgXCJhcmlhLWxhYmVsXCI6IFwiUmVmcmVzaCBJbmRleCAmIFJlZHJhd1wiIH0gfSxcclxuXHRcdFx0KGJ1dCkgPT4ge1xyXG5cdFx0XHRcdGJ1dC5vbmNsaWNrID0gYXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRcdFx0YXdhaXQgcGx1Z2luLnJlZnJlc2hJbmRleCgpO1xyXG5cdFx0XHRcdFx0cGx1Z2luLmluZGV4LmNvcnJzID0gYnVpbGRBbGxDb3JyZWxhdGlvbnMoXHJcblx0XHRcdFx0XHRcdHBsdWdpbi5pbmRleC5kYXRhLFxyXG5cdFx0XHRcdFx0XHRwbHVnaW4uc2V0dGluZ3MuZmllbGRzVG9DaGVjayxcclxuXHRcdFx0XHRcdFx0cGx1Z2luLnNldHRpbmdzLmZpZWxkc1RvSWdub3JlRm9yQ29ycnNcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLmRyYXcoKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblx0XHQpO1xyXG5cclxuXHRcdG5ldyBDb3JyZWxhdGlvbnMoeyB0YXJnZXQ6IGNvbnRlbnRFbCwgcHJvcHM6IHsgdmlldzogdGhpcyB9IH0pO1xyXG5cdH1cclxufVxyXG4iLCAiPHNjcmlwdCBsYW5nPVwidHNcIj5cclxuXHRpbXBvcnQgbm9VaVNsaWRlciwgeyBBUEkgfSBmcm9tIFwibm91aXNsaWRlclwiO1xyXG5cdGltcG9ydCB7IFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcblx0aW1wb3J0IENvcnJlbGF0aW9uVmlldyBmcm9tIFwiLi4vQ29ycmVsYXRpb25WaWV3XCI7XHJcblx0aW1wb3J0IHsgbWVudUZvckNoYXJ0TlN0YXRzTW9kYWwgfSBmcm9tIFwiLi4vdXRpbHNcIjtcclxuXHJcblx0ZXhwb3J0IGxldCB2aWV3OiBDb3JyZWxhdGlvblZpZXc7XHJcblxyXG5cdGNvbnN0IHsgcGx1Z2luLCBhcHAgfSA9IHZpZXc7XHJcblx0Y29uc3QgeyBpbmRleCB9ID0gcGx1Z2luO1xyXG5cdGNvbnN0IHsgY29ycnMgfSA9IGluZGV4O1xyXG5cclxuXHRsZXQgW2xvd2VyLCB1cHBlcl0gPSBbLTEsIDAuNV07XHJcblx0bGV0IGFic1EgPSBmYWxzZTtcclxuXHRsZXQgc2xpZGVyOiBBUEk7XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZVNsaWRlcihub2RlKSB7XHJcblx0XHRzbGlkZXIgPSBub1VpU2xpZGVyLmNyZWF0ZShub2RlLCB7XHJcblx0XHRcdHN0YXJ0OiBbbG93ZXIsIHVwcGVyXSxcclxuXHRcdFx0Y29ubmVjdDogdHJ1ZSxcclxuXHRcdFx0cmFuZ2U6IHtcclxuXHRcdFx0XHRtaW46IC0xLFxyXG5cdFx0XHRcdG1heDogMSxcclxuXHRcdFx0fSxcclxuXHRcdH0pO1xyXG5cdFx0c2xpZGVyLm9uKFwidXBkYXRlXCIsIChlKSA9PiB7XHJcblx0XHRcdGxvd2VyID0gTnVtYmVyLnBhcnNlRmxvYXQoZVswXSk7XHJcblx0XHRcdHVwcGVyID0gTnVtYmVyLnBhcnNlRmxvYXQoZVsxXSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZUZpZWxkc0luRmlsZShjdXJyRmlsZTogVEZpbGUpOiBzdHJpbmdbXSB7XHJcblx0XHRjb25zdCBjdXJyUGFnZSA9IGluZGV4LmRhdGEuZmluZChcclxuXHRcdFx0KGQpID0+IGQuZmlsZS5uYW1lID09PSBjdXJyRmlsZS5iYXNlbmFtZVxyXG5cdFx0KTtcclxuXHJcblx0XHQvLyBJZiB3ZSBkaWRuJ3QgaW5kZXhlZCB0aGUgY3VycmVudCBwYWdlLCBpdCBkaWRuJ3QgaGF2ZSBhbnkgZmllbGRzXHJcblx0XHRpZiAoIWN1cnJQYWdlKSB7XHJcblx0XHRcdHJldHVybiBbXTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBmaWVsZHNJbkZpbGUgPSBPYmplY3Qua2V5cyhjdXJyUGFnZSk7XHJcblxyXG5cdFx0Y29uc3QgeyB1bndyYXBwZWRGaWVsZHMgfSA9IHBsdWdpbjtcclxuXHRcdE9iamVjdC5rZXlzKHVud3JhcHBlZEZpZWxkcykuZm9yRWFjaCgoZmllbGQpID0+IHtcclxuXHRcdFx0aWYgKGZpZWxkc0luRmlsZS5pbmNsdWRlcyhmaWVsZCkpIHtcclxuXHRcdFx0XHR1bndyYXBwZWRGaWVsZHNbZmllbGRdLmZvckVhY2goKHN1YkYpID0+IHtcclxuXHRcdFx0XHRcdGlmIChcclxuXHRcdFx0XHRcdFx0Y3VyclBhZ2VbZmllbGRdLmluY2x1ZGVzICYmXHJcblx0XHRcdFx0XHRcdGN1cnJQYWdlW2ZpZWxkXT8uaW5jbHVkZXMoc3ViRilcclxuXHRcdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0XHRmaWVsZHNJbkZpbGUucHVzaChmaWVsZCArIFwiLlwiICsgc3ViRik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0Y29uc29sZS5sb2coeyBmaWVsZHNJbkZpbGUgfSk7XHJcblx0XHRyZXR1cm4gZmllbGRzSW5GaWxlO1xyXG5cdH1cclxuXHJcblx0bGV0IGN1cnJGaWxlID0gYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcblx0bGV0IGZpZWxkc0luRmlsZSA9IHVwZGF0ZUZpZWxkc0luRmlsZShjdXJyRmlsZSk7XHJcblxyXG5cdHBsdWdpbi5yZWdpc3RlckV2ZW50KFxyXG5cdFx0YXBwLndvcmtzcGFjZS5vbihcImFjdGl2ZS1sZWFmLWNoYW5nZVwiLCAoKSA9PiB7XHJcblx0XHRcdGN1cnJGaWxlID0gYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcblx0XHRcdGZpZWxkc0luRmlsZSA9IHVwZGF0ZUZpZWxkc0luRmlsZShjdXJyRmlsZSk7XHJcblx0XHR9KVxyXG5cdCk7XHJcblxyXG5cdGNvbnN0IGZpZWxkcyA9IE9iamVjdC5rZXlzKGNvcnJzKTtcclxuXHRjb25zdCBjb3Jyc1RvU2hvdyA9IGZpZWxkc1xyXG5cdFx0Lm1hcCgoZkEpID0+XHJcblx0XHRcdGZpZWxkc0luRmlsZS5tYXAoKGZCKSA9PiB7XHJcblx0XHRcdFx0cmV0dXJuIHsgZkEsIGZCLCBpbmZvOiBjb3Jyc1tmQV1bZkJdIH07XHJcblx0XHRcdH0pXHJcblx0XHQpXHJcblx0XHQuZmxhdCgpXHJcblx0XHQuZmlsdGVyKChpdGVtKSA9PiB7XHJcblx0XHRcdGNvbnN0IHsgaW5mbyB9ID0gaXRlbTtcclxuXHRcdFx0cmV0dXJuIGluZm8gJiYgaW5mby5jb3JyICE9PSBOYU47XHJcblx0XHR9KVxyXG5cdFx0LnNvcnQoKGEsIGIpID0+IGIuaW5mby5jb3JyIC0gYS5pbmZvLmNvcnIpO1xyXG5cclxuXHRjb25zb2xlLmxvZyh7IGNvcnJzVG9TaG93IH0pO1xyXG48L3NjcmlwdD5cclxuXHJcbjxkaXYgY2xhc3M9XCJjb21wb25lbnRcIj5cclxuXHQ8ZGl2PlxyXG5cdFx0PCEtLSBzdmVsdGUtaWdub3JlIGExMXktbGFiZWwtaGFzLWFzc29jaWF0ZWQtY29udHJvbCAtLT5cclxuXHRcdDxsYWJlbD5cclxuXHRcdFx0PGRpdiBjbGFzcz1cInNsaWRlclwiIHVzZTpjcmVhdGVTbGlkZXIgLz5cclxuXHRcdFx0KHtsb3dlcn0pIFx1MjE5NCAoe3VwcGVyfSlcclxuXHRcdDwvbGFiZWw+XHJcblx0XHQ8bGFiZWw+XHJcblx0XHRcdDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBiaW5kOmNoZWNrZWQ9e2Fic1F9IC8+XHJcblx0XHRcdHxBYnN8XHJcblx0XHQ8L2xhYmVsPlxyXG5cdDwvZGl2PlxyXG5cclxuXHR7I2lmIGNvcnJzVG9TaG93Lmxlbmd0aCA9PSAwfVxyXG5cdFx0Tm8gcmVsZXZhbnQgZmllbGRzIGluIGN1cnJlbnQgZmlsZS4gU2VsZWN0IGEgZGlmZmVyZW50IGZpbGUuXHJcblx0ezplbHNlfVxyXG5cdFx0PHRhYmxlIGNsYXNzPVwibWFya2Rvd24tcHJldmlldy12aWV3XCI+XHJcblx0XHRcdDx0aGVhZD5cclxuXHRcdFx0XHQ8dHI+XHJcblx0XHRcdFx0XHQ8dGg+RmllbGQgMTwvdGg+XHJcblx0XHRcdFx0XHQ8dGg+RmllbGQgMjwvdGg+XHJcblx0XHRcdFx0XHQ8dGg+Q29ycmVsYXRpb248L3RoPlxyXG5cdFx0XHRcdDwvdHI+XHJcblx0XHRcdDwvdGhlYWQ+XHJcblxyXG5cdFx0XHQ8dGJvZHk+XHJcblx0XHRcdFx0eyNrZXkgYWJzUX1cclxuXHRcdFx0XHRcdHsjZWFjaCBjb3Jyc1RvU2hvdyBhcyB7IGZBLCBmQiwgaW5mbzogeyBjb3JyLCBuIH0gfX1cclxuXHRcdFx0XHRcdFx0eyNpZiAoZmllbGRzSW5GaWxlLmluY2x1ZGVzKGZBKSB8fCAoZkIuaW5jbHVkZXMoXCIuXCIpICYmIGZpZWxkc0luRmlsZS5pbmNsdWRlcyhmQikpKSAmJiBsb3dlciA8PSBjb3JyICYmIGNvcnIgPD0gdXBwZXJ9XHJcblx0XHRcdFx0XHRcdFx0PCEtLSBzdmVsdGUtaWdub3JlIGExMXktdW5rbm93bi1hcmlhLWF0dHJpYnV0ZSAtLT5cclxuXHRcdFx0XHRcdFx0XHQ8dHJcclxuXHRcdFx0XHRcdFx0XHRcdGFyaWEtbGFiZWw9e24gPyBcIm46IFwiICsgbi50b0ZpeGVkKCkgOiBcIlwifVxyXG5cdFx0XHRcdFx0XHRcdFx0YXJpYS1sYWJlbC1wb3NpdGlvbj1cImxlZnRcIlxyXG5cdFx0XHRcdFx0XHRcdFx0b246Y29udGV4dG1lbnU9eyhlKSA9PlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRtZW51Rm9yQ2hhcnROU3RhdHNNb2RhbChlLCBwbHVnaW4pfVxyXG5cdFx0XHRcdFx0XHRcdD5cclxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57ZkF9PC90ZD5cclxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57ZkJ9PC90ZD5cclxuXHRcdFx0XHRcdFx0XHRcdDx0ZD57Y29yci50b0ZpeGVkKDQpfTwvdGQ+XHJcblx0XHRcdFx0XHRcdFx0PC90cj5cclxuXHRcdFx0XHRcdFx0ey9pZn1cclxuXHRcdFx0XHRcdHsvZWFjaH1cclxuXHRcdFx0XHR7L2tleX1cclxuXHRcdFx0PC90Ym9keT5cclxuXHRcdDwvdGFibGU+XHJcblx0ey9pZn1cclxuPC9kaXY+XHJcblxyXG48c3R5bGU+XHJcblx0ZGl2LmNvbXBvbmVudCB7XHJcblx0XHRwYWRkaW5nOiA1cHg7XHJcblx0fVxyXG5cclxuXHRkaXYuc2xpZGVyIHtcclxuXHRcdHdpZHRoOiAxNTBweDtcclxuXHRcdGhlaWdodDogMTBweDtcclxuXHRcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcclxuXHR9XHJcblx0dGFibGUge1xyXG5cdFx0Ym9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcclxuXHRcdG92ZXJmbG93OiBhdXRvO1xyXG5cdH1cclxuXHR0YWJsZSxcclxuXHR0YWJsZSB0cixcclxuXHR0YWJsZSB0ZCB7XHJcblx0XHRib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlcik7XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iLCAiaW1wb3J0IHsgQXBwLCBOb3RpY2UsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHsgREVGQVVMVF9TRVRUSU5HUyB9IGZyb20gXCIuL2NvbnN0XCI7XHJcbmltcG9ydCB7IHNwbGl0QW5kVHJpbSB9IGZyb20gXCIuL2NvcnJlbGF0aW9uVXRpbHNcIjtcclxuaW1wb3J0IERhdGFBbmFseXNpc1BsdWdpbiBmcm9tIFwiLi9tYWluXCI7XHJcbmltcG9ydCB7IHRvS2ViYWJDYXNlIH0gZnJvbSBcIi4vdXRpbHNcIjtcclxuXHJcbmNvbnN0IGZyYWdXaXRoSFRNTCA9IChodG1sOiBzdHJpbmcpID0+XHJcblx0Y3JlYXRlRnJhZ21lbnQoKGZyYWcpID0+IChmcmFnLmNyZWF0ZURpdigpLmlubmVySFRNTCA9IGh0bWwpKTtcclxuZXhwb3J0IGNsYXNzIFNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcclxuXHRwbHVnaW46IERhdGFBbmFseXNpc1BsdWdpbjtcclxuXHJcblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogRGF0YUFuYWx5c2lzUGx1Z2luKSB7XHJcblx0XHRzdXBlcihhcHAsIHBsdWdpbik7XHJcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuXHR9XHJcblxyXG5cdGRpc3BsYXkoKTogdm9pZCB7XHJcblx0XHRsZXQgeyBjb250YWluZXJFbCwgcGx1Z2luIH0gPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyBzZXR0aW5ncyB9ID0gcGx1Z2luO1xyXG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcclxuXHJcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0LnNldENsYXNzKFwiZmllbGRzLXRvLWNoZWNrXCIpXHJcblx0XHRcdC5zZXROYW1lKFwiRmllbGRzIHRvIENoZWNrXCIpXHJcblx0XHRcdC5zZXREZXNjKFwiQSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBmaWVsZHMgdG8gbG9vayBmb3IgZGF0YSBpbi5cIilcclxuXHRcdFx0LmFkZFRleHRBcmVhKCh0ZXh0KSA9PiB7XHJcblx0XHRcdFx0dGV4dC5zZXRWYWx1ZShzZXR0aW5ncy5maWVsZHNUb0NoZWNrLmpvaW4oXCIsIFwiKSk7XHJcblx0XHRcdFx0dGV4dC5pbnB1dEVsLm9uYmx1ciA9IGFzeW5jICgpID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHNwbGl0cyA9IHNwbGl0QW5kVHJpbSh0ZXh0LmdldFZhbHVlKCkpO1xyXG5cdFx0XHRcdFx0Y29uc3Qgbm9EdXBzID0gWy4uLm5ldyBTZXQoc3BsaXRzKV07XHJcblx0XHRcdFx0XHRpZiAoc3BsaXRzLmxlbmd0aCAhPT0gbm9EdXBzLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKFwiRHVwbGljYXRlcyBmb3VuZCBhbmQgcmVtb3ZlZFwiKTtcclxuXHRcdFx0XHRcdFx0c2V0dGluZ3MuZmllbGRzVG9DaGVjayA9IG5vRHVwcztcclxuXHRcdFx0XHRcdFx0YXdhaXQgcGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmRpc3BsYXkoKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHNldHRpbmdzLmZpZWxkc1RvQ2hlY2sgPSBzcGxpdHM7XHJcblx0XHRcdFx0XHRcdGF3YWl0IHBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGF3YWl0IHBsdWdpbi5yZWZyZXNoSW5kZXgoKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9KTtcclxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG5cdFx0XHQuc2V0TmFtZShcIkFkZCBBbGwgTnVtZXJpYyBGaWVsZHNcIilcclxuXHRcdFx0LnNldERlc2MoXHJcblx0XHRcdFx0XCJBZGQgYWxsIGZpZWxkcyB3aXRoIG51bWVyaWMgdmFsdWVzIHRvIHRoZSBsaXN0IG9mIGZpZWxkcyB0byBjaGVja1wiXHJcblx0XHRcdClcclxuXHRcdFx0LmFkZEJ1dHRvbigoYnV0KSA9PiB7XHJcblx0XHRcdFx0YnV0LnNldEJ1dHRvblRleHQoXCJBZGRcIikub25DbGljayhhc3luYyAoKSA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCB7IGRhdGEgfSA9IHBsdWdpbi5pbmRleDtcclxuXHRcdFx0XHRcdGZvciAoY29uc3QgcGFnZSBvZiBkYXRhKSB7XHJcblx0XHRcdFx0XHRcdGZvciAoY29uc3QgZmllbGQgaW4gcGFnZSkge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChcclxuXHRcdFx0XHRcdFx0XHRcdHR5cGVvZiBwYWdlW2ZpZWxkXSA9PT0gXCJudW1iZXJcIiAmJlxyXG5cdFx0XHRcdFx0XHRcdFx0IXNldHRpbmdzLmZpZWxkc1RvQ2hlY2suaW5jbHVkZXMoZmllbGQpICYmXHJcblx0XHRcdFx0XHRcdFx0XHQhc2V0dGluZ3MuZmllbGRzVG9DaGVja1xyXG5cdFx0XHRcdFx0XHRcdFx0XHQubWFwKChmaWVsZCkgPT4gdG9LZWJhYkNhc2UoZmllbGQpKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHQuaW5jbHVkZXMoZmllbGQpXHJcblx0XHRcdFx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRzZXR0aW5ncy5maWVsZHNUb0NoZWNrLnB1c2goZmllbGQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0c2V0dGluZ3MuZmllbGRzVG9DaGVjayA9XHJcblx0XHRcdFx0XHRcdFx0XHRcdHNldHRpbmdzLmZpZWxkc1RvQ2hlY2suc29ydCgoYSwgYikgPT5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhLmxvY2FsZUNvbXBhcmUoYilcclxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHRcdGF3YWl0IHBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0aGlzLmRpc3BsYXkoKTtcclxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJOdW1lcmljIGZpZWxkcyBhZGRlZFwiKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcblx0XHRcdC5zZXROYW1lKFwiRmllbGQgTGlzdHNcIilcclxuXHRcdFx0LnNldERlc2MoXHJcblx0XHRcdFx0XCJBIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZpbGVzIHRoYXQgeW91IGtlZXAgZmllbGRzIGluLiBFYWNoIGZpZWxkIG11c3QgYmUgb24gYSBuZXcgbGluZS4gSXQgY2FuIGJlIGEgd2lraWxpbmssIG9yIG5vdC5cIlxyXG5cdFx0XHQpXHJcblx0XHRcdC5hZGRUZXh0KCh0ZXh0KSA9PiB7XHJcblx0XHRcdFx0dGV4dC5zZXRWYWx1ZShzZXR0aW5ncy5maWVsZExpc3RzLmpvaW4oXCIsIFwiKSk7XHJcblx0XHRcdFx0dGV4dC5pbnB1dEVsLm9uYmx1ciA9IGFzeW5jICgpID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHNwbGl0cyA9IHNwbGl0QW5kVHJpbSh0ZXh0LmdldFZhbHVlKCkpO1xyXG5cdFx0XHRcdFx0c2V0dGluZ3MuZmllbGRMaXN0cyA9IHNwbGl0cztcclxuXHRcdFx0XHRcdGF3YWl0IHBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdGF3YWl0IHBsdWdpbi5yZWZyZXNoSW5kZXgoKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9KTtcclxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG5cdFx0XHQuc2V0Q2xhc3MoXCJmaWVsZHMtdG8tc2tpcFwiKVxyXG5cdFx0XHQuc2V0TmFtZShcIkZpZWxkcyB0byBDaGVjayBTa2lwIGluIENvcnJlbGF0aW9uc1wiKVxyXG5cdFx0XHQuc2V0RGVzYyhcclxuXHRcdFx0XHRmcmFnV2l0aEhUTUwoXHJcblx0XHRcdFx0XHRgQSBsaXN0IG9mIHBhaXJzIG9mIGZpZWxkcyB0byBOT1Qgc2hvdyBpbiB0aGUgQ29ycmVsYXRpb25zIFZpZXcuIEVudGVyIGVhY2ggcGFpciBvbiBhIG5ldyBsaW5lLCB3aXRoIGVhY2ggcGFpciBzZXBhcmF0ZWQgYnkgYSBjb21tYS48L2JyPlxyXG5cdFx0XHRcdFx0Rm9yIGV4YW1wbGU6XHJcblx0XHRcdFx0XHQ8cHJlPjxjb2RlPlxyXG5cdFx0XHRcdFx0YSwgYlxyXG5cdFx0XHRcdFx0YywgZFxyXG5cdFx0XHRcdFx0PC9jb2RlPjwvcHJlPmBcclxuXHRcdFx0XHQpXHJcblx0XHRcdClcclxuXHRcdFx0LmFkZFRleHRBcmVhKCh0ZXh0KSA9PiB7XHJcblx0XHRcdFx0dGV4dC5zZXRWYWx1ZShcclxuXHRcdFx0XHRcdHNldHRpbmdzLmZpZWxkc1RvSWdub3JlRm9yQ29ycnNcclxuXHRcdFx0XHRcdFx0Lm1hcCgocGFpcikgPT4gcGFpci5qb2luKFwiLCBcIikpXHJcblx0XHRcdFx0XHRcdC5qb2luKFwiXFxuXCIpXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHR0ZXh0LmlucHV0RWwub25ibHVyID0gYXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSB0ZXh0LmdldFZhbHVlKCk7XHJcblx0XHRcdFx0XHRjb25zdCBzcGxpdHMgPSB2YWx1ZS5zcGxpdChcIlxcblwiKS5tYXAoc3BsaXRBbmRUcmltKSBhcyBbXHJcblx0XHRcdFx0XHRcdHN0cmluZyxcclxuXHRcdFx0XHRcdFx0c3RyaW5nXHJcblx0XHRcdFx0XHRdW107XHJcblxyXG5cdFx0XHRcdFx0c2V0dGluZ3MuZmllbGRzVG9JZ25vcmVGb3JDb3JycyA9IHNwbGl0cztcclxuXHRcdFx0XHRcdGF3YWl0IHBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdGF3YWl0IHBsdWdpbi5yZWZyZXNoSW5kZXgoKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0LnNldE5hbWUoXCJEYXRlIEZvcm1hdFwiKVxyXG5cdFx0XHQuc2V0RGVzYyhcIlRoZSBkYXRlIGZvcm1hdCB5b3UgdXNlIGluIHlvdXIgdmF1bHQuXCIpXHJcblx0XHRcdC5hZGRNb21lbnRGb3JtYXQoKGZvcm1hdCkgPT4ge1xyXG5cdFx0XHRcdGZvcm1hdFxyXG5cdFx0XHRcdFx0LnNldERlZmF1bHRGb3JtYXQoREVGQVVMVF9TRVRUSU5HUy5kYXRlRm9ybWF0KVxyXG5cdFx0XHRcdFx0LnNldFZhbHVlKHNldHRpbmdzLmRhdGVGb3JtYXQpXHJcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHRcdHNldHRpbmdzLmRhdGVGb3JtYXQgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0YXdhaXQgcGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDJcIiwgeyB0ZXh0OiBcIkV4cG9ydGluZyBEYXRhXCIgfSk7XHJcblxyXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcblx0XHRcdC5zZXROYW1lKFwiRGVmYXVsdCBzYXZlIHBhdGhcIilcclxuXHRcdFx0LnNldERlc2MoXHJcblx0XHRcdFx0J1RoZSBmdWxsIGZpbGUgcGF0aCB0byBzYXZlIHRoZSBtZXRhZGF0YWZyYW1lIHRvLiBEb25cXCd0IGluY2x1ZGUgdGhlIGZpbGUgZXh0ZW5zaW9uLiBGb3IgZXhhbXBsZSwgdGhpcyBpcyBhIGNvcnJlY3QgZmlsZSBwYXRoOiBTdWJGb2xkZXIvbWV0YWRhdGFmcmFtZS4gVXNlIFwiL1wiIHRvIHNhdmUgdG8gdGhlIHJvb3Qgb2YgeW91ciB2YXVsdC4nXHJcblx0XHRcdClcclxuXHRcdFx0LmFkZFRleHQoKHRleHQpID0+XHJcblx0XHRcdFx0dGV4dFxyXG5cdFx0XHRcdFx0LnNldFZhbHVlKHNldHRpbmdzLmRlZmF1bHRTYXZlUGF0aClcclxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuXHRcdFx0XHRcdFx0c2V0dGluZ3MuZGVmYXVsdFNhdmVQYXRoID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdGF3YWl0IHBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcblx0XHRcdC5zZXROYW1lKFwiTnVsbCB2YWx1ZVwiKVxyXG5cdFx0XHQuc2V0RGVzYyhcclxuXHRcdFx0XHRcIldoYXQgc2hvdWxkIHRoZSBkZWZhdWx0IHZhbHVlIGJlIGZvciBtaXNzaW5nIGZpZWxkIHZhbHVlcz8gRGVmYXVsdCBpcyAnbnVsbCcuIERvbid0IHVzZSBxdW90ZXMsIGp1c3QgZW50ZXIgdGhlIHZhbHVlLlwiXHJcblx0XHRcdClcclxuXHRcdFx0LmFkZFRleHQoKHRleHQpID0+XHJcblx0XHRcdFx0dGV4dC5zZXRWYWx1ZShzZXR0aW5ncy5udWxsVmFsdWUpLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdFx0c2V0dGluZ3MubnVsbFZhbHVlID0gdmFsdWU7XHJcblx0XHRcdFx0XHRhd2FpdCBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0KTtcclxuXHJcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0LnNldE5hbWUoXCJBZGQgaW5oZXJlbnQgZmlsZSBtZXRhZGF0YVwiKVxyXG5cdFx0XHQuc2V0RGVzYyhcclxuXHRcdFx0XHRcIkVhY2ggZmlsZSBoYXMgYWxvdCBvZiBpbmhlcmVudCBtZXRhZGF0YSB0byBpdCAoYmVzaWRlcyB0aGUgZmllbGRzIHlvdSBhZGQpLiBTaG91bGQgbWV0YWRhdGFmcmFtZSBhZGQgdGhlc2UgZmllbGRzIHRvbz8gSXQgY2FuIGJlIGFsb3QsIHNvIHRoZXJlIGlzIHRoZSBvcHRpb24gdG8gZGlzYWJsZSB0aGlzIGJlaGF2aW91ci5cIlxyXG5cdFx0XHQpXHJcblx0XHRcdC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT5cclxuXHRcdFx0XHR0b2dnbGVcclxuXHRcdFx0XHRcdC5zZXRWYWx1ZShzZXR0aW5ncy5hZGRGaWxlRGF0YSlcclxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuXHRcdFx0XHRcdFx0c2V0dGluZ3MuYWRkRmlsZURhdGEgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0YXdhaXQgcGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0KTtcclxuXHJcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0LnNldE5hbWUoXCJBZGQgY29udGVudCBvZiBlYWNoIG5vdGVcIilcclxuXHRcdFx0LnNldERlc2MoXHJcblx0XHRcdFx0XCJBZGQgYSBjb2x1bW4gZm9yIHRoZSBjb250ZW50IG9mIGVhY2ggbm90ZS4gVGhpcyB3aWxsIGFkZCBhbG90IG9mIHNpemUgdG8gdGhlIENTViBmaWxlLCBzbyBpdCBpcyBvZmYgYnkgZGVmYXVsdC5cIlxyXG5cdFx0XHQpXHJcblx0XHRcdC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT5cclxuXHRcdFx0XHR0b2dnbGVcclxuXHRcdFx0XHRcdC5zZXRWYWx1ZShzZXR0aW5ncy5hZGROb3RlQ29udGVudClcclxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuXHRcdFx0XHRcdFx0c2V0dGluZ3MuYWRkTm90ZUNvbnRlbnQgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0YXdhaXQgcGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0KTtcclxuXHR9XHJcbn1cclxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBLElBQUMsVUFBVSxTQUFRLFNBQVM7QUFDMUIsYUFBTyxZQUFZLFlBQVksT0FBTyxZQUFX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QUEsRUFDYixNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxjQUFjO0FBQUEsRUFDZCxJQUFJO0FBQUEsRUFDSixTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxhQUFhO0FBQUEsRUFDYixTQUFTO0FBQUEsRUFDVCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxXQUFXO0FBQUEsRUFDWCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixLQUFLO0FBQUEsRUFDTCxLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxLQUFLO0FBQUEsRUFDTCxTQUFTO0FBQUEsRUFDVCxRQUFRO0FBQUEsRUFDUixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixXQUFXO0FBQUEsRUFDWCxTQUFTO0FBQUEsRUFDVCxZQUFZO0FBQUEsRUFDWixLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixPQUFPO0FBQUEsRUFDUCxXQUFXO0FBQUEsRUFDWCxNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxZQUFZO0FBQUEsRUFDWixLQUFLO0FBQUEsRUFDTCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxLQUFLO0FBQUEsRUFDTCxVQUFVO0FBQUEsRUFDVixZQUFZO0FBQUEsRUFDWixTQUFTO0FBQUEsRUFDVCxVQUFVO0FBQUEsRUFDVixTQUFTO0FBQUEsRUFDVCxZQUFZO0FBQUEsRUFDWixNQUFNO0FBQUEsRUFDTixRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixXQUFXO0FBQUEsRUFDWCxRQUFRO0FBQUEsRUFDUixPQUFPO0FBQUEsRUFDUCxZQUFZO0FBQUEsRUFDWixXQUFXO0FBQUEsRUFDWCxTQUFTO0FBQUEsRUFDVCxNQUFNO0FBQUEsRUFDTixLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixTQUFTO0FBQUEsRUFDVCxPQUFPO0FBQUEsRUFDUCxhQUFhO0FBQUEsRUFDYixJQUFJO0FBQUEsRUFDSixVQUFVO0FB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
