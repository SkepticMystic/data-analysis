/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/luxon/build/cjs-browser/luxon.js
var require_luxon = __commonJS({
  "node_modules/luxon/build/cjs-browser/luxon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance7 = new Constructor();
          if (Class2)
            _setPrototypeOf(instance7, Class2.prototype);
          return instance7;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it)
        return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        return function() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var LuxonError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose(LuxonError2, _Error);
      function LuxonError2() {
        return _Error.apply(this, arguments) || this;
      }
      return LuxonError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    var InvalidDateTimeError = /* @__PURE__ */ function(_LuxonError) {
      _inheritsLoose(InvalidDateTimeError2, _LuxonError);
      function InvalidDateTimeError2(reason) {
        return _LuxonError.call(this, "Invalid DateTime: " + reason.toMessage()) || this;
      }
      return InvalidDateTimeError2;
    }(LuxonError);
    var InvalidIntervalError = /* @__PURE__ */ function(_LuxonError2) {
      _inheritsLoose(InvalidIntervalError2, _LuxonError2);
      function InvalidIntervalError2(reason) {
        return _LuxonError2.call(this, "Invalid Interval: " + reason.toMessage()) || this;
      }
      return InvalidIntervalError2;
    }(LuxonError);
    var InvalidDurationError = /* @__PURE__ */ function(_LuxonError3) {
      _inheritsLoose(InvalidDurationError2, _LuxonError3);
      function InvalidDurationError2(reason) {
        return _LuxonError3.call(this, "Invalid Duration: " + reason.toMessage()) || this;
      }
      return InvalidDurationError2;
    }(LuxonError);
    var ConflictingSpecificationError = /* @__PURE__ */ function(_LuxonError4) {
      _inheritsLoose(ConflictingSpecificationError2, _LuxonError4);
      function ConflictingSpecificationError2() {
        return _LuxonError4.apply(this, arguments) || this;
      }
      return ConflictingSpecificationError2;
    }(LuxonError);
    var InvalidUnitError = /* @__PURE__ */ function(_LuxonError5) {
      _inheritsLoose(InvalidUnitError2, _LuxonError5);
      function InvalidUnitError2(unit) {
        return _LuxonError5.call(this, "Invalid unit " + unit) || this;
      }
      return InvalidUnitError2;
    }(LuxonError);
    var InvalidArgumentError = /* @__PURE__ */ function(_LuxonError6) {
      _inheritsLoose(InvalidArgumentError2, _LuxonError6);
      function InvalidArgumentError2() {
        return _LuxonError6.apply(this, arguments) || this;
      }
      return InvalidArgumentError2;
    }(LuxonError);
    var ZoneIsAbstractError = /* @__PURE__ */ function(_LuxonError7) {
      _inheritsLoose(ZoneIsAbstractError2, _LuxonError7);
      function ZoneIsAbstractError2() {
        return _LuxonError7.call(this, "Zone is an abstract class") || this;
      }
      return ZoneIsAbstractError2;
    }(LuxonError);
    var n = "numeric";
    var s = "short";
    var l = "long";
    var DATE_SHORT = {
      year: n,
      month: n,
      day: n
    };
    var DATE_MED = {
      year: n,
      month: s,
      day: n
    };
    var DATE_MED_WITH_WEEKDAY = {
      year: n,
      month: s,
      day: n,
      weekday: s
    };
    var DATE_FULL = {
      year: n,
      month: l,
      day: n
    };
    var DATE_HUGE = {
      year: n,
      month: l,
      day: n,
      weekday: l
    };
    var TIME_SIMPLE = {
      hour: n,
      minute: n
    };
    var TIME_WITH_SECONDS = {
      hour: n,
      minute: n,
      second: n
    };
    var TIME_WITH_SHORT_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      timeZoneName: s
    };
    var TIME_WITH_LONG_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      timeZoneName: l
    };
    var TIME_24_SIMPLE = {
      hour: n,
      minute: n,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SECONDS = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SHORT_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23",
      timeZoneName: s
    };
    var TIME_24_WITH_LONG_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23",
      timeZoneName: l
    };
    var DATETIME_SHORT = {
      year: n,
      month: n,
      day: n,
      hour: n,
      minute: n
    };
    var DATETIME_SHORT_WITH_SECONDS = {
      year: n,
      month: n,
      day: n,
      hour: n,
      minute: n,
      second: n
    };
    var DATETIME_MED = {
      year: n,
      month: s,
      day: n,
      hour: n,
      minute: n
    };
    var DATETIME_MED_WITH_SECONDS = {
      year: n,
      month: s,
      day: n,
      hour: n,
      minute: n,
      second: n
    };
    var DATETIME_MED_WITH_WEEKDAY = {
      year: n,
      month: s,
      day: n,
      weekday: s,
      hour: n,
      minute: n
    };
    var DATETIME_FULL = {
      year: n,
      month: l,
      day: n,
      hour: n,
      minute: n,
      timeZoneName: s
    };
    var DATETIME_FULL_WITH_SECONDS = {
      year: n,
      month: l,
      day: n,
      hour: n,
      minute: n,
      second: n,
      timeZoneName: s
    };
    var DATETIME_HUGE = {
      year: n,
      month: l,
      day: n,
      weekday: l,
      hour: n,
      minute: n,
      timeZoneName: l
    };
    var DATETIME_HUGE_WITH_SECONDS = {
      year: n,
      month: l,
      day: n,
      weekday: l,
      hour: n,
      minute: n,
      second: n,
      timeZoneName: l
    };
    function isUndefined(o) {
      return typeof o === "undefined";
    }
    function isNumber2(o) {
      return typeof o === "number";
    }
    function isInteger(o) {
      return typeof o === "number" && o % 1 === 0;
    }
    function isString(o) {
      return typeof o === "string";
    }
    function isDate(o) {
      return Object.prototype.toString.call(o) === "[object Date]";
    }
    function hasRelative() {
      try {
        return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
      } catch (e) {
        return false;
      }
    }
    function maybeArray(thing) {
      return Array.isArray(thing) ? thing : [thing];
    }
    function bestBy(arr, by, compare) {
      if (arr.length === 0) {
        return void 0;
      }
      return arr.reduce(function(best, next) {
        var pair = [by(next), next];
        if (!best) {
          return pair;
        } else if (compare(best[0], pair[0]) === best[0]) {
          return best;
        } else {
          return pair;
        }
      }, null)[1];
    }
    function pick(obj, keys) {
      return keys.reduce(function(a, k) {
        a[k] = obj[k];
        return a;
      }, {});
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function integerBetween(thing, bottom, top) {
      return isInteger(thing) && thing >= bottom && thing <= top;
    }
    function floorMod(x, n2) {
      return x - n2 * Math.floor(x / n2);
    }
    function padStart(input, n2) {
      if (n2 === void 0) {
        n2 = 2;
      }
      var isNeg = input < 0;
      var padded;
      if (isNeg) {
        padded = "-" + ("" + -input).padStart(n2, "0");
      } else {
        padded = ("" + input).padStart(n2, "0");
      }
      return padded;
    }
    function parseInteger(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseInt(string, 10);
      }
    }
    function parseFloating(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseFloat(string);
      }
    }
    function parseMillis(fraction) {
      if (isUndefined(fraction) || fraction === null || fraction === "") {
        return void 0;
      } else {
        var f = parseFloat("0." + fraction) * 1e3;
        return Math.floor(f);
      }
    }
    function roundTo(number, digits, towardZero) {
      if (towardZero === void 0) {
        towardZero = false;
      }
      var factor = Math.pow(10, digits), rounder = towardZero ? Math.trunc : Math.round;
      return rounder(number * factor) / factor;
    }
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    function daysInMonth(year, month) {
      var modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
      if (modMonth === 2) {
        return isLeapYear(modYear) ? 29 : 28;
      } else {
        return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
      }
    }
    function objToLocalTS(obj) {
      var d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
      if (obj.year < 100 && obj.year >= 0) {
        d = new Date(d);
        d.setUTCFullYear(d.getUTCFullYear() - 1900);
      }
      return +d;
    }
    function weeksInWeekYear(weekYear) {
      var p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
      return p1 === 4 || p2 === 3 ? 53 : 52;
    }
    function untruncateYear(year) {
      if (year > 99) {
        return year;
      } else
        return year > 60 ? 1900 + year : 2e3 + year;
    }
    function parseZoneInfo(ts, offsetFormat, locale, timeZone) {
      if (timeZone === void 0) {
        timeZone = null;
      }
      var date = new Date(ts), intlOpts = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      };
      if (timeZone) {
        intlOpts.timeZone = timeZone;
      }
      var modified = _extends({
        timeZoneName: offsetFormat
      }, intlOpts);
      var parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find(function(m) {
        return m.type.toLowerCase() === "timezonename";
      });
      return parsed ? parsed.value : null;
    }
    function signedOffset(offHourStr, offMinuteStr) {
      var offHour = parseInt(offHourStr, 10);
      if (Number.isNaN(offHour)) {
        offHour = 0;
      }
      var offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
      return offHour * 60 + offMinSigned;
    }
    function asNumber(value) {
      var numericValue = Number(value);
      if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
        throw new InvalidArgumentError("Invalid unit value " + value);
      return numericValue;
    }
    function normalizeObject(obj, normalizer) {
      var normalized = {};
      for (var u in obj) {
        if (hasOwnProperty(obj, u)) {
          var v = obj[u];
          if (v === void 0 || v === null)
            continue;
          normalized[normalizer(u)] = asNumber(v);
        }
      }
      return normalized;
    }
    function formatOffset(offset2, format) {
      var hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign2 = offset2 >= 0 ? "+" : "-";
      switch (format) {
        case "short":
          return "" + sign2 + padStart(hours, 2) + ":" + padStart(minutes, 2);
        case "narrow":
          return "" + sign2 + hours + (minutes > 0 ? ":" + minutes : "");
        case "techie":
          return "" + sign2 + padStart(hours, 2) + padStart(minutes, 2);
        default:
          throw new RangeError("Value format " + format + " is out of range for property format");
      }
    }
    function timeObject(obj) {
      return pick(obj, ["hour", "minute", "second", "millisecond"]);
    }
    var ianaRegex = /[A-Za-z_+-]{1,256}(:?\/[A-Za-z0-9_+-]{1,256}(\/[A-Za-z0-9_+-]{1,256})?)?/;
    var monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    var monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
    function months(length) {
      switch (length) {
        case "narrow":
          return [].concat(monthsNarrow);
        case "short":
          return [].concat(monthsShort);
        case "long":
          return [].concat(monthsLong);
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
        case "2-digit":
          return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
        default:
          return null;
      }
    }
    var weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
    var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
    function weekdays(length) {
      switch (length) {
        case "narrow":
          return [].concat(weekdaysNarrow);
        case "short":
          return [].concat(weekdaysShort);
        case "long":
          return [].concat(weekdaysLong);
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7"];
        default:
          return null;
      }
    }
    var meridiems = ["AM", "PM"];
    var erasLong = ["Before Christ", "Anno Domini"];
    var erasShort = ["BC", "AD"];
    var erasNarrow = ["B", "A"];
    function eras(length) {
      switch (length) {
        case "narrow":
          return [].concat(erasNarrow);
        case "short":
          return [].concat(erasShort);
        case "long":
          return [].concat(erasLong);
        default:
          return null;
      }
    }
    function meridiemForDateTime(dt) {
      return meridiems[dt.hour < 12 ? 0 : 1];
    }
    function weekdayForDateTime(dt, length) {
      return weekdays(length)[dt.weekday - 1];
    }
    function monthForDateTime(dt, length) {
      return months(length)[dt.month - 1];
    }
    function eraForDateTime(dt, length) {
      return eras(length)[dt.year < 0 ? 0 : 1];
    }
    function formatRelativeTime(unit, count, numeric, narrow) {
      if (numeric === void 0) {
        numeric = "always";
      }
      if (narrow === void 0) {
        narrow = false;
      }
      var units = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
      };
      var lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
      if (numeric === "auto" && lastable) {
        var isDay = unit === "days";
        switch (count) {
          case 1:
            return isDay ? "tomorrow" : "next " + units[unit][0];
          case -1:
            return isDay ? "yesterday" : "last " + units[unit][0];
          case 0:
            return isDay ? "today" : "this " + units[unit][0];
        }
      }
      var isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
      return isInPast ? fmtValue + " " + fmtUnit + " ago" : "in " + fmtValue + " " + fmtUnit;
    }
    function stringifyTokens(splits, tokenToString) {
      var s2 = "";
      for (var _iterator = _createForOfIteratorHelperLoose(splits), _step; !(_step = _iterator()).done; ) {
        var token = _step.value;
        if (token.literal) {
          s2 += token.val;
        } else {
          s2 += tokenToString(token.val);
        }
      }
      return s2;
    }
    var _macroTokenToFormatOpts = {
      D: DATE_SHORT,
      DD: DATE_MED,
      DDD: DATE_FULL,
      DDDD: DATE_HUGE,
      t: TIME_SIMPLE,
      tt: TIME_WITH_SECONDS,
      ttt: TIME_WITH_SHORT_OFFSET,
      tttt: TIME_WITH_LONG_OFFSET,
      T: TIME_24_SIMPLE,
      TT: TIME_24_WITH_SECONDS,
      TTT: TIME_24_WITH_SHORT_OFFSET,
      TTTT: TIME_24_WITH_LONG_OFFSET,
      f: DATETIME_SHORT,
      ff: DATETIME_MED,
      fff: DATETIME_FULL,
      ffff: DATETIME_HUGE,
      F: DATETIME_SHORT_WITH_SECONDS,
      FF: DATETIME_MED_WITH_SECONDS,
      FFF: DATETIME_FULL_WITH_SECONDS,
      FFFF: DATETIME_HUGE_WITH_SECONDS
    };
    var Formatter = /* @__PURE__ */ function() {
      Formatter2.create = function create(locale, opts) {
        if (opts === void 0) {
          opts = {};
        }
        return new Formatter2(locale, opts);
      };
      Formatter2.parseFormat = function parseFormat(fmt) {
        var current = null, currentFull = "", bracketed = false;
        var splits = [];
        for (var i = 0; i < fmt.length; i++) {
          var c = fmt.charAt(i);
          if (c === "'") {
            if (currentFull.length > 0) {
              splits.push({
                literal: bracketed,
                val: currentFull
              });
            }
            current = null;
            currentFull = "";
            bracketed = !bracketed;
          } else if (bracketed) {
            currentFull += c;
          } else if (c === current) {
            currentFull += c;
          } else {
            if (currentFull.length > 0) {
              splits.push({
                literal: false,
                val: currentFull
              });
            }
            currentFull = c;
            current = c;
          }
        }
        if (currentFull.length > 0) {
          splits.push({
            literal: bracketed,
            val: currentFull
          });
        }
        return splits;
      };
      Formatter2.macroTokenToFormatOpts = function macroTokenToFormatOpts(token) {
        return _macroTokenToFormatOpts[token];
      };
      function Formatter2(locale, formatOpts) {
        this.opts = formatOpts;
        this.loc = locale;
        this.systemLoc = null;
      }
      var _proto = Formatter2.prototype;
      _proto.formatWithSystemDefault = function formatWithSystemDefault(dt, opts) {
        if (this.systemLoc === null) {
          this.systemLoc = this.loc.redefaultToSystem();
        }
        var df = this.systemLoc.dtFormatter(dt, _extends({}, this.opts, opts));
        return df.format();
      };
      _proto.formatDateTime = function formatDateTime(dt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var df = this.loc.dtFormatter(dt, _extends({}, this.opts, opts));
        return df.format();
      };
      _proto.formatDateTimeParts = function formatDateTimeParts(dt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var df = this.loc.dtFormatter(dt, _extends({}, this.opts, opts));
        return df.formatToParts();
      };
      _proto.resolvedOptions = function resolvedOptions(dt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var df = this.loc.dtFormatter(dt, _extends({}, this.opts, opts));
        return df.resolvedOptions();
      };
      _proto.num = function num(n2, p) {
        if (p === void 0) {
          p = 0;
        }
        if (this.opts.forceSimple) {
          return padStart(n2, p);
        }
        var opts = _extends({}, this.opts);
        if (p > 0) {
          opts.padTo = p;
        }
        return this.loc.numberFormatter(opts).format(n2);
      };
      _proto.formatDateTimeFromString = function formatDateTimeFromString(dt, fmt) {
        var _this = this;
        var knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = function string2(opts, extract) {
          return _this.loc.extract(dt, opts, extract);
        }, formatOffset2 = function formatOffset3(opts) {
          if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
            return "Z";
          }
          return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
        }, meridiem = function meridiem2() {
          return knownEnglish ? meridiemForDateTime(dt) : string({
            hour: "numeric",
            hourCycle: "h12"
          }, "dayperiod");
        }, month = function month2(length, standalone) {
          return knownEnglish ? monthForDateTime(dt, length) : string(standalone ? {
            month: length
          } : {
            month: length,
            day: "numeric"
          }, "month");
        }, weekday = function weekday2(length, standalone) {
          return knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? {
            weekday: length
          } : {
            weekday: length,
            month: "long",
            day: "numeric"
          }, "weekday");
        }, maybeMacro = function maybeMacro2(token) {
          var formatOpts = Formatter2.macroTokenToFormatOpts(token);
          if (formatOpts) {
            return _this.formatWithSystemDefault(dt, formatOpts);
          } else {
            return token;
          }
        }, era = function era2(length) {
          return knownEnglish ? eraForDateTime(dt, length) : string({
            era: length
          }, "era");
        }, tokenToString = function tokenToString2(token) {
          switch (token) {
            case "S":
              return _this.num(dt.millisecond);
            case "u":
            case "SSS":
              return _this.num(dt.millisecond, 3);
            case "s":
              return _this.num(dt.second);
            case "ss":
              return _this.num(dt.second, 2);
            case "uu":
              return _this.num(Math.floor(dt.millisecond / 10), 2);
            case "uuu":
              return _this.num(Math.floor(dt.millisecond / 100));
            case "m":
              return _this.num(dt.minute);
            case "mm":
              return _this.num(dt.minute, 2);
            case "h":
              return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
            case "hh":
              return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
            case "H":
              return _this.num(dt.hour);
            case "HH":
              return _this.num(dt.hour, 2);
            case "Z":
              return formatOffset2({
                format: "narrow",
                allowZ: _this.opts.allowZ
              });
            case "ZZ":
              return formatOffset2({
                format: "short",
                allowZ: _this.opts.allowZ
              });
            case "ZZZ":
              return formatOffset2({
                format: "techie",
                allowZ: _this.opts.allowZ
              });
            case "ZZZZ":
              return dt.zone.offsetName(dt.ts, {
                format: "short",
                locale: _this.loc.locale
              });
            case "ZZZZZ":
              return dt.zone.offsetName(dt.ts, {
                format: "long",
                locale: _this.loc.locale
              });
            case "z":
              return dt.zoneName;
            case "a":
              return meridiem();
            case "d":
              return useDateTimeFormatter ? string({
                day: "numeric"
              }, "day") : _this.num(dt.day);
            case "dd":
              return useDateTimeFormatter ? string({
                day: "2-digit"
              }, "day") : _this.num(dt.day, 2);
            case "c":
              return _this.num(dt.weekday);
            case "ccc":
              return weekday("short", true);
            case "cccc":
              return weekday("long", true);
            case "ccccc":
              return weekday("narrow", true);
            case "E":
              return _this.num(dt.weekday);
            case "EEE":
              return weekday("short", false);
            case "EEEE":
              return weekday("long", false);
            case "EEEEE":
              return weekday("narrow", false);
            case "L":
              return useDateTimeFormatter ? string({
                month: "numeric",
                day: "numeric"
              }, "month") : _this.num(dt.month);
            case "LL":
              return useDateTimeFormatter ? string({
                month: "2-digit",
                day: "numeric"
              }, "month") : _this.num(dt.month, 2);
            case "LLL":
              return month("short", true);
            case "LLLL":
              return month("long", true);
            case "LLLLL":
              return month("narrow", true);
            case "M":
              return useDateTimeFormatter ? string({
                month: "numeric"
              }, "month") : _this.num(dt.month);
            case "MM":
              return useDateTimeFormatter ? string({
                month: "2-digit"
              }, "month") : _this.num(dt.month, 2);
            case "MMM":
              return month("short", false);
            case "MMMM":
              return month("long", false);
            case "MMMMM":
              return month("narrow", false);
            case "y":
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : _this.num(dt.year);
            case "yy":
              return useDateTimeFormatter ? string({
                year: "2-digit"
              }, "year") : _this.num(dt.year.toString().slice(-2), 2);
            case "yyyy":
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : _this.num(dt.year, 4);
            case "yyyyyy":
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : _this.num(dt.year, 6);
            case "G":
              return era("short");
            case "GG":
              return era("long");
            case "GGGGG":
              return era("narrow");
            case "kk":
              return _this.num(dt.weekYear.toString().slice(-2), 2);
            case "kkkk":
              return _this.num(dt.weekYear, 4);
            case "W":
              return _this.num(dt.weekNumber);
            case "WW":
              return _this.num(dt.weekNumber, 2);
            case "o":
              return _this.num(dt.ordinal);
            case "ooo":
              return _this.num(dt.ordinal, 3);
            case "q":
              return _this.num(dt.quarter);
            case "qq":
              return _this.num(dt.quarter, 2);
            case "X":
              return _this.num(Math.floor(dt.ts / 1e3));
            case "x":
              return _this.num(dt.ts);
            default:
              return maybeMacro(token);
          }
        };
        return stringifyTokens(Formatter2.parseFormat(fmt), tokenToString);
      };
      _proto.formatDurationFromString = function formatDurationFromString(dur, fmt) {
        var _this2 = this;
        var tokenToField = function tokenToField2(token) {
          switch (token[0]) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
              return "hour";
            case "d":
              return "day";
            case "M":
              return "month";
            case "y":
              return "year";
            default:
              return null;
          }
        }, tokenToString = function tokenToString2(lildur) {
          return function(token) {
            var mapped = tokenToField(token);
            if (mapped) {
              return _this2.num(lildur.get(mapped), token.length);
            } else {
              return token;
            }
          };
        }, tokens = Formatter2.parseFormat(fmt), realTokens = tokens.reduce(function(found, _ref) {
          var literal = _ref.literal, val = _ref.val;
          return literal ? found : found.concat(val);
        }, []), collapsed = dur.shiftTo.apply(dur, realTokens.map(tokenToField).filter(function(t) {
          return t;
        }));
        return stringifyTokens(tokens, tokenToString(collapsed));
      };
      return Formatter2;
    }();
    var Invalid = /* @__PURE__ */ function() {
      function Invalid2(reason, explanation) {
        this.reason = reason;
        this.explanation = explanation;
      }
      var _proto = Invalid2.prototype;
      _proto.toMessage = function toMessage() {
        if (this.explanation) {
          return this.reason + ": " + this.explanation;
        } else {
          return this.reason;
        }
      };
      return Invalid2;
    }();
    var Zone = /* @__PURE__ */ function() {
      function Zone2() {
      }
      var _proto = Zone2.prototype;
      _proto.offsetName = function offsetName(ts, opts) {
        throw new ZoneIsAbstractError();
      };
      _proto.formatOffset = function formatOffset2(ts, format) {
        throw new ZoneIsAbstractError();
      };
      _proto.offset = function offset2(ts) {
        throw new ZoneIsAbstractError();
      };
      _proto.equals = function equals(otherZone) {
        throw new ZoneIsAbstractError();
      };
      _createClass(Zone2, [{
        key: "type",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
      }, {
        key: "name",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
      }, {
        key: "isUniversal",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
      }, {
        key: "isValid",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
      }]);
      return Zone2;
    }();
    var singleton$1 = null;
    var SystemZone = /* @__PURE__ */ function(_Zone) {
      _inheritsLoose(SystemZone2, _Zone);
      function SystemZone2() {
        return _Zone.apply(this, arguments) || this;
      }
      var _proto = SystemZone2.prototype;
      _proto.offsetName = function offsetName(ts, _ref) {
        var format = _ref.format, locale = _ref.locale;
        return parseZoneInfo(ts, format, locale);
      };
      _proto.formatOffset = function formatOffset$1(ts, format) {
        return formatOffset(this.offset(ts), format);
      };
      _proto.offset = function offset2(ts) {
        return -new Date(ts).getTimezoneOffset();
      };
      _proto.equals = function equals(otherZone) {
        return otherZone.type === "system";
      };
      _createClass(SystemZone2, [{
        key: "type",
        get: function get() {
          return "system";
        }
      }, {
        key: "name",
        get: function get() {
          return new Intl.DateTimeFormat().resolvedOptions().timeZone;
        }
      }, {
        key: "isUniversal",
        get: function get() {
          return false;
        }
      }, {
        key: "isValid",
        get: function get() {
          return true;
        }
      }], [{
        key: "instance",
        get: function get() {
          if (singleton$1 === null) {
            singleton$1 = new SystemZone2();
          }
          return singleton$1;
        }
      }]);
      return SystemZone2;
    }(Zone);
    var matchingRegex = RegExp("^" + ianaRegex.source + "$");
    var dtfCache = {};
    function makeDTF(zone) {
      if (!dtfCache[zone]) {
        dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
          hour12: false,
          timeZone: zone,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        });
      }
      return dtfCache[zone];
    }
    var typeToPos = {
      year: 0,
      month: 1,
      day: 2,
      hour: 3,
      minute: 4,
      second: 5
    };
    function hackyOffset(dtf, date) {
      var formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted), fMonth = parsed[1], fDay = parsed[2], fYear = parsed[3], fHour = parsed[4], fMinute = parsed[5], fSecond = parsed[6];
      return [fYear, fMonth, fDay, fHour, fMinute, fSecond];
    }
    function partsOffset(dtf, date) {
      var formatted = dtf.formatToParts(date), filled = [];
      for (var i = 0; i < formatted.length; i++) {
        var _formatted$i = formatted[i], type = _formatted$i.type, value = _formatted$i.value, pos = typeToPos[type];
        if (!isUndefined(pos)) {
          filled[pos] = parseInt(value, 10);
        }
      }
      return filled;
    }
    var ianaZoneCache = {};
    var IANAZone = /* @__PURE__ */ function(_Zone) {
      _inheritsLoose(IANAZone2, _Zone);
      IANAZone2.create = function create(name) {
        if (!ianaZoneCache[name]) {
          ianaZoneCache[name] = new IANAZone2(name);
        }
        return ianaZoneCache[name];
      };
      IANAZone2.resetCache = function resetCache() {
        ianaZoneCache = {};
        dtfCache = {};
      };
      IANAZone2.isValidSpecifier = function isValidSpecifier(s2) {
        return !!(s2 && s2.match(matchingRegex));
      };
      IANAZone2.isValidZone = function isValidZone(zone) {
        if (!zone) {
          return false;
        }
        try {
          new Intl.DateTimeFormat("en-US", {
            timeZone: zone
          }).format();
          return true;
        } catch (e) {
          return false;
        }
      };
      function IANAZone2(name) {
        var _this;
        _this = _Zone.call(this) || this;
        _this.zoneName = name;
        _this.valid = IANAZone2.isValidZone(name);
        return _this;
      }
      var _proto = IANAZone2.prototype;
      _proto.offsetName = function offsetName(ts, _ref) {
        var format = _ref.format, locale = _ref.locale;
        return parseZoneInfo(ts, format, locale, this.name);
      };
      _proto.formatOffset = function formatOffset$1(ts, format) {
        return formatOffset(this.offset(ts), format);
      };
      _proto.offset = function offset2(ts) {
        var date = new Date(ts);
        if (isNaN(date))
          return NaN;
        var dtf = makeDTF(this.name), _ref2 = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date), year = _ref2[0], month = _ref2[1], day = _ref2[2], hour = _ref2[3], minute = _ref2[4], second = _ref2[5];
        var adjustedHour = hour === 24 ? 0 : hour;
        var asUTC = objToLocalTS({
          year,
          month,
          day,
          hour: adjustedHour,
          minute,
          second,
          millisecond: 0
        });
        var asTS = +date;
        var over = asTS % 1e3;
        asTS -= over >= 0 ? over : 1e3 + over;
        return (asUTC - asTS) / (60 * 1e3);
      };
      _proto.equals = function equals(otherZone) {
        return otherZone.type === "iana" && otherZone.name === this.name;
      };
      _createClass(IANAZone2, [{
        key: "type",
        get: function get() {
          return "iana";
        }
      }, {
        key: "name",
        get: function get() {
          return this.zoneName;
        }
      }, {
        key: "isUniversal",
        get: function get() {
          return false;
        }
      }, {
        key: "isValid",
        get: function get() {
          return this.valid;
        }
      }]);
      return IANAZone2;
    }(Zone);
    var singleton = null;
    var FixedOffsetZone = /* @__PURE__ */ function(_Zone) {
      _inheritsLoose(FixedOffsetZone2, _Zone);
      FixedOffsetZone2.instance = function instance7(offset2) {
        return offset2 === 0 ? FixedOffsetZone2.utcInstance : new FixedOffsetZone2(offset2);
      };
      FixedOffsetZone2.parseSpecifier = function parseSpecifier(s2) {
        if (s2) {
          var r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
          if (r) {
            return new FixedOffsetZone2(signedOffset(r[1], r[2]));
          }
        }
        return null;
      };
      function FixedOffsetZone2(offset2) {
        var _this;
        _this = _Zone.call(this) || this;
        _this.fixed = offset2;
        return _this;
      }
      var _proto = FixedOffsetZone2.prototype;
      _proto.offsetName = function offsetName() {
        return this.name;
      };
      _proto.formatOffset = function formatOffset$1(ts, format) {
        return formatOffset(this.fixed, format);
      };
      _proto.offset = function offset2() {
        return this.fixed;
      };
      _proto.equals = function equals(otherZone) {
        return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
      };
      _createClass(FixedOffsetZone2, [{
        key: "type",
        get: function get() {
          return "fixed";
        }
      }, {
        key: "name",
        get: function get() {
          return this.fixed === 0 ? "UTC" : "UTC" + formatOffset(this.fixed, "narrow");
        }
      }, {
        key: "isUniversal",
        get: function get() {
          return true;
        }
      }, {
        key: "isValid",
        get: function get() {
          return true;
        }
      }], [{
        key: "utcInstance",
        get: function get() {
          if (singleton === null) {
            singleton = new FixedOffsetZone2(0);
          }
          return singleton;
        }
      }]);
      return FixedOffsetZone2;
    }(Zone);
    var InvalidZone = /* @__PURE__ */ function(_Zone) {
      _inheritsLoose(InvalidZone2, _Zone);
      function InvalidZone2(zoneName) {
        var _this;
        _this = _Zone.call(this) || this;
        _this.zoneName = zoneName;
        return _this;
      }
      var _proto = InvalidZone2.prototype;
      _proto.offsetName = function offsetName() {
        return null;
      };
      _proto.formatOffset = function formatOffset2() {
        return "";
      };
      _proto.offset = function offset2() {
        return NaN;
      };
      _proto.equals = function equals() {
        return false;
      };
      _createClass(InvalidZone2, [{
        key: "type",
        get: function get() {
          return "invalid";
        }
      }, {
        key: "name",
        get: function get() {
          return this.zoneName;
        }
      }, {
        key: "isUniversal",
        get: function get() {
          return false;
        }
      }, {
        key: "isValid",
        get: function get() {
          return false;
        }
      }]);
      return InvalidZone2;
    }(Zone);
    function normalizeZone(input, defaultZone2) {
      if (isUndefined(input) || input === null) {
        return defaultZone2;
      } else if (input instanceof Zone) {
        return input;
      } else if (isString(input)) {
        var lowered = input.toLowerCase();
        if (lowered === "local" || lowered === "system")
          return defaultZone2;
        else if (lowered === "utc" || lowered === "gmt")
          return FixedOffsetZone.utcInstance;
        else if (IANAZone.isValidSpecifier(lowered))
          return IANAZone.create(input);
        else
          return FixedOffsetZone.parseSpecifier(lowered) || new InvalidZone(input);
      } else if (isNumber2(input)) {
        return FixedOffsetZone.instance(input);
      } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
        return input;
      } else {
        return new InvalidZone(input);
      }
    }
    var now = function now2() {
      return Date.now();
    };
    var defaultZone = "system";
    var defaultLocale = null;
    var defaultNumberingSystem = null;
    var defaultOutputCalendar = null;
    var throwOnInvalid;
    var Settings = /* @__PURE__ */ function() {
      function Settings2() {
      }
      Settings2.resetCaches = function resetCaches() {
        Locale.resetCache();
        IANAZone.resetCache();
      };
      _createClass(Settings2, null, [{
        key: "now",
        get: function get() {
          return now;
        },
        set: function set2(n2) {
          now = n2;
        }
      }, {
        key: "defaultZone",
        get: function get() {
          return normalizeZone(defaultZone, SystemZone.instance);
        },
        set: function set2(zone) {
          defaultZone = zone;
        }
      }, {
        key: "defaultLocale",
        get: function get() {
          return defaultLocale;
        },
        set: function set2(locale) {
          defaultLocale = locale;
        }
      }, {
        key: "defaultNumberingSystem",
        get: function get() {
          return defaultNumberingSystem;
        },
        set: function set2(numberingSystem) {
          defaultNumberingSystem = numberingSystem;
        }
      }, {
        key: "defaultOutputCalendar",
        get: function get() {
          return defaultOutputCalendar;
        },
        set: function set2(outputCalendar) {
          defaultOutputCalendar = outputCalendar;
        }
      }, {
        key: "throwOnInvalid",
        get: function get() {
          return throwOnInvalid;
        },
        set: function set2(t) {
          throwOnInvalid = t;
        }
      }]);
      return Settings2;
    }();
    var _excluded = ["base"];
    var _excluded2 = ["padTo", "floor"];
    var intlLFCache = {};
    function getCachedLF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var key = JSON.stringify([locString, opts]);
      var dtf = intlLFCache[key];
      if (!dtf) {
        dtf = new Intl.ListFormat(locString, opts);
        intlLFCache[key] = dtf;
      }
      return dtf;
    }
    var intlDTCache = {};
    function getCachedDTF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var key = JSON.stringify([locString, opts]);
      var dtf = intlDTCache[key];
      if (!dtf) {
        dtf = new Intl.DateTimeFormat(locString, opts);
        intlDTCache[key] = dtf;
      }
      return dtf;
    }
    var intlNumCache = {};
    function getCachedINF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var key = JSON.stringify([locString, opts]);
      var inf = intlNumCache[key];
      if (!inf) {
        inf = new Intl.NumberFormat(locString, opts);
        intlNumCache[key] = inf;
      }
      return inf;
    }
    var intlRelCache = {};
    function getCachedRTF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var _opts = opts;
      _opts.base;
      var cacheKeyOpts = _objectWithoutPropertiesLoose(_opts, _excluded);
      var key = JSON.stringify([locString, cacheKeyOpts]);
      var inf = intlRelCache[key];
      if (!inf) {
        inf = new Intl.RelativeTimeFormat(locString, opts);
        intlRelCache[key] = inf;
      }
      return inf;
    }
    var sysLocaleCache = null;
    function systemLocale() {
      if (sysLocaleCache) {
        return sysLocaleCache;
      } else {
        sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
        return sysLocaleCache;
      }
    }
    function parseLocaleString(localeStr) {
      var uIndex = localeStr.indexOf("-u-");
      if (uIndex === -1) {
        return [localeStr];
      } else {
        var options;
        var smaller = localeStr.substring(0, uIndex);
        try {
          options = getCachedDTF(localeStr).resolvedOptions();
        } catch (e) {
          options = getCachedDTF(smaller).resolvedOptions();
        }
        var _options = options, numberingSystem = _options.numberingSystem, calendar = _options.calendar;
        return [smaller, numberingSystem, calendar];
      }
    }
    function intlConfigString(localeStr, numberingSystem, outputCalendar) {
      if (outputCalendar || numberingSystem) {
        localeStr += "-u";
        if (outputCalendar) {
          localeStr += "-ca-" + outputCalendar;
        }
        if (numberingSystem) {
          localeStr += "-nu-" + numberingSystem;
        }
        return localeStr;
      } else {
        return localeStr;
      }
    }
    function mapMonths(f) {
      var ms = [];
      for (var i = 1; i <= 12; i++) {
        var dt = DateTime3.utc(2016, i, 1);
        ms.push(f(dt));
      }
      return ms;
    }
    function mapWeekdays(f) {
      var ms = [];
      for (var i = 1; i <= 7; i++) {
        var dt = DateTime3.utc(2016, 11, 13 + i);
        ms.push(f(dt));
      }
      return ms;
    }
    function listStuff(loc, length, defaultOK, englishFn, intlFn) {
      var mode = loc.listingMode(defaultOK);
      if (mode === "error") {
        return null;
      } else if (mode === "en") {
        return englishFn(length);
      } else {
        return intlFn(length);
      }
    }
    function supportsFastNumbers(loc) {
      if (loc.numberingSystem && loc.numberingSystem !== "latn") {
        return false;
      } else {
        return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
      }
    }
    var PolyNumberFormatter = /* @__PURE__ */ function() {
      function PolyNumberFormatter2(intl, forceSimple, opts) {
        this.padTo = opts.padTo || 0;
        this.floor = opts.floor || false;
        opts.padTo;
        opts.floor;
        var otherOpts = _objectWithoutPropertiesLoose(opts, _excluded2);
        if (!forceSimple || Object.keys(otherOpts).length > 0) {
          var intlOpts = _extends({
            useGrouping: false
          }, opts);
          if (opts.padTo > 0)
            intlOpts.minimumIntegerDigits = opts.padTo;
          this.inf = getCachedINF(intl, intlOpts);
        }
      }
      var _proto = PolyNumberFormatter2.prototype;
      _proto.format = function format(i) {
        if (this.inf) {
          var fixed = this.floor ? Math.floor(i) : i;
          return this.inf.format(fixed);
        } else {
          var _fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
          return padStart(_fixed, this.padTo);
        }
      };
      return PolyNumberFormatter2;
    }();
    var PolyDateFormatter = /* @__PURE__ */ function() {
      function PolyDateFormatter2(dt, intl, opts) {
        this.opts = opts;
        var z;
        if (dt.zone.isUniversal) {
          var gmtOffset = -1 * (dt.offset / 60);
          var offsetZ = gmtOffset >= 0 ? "Etc/GMT+" + gmtOffset : "Etc/GMT" + gmtOffset;
          if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
            z = offsetZ;
            this.dt = dt;
          } else {
            z = "UTC";
            if (opts.timeZoneName) {
              this.dt = dt;
            } else {
              this.dt = dt.offset === 0 ? dt : DateTime3.fromMillis(dt.ts + dt.offset * 60 * 1e3);
            }
          }
        } else if (dt.zone.type === "system") {
          this.dt = dt;
        } else {
          this.dt = dt;
          z = dt.zone.name;
        }
        var intlOpts = _extends({}, this.opts);
        if (z) {
          intlOpts.timeZone = z;
        }
        this.dtf = getCachedDTF(intl, intlOpts);
      }
      var _proto2 = PolyDateFormatter2.prototype;
      _proto2.format = function format() {
        return this.dtf.format(this.dt.toJSDate());
      };
      _proto2.formatToParts = function formatToParts() {
        return this.dtf.formatToParts(this.dt.toJSDate());
      };
      _proto2.resolvedOptions = function resolvedOptions() {
        return this.dtf.resolvedOptions();
      };
      return PolyDateFormatter2;
    }();
    var PolyRelFormatter = /* @__PURE__ */ function() {
      function PolyRelFormatter2(intl, isEnglish, opts) {
        this.opts = _extends({
          style: "long"
        }, opts);
        if (!isEnglish && hasRelative()) {
          this.rtf = getCachedRTF(intl, opts);
        }
      }
      var _proto3 = PolyRelFormatter2.prototype;
      _proto3.format = function format(count, unit) {
        if (this.rtf) {
          return this.rtf.format(count, unit);
        } else {
          return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
        }
      };
      _proto3.formatToParts = function formatToParts(count, unit) {
        if (this.rtf) {
          return this.rtf.formatToParts(count, unit);
        } else {
          return [];
        }
      };
      return PolyRelFormatter2;
    }();
    var Locale = /* @__PURE__ */ function() {
      Locale2.fromOpts = function fromOpts(opts) {
        return Locale2.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
      };
      Locale2.create = function create(locale, numberingSystem, outputCalendar, defaultToEN) {
        if (defaultToEN === void 0) {
          defaultToEN = false;
        }
        var specifiedLocale = locale || Settings.defaultLocale;
        var localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
        var numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
        var outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
        return new Locale2(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
      };
      Locale2.resetCache = function resetCache() {
        sysLocaleCache = null;
        intlDTCache = {};
        intlNumCache = {};
        intlRelCache = {};
      };
      Locale2.fromObject = function fromObject2(_temp) {
        var _ref = _temp === void 0 ? {} : _temp, locale = _ref.locale, numberingSystem = _ref.numberingSystem, outputCalendar = _ref.outputCalendar;
        return Locale2.create(locale, numberingSystem, outputCalendar);
      };
      function Locale2(locale, numbering, outputCalendar, specifiedLocale) {
        var _parseLocaleString = parseLocaleString(locale), parsedLocale = _parseLocaleString[0], parsedNumberingSystem = _parseLocaleString[1], parsedOutputCalendar = _parseLocaleString[2];
        this.locale = parsedLocale;
        this.numberingSystem = numbering || parsedNumberingSystem || null;
        this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
        this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
        this.weekdaysCache = {
          format: {},
          standalone: {}
        };
        this.monthsCache = {
          format: {},
          standalone: {}
        };
        this.meridiemCache = null;
        this.eraCache = {};
        this.specifiedLocale = specifiedLocale;
        this.fastNumbersCached = null;
      }
      var _proto4 = Locale2.prototype;
      _proto4.listingMode = function listingMode() {
        var isActuallyEn = this.isEnglish();
        var hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return isActuallyEn && hasNoWeirdness ? "en" : "intl";
      };
      _proto4.clone = function clone3(alts) {
        if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
          return this;
        } else {
          return Locale2.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);
        }
      };
      _proto4.redefaultToEN = function redefaultToEN(alts) {
        if (alts === void 0) {
          alts = {};
        }
        return this.clone(_extends({}, alts, {
          defaultToEN: true
        }));
      };
      _proto4.redefaultToSystem = function redefaultToSystem(alts) {
        if (alts === void 0) {
          alts = {};
        }
        return this.clone(_extends({}, alts, {
          defaultToEN: false
        }));
      };
      _proto4.months = function months$1(length, format, defaultOK) {
        var _this = this;
        if (format === void 0) {
          format = false;
        }
        if (defaultOK === void 0) {
          defaultOK = true;
        }
        return listStuff(this, length, defaultOK, months, function() {
          var intl = format ? {
            month: length,
            day: "numeric"
          } : {
            month: length
          }, formatStr = format ? "format" : "standalone";
          if (!_this.monthsCache[formatStr][length]) {
            _this.monthsCache[formatStr][length] = mapMonths(function(dt) {
              return _this.extract(dt, intl, "month");
            });
          }
          return _this.monthsCache[formatStr][length];
        });
      };
      _proto4.weekdays = function weekdays$1(length, format, defaultOK) {
        var _this2 = this;
        if (format === void 0) {
          format = false;
        }
        if (defaultOK === void 0) {
          defaultOK = true;
        }
        return listStuff(this, length, defaultOK, weekdays, function() {
          var intl = format ? {
            weekday: length,
            year: "numeric",
            month: "long",
            day: "numeric"
          } : {
            weekday: length
          }, formatStr = format ? "format" : "standalone";
          if (!_this2.weekdaysCache[formatStr][length]) {
            _this2.weekdaysCache[formatStr][length] = mapWeekdays(function(dt) {
              return _this2.extract(dt, intl, "weekday");
            });
          }
          return _this2.weekdaysCache[formatStr][length];
        });
      };
      _proto4.meridiems = function meridiems$1(defaultOK) {
        var _this3 = this;
        if (defaultOK === void 0) {
          defaultOK = true;
        }
        return listStuff(this, void 0, defaultOK, function() {
          return meridiems;
        }, function() {
          if (!_this3.meridiemCache) {
            var intl = {
              hour: "numeric",
              hourCycle: "h12"
            };
            _this3.meridiemCache = [DateTime3.utc(2016, 11, 13, 9), DateTime3.utc(2016, 11, 13, 19)].map(function(dt) {
              return _this3.extract(dt, intl, "dayperiod");
            });
          }
          return _this3.meridiemCache;
        });
      };
      _proto4.eras = function eras$1(length, defaultOK) {
        var _this4 = this;
        if (defaultOK === void 0) {
          defaultOK = true;
        }
        return listStuff(this, length, defaultOK, eras, function() {
          var intl = {
            era: length
          };
          if (!_this4.eraCache[length]) {
            _this4.eraCache[length] = [DateTime3.utc(-40, 1, 1), DateTime3.utc(2017, 1, 1)].map(function(dt) {
              return _this4.extract(dt, intl, "era");
            });
          }
          return _this4.eraCache[length];
        });
      };
      _proto4.extract = function extract(dt, intlOpts, field) {
        var df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find(function(m) {
          return m.type.toLowerCase() === field;
        });
        return matching ? matching.value : null;
      };
      _proto4.numberFormatter = function numberFormatter(opts) {
        if (opts === void 0) {
          opts = {};
        }
        return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
      };
      _proto4.dtFormatter = function dtFormatter(dt, intlOpts) {
        if (intlOpts === void 0) {
          intlOpts = {};
        }
        return new PolyDateFormatter(dt, this.intl, intlOpts);
      };
      _proto4.relFormatter = function relFormatter(opts) {
        if (opts === void 0) {
          opts = {};
        }
        return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
      };
      _proto4.listFormatter = function listFormatter(opts) {
        if (opts === void 0) {
          opts = {};
        }
        return getCachedLF(this.intl, opts);
      };
      _proto4.isEnglish = function isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
      };
      _proto4.equals = function equals(other) {
        return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
      };
      _createClass(Locale2, [{
        key: "fastNumbers",
        get: function get() {
          if (this.fastNumbersCached == null) {
            this.fastNumbersCached = supportsFastNumbers(this);
          }
          return this.fastNumbersCached;
        }
      }]);
      return Locale2;
    }();
    function combineRegexes() {
      for (var _len = arguments.length, regexes = new Array(_len), _key = 0; _key < _len; _key++) {
        regexes[_key] = arguments[_key];
      }
      var full = regexes.reduce(function(f, r) {
        return f + r.source;
      }, "");
      return RegExp("^" + full + "$");
    }
    function combineExtractors() {
      for (var _len2 = arguments.length, extractors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        extractors[_key2] = arguments[_key2];
      }
      return function(m) {
        return extractors.reduce(function(_ref, ex) {
          var mergedVals = _ref[0], mergedZone = _ref[1], cursor = _ref[2];
          var _ex = ex(m, cursor), val = _ex[0], zone = _ex[1], next = _ex[2];
          return [_extends({}, mergedVals, val), mergedZone || zone, next];
        }, [{}, null, 1]).slice(0, 2);
      };
    }
    function parse2(s2) {
      if (s2 == null) {
        return [null, null];
      }
      for (var _len3 = arguments.length, patterns = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        patterns[_key3 - 1] = arguments[_key3];
      }
      for (var _i = 0, _patterns = patterns; _i < _patterns.length; _i++) {
        var _patterns$_i = _patterns[_i], regex = _patterns$_i[0], extractor = _patterns$_i[1];
        var m = regex.exec(s2);
        if (m) {
          return extractor(m);
        }
      }
      return [null, null];
    }
    function simpleParse() {
      for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        keys[_key4] = arguments[_key4];
      }
      return function(match2, cursor) {
        var ret = {};
        var i;
        for (i = 0; i < keys.length; i++) {
          ret[keys[i]] = parseInteger(match2[cursor + i]);
        }
        return [ret, null, cursor + i];
      };
    }
    var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
    var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
    var isoTimeRegex = RegExp("" + isoTimeBaseRegex.source + offsetRegex.source + "?");
    var isoTimeExtensionRegex = RegExp("(?:T" + isoTimeRegex.source + ")?");
    var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
    var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
    var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
    var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
    var extractISOOrdinalData = simpleParse("year", "ordinal");
    var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
    var sqlTimeRegex = RegExp(isoTimeBaseRegex.source + " ?(?:" + offsetRegex.source + "|(" + ianaRegex.source + "))?");
    var sqlTimeExtensionRegex = RegExp("(?: " + sqlTimeRegex.source + ")?");
    function int(match2, pos, fallback) {
      var m = match2[pos];
      return isUndefined(m) ? fallback : parseInteger(m);
    }
    function extractISOYmd(match2, cursor) {
      var item = {
        year: int(match2, cursor),
        month: int(match2, cursor + 1, 1),
        day: int(match2, cursor + 2, 1)
      };
      return [item, null, cursor + 3];
    }
    function extractISOTime(match2, cursor) {
      var item = {
        hours: int(match2, cursor, 0),
        minutes: int(match2, cursor + 1, 0),
        seconds: int(match2, cursor + 2, 0),
        milliseconds: parseMillis(match2[cursor + 3])
      };
      return [item, null, cursor + 4];
    }
    function extractISOOffset(match2, cursor) {
      var local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
      return [{}, zone, cursor + 3];
    }
    function extractIANAZone(match2, cursor) {
      var zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
      return [{}, zone, cursor + 1];
    }
    var isoTimeOnly = RegExp("^T?" + isoTimeBaseRegex.source + "$");
    var isoDuration = /^-?P(?:(?:(-?\d{1,9}(?:\.\d{1,9})?)Y)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,9}(?:\.\d{1,9})?)W)?(?:(-?\d{1,9}(?:\.\d{1,9})?)D)?(?:T(?:(-?\d{1,9}(?:\.\d{1,9})?)H)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,9}))?S)?)?)$/;
    function extractISODuration(match2) {
      var s2 = match2[0], yearStr = match2[1], monthStr = match2[2], weekStr = match2[3], dayStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], millisecondsStr = match2[8];
      var hasNegativePrefix = s2[0] === "-";
      var negativeSeconds = secondStr && secondStr[0] === "-";
      var maybeNegate = function maybeNegate2(num, force) {
        if (force === void 0) {
          force = false;
        }
        return num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
      };
      return [{
        years: maybeNegate(parseFloating(yearStr)),
        months: maybeNegate(parseFloating(monthStr)),
        weeks: maybeNegate(parseFloating(weekStr)),
        days: maybeNegate(parseFloating(dayStr)),
        hours: maybeNegate(parseFloating(hourStr)),
        minutes: maybeNegate(parseFloating(minuteStr)),
        seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
        milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
      }];
    }
    var obsOffsets = {
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = {
        year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
        month: monthsShort.indexOf(monthStr) + 1,
        day: parseInteger(dayStr),
        hour: parseInteger(hourStr),
        minute: parseInteger(minuteStr)
      };
      if (secondStr)
        result.second = parseInteger(secondStr);
      if (weekdayStr) {
        result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
      }
      return result;
    }
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
    function extractRFC2822(match2) {
      var weekdayStr = match2[1], dayStr = match2[2], monthStr = match2[3], yearStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], obsOffset = match2[8], milOffset = match2[9], offHourStr = match2[10], offMinuteStr = match2[11], result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      var offset2;
      if (obsOffset) {
        offset2 = obsOffsets[obsOffset];
      } else if (milOffset) {
        offset2 = 0;
      } else {
        offset2 = signedOffset(offHourStr, offMinuteStr);
      }
      return [result, new FixedOffsetZone(offset2)];
    }
    function preprocessRFC2822(s2) {
      return s2.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
    }
    var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
    var rfc850 = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
    var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
    function extractRFC1123Or850(match2) {
      var weekdayStr = match2[1], dayStr = match2[2], monthStr = match2[3], yearStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    function extractASCII(match2) {
      var weekdayStr = match2[1], monthStr = match2[2], dayStr = match2[3], hourStr = match2[4], minuteStr = match2[5], secondStr = match2[6], yearStr = match2[7], result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
    var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
    var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
    var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
    var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset);
    var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset);
    var extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset);
    var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset);
    function parseISODate(s2) {
      return parse2(s2, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
    }
    function parseRFC2822Date(s2) {
      return parse2(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
    }
    function parseHTTPDate(s2) {
      return parse2(s2, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
    }
    function parseISODuration(s2) {
      return parse2(s2, [isoDuration, extractISODuration]);
    }
    var extractISOTimeOnly = combineExtractors(extractISOTime);
    function parseISOTimeOnly(s2) {
      return parse2(s2, [isoTimeOnly, extractISOTimeOnly]);
    }
    var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
    var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
    var extractISOYmdTimeOffsetAndIANAZone = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
    var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
    function parseSQL(s2) {
      return parse2(s2, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeOffsetAndIANAZone], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
    }
    var INVALID$2 = "Invalid Duration";
    var lowOrderMatrix = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1e3
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1e3
      },
      hours: {
        minutes: 60,
        seconds: 60 * 60,
        milliseconds: 60 * 60 * 1e3
      },
      minutes: {
        seconds: 60,
        milliseconds: 60 * 1e3
      },
      seconds: {
        milliseconds: 1e3
      }
    };
    var casualMatrix = _extends({
      years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1e3
      },
      months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1e3
      }
    }, lowOrderMatrix);
    var daysInYearAccurate = 146097 / 400;
    var daysInMonthAccurate = 146097 / 4800;
    var accurateMatrix = _extends({
      years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate / 7,
        days: daysInYearAccurate,
        hours: daysInYearAccurate * 24,
        minutes: daysInYearAccurate * 24 * 60,
        seconds: daysInYearAccurate * 24 * 60 * 60,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: daysInYearAccurate / 28,
        days: daysInYearAccurate / 4,
        hours: daysInYearAccurate * 24 / 4,
        minutes: daysInYearAccurate * 24 * 60 / 4,
        seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
      },
      months: {
        weeks: daysInMonthAccurate / 7,
        days: daysInMonthAccurate,
        hours: daysInMonthAccurate * 24,
        minutes: daysInMonthAccurate * 24 * 60,
        seconds: daysInMonthAccurate * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
      }
    }, lowOrderMatrix);
    var orderedUnits$1 = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
    var reverseUnits = orderedUnits$1.slice(0).reverse();
    function clone$12(dur, alts, clear) {
      if (clear === void 0) {
        clear = false;
      }
      var conf = {
        values: clear ? alts.values : _extends({}, dur.values, alts.values || {}),
        loc: dur.loc.clone(alts.loc),
        conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy
      };
      return new Duration(conf);
    }
    function antiTrunc(n2) {
      return n2 < 0 ? Math.floor(n2) : Math.ceil(n2);
    }
    function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
      var conv = matrix[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
      toMap[toUnit] += added;
      fromMap[fromUnit] -= added * conv;
    }
    function normalizeValues(matrix, vals) {
      reverseUnits.reduce(function(previous, current) {
        if (!isUndefined(vals[current])) {
          if (previous) {
            convert(matrix, vals, previous, vals, current);
          }
          return current;
        } else {
          return previous;
        }
      }, null);
    }
    var Duration = /* @__PURE__ */ function() {
      function Duration2(config) {
        var accurate = config.conversionAccuracy === "longterm" || false;
        this.values = config.values;
        this.loc = config.loc || Locale.create();
        this.conversionAccuracy = accurate ? "longterm" : "casual";
        this.invalid = config.invalid || null;
        this.matrix = accurate ? accurateMatrix : casualMatrix;
        this.isLuxonDuration = true;
      }
      Duration2.fromMillis = function fromMillis(count, opts) {
        return Duration2.fromObject({
          milliseconds: count
        }, opts);
      };
      Duration2.fromObject = function fromObject2(obj, opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (obj == null || typeof obj !== "object") {
          throw new InvalidArgumentError("Duration.fromObject: argument expected to be an object, got " + (obj === null ? "null" : typeof obj));
        }
        return new Duration2({
          values: normalizeObject(obj, Duration2.normalizeUnit),
          loc: Locale.fromObject(opts),
          conversionAccuracy: opts.conversionAccuracy
        });
      };
      Duration2.fromDurationLike = function fromDurationLike(durationLike) {
        if (isNumber2(durationLike)) {
          return Duration2.fromMillis(durationLike);
        } else if (Duration2.isDuration(durationLike)) {
          return durationLike;
        } else if (typeof durationLike === "object") {
          return Duration2.fromObject(durationLike);
        } else {
          throw new InvalidArgumentError("Unknown duration argument " + durationLike + " of type " + typeof durationLike);
        }
      };
      Duration2.fromISO = function fromISO(text2, opts) {
        var _parseISODuration = parseISODuration(text2), parsed = _parseISODuration[0];
        if (parsed) {
          return Duration2.fromObject(parsed, opts);
        } else {
          return Duration2.invalid("unparsable", 'the input "' + text2 + `" can't be parsed as ISO 8601`);
        }
      };
      Duration2.fromISOTime = function fromISOTime(text2, opts) {
        var _parseISOTimeOnly = parseISOTimeOnly(text2), parsed = _parseISOTimeOnly[0];
        if (parsed) {
          return Duration2.fromObject(parsed, opts);
        } else {
          return Duration2.invalid("unparsable", 'the input "' + text2 + `" can't be parsed as ISO 8601`);
        }
      };
      Duration2.invalid = function invalid(reason, explanation) {
        if (explanation === void 0) {
          explanation = null;
        }
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
        }
        var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDurationError(invalid2);
        } else {
          return new Duration2({
            invalid: invalid2
          });
        }
      };
      Duration2.normalizeUnit = function normalizeUnit2(unit) {
        var normalized = {
          year: "years",
          years: "years",
          quarter: "quarters",
          quarters: "quarters",
          month: "months",
          months: "months",
          week: "weeks",
          weeks: "weeks",
          day: "days",
          days: "days",
          hour: "hours",
          hours: "hours",
          minute: "minutes",
          minutes: "minutes",
          second: "seconds",
          seconds: "seconds",
          millisecond: "milliseconds",
          milliseconds: "milliseconds"
        }[unit ? unit.toLowerCase() : unit];
        if (!normalized)
          throw new InvalidUnitError(unit);
        return normalized;
      };
      Duration2.isDuration = function isDuration(o) {
        return o && o.isLuxonDuration || false;
      };
      var _proto = Duration2.prototype;
      _proto.toFormat = function toFormat(fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var fmtOpts = _extends({}, opts, {
          floor: opts.round !== false && opts.floor !== false
        });
        return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
      };
      _proto.toHuman = function toHuman(opts) {
        var _this = this;
        if (opts === void 0) {
          opts = {};
        }
        var l2 = orderedUnits$1.map(function(unit) {
          var val = _this.values[unit];
          if (isUndefined(val)) {
            return null;
          }
          return _this.loc.numberFormatter(_extends({
            style: "unit",
            unitDisplay: "long"
          }, opts, {
            unit: unit.slice(0, -1)
          })).format(val);
        }).filter(function(n2) {
          return n2;
        });
        return this.loc.listFormatter(_extends({
          type: "conjunction",
          style: opts.listStyle || "narrow"
        }, opts)).format(l2);
      };
      _proto.toObject = function toObject() {
        if (!this.isValid)
          return {};
        return _extends({}, this.values);
      };
      _proto.toISO = function toISO() {
        if (!this.isValid)
          return null;
        var s2 = "P";
        if (this.years !== 0)
          s2 += this.years + "Y";
        if (this.months !== 0 || this.quarters !== 0)
          s2 += this.months + this.quarters * 3 + "M";
        if (this.weeks !== 0)
          s2 += this.weeks + "W";
        if (this.days !== 0)
          s2 += this.days + "D";
        if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
          s2 += "T";
        if (this.hours !== 0)
          s2 += this.hours + "H";
        if (this.minutes !== 0)
          s2 += this.minutes + "M";
        if (this.seconds !== 0 || this.milliseconds !== 0)
          s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
        if (s2 === "P")
          s2 += "T0S";
        return s2;
      };
      _proto.toISOTime = function toISOTime(opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid)
          return null;
        var millis = this.toMillis();
        if (millis < 0 || millis >= 864e5)
          return null;
        opts = _extends({
          suppressMilliseconds: false,
          suppressSeconds: false,
          includePrefix: false,
          format: "extended"
        }, opts);
        var value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
        var fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
        if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
          fmt += opts.format === "basic" ? "ss" : ":ss";
          if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
            fmt += ".SSS";
          }
        }
        var str = value.toFormat(fmt);
        if (opts.includePrefix) {
          str = "T" + str;
        }
        return str;
      };
      _proto.toJSON = function toJSON() {
        return this.toISO();
      };
      _proto.toString = function toString() {
        return this.toISO();
      };
      _proto.toMillis = function toMillis() {
        return this.as("milliseconds");
      };
      _proto.valueOf = function valueOf() {
        return this.toMillis();
      };
      _proto.plus = function plus(duration) {
        if (!this.isValid)
          return this;
        var dur = Duration2.fromDurationLike(duration), result = {};
        for (var _iterator = _createForOfIteratorHelperLoose(orderedUnits$1), _step; !(_step = _iterator()).done; ) {
          var k = _step.value;
          if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
            result[k] = dur.get(k) + this.get(k);
          }
        }
        return clone$12(this, {
          values: result
        }, true);
      };
      _proto.minus = function minus(duration) {
        if (!this.isValid)
          return this;
        var dur = Duration2.fromDurationLike(duration);
        return this.plus(dur.negate());
      };
      _proto.mapUnits = function mapUnits(fn) {
        if (!this.isValid)
          return this;
        var result = {};
        for (var _i = 0, _Object$keys = Object.keys(this.values); _i < _Object$keys.length; _i++) {
          var k = _Object$keys[_i];
          result[k] = asNumber(fn(this.values[k], k));
        }
        return clone$12(this, {
          values: result
        }, true);
      };
      _proto.get = function get(unit) {
        return this[Duration2.normalizeUnit(unit)];
      };
      _proto.set = function set2(values) {
        if (!this.isValid)
          return this;
        var mixed = _extends({}, this.values, normalizeObject(values, Duration2.normalizeUnit));
        return clone$12(this, {
          values: mixed
        });
      };
      _proto.reconfigure = function reconfigure(_temp) {
        var _ref = _temp === void 0 ? {} : _temp, locale = _ref.locale, numberingSystem = _ref.numberingSystem, conversionAccuracy = _ref.conversionAccuracy;
        var loc = this.loc.clone({
          locale,
          numberingSystem
        }), opts = {
          loc
        };
        if (conversionAccuracy) {
          opts.conversionAccuracy = conversionAccuracy;
        }
        return clone$12(this, opts);
      };
      _proto.as = function as(unit) {
        return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
      };
      _proto.normalize = function normalize() {
        if (!this.isValid)
          return this;
        var vals = this.toObject();
        normalizeValues(this.matrix, vals);
        return clone$12(this, {
          values: vals
        }, true);
      };
      _proto.shiftTo = function shiftTo() {
        for (var _len = arguments.length, units = new Array(_len), _key = 0; _key < _len; _key++) {
          units[_key] = arguments[_key];
        }
        if (!this.isValid)
          return this;
        if (units.length === 0) {
          return this;
        }
        units = units.map(function(u) {
          return Duration2.normalizeUnit(u);
        });
        var built = {}, accumulated = {}, vals = this.toObject();
        var lastUnit;
        for (var _iterator2 = _createForOfIteratorHelperLoose(orderedUnits$1), _step2; !(_step2 = _iterator2()).done; ) {
          var k = _step2.value;
          if (units.indexOf(k) >= 0) {
            lastUnit = k;
            var own = 0;
            for (var ak in accumulated) {
              own += this.matrix[ak][k] * accumulated[ak];
              accumulated[ak] = 0;
            }
            if (isNumber2(vals[k])) {
              own += vals[k];
            }
            var i = Math.trunc(own);
            built[k] = i;
            accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
            for (var down in vals) {
              if (orderedUnits$1.indexOf(down) > orderedUnits$1.indexOf(k)) {
                convert(this.matrix, vals, down, built, k);
              }
            }
          } else if (isNumber2(vals[k])) {
            accumulated[k] = vals[k];
          }
        }
        for (var key in accumulated) {
          if (accumulated[key] !== 0) {
            built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
          }
        }
        return clone$12(this, {
          values: built
        }, true).normalize();
      };
      _proto.negate = function negate() {
        if (!this.isValid)
          return this;
        var negated = {};
        for (var _i2 = 0, _Object$keys2 = Object.keys(this.values); _i2 < _Object$keys2.length; _i2++) {
          var k = _Object$keys2[_i2];
          negated[k] = -this.values[k];
        }
        return clone$12(this, {
          values: negated
        }, true);
      };
      _proto.equals = function equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        if (!this.loc.equals(other.loc)) {
          return false;
        }
        function eq2(v1, v2) {
          if (v1 === void 0 || v1 === 0)
            return v2 === void 0 || v2 === 0;
          return v1 === v2;
        }
        for (var _iterator3 = _createForOfIteratorHelperLoose(orderedUnits$1), _step3; !(_step3 = _iterator3()).done; ) {
          var u = _step3.value;
          if (!eq2(this.values[u], other.values[u])) {
            return false;
          }
        }
        return true;
      };
      _createClass(Duration2, [{
        key: "locale",
        get: function get() {
          return this.isValid ? this.loc.locale : null;
        }
      }, {
        key: "numberingSystem",
        get: function get() {
          return this.isValid ? this.loc.numberingSystem : null;
        }
      }, {
        key: "years",
        get: function get() {
          return this.isValid ? this.values.years || 0 : NaN;
        }
      }, {
        key: "quarters",
        get: function get() {
          return this.isValid ? this.values.quarters || 0 : NaN;
        }
      }, {
        key: "months",
        get: function get() {
          return this.isValid ? this.values.months || 0 : NaN;
        }
      }, {
        key: "weeks",
        get: function get() {
          return this.isValid ? this.values.weeks || 0 : NaN;
        }
      }, {
        key: "days",
        get: function get() {
          return this.isValid ? this.values.days || 0 : NaN;
        }
      }, {
        key: "hours",
        get: function get() {
          return this.isValid ? this.values.hours || 0 : NaN;
        }
      }, {
        key: "minutes",
        get: function get() {
          return this.isValid ? this.values.minutes || 0 : NaN;
        }
      }, {
        key: "seconds",
        get: function get() {
          return this.isValid ? this.values.seconds || 0 : NaN;
        }
      }, {
        key: "milliseconds",
        get: function get() {
          return this.isValid ? this.values.milliseconds || 0 : NaN;
        }
      }, {
        key: "isValid",
        get: function get() {
          return this.invalid === null;
        }
      }, {
        key: "invalidReason",
        get: function get() {
          return this.invalid ? this.invalid.reason : null;
        }
      }, {
        key: "invalidExplanation",
        get: function get() {
          return this.invalid ? this.invalid.explanation : null;
        }
      }]);
      return Duration2;
    }();
    var INVALID$1 = "Invalid Interval";
    function validateStartEnd(start, end) {
      if (!start || !start.isValid) {
        return Interval.invalid("missing or invalid start");
      } else if (!end || !end.isValid) {
        return Interval.invalid("missing or invalid end");
      } else if (end < start) {
        return Interval.invalid("end before start", "The end of an interval must be after its start, but you had start=" + start.toISO() + " and end=" + end.toISO());
      } else {
        return null;
      }
    }
    var Interval = /* @__PURE__ */ function() {
      function Interval2(config) {
        this.s = config.start;
        this.e = config.end;
        this.invalid = config.invalid || null;
        this.isLuxonInterval = true;
      }
      Interval2.invalid = function invalid(reason, explanation) {
        if (explanation === void 0) {
          explanation = null;
        }
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
        }
        var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidIntervalError(invalid2);
        } else {
          return new Interval2({
            invalid: invalid2
          });
        }
      };
      Interval2.fromDateTimes = function fromDateTimes(start, end) {
        var builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
        var validateError = validateStartEnd(builtStart, builtEnd);
        if (validateError == null) {
          return new Interval2({
            start: builtStart,
            end: builtEnd
          });
        } else {
          return validateError;
        }
      };
      Interval2.after = function after(start, duration) {
        var dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
        return Interval2.fromDateTimes(dt, dt.plus(dur));
      };
      Interval2.before = function before(end, duration) {
        var dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
        return Interval2.fromDateTimes(dt.minus(dur), dt);
      };
      Interval2.fromISO = function fromISO(text2, opts) {
        var _split = (text2 || "").split("/", 2), s2 = _split[0], e = _split[1];
        if (s2 && e) {
          var start, startIsValid;
          try {
            start = DateTime3.fromISO(s2, opts);
            startIsValid = start.isValid;
          } catch (e2) {
            startIsValid = false;
          }
          var end, endIsValid;
          try {
            end = DateTime3.fromISO(e, opts);
            endIsValid = end.isValid;
          } catch (e2) {
            endIsValid = false;
          }
          if (startIsValid && endIsValid) {
            return Interval2.fromDateTimes(start, end);
          }
          if (startIsValid) {
            var dur = Duration.fromISO(e, opts);
            if (dur.isValid) {
              return Interval2.after(start, dur);
            }
          } else if (endIsValid) {
            var _dur = Duration.fromISO(s2, opts);
            if (_dur.isValid) {
              return Interval2.before(end, _dur);
            }
          }
        }
        return Interval2.invalid("unparsable", 'the input "' + text2 + `" can't be parsed as ISO 8601`);
      };
      Interval2.isInterval = function isInterval(o) {
        return o && o.isLuxonInterval || false;
      };
      var _proto = Interval2.prototype;
      _proto.length = function length(unit) {
        if (unit === void 0) {
          unit = "milliseconds";
        }
        return this.isValid ? this.toDuration.apply(this, [unit]).get(unit) : NaN;
      };
      _proto.count = function count(unit) {
        if (unit === void 0) {
          unit = "milliseconds";
        }
        if (!this.isValid)
          return NaN;
        var start = this.start.startOf(unit), end = this.end.startOf(unit);
        return Math.floor(end.diff(start, unit).get(unit)) + 1;
      };
      _proto.hasSame = function hasSame(unit) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
      };
      _proto.isEmpty = function isEmpty() {
        return this.s.valueOf() === this.e.valueOf();
      };
      _proto.isAfter = function isAfter(dateTime) {
        if (!this.isValid)
          return false;
        return this.s > dateTime;
      };
      _proto.isBefore = function isBefore(dateTime) {
        if (!this.isValid)
          return false;
        return this.e <= dateTime;
      };
      _proto.contains = function contains(dateTime) {
        if (!this.isValid)
          return false;
        return this.s <= dateTime && this.e > dateTime;
      };
      _proto.set = function set2(_temp) {
        var _ref = _temp === void 0 ? {} : _temp, start = _ref.start, end = _ref.end;
        if (!this.isValid)
          return this;
        return Interval2.fromDateTimes(start || this.s, end || this.e);
      };
      _proto.splitAt = function splitAt() {
        var _this = this;
        if (!this.isValid)
          return [];
        for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
          dateTimes[_key] = arguments[_key];
        }
        var sorted = dateTimes.map(friendlyDateTime).filter(function(d) {
          return _this.contains(d);
        }).sort(), results = [];
        var s2 = this.s, i = 0;
        while (s2 < this.e) {
          var added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
          results.push(Interval2.fromDateTimes(s2, next));
          s2 = next;
          i += 1;
        }
        return results;
      };
      _proto.splitBy = function splitBy(duration) {
        var dur = Duration.fromDurationLike(duration);
        if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
          return [];
        }
        var s2 = this.s, idx = 1, next;
        var results = [];
        while (s2 < this.e) {
          var added = this.start.plus(dur.mapUnits(function(x) {
            return x * idx;
          }));
          next = +added > +this.e ? this.e : added;
          results.push(Interval2.fromDateTimes(s2, next));
          s2 = next;
          idx += 1;
        }
        return results;
      };
      _proto.divideEqually = function divideEqually(numberOfParts) {
        if (!this.isValid)
          return [];
        return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
      };
      _proto.overlaps = function overlaps(other) {
        return this.e > other.s && this.s < other.e;
      };
      _proto.abutsStart = function abutsStart(other) {
        if (!this.isValid)
          return false;
        return +this.e === +other.s;
      };
      _proto.abutsEnd = function abutsEnd(other) {
        if (!this.isValid)
          return false;
        return +other.e === +this.s;
      };
      _proto.engulfs = function engulfs(other) {
        if (!this.isValid)
          return false;
        return this.s <= other.s && this.e >= other.e;
      };
      _proto.equals = function equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        return this.s.equals(other.s) && this.e.equals(other.e);
      };
      _proto.intersection = function intersection(other) {
        if (!this.isValid)
          return this;
        var s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
        if (s2 >= e) {
          return null;
        } else {
          return Interval2.fromDateTimes(s2, e);
        }
      };
      _proto.union = function union(other) {
        if (!this.isValid)
          return this;
        var s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
        return Interval2.fromDateTimes(s2, e);
      };
      Interval2.merge = function merge2(intervals) {
        var _intervals$sort$reduc = intervals.sort(function(a, b) {
          return a.s - b.s;
        }).reduce(function(_ref2, item) {
          var sofar = _ref2[0], current = _ref2[1];
          if (!current) {
            return [sofar, item];
          } else if (current.overlaps(item) || current.abutsStart(item)) {
            return [sofar, current.union(item)];
          } else {
            return [sofar.concat([current]), item];
          }
        }, [[], null]), found = _intervals$sort$reduc[0], final = _intervals$sort$reduc[1];
        if (final) {
          found.push(final);
        }
        return found;
      };
      Interval2.xor = function xor(intervals) {
        var _Array$prototype;
        var start = null, currentCount = 0;
        var results = [], ends = intervals.map(function(i2) {
          return [{
            time: i2.s,
            type: "s"
          }, {
            time: i2.e,
            type: "e"
          }];
        }), flattened = (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, ends), arr = flattened.sort(function(a, b) {
          return a.time - b.time;
        });
        for (var _iterator = _createForOfIteratorHelperLoose(arr), _step; !(_step = _iterator()).done; ) {
          var i = _step.value;
          currentCount += i.type === "s" ? 1 : -1;
          if (currentCount === 1) {
            start = i.time;
          } else {
            if (start && +start !== +i.time) {
              results.push(Interval2.fromDateTimes(start, i.time));
            }
            start = null;
          }
        }
        return Interval2.merge(results);
      };
      _proto.difference = function difference() {
        var _this2 = this;
        for (var _len2 = arguments.length, intervals = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          intervals[_key2] = arguments[_key2];
        }
        return Interval2.xor([this].concat(intervals)).map(function(i) {
          return _this2.intersection(i);
        }).filter(function(i) {
          return i && !i.isEmpty();
        });
      };
      _proto.toString = function toString() {
        if (!this.isValid)
          return INVALID$1;
        return "[" + this.s.toISO() + " \u2013 " + this.e.toISO() + ")";
      };
      _proto.toISO = function toISO(opts) {
        if (!this.isValid)
          return INVALID$1;
        return this.s.toISO(opts) + "/" + this.e.toISO(opts);
      };
      _proto.toISODate = function toISODate() {
        if (!this.isValid)
          return INVALID$1;
        return this.s.toISODate() + "/" + this.e.toISODate();
      };
      _proto.toISOTime = function toISOTime(opts) {
        if (!this.isValid)
          return INVALID$1;
        return this.s.toISOTime(opts) + "/" + this.e.toISOTime(opts);
      };
      _proto.toFormat = function toFormat(dateFormat, _temp2) {
        var _ref3 = _temp2 === void 0 ? {} : _temp2, _ref3$separator = _ref3.separator, separator = _ref3$separator === void 0 ? " \u2013 " : _ref3$separator;
        if (!this.isValid)
          return INVALID$1;
        return "" + this.s.toFormat(dateFormat) + separator + this.e.toFormat(dateFormat);
      };
      _proto.toDuration = function toDuration(unit, opts) {
        if (!this.isValid) {
          return Duration.invalid(this.invalidReason);
        }
        return this.e.diff(this.s, unit, opts);
      };
      _proto.mapEndpoints = function mapEndpoints(mapFn) {
        return Interval2.fromDateTimes(mapFn(this.s), mapFn(this.e));
      };
      _createClass(Interval2, [{
        key: "start",
        get: function get() {
          return this.isValid ? this.s : null;
        }
      }, {
        key: "end",
        get: function get() {
          return this.isValid ? this.e : null;
        }
      }, {
        key: "isValid",
        get: function get() {
          return this.invalidReason === null;
        }
      }, {
        key: "invalidReason",
        get: function get() {
          return this.invalid ? this.invalid.reason : null;
        }
      }, {
        key: "invalidExplanation",
        get: function get() {
          return this.invalid ? this.invalid.explanation : null;
        }
      }]);
      return Interval2;
    }();
    var Info = /* @__PURE__ */ function() {
      function Info2() {
      }
      Info2.hasDST = function hasDST(zone) {
        if (zone === void 0) {
          zone = Settings.defaultZone;
        }
        var proto = DateTime3.now().setZone(zone).set({
          month: 12
        });
        return !zone.isUniversal && proto.offset !== proto.set({
          month: 6
        }).offset;
      };
      Info2.isValidIANAZone = function isValidIANAZone(zone) {
        return IANAZone.isValidSpecifier(zone) && IANAZone.isValidZone(zone);
      };
      Info2.normalizeZone = function normalizeZone$1(input) {
        return normalizeZone(input, Settings.defaultZone);
      };
      Info2.months = function months2(length, _temp) {
        if (length === void 0) {
          length = "long";
        }
        var _ref = _temp === void 0 ? {} : _temp, _ref$locale = _ref.locale, locale = _ref$locale === void 0 ? null : _ref$locale, _ref$numberingSystem = _ref.numberingSystem, numberingSystem = _ref$numberingSystem === void 0 ? null : _ref$numberingSystem, _ref$locObj = _ref.locObj, locObj = _ref$locObj === void 0 ? null : _ref$locObj, _ref$outputCalendar = _ref.outputCalendar, outputCalendar = _ref$outputCalendar === void 0 ? "gregory" : _ref$outputCalendar;
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
      };
      Info2.monthsFormat = function monthsFormat(length, _temp2) {
        if (length === void 0) {
          length = "long";
        }
        var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$locale = _ref2.locale, locale = _ref2$locale === void 0 ? null : _ref2$locale, _ref2$numberingSystem = _ref2.numberingSystem, numberingSystem = _ref2$numberingSystem === void 0 ? null : _ref2$numberingSystem, _ref2$locObj = _ref2.locObj, locObj = _ref2$locObj === void 0 ? null : _ref2$locObj, _ref2$outputCalendar = _ref2.outputCalendar, outputCalendar = _ref2$outputCalendar === void 0 ? "gregory" : _ref2$outputCalendar;
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
      };
      Info2.weekdays = function weekdays2(length, _temp3) {
        if (length === void 0) {
          length = "long";
        }
        var _ref3 = _temp3 === void 0 ? {} : _temp3, _ref3$locale = _ref3.locale, locale = _ref3$locale === void 0 ? null : _ref3$locale, _ref3$numberingSystem = _ref3.numberingSystem, numberingSystem = _ref3$numberingSystem === void 0 ? null : _ref3$numberingSystem, _ref3$locObj = _ref3.locObj, locObj = _ref3$locObj === void 0 ? null : _ref3$locObj;
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
      };
      Info2.weekdaysFormat = function weekdaysFormat(length, _temp4) {
        if (length === void 0) {
          length = "long";
        }
        var _ref4 = _temp4 === void 0 ? {} : _temp4, _ref4$locale = _ref4.locale, locale = _ref4$locale === void 0 ? null : _ref4$locale, _ref4$numberingSystem = _ref4.numberingSystem, numberingSystem = _ref4$numberingSystem === void 0 ? null : _ref4$numberingSystem, _ref4$locObj = _ref4.locObj, locObj = _ref4$locObj === void 0 ? null : _ref4$locObj;
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
      };
      Info2.meridiems = function meridiems2(_temp5) {
        var _ref5 = _temp5 === void 0 ? {} : _temp5, _ref5$locale = _ref5.locale, locale = _ref5$locale === void 0 ? null : _ref5$locale;
        return Locale.create(locale).meridiems();
      };
      Info2.eras = function eras2(length, _temp6) {
        if (length === void 0) {
          length = "short";
        }
        var _ref6 = _temp6 === void 0 ? {} : _temp6, _ref6$locale = _ref6.locale, locale = _ref6$locale === void 0 ? null : _ref6$locale;
        return Locale.create(locale, null, "gregory").eras(length);
      };
      Info2.features = function features() {
        return {
          relative: hasRelative()
        };
      };
      return Info2;
    }();
    function dayDiff(earlier, later) {
      var utcDayStart = function utcDayStart2(dt) {
        return dt.toUTC(0, {
          keepLocalTime: true
        }).startOf("day").valueOf();
      }, ms = utcDayStart(later) - utcDayStart(earlier);
      return Math.floor(Duration.fromMillis(ms).as("days"));
    }
    function highOrderDiffs(cursor, later, units) {
      var differs = [["years", function(a, b) {
        return b.year - a.year;
      }], ["quarters", function(a, b) {
        return b.quarter - a.quarter;
      }], ["months", function(a, b) {
        return b.month - a.month + (b.year - a.year) * 12;
      }], ["weeks", function(a, b) {
        var days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }], ["days", dayDiff]];
      var results = {};
      var lowestOrder, highWater;
      for (var _i = 0, _differs = differs; _i < _differs.length; _i++) {
        var _differs$_i = _differs[_i], unit = _differs$_i[0], differ = _differs$_i[1];
        if (units.indexOf(unit) >= 0) {
          var _cursor$plus;
          lowestOrder = unit;
          var delta = differ(cursor, later);
          highWater = cursor.plus((_cursor$plus = {}, _cursor$plus[unit] = delta, _cursor$plus));
          if (highWater > later) {
            var _cursor$plus2;
            cursor = cursor.plus((_cursor$plus2 = {}, _cursor$plus2[unit] = delta - 1, _cursor$plus2));
            delta -= 1;
          } else {
            cursor = highWater;
          }
          results[unit] = delta;
        }
      }
      return [cursor, results, highWater, lowestOrder];
    }
    function _diff(earlier, later, units, opts) {
      var _highOrderDiffs = highOrderDiffs(earlier, later, units), cursor = _highOrderDiffs[0], results = _highOrderDiffs[1], highWater = _highOrderDiffs[2], lowestOrder = _highOrderDiffs[3];
      var remainingMillis = later - cursor;
      var lowerOrderUnits = units.filter(function(u) {
        return ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0;
      });
      if (lowerOrderUnits.length === 0) {
        if (highWater < later) {
          var _cursor$plus3;
          highWater = cursor.plus((_cursor$plus3 = {}, _cursor$plus3[lowestOrder] = 1, _cursor$plus3));
        }
        if (highWater !== cursor) {
          results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
        }
      }
      var duration = Duration.fromObject(results, opts);
      if (lowerOrderUnits.length > 0) {
        var _Duration$fromMillis;
        return (_Duration$fromMillis = Duration.fromMillis(remainingMillis, opts)).shiftTo.apply(_Duration$fromMillis, lowerOrderUnits).plus(duration);
      } else {
        return duration;
      }
    }
    var numberingSystems = {
      arab: "[\u0660-\u0669]",
      arabext: "[\u06F0-\u06F9]",
      bali: "[\u1B50-\u1B59]",
      beng: "[\u09E6-\u09EF]",
      deva: "[\u0966-\u096F]",
      fullwide: "[\uFF10-\uFF19]",
      gujr: "[\u0AE6-\u0AEF]",
      hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
      khmr: "[\u17E0-\u17E9]",
      knda: "[\u0CE6-\u0CEF]",
      laoo: "[\u0ED0-\u0ED9]",
      limb: "[\u1946-\u194F]",
      mlym: "[\u0D66-\u0D6F]",
      mong: "[\u1810-\u1819]",
      mymr: "[\u1040-\u1049]",
      orya: "[\u0B66-\u0B6F]",
      tamldec: "[\u0BE6-\u0BEF]",
      telu: "[\u0C66-\u0C6F]",
      thai: "[\u0E50-\u0E59]",
      tibt: "[\u0F20-\u0F29]",
      latn: "\\d"
    };
    var numberingSystemsUTF16 = {
      arab: [1632, 1641],
      arabext: [1776, 1785],
      bali: [6992, 7001],
      beng: [2534, 2543],
      deva: [2406, 2415],
      fullwide: [65296, 65303],
      gujr: [2790, 2799],
      khmr: [6112, 6121],
      knda: [3302, 3311],
      laoo: [3792, 3801],
      limb: [6470, 6479],
      mlym: [3430, 3439],
      mong: [6160, 6169],
      mymr: [4160, 4169],
      orya: [2918, 2927],
      tamldec: [3046, 3055],
      telu: [3174, 3183],
      thai: [3664, 3673],
      tibt: [3872, 3881]
    };
    var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
    function parseDigits(str) {
      var value = parseInt(str, 10);
      if (isNaN(value)) {
        value = "";
        for (var i = 0; i < str.length; i++) {
          var code = str.charCodeAt(i);
          if (str[i].search(numberingSystems.hanidec) !== -1) {
            value += hanidecChars.indexOf(str[i]);
          } else {
            for (var key in numberingSystemsUTF16) {
              var _numberingSystemsUTF = numberingSystemsUTF16[key], min = _numberingSystemsUTF[0], max = _numberingSystemsUTF[1];
              if (code >= min && code <= max) {
                value += code - min;
              }
            }
          }
        }
        return parseInt(value, 10);
      } else {
        return value;
      }
    }
    function digitRegex(_ref, append2) {
      var numberingSystem = _ref.numberingSystem;
      if (append2 === void 0) {
        append2 = "";
      }
      return new RegExp("" + numberingSystems[numberingSystem || "latn"] + append2);
    }
    var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
    function intUnit(regex, post) {
      if (post === void 0) {
        post = function post2(i) {
          return i;
        };
      }
      return {
        regex,
        deser: function deser(_ref) {
          var s2 = _ref[0];
          return post(parseDigits(s2));
        }
      };
    }
    var NBSP = String.fromCharCode(160);
    var spaceOrNBSP = "( |" + NBSP + ")";
    var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
    function fixListRegex(s2) {
      return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
    }
    function stripInsensitivities(s2) {
      return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
    }
    function oneOf(strings, startIndex) {
      if (strings === null) {
        return null;
      } else {
        return {
          regex: RegExp(strings.map(fixListRegex).join("|")),
          deser: function deser(_ref2) {
            var s2 = _ref2[0];
            return strings.findIndex(function(i) {
              return stripInsensitivities(s2) === stripInsensitivities(i);
            }) + startIndex;
          }
        };
      }
    }
    function offset(regex, groups) {
      return {
        regex,
        deser: function deser(_ref3) {
          var h = _ref3[1], m = _ref3[2];
          return signedOffset(h, m);
        },
        groups
      };
    }
    function simple(regex) {
      return {
        regex,
        deser: function deser(_ref4) {
          var s2 = _ref4[0];
          return s2;
        }
      };
    }
    function escapeToken(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function unitForToken(token, loc) {
      var one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = function literal2(t) {
        return {
          regex: RegExp(escapeToken(t.val)),
          deser: function deser(_ref5) {
            var s2 = _ref5[0];
            return s2;
          },
          literal: true
        };
      }, unitate = function unitate2(t) {
        if (token.literal) {
          return literal(t);
        }
        switch (t.val) {
          case "G":
            return oneOf(loc.eras("short", false), 0);
          case "GG":
            return oneOf(loc.eras("long", false), 0);
          case "y":
            return intUnit(oneToSix);
          case "yy":
            return intUnit(twoToFour, untruncateYear);
          case "yyyy":
            return intUnit(four);
          case "yyyyy":
            return intUnit(fourToSix);
          case "yyyyyy":
            return intUnit(six);
          case "M":
            return intUnit(oneOrTwo);
          case "MM":
            return intUnit(two);
          case "MMM":
            return oneOf(loc.months("short", true, false), 1);
          case "MMMM":
            return oneOf(loc.months("long", true, false), 1);
          case "L":
            return intUnit(oneOrTwo);
          case "LL":
            return intUnit(two);
          case "LLL":
            return oneOf(loc.months("short", false, false), 1);
          case "LLLL":
            return oneOf(loc.months("long", false, false), 1);
          case "d":
            return intUnit(oneOrTwo);
          case "dd":
            return intUnit(two);
          case "o":
            return intUnit(oneToThree);
          case "ooo":
            return intUnit(three);
          case "HH":
            return intUnit(two);
          case "H":
            return intUnit(oneOrTwo);
          case "hh":
            return intUnit(two);
          case "h":
            return intUnit(oneOrTwo);
          case "mm":
            return intUnit(two);
          case "m":
            return intUnit(oneOrTwo);
          case "q":
            return intUnit(oneOrTwo);
          case "qq":
            return intUnit(two);
          case "s":
            return intUnit(oneOrTwo);
          case "ss":
            return intUnit(two);
          case "S":
            return intUnit(oneToThree);
          case "SSS":
            return intUnit(three);
          case "u":
            return simple(oneToNine);
          case "uu":
            return simple(oneOrTwo);
          case "uuu":
            return intUnit(one);
          case "a":
            return oneOf(loc.meridiems(), 0);
          case "kkkk":
            return intUnit(four);
          case "kk":
            return intUnit(twoToFour, untruncateYear);
          case "W":
            return intUnit(oneOrTwo);
          case "WW":
            return intUnit(two);
          case "E":
          case "c":
            return intUnit(one);
          case "EEE":
            return oneOf(loc.weekdays("short", false, false), 1);
          case "EEEE":
            return oneOf(loc.weekdays("long", false, false), 1);
          case "ccc":
            return oneOf(loc.weekdays("short", true, false), 1);
          case "cccc":
            return oneOf(loc.weekdays("long", true, false), 1);
          case "Z":
          case "ZZ":
            return offset(new RegExp("([+-]" + oneOrTwo.source + ")(?::(" + two.source + "))?"), 2);
          case "ZZZ":
            return offset(new RegExp("([+-]" + oneOrTwo.source + ")(" + two.source + ")?"), 2);
          case "z":
            return simple(/[a-z_+-/]{1,256}?/i);
          default:
            return literal(t);
        }
      };
      var unit = unitate(token) || {
        invalidReason: MISSING_FTP
      };
      unit.token = token;
      return unit;
    }
    var partTypeStyleToTokenVal = {
      year: {
        "2-digit": "yy",
        numeric: "yyyyy"
      },
      month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
      },
      day: {
        numeric: "d",
        "2-digit": "dd"
      },
      weekday: {
        short: "EEE",
        long: "EEEE"
      },
      dayperiod: "a",
      dayPeriod: "a",
      hour: {
        numeric: "h",
        "2-digit": "hh"
      },
      minute: {
        numeric: "m",
        "2-digit": "mm"
      },
      second: {
        numeric: "s",
        "2-digit": "ss"
      }
    };
    function tokenForPart(part, locale, formatOpts) {
      var type = part.type, value = part.value;
      if (type === "literal") {
        return {
          literal: true,
          val: value
        };
      }
      var style = formatOpts[type];
      var val = partTypeStyleToTokenVal[type];
      if (typeof val === "object") {
        val = val[style];
      }
      if (val) {
        return {
          literal: false,
          val
        };
      }
      return void 0;
    }
    function buildRegex(units) {
      var re = units.map(function(u) {
        return u.regex;
      }).reduce(function(f, r) {
        return f + "(" + r.source + ")";
      }, "");
      return ["^" + re + "$", units];
    }
    function match(input, regex, handlers) {
      var matches = input.match(regex);
      if (matches) {
        var all = {};
        var matchIndex = 1;
        for (var i in handlers) {
          if (hasOwnProperty(handlers, i)) {
            var h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
            if (!h.literal && h.token) {
              all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
            }
            matchIndex += groups;
          }
        }
        return [matches, all];
      } else {
        return [matches, {}];
      }
    }
    function dateTimeFromMatches(matches) {
      var toField = function toField2(token) {
        switch (token) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
          case "H":
            return "hour";
          case "d":
            return "day";
          case "o":
            return "ordinal";
          case "L":
          case "M":
            return "month";
          case "y":
            return "year";
          case "E":
          case "c":
            return "weekday";
          case "W":
            return "weekNumber";
          case "k":
            return "weekYear";
          case "q":
            return "quarter";
          default:
            return null;
        }
      };
      var zone = null;
      var specificOffset;
      if (!isUndefined(matches.z)) {
        zone = IANAZone.create(matches.z);
      }
      if (!isUndefined(matches.Z)) {
        if (!zone) {
          zone = new FixedOffsetZone(matches.Z);
        }
        specificOffset = matches.Z;
      }
      if (!isUndefined(matches.q)) {
        matches.M = (matches.q - 1) * 3 + 1;
      }
      if (!isUndefined(matches.h)) {
        if (matches.h < 12 && matches.a === 1) {
          matches.h += 12;
        } else if (matches.h === 12 && matches.a === 0) {
          matches.h = 0;
        }
      }
      if (matches.G === 0 && matches.y) {
        matches.y = -matches.y;
      }
      if (!isUndefined(matches.u)) {
        matches.S = parseMillis(matches.u);
      }
      var vals = Object.keys(matches).reduce(function(r, k) {
        var f = toField(k);
        if (f) {
          r[f] = matches[k];
        }
        return r;
      }, {});
      return [vals, zone, specificOffset];
    }
    var dummyDateTimeCache = null;
    function getDummyDateTime() {
      if (!dummyDateTimeCache) {
        dummyDateTimeCache = DateTime3.fromMillis(1555555555555);
      }
      return dummyDateTimeCache;
    }
    function maybeExpandMacroToken(token, locale) {
      if (token.literal) {
        return token;
      }
      var formatOpts = Formatter.macroTokenToFormatOpts(token.val);
      if (!formatOpts) {
        return token;
      }
      var formatter = Formatter.create(locale, formatOpts);
      var parts = formatter.formatDateTimeParts(getDummyDateTime());
      var tokens = parts.map(function(p) {
        return tokenForPart(p, locale, formatOpts);
      });
      if (tokens.includes(void 0)) {
        return token;
      }
      return tokens;
    }
    function expandMacroTokens(tokens, locale) {
      var _Array$prototype;
      return (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, tokens.map(function(t) {
        return maybeExpandMacroToken(t, locale);
      }));
    }
    function explainFromTokens(locale, input, format) {
      var tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map(function(t) {
        return unitForToken(t, locale);
      }), disqualifyingUnit = units.find(function(t) {
        return t.invalidReason;
      });
      if (disqualifyingUnit) {
        return {
          input,
          tokens,
          invalidReason: disqualifyingUnit.invalidReason
        };
      } else {
        var _buildRegex = buildRegex(units), regexString = _buildRegex[0], handlers = _buildRegex[1], regex = RegExp(regexString, "i"), _match = match(input, regex, handlers), rawMatches = _match[0], matches = _match[1], _ref6 = matches ? dateTimeFromMatches(matches) : [null, null, void 0], result = _ref6[0], zone = _ref6[1], specificOffset = _ref6[2];
        if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
          throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
        }
        return {
          input,
          tokens,
          regex,
          rawMatches,
          matches,
          result,
          zone,
          specificOffset
        };
      }
    }
    function parseFromTokens(locale, input, format) {
      var _explainFromTokens = explainFromTokens(locale, input, format), result = _explainFromTokens.result, zone = _explainFromTokens.zone, specificOffset = _explainFromTokens.specificOffset, invalidReason = _explainFromTokens.invalidReason;
      return [result, zone, specificOffset, invalidReason];
    }
    var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    function unitOutOfRange(unit, value) {
      return new Invalid("unit out of range", "you specified " + value + " (of type " + typeof value + ") as a " + unit + ", which is invalid");
    }
    function dayOfWeek(year, month, day) {
      var js = new Date(Date.UTC(year, month - 1, day)).getUTCDay();
      return js === 0 ? 7 : js;
    }
    function computeOrdinal(year, month, day) {
      return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
    }
    function uncomputeOrdinal(year, ordinal) {
      var table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex(function(i) {
        return i < ordinal;
      }), day = ordinal - table[month0];
      return {
        month: month0 + 1,
        day
      };
    }
    function gregorianToWeek(gregObj) {
      var year = gregObj.year, month = gregObj.month, day = gregObj.day, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
      var weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
      if (weekNumber < 1) {
        weekYear = year - 1;
        weekNumber = weeksInWeekYear(weekYear);
      } else if (weekNumber > weeksInWeekYear(year)) {
        weekYear = year + 1;
        weekNumber = 1;
      } else {
        weekYear = year;
      }
      return _extends({
        weekYear,
        weekNumber,
        weekday
      }, timeObject(gregObj));
    }
    function weekToGregorian(weekData) {
      var weekYear = weekData.weekYear, weekNumber = weekData.weekNumber, weekday = weekData.weekday, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
      var ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
      if (ordinal < 1) {
        year = weekYear - 1;
        ordinal += daysInYear(year);
      } else if (ordinal > yearInDays) {
        year = weekYear + 1;
        ordinal -= daysInYear(weekYear);
      } else {
        year = weekYear;
      }
      var _uncomputeOrdinal = uncomputeOrdinal(year, ordinal), month = _uncomputeOrdinal.month, day = _uncomputeOrdinal.day;
      return _extends({
        year,
        month,
        day
      }, timeObject(weekData));
    }
    function gregorianToOrdinal(gregData) {
      var year = gregData.year, month = gregData.month, day = gregData.day;
      var ordinal = computeOrdinal(year, month, day);
      return _extends({
        year,
        ordinal
      }, timeObject(gregData));
    }
    function ordinalToGregorian(ordinalData) {
      var year = ordinalData.year, ordinal = ordinalData.ordinal;
      var _uncomputeOrdinal2 = uncomputeOrdinal(year, ordinal), month = _uncomputeOrdinal2.month, day = _uncomputeOrdinal2.day;
      return _extends({
        year,
        month,
        day
      }, timeObject(ordinalData));
    }
    function hasInvalidWeekData(obj) {
      var validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
      if (!validYear) {
        return unitOutOfRange("weekYear", obj.weekYear);
      } else if (!validWeek) {
        return unitOutOfRange("week", obj.week);
      } else if (!validWeekday) {
        return unitOutOfRange("weekday", obj.weekday);
      } else
        return false;
    }
    function hasInvalidOrdinalData(obj) {
      var validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validOrdinal) {
        return unitOutOfRange("ordinal", obj.ordinal);
      } else
        return false;
    }
    function hasInvalidGregorianData(obj) {
      var validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validMonth) {
        return unitOutOfRange("month", obj.month);
      } else if (!validDay) {
        return unitOutOfRange("day", obj.day);
      } else
        return false;
    }
    function hasInvalidTimeData(obj) {
      var hour = obj.hour, minute = obj.minute, second = obj.second, millisecond = obj.millisecond;
      var validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
      if (!validHour) {
        return unitOutOfRange("hour", hour);
      } else if (!validMinute) {
        return unitOutOfRange("minute", minute);
      } else if (!validSecond) {
        return unitOutOfRange("second", second);
      } else if (!validMillisecond) {
        return unitOutOfRange("millisecond", millisecond);
      } else
        return false;
    }
    var INVALID = "Invalid DateTime";
    var MAX_DATE = 864e13;
    function unsupportedZone(zone) {
      return new Invalid("unsupported zone", 'the zone "' + zone.name + '" is not supported');
    }
    function possiblyCachedWeekData(dt) {
      if (dt.weekData === null) {
        dt.weekData = gregorianToWeek(dt.c);
      }
      return dt.weekData;
    }
    function clone2(inst, alts) {
      var current = {
        ts: inst.ts,
        zone: inst.zone,
        c: inst.c,
        o: inst.o,
        loc: inst.loc,
        invalid: inst.invalid
      };
      return new DateTime3(_extends({}, current, alts, {
        old: current
      }));
    }
    function fixOffset(localTS, o, tz) {
      var utcGuess = localTS - o * 60 * 1e3;
      var o2 = tz.offset(utcGuess);
      if (o === o2) {
        return [utcGuess, o];
      }
      utcGuess -= (o2 - o) * 60 * 1e3;
      var o3 = tz.offset(utcGuess);
      if (o2 === o3) {
        return [utcGuess, o2];
      }
      return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
    }
    function tsToObj(ts, offset2) {
      ts += offset2 * 60 * 1e3;
      var d = new Date(ts);
      return {
        year: d.getUTCFullYear(),
        month: d.getUTCMonth() + 1,
        day: d.getUTCDate(),
        hour: d.getUTCHours(),
        minute: d.getUTCMinutes(),
        second: d.getUTCSeconds(),
        millisecond: d.getUTCMilliseconds()
      };
    }
    function objToTS(obj, offset2, zone) {
      return fixOffset(objToLocalTS(obj), offset2, zone);
    }
    function adjustTime(inst, dur) {
      var oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = _extends({}, inst.c, {
        year,
        month,
        day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
      }), millisToAdd = Duration.fromObject({
        years: dur.years - Math.trunc(dur.years),
        quarters: dur.quarters - Math.trunc(dur.quarters),
        months: dur.months - Math.trunc(dur.months),
        weeks: dur.weeks - Math.trunc(dur.weeks),
        days: dur.days - Math.trunc(dur.days),
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds
      }).as("milliseconds"), localTS = objToLocalTS(c);
      var _fixOffset = fixOffset(localTS, oPre, inst.zone), ts = _fixOffset[0], o = _fixOffset[1];
      if (millisToAdd !== 0) {
        ts += millisToAdd;
        o = inst.zone.offset(ts);
      }
      return {
        ts,
        o
      };
    }
    function parseDataToDateTime(parsed, parsedZone, opts, format, text2, specificOffset) {
      var setZone = opts.setZone, zone = opts.zone;
      if (parsed && Object.keys(parsed).length !== 0) {
        var interpretationZone = parsedZone || zone, inst = DateTime3.fromObject(parsed, _extends({}, opts, {
          zone: interpretationZone,
          specificOffset
        }));
        return setZone ? inst : inst.setZone(zone);
      } else {
        return DateTime3.invalid(new Invalid("unparsable", 'the input "' + text2 + `" can't be parsed as ` + format));
      }
    }
    function toTechFormat(dt, format, allowZ) {
      if (allowZ === void 0) {
        allowZ = true;
      }
      return dt.isValid ? Formatter.create(Locale.create("en-US"), {
        allowZ,
        forceSimple: true
      }).formatDateTimeFromString(dt, format) : null;
    }
    function _toISODate(o, extended) {
      var longFormat = o.c.year > 9999 || o.c.year < 0;
      var c = "";
      if (longFormat && o.c.year >= 0)
        c += "+";
      c += padStart(o.c.year, longFormat ? 6 : 4);
      if (extended) {
        c += "-";
        c += padStart(o.c.month);
        c += "-";
        c += padStart(o.c.day);
      } else {
        c += padStart(o.c.month);
        c += padStart(o.c.day);
      }
      return c;
    }
    function _toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset) {
      var c = padStart(o.c.hour);
      if (extended) {
        c += ":";
        c += padStart(o.c.minute);
        if (o.c.second !== 0 || !suppressSeconds) {
          c += ":";
        }
      } else {
        c += padStart(o.c.minute);
      }
      if (o.c.second !== 0 || !suppressSeconds) {
        c += padStart(o.c.second);
        if (o.c.millisecond !== 0 || !suppressMilliseconds) {
          c += ".";
          c += padStart(o.c.millisecond, 3);
        }
      }
      if (includeOffset) {
        if (o.isOffsetFixed && o.offset === 0) {
          c += "Z";
        } else if (o.o < 0) {
          c += "-";
          c += padStart(Math.trunc(-o.o / 60));
          c += ":";
          c += padStart(Math.trunc(-o.o % 60));
        } else {
          c += "+";
          c += padStart(Math.trunc(o.o / 60));
          c += ":";
          c += padStart(Math.trunc(o.o % 60));
        }
      }
      return c;
    }
    var defaultUnitValues = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultWeekUnitValues = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultOrdinalUnitValues = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
    var orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"];
    var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
    function normalizeUnit(unit) {
      var normalized = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
      }[unit.toLowerCase()];
      if (!normalized)
        throw new InvalidUnitError(unit);
      return normalized;
    }
    function quickDT(obj, opts) {
      var zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
      var ts, o;
      if (!isUndefined(obj.year)) {
        for (var _iterator = _createForOfIteratorHelperLoose(orderedUnits), _step; !(_step = _iterator()).done; ) {
          var u = _step.value;
          if (isUndefined(obj[u])) {
            obj[u] = defaultUnitValues[u];
          }
        }
        var invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
        if (invalid) {
          return DateTime3.invalid(invalid);
        }
        var offsetProvis = zone.offset(tsNow);
        var _objToTS = objToTS(obj, offsetProvis, zone);
        ts = _objToTS[0];
        o = _objToTS[1];
      } else {
        ts = tsNow;
      }
      return new DateTime3({
        ts,
        zone,
        loc,
        o
      });
    }
    function diffRelative(start, end, opts) {
      var round2 = isUndefined(opts.round) ? true : opts.round, format = function format2(c, unit2) {
        c = roundTo(c, round2 || opts.calendary ? 0 : 2, true);
        var formatter = end.loc.clone(opts).relFormatter(opts);
        return formatter.format(c, unit2);
      }, differ = function differ2(unit2) {
        if (opts.calendary) {
          if (!end.hasSame(start, unit2)) {
            return end.startOf(unit2).diff(start.startOf(unit2), unit2).get(unit2);
          } else
            return 0;
        } else {
          return end.diff(start, unit2).get(unit2);
        }
      };
      if (opts.unit) {
        return format(differ(opts.unit), opts.unit);
      }
      for (var _iterator2 = _createForOfIteratorHelperLoose(opts.units), _step2; !(_step2 = _iterator2()).done; ) {
        var unit = _step2.value;
        var count = differ(unit);
        if (Math.abs(count) >= 1) {
          return format(count, unit);
        }
      }
      return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
    }
    function lastOpts(argList) {
      var opts = {}, args;
      if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
        opts = argList[argList.length - 1];
        args = Array.from(argList).slice(0, argList.length - 1);
      } else {
        args = Array.from(argList);
      }
      return [opts, args];
    }
    var DateTime3 = /* @__PURE__ */ function() {
      function DateTime4(config) {
        var zone = config.zone || Settings.defaultZone;
        var invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
        this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
        var c = null, o = null;
        if (!invalid) {
          var unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
          if (unchanged) {
            var _ref = [config.old.c, config.old.o];
            c = _ref[0];
            o = _ref[1];
          } else {
            var ot = zone.offset(this.ts);
            c = tsToObj(this.ts, ot);
            invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
            c = invalid ? null : c;
            o = invalid ? null : ot;
          }
        }
        this._zone = zone;
        this.loc = config.loc || Locale.create();
        this.invalid = invalid;
        this.weekData = null;
        this.c = c;
        this.o = o;
        this.isLuxonDateTime = true;
      }
      DateTime4.now = function now2() {
        return new DateTime4({});
      };
      DateTime4.local = function local() {
        var _lastOpts = lastOpts(arguments), opts = _lastOpts[0], args = _lastOpts[1], year = args[0], month = args[1], day = args[2], hour = args[3], minute = args[4], second = args[5], millisecond = args[6];
        return quickDT({
          year,
          month,
          day,
          hour,
          minute,
          second,
          millisecond
        }, opts);
      };
      DateTime4.utc = function utc() {
        var _lastOpts2 = lastOpts(arguments), opts = _lastOpts2[0], args = _lastOpts2[1], year = args[0], month = args[1], day = args[2], hour = args[3], minute = args[4], second = args[5], millisecond = args[6];
        opts.zone = FixedOffsetZone.utcInstance;
        return quickDT({
          year,
          month,
          day,
          hour,
          minute,
          second,
          millisecond
        }, opts);
      };
      DateTime4.fromJSDate = function fromJSDate(date, options) {
        if (options === void 0) {
          options = {};
        }
        var ts = isDate(date) ? date.valueOf() : NaN;
        if (Number.isNaN(ts)) {
          return DateTime4.invalid("invalid input");
        }
        var zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime4.invalid(unsupportedZone(zoneToUse));
        }
        return new DateTime4({
          ts,
          zone: zoneToUse,
          loc: Locale.fromObject(options)
        });
      };
      DateTime4.fromMillis = function fromMillis(milliseconds, options) {
        if (options === void 0) {
          options = {};
        }
        if (!isNumber2(milliseconds)) {
          throw new InvalidArgumentError("fromMillis requires a numerical input, but received a " + typeof milliseconds + " with value " + milliseconds);
        } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
          return DateTime4.invalid("Timestamp out of range");
        } else {
          return new DateTime4({
            ts: milliseconds,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      };
      DateTime4.fromSeconds = function fromSeconds(seconds, options) {
        if (options === void 0) {
          options = {};
        }
        if (!isNumber2(seconds)) {
          throw new InvalidArgumentError("fromSeconds requires a numerical input");
        } else {
          return new DateTime4({
            ts: seconds * 1e3,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      };
      DateTime4.fromObject = function fromObject2(obj, opts) {
        if (opts === void 0) {
          opts = {};
        }
        obj = obj || {};
        var zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime4.invalid(unsupportedZone(zoneToUse));
        }
        var tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        var useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
        var units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
        if (useWeekData) {
          units = orderedWeekUnits;
          defaultValues = defaultWeekUnitValues;
          objNow = gregorianToWeek(objNow);
        } else if (containsOrdinal) {
          units = orderedOrdinalUnits;
          defaultValues = defaultOrdinalUnitValues;
          objNow = gregorianToOrdinal(objNow);
        } else {
          units = orderedUnits;
          defaultValues = defaultUnitValues;
        }
        var foundFirst = false;
        for (var _iterator3 = _createForOfIteratorHelperLoose(units), _step3; !(_step3 = _iterator3()).done; ) {
          var u = _step3.value;
          var v = normalized[u];
          if (!isUndefined(v)) {
            foundFirst = true;
          } else if (foundFirst) {
            normalized[u] = defaultValues[u];
          } else {
            normalized[u] = objNow[u];
          }
        }
        var higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
        if (invalid) {
          return DateTime4.invalid(invalid);
        }
        var gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, _objToTS2 = objToTS(gregorian, offsetProvis, zoneToUse), tsFinal = _objToTS2[0], offsetFinal = _objToTS2[1], inst = new DateTime4({
          ts: tsFinal,
          zone: zoneToUse,
          o: offsetFinal,
          loc
        });
        if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
          return DateTime4.invalid("mismatched weekday", "you can't specify both a weekday of " + normalized.weekday + " and a date of " + inst.toISO());
        }
        return inst;
      };
      DateTime4.fromISO = function fromISO(text2, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _parseISODate = parseISODate(text2), vals = _parseISODate[0], parsedZone = _parseISODate[1];
        return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text2);
      };
      DateTime4.fromRFC2822 = function fromRFC2822(text2, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _parseRFC2822Date = parseRFC2822Date(text2), vals = _parseRFC2822Date[0], parsedZone = _parseRFC2822Date[1];
        return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text2);
      };
      DateTime4.fromHTTP = function fromHTTP(text2, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _parseHTTPDate = parseHTTPDate(text2), vals = _parseHTTPDate[0], parsedZone = _parseHTTPDate[1];
        return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
      };
      DateTime4.fromFormat = function fromFormat(text2, fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (isUndefined(text2) || isUndefined(fmt)) {
          throw new InvalidArgumentError("fromFormat requires an input string and a format");
        }
        var _opts = opts, _opts$locale = _opts.locale, locale = _opts$locale === void 0 ? null : _opts$locale, _opts$numberingSystem = _opts.numberingSystem, numberingSystem = _opts$numberingSystem === void 0 ? null : _opts$numberingSystem, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        }), _parseFromTokens = parseFromTokens(localeToUse, text2, fmt), vals = _parseFromTokens[0], parsedZone = _parseFromTokens[1], specificOffset = _parseFromTokens[2], invalid = _parseFromTokens[3];
        if (invalid) {
          return DateTime4.invalid(invalid);
        } else {
          return parseDataToDateTime(vals, parsedZone, opts, "format " + fmt, text2, specificOffset);
        }
      };
      DateTime4.fromString = function fromString(text2, fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        return DateTime4.fromFormat(text2, fmt, opts);
      };
      DateTime4.fromSQL = function fromSQL(text2, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _parseSQL = parseSQL(text2), vals = _parseSQL[0], parsedZone = _parseSQL[1];
        return parseDataToDateTime(vals, parsedZone, opts, "SQL", text2);
      };
      DateTime4.invalid = function invalid(reason, explanation) {
        if (explanation === void 0) {
          explanation = null;
        }
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
        }
        var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDateTimeError(invalid2);
        } else {
          return new DateTime4({
            invalid: invalid2
          });
        }
      };
      DateTime4.isDateTime = function isDateTime(o) {
        return o && o.isLuxonDateTime || false;
      };
      var _proto = DateTime4.prototype;
      _proto.get = function get(unit) {
        return this[unit];
      };
      _proto.resolvedLocaleOptions = function resolvedLocaleOptions(opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _Formatter$create$res = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this), locale = _Formatter$create$res.locale, numberingSystem = _Formatter$create$res.numberingSystem, calendar = _Formatter$create$res.calendar;
        return {
          locale,
          numberingSystem,
          outputCalendar: calendar
        };
      };
      _proto.toUTC = function toUTC(offset2, opts) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        if (opts === void 0) {
          opts = {};
        }
        return this.setZone(FixedOffsetZone.instance(offset2), opts);
      };
      _proto.toLocal = function toLocal() {
        return this.setZone(Settings.defaultZone);
      };
      _proto.setZone = function setZone(zone, _temp) {
        var _ref2 = _temp === void 0 ? {} : _temp, _ref2$keepLocalTime = _ref2.keepLocalTime, keepLocalTime = _ref2$keepLocalTime === void 0 ? false : _ref2$keepLocalTime, _ref2$keepCalendarTim = _ref2.keepCalendarTime, keepCalendarTime = _ref2$keepCalendarTim === void 0 ? false : _ref2$keepCalendarTim;
        zone = normalizeZone(zone, Settings.defaultZone);
        if (zone.equals(this.zone)) {
          return this;
        } else if (!zone.isValid) {
          return DateTime4.invalid(unsupportedZone(zone));
        } else {
          var newTS = this.ts;
          if (keepLocalTime || keepCalendarTime) {
            var offsetGuess = zone.offset(this.ts);
            var asObj = this.toObject();
            var _objToTS3 = objToTS(asObj, offsetGuess, zone);
            newTS = _objToTS3[0];
          }
          return clone2(this, {
            ts: newTS,
            zone
          });
        }
      };
      _proto.reconfigure = function reconfigure(_temp2) {
        var _ref3 = _temp2 === void 0 ? {} : _temp2, locale = _ref3.locale, numberingSystem = _ref3.numberingSystem, outputCalendar = _ref3.outputCalendar;
        var loc = this.loc.clone({
          locale,
          numberingSystem,
          outputCalendar
        });
        return clone2(this, {
          loc
        });
      };
      _proto.setLocale = function setLocale(locale) {
        return this.reconfigure({
          locale
        });
      };
      _proto.set = function set2(values) {
        if (!this.isValid)
          return this;
        var normalized = normalizeObject(values, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        var mixed;
        if (settingWeekStuff) {
          mixed = weekToGregorian(_extends({}, gregorianToWeek(this.c), normalized));
        } else if (!isUndefined(normalized.ordinal)) {
          mixed = ordinalToGregorian(_extends({}, gregorianToOrdinal(this.c), normalized));
        } else {
          mixed = _extends({}, this.toObject(), normalized);
          if (isUndefined(normalized.day)) {
            mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
          }
        }
        var _objToTS4 = objToTS(mixed, this.o, this.zone), ts = _objToTS4[0], o = _objToTS4[1];
        return clone2(this, {
          ts,
          o
        });
      };
      _proto.plus = function plus(duration) {
        if (!this.isValid)
          return this;
        var dur = Duration.fromDurationLike(duration);
        return clone2(this, adjustTime(this, dur));
      };
      _proto.minus = function minus(duration) {
        if (!this.isValid)
          return this;
        var dur = Duration.fromDurationLike(duration).negate();
        return clone2(this, adjustTime(this, dur));
      };
      _proto.startOf = function startOf(unit) {
        if (!this.isValid)
          return this;
        var o = {}, normalizedUnit = Duration.normalizeUnit(unit);
        switch (normalizedUnit) {
          case "years":
            o.month = 1;
          case "quarters":
          case "months":
            o.day = 1;
          case "weeks":
          case "days":
            o.hour = 0;
          case "hours":
            o.minute = 0;
          case "minutes":
            o.second = 0;
          case "seconds":
            o.millisecond = 0;
            break;
        }
        if (normalizedUnit === "weeks") {
          o.weekday = 1;
        }
        if (normalizedUnit === "quarters") {
          var q = Math.ceil(this.month / 3);
          o.month = (q - 1) * 3 + 1;
        }
        return this.set(o);
      };
      _proto.endOf = function endOf(unit) {
        var _this$plus;
        return this.isValid ? this.plus((_this$plus = {}, _this$plus[unit] = 1, _this$plus)).startOf(unit).minus(1) : this;
      };
      _proto.toFormat = function toFormat(fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }
        return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
      };
      _proto.toLocaleString = function toLocaleString(formatOpts, opts) {
        if (formatOpts === void 0) {
          formatOpts = DATE_SHORT;
        }
        if (opts === void 0) {
          opts = {};
        }
        return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
      };
      _proto.toLocaleParts = function toLocaleParts(opts) {
        if (opts === void 0) {
          opts = {};
        }
        return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
      };
      _proto.toISO = function toISO(_temp3) {
        var _ref4 = _temp3 === void 0 ? {} : _temp3, _ref4$format = _ref4.format, format = _ref4$format === void 0 ? "extended" : _ref4$format, _ref4$suppressSeconds = _ref4.suppressSeconds, suppressSeconds = _ref4$suppressSeconds === void 0 ? false : _ref4$suppressSeconds, _ref4$suppressMillise = _ref4.suppressMilliseconds, suppressMilliseconds = _ref4$suppressMillise === void 0 ? false : _ref4$suppressMillise, _ref4$includeOffset = _ref4.includeOffset, includeOffset = _ref4$includeOffset === void 0 ? true : _ref4$includeOffset;
        if (!this.isValid) {
          return null;
        }
        var ext = format === "extended";
        var c = _toISODate(this, ext);
        c += "T";
        c += _toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset);
        return c;
      };
      _proto.toISODate = function toISODate(_temp4) {
        var _ref5 = _temp4 === void 0 ? {} : _temp4, _ref5$format = _ref5.format, format = _ref5$format === void 0 ? "extended" : _ref5$format;
        if (!this.isValid) {
          return null;
        }
        return _toISODate(this, format === "extended");
      };
      _proto.toISOWeekDate = function toISOWeekDate() {
        return toTechFormat(this, "kkkk-'W'WW-c");
      };
      _proto.toISOTime = function toISOTime(_temp5) {
        var _ref6 = _temp5 === void 0 ? {} : _temp5, _ref6$suppressMillise = _ref6.suppressMilliseconds, suppressMilliseconds = _ref6$suppressMillise === void 0 ? false : _ref6$suppressMillise, _ref6$suppressSeconds = _ref6.suppressSeconds, suppressSeconds = _ref6$suppressSeconds === void 0 ? false : _ref6$suppressSeconds, _ref6$includeOffset = _ref6.includeOffset, includeOffset = _ref6$includeOffset === void 0 ? true : _ref6$includeOffset, _ref6$includePrefix = _ref6.includePrefix, includePrefix = _ref6$includePrefix === void 0 ? false : _ref6$includePrefix, _ref6$format = _ref6.format, format = _ref6$format === void 0 ? "extended" : _ref6$format;
        if (!this.isValid) {
          return null;
        }
        var c = includePrefix ? "T" : "";
        return c + _toISOTime(this, format === "extended", suppressSeconds, suppressMilliseconds, includeOffset);
      };
      _proto.toRFC2822 = function toRFC2822() {
        return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
      };
      _proto.toHTTP = function toHTTP() {
        return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
      };
      _proto.toSQLDate = function toSQLDate() {
        if (!this.isValid) {
          return null;
        }
        return _toISODate(this, true);
      };
      _proto.toSQLTime = function toSQLTime(_temp6) {
        var _ref7 = _temp6 === void 0 ? {} : _temp6, _ref7$includeOffset = _ref7.includeOffset, includeOffset = _ref7$includeOffset === void 0 ? true : _ref7$includeOffset, _ref7$includeZone = _ref7.includeZone, includeZone = _ref7$includeZone === void 0 ? false : _ref7$includeZone;
        var fmt = "HH:mm:ss.SSS";
        if (includeZone || includeOffset) {
          fmt += " ";
          if (includeZone) {
            fmt += "z";
          } else if (includeOffset) {
            fmt += "ZZ";
          }
        }
        return toTechFormat(this, fmt, true);
      };
      _proto.toSQL = function toSQL(opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid) {
          return null;
        }
        return this.toSQLDate() + " " + this.toSQLTime(opts);
      };
      _proto.toString = function toString() {
        return this.isValid ? this.toISO() : INVALID;
      };
      _proto.valueOf = function valueOf() {
        return this.toMillis();
      };
      _proto.toMillis = function toMillis() {
        return this.isValid ? this.ts : NaN;
      };
      _proto.toSeconds = function toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN;
      };
      _proto.toJSON = function toJSON() {
        return this.toISO();
      };
      _proto.toBSON = function toBSON() {
        return this.toJSDate();
      };
      _proto.toObject = function toObject(opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid)
          return {};
        var base = _extends({}, this.c);
        if (opts.includeConfig) {
          base.outputCalendar = this.outputCalendar;
          base.numberingSystem = this.loc.numberingSystem;
          base.locale = this.loc.locale;
        }
        return base;
      };
      _proto.toJSDate = function toJSDate() {
        return new Date(this.isValid ? this.ts : NaN);
      };
      _proto.diff = function diff(otherDateTime, unit, opts) {
        if (unit === void 0) {
          unit = "milliseconds";
        }
        if (opts === void 0) {
          opts = {};
        }
        if (!this.isValid || !otherDateTime.isValid) {
          return Duration.invalid("created by diffing an invalid DateTime");
        }
        var durOpts = _extends({
          locale: this.locale,
          numberingSystem: this.numberingSystem
        }, opts);
        var units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = _diff(earlier, later, units, durOpts);
        return otherIsLater ? diffed.negate() : diffed;
      };
      _proto.diffNow = function diffNow(unit, opts) {
        if (unit === void 0) {
          unit = "milliseconds";
        }
        if (opts === void 0) {
          opts = {};
        }
        return this.diff(DateTime4.now(), unit, opts);
      };
      _proto.until = function until(otherDateTime) {
        return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
      };
      _proto.hasSame = function hasSame(otherDateTime, unit) {
        if (!this.isValid)
          return false;
        var inputMs = otherDateTime.valueOf();
        var adjustedToZone = this.setZone(otherDateTime.zone, {
          keepLocalTime: true
        });
        return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
      };
      _proto.equals = function equals(other) {
        return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
      };
      _proto.toRelative = function toRelative(options) {
        if (options === void 0) {
          options = {};
        }
        if (!this.isValid)
          return null;
        var base = options.base || DateTime4.fromObject({}, {
          zone: this.zone
        }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
        var units = ["years", "months", "days", "hours", "minutes", "seconds"];
        var unit = options.unit;
        if (Array.isArray(options.unit)) {
          units = options.unit;
          unit = void 0;
        }
        return diffRelative(base, this.plus(padding), _extends({}, options, {
          numeric: "always",
          units,
          unit
        }));
      };
      _proto.toRelativeCalendar = function toRelativeCalendar(options) {
        if (options === void 0) {
          options = {};
        }
        if (!this.isValid)
          return null;
        return diffRelative(options.base || DateTime4.fromObject({}, {
          zone: this.zone
        }), this, _extends({}, options, {
          numeric: "auto",
          units: ["years", "months", "days"],
          calendary: true
        }));
      };
      DateTime4.min = function min() {
        for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
          dateTimes[_key] = arguments[_key];
        }
        if (!dateTimes.every(DateTime4.isDateTime)) {
          throw new InvalidArgumentError("min requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, function(i) {
          return i.valueOf();
        }, Math.min);
      };
      DateTime4.max = function max() {
        for (var _len2 = arguments.length, dateTimes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          dateTimes[_key2] = arguments[_key2];
        }
        if (!dateTimes.every(DateTime4.isDateTime)) {
          throw new InvalidArgumentError("max requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, function(i) {
          return i.valueOf();
        }, Math.max);
      };
      DateTime4.fromFormatExplain = function fromFormatExplain(text2, fmt, options) {
        if (options === void 0) {
          options = {};
        }
        var _options = options, _options$locale = _options.locale, locale = _options$locale === void 0 ? null : _options$locale, _options$numberingSys = _options.numberingSystem, numberingSystem = _options$numberingSys === void 0 ? null : _options$numberingSys, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        });
        return explainFromTokens(localeToUse, text2, fmt);
      };
      DateTime4.fromStringExplain = function fromStringExplain(text2, fmt, options) {
        if (options === void 0) {
          options = {};
        }
        return DateTime4.fromFormatExplain(text2, fmt, options);
      };
      _createClass(DateTime4, [{
        key: "isValid",
        get: function get() {
          return this.invalid === null;
        }
      }, {
        key: "invalidReason",
        get: function get() {
          return this.invalid ? this.invalid.reason : null;
        }
      }, {
        key: "invalidExplanation",
        get: function get() {
          return this.invalid ? this.invalid.explanation : null;
        }
      }, {
        key: "locale",
        get: function get() {
          return this.isValid ? this.loc.locale : null;
        }
      }, {
        key: "numberingSystem",
        get: function get() {
          return this.isValid ? this.loc.numberingSystem : null;
        }
      }, {
        key: "outputCalendar",
        get: function get() {
          return this.isValid ? this.loc.outputCalendar : null;
        }
      }, {
        key: "zone",
        get: function get() {
          return this._zone;
        }
      }, {
        key: "zoneName",
        get: function get() {
          return this.isValid ? this.zone.name : null;
        }
      }, {
        key: "year",
        get: function get() {
          return this.isValid ? this.c.year : NaN;
        }
      }, {
        key: "quarter",
        get: function get() {
          return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
        }
      }, {
        key: "month",
        get: function get() {
          return this.isValid ? this.c.month : NaN;
        }
      }, {
        key: "day",
        get: function get() {
          return this.isValid ? this.c.day : NaN;
        }
      }, {
        key: "hour",
        get: function get() {
          return this.isValid ? this.c.hour : NaN;
        }
      }, {
        key: "minute",
        get: function get() {
          return this.isValid ? this.c.minute : NaN;
        }
      }, {
        key: "second",
        get: function get() {
          return this.isValid ? this.c.second : NaN;
        }
      }, {
        key: "millisecond",
        get: function get() {
          return this.isValid ? this.c.millisecond : NaN;
        }
      }, {
        key: "weekYear",
        get: function get() {
          return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
        }
      }, {
        key: "weekNumber",
        get: function get() {
          return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
        }
      }, {
        key: "weekday",
        get: function get() {
          return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
        }
      }, {
        key: "ordinal",
        get: function get() {
          return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
        }
      }, {
        key: "monthShort",
        get: function get() {
          return this.isValid ? Info.months("short", {
            locObj: this.loc
          })[this.month - 1] : null;
        }
      }, {
        key: "monthLong",
        get: function get() {
          return this.isValid ? Info.months("long", {
            locObj: this.loc
          })[this.month - 1] : null;
        }
      }, {
        key: "weekdayShort",
        get: function get() {
          return this.isValid ? Info.weekdays("short", {
            locObj: this.loc
          })[this.weekday - 1] : null;
        }
      }, {
        key: "weekdayLong",
        get: function get() {
          return this.isValid ? Info.weekdays("long", {
            locObj: this.loc
          })[this.weekday - 1] : null;
        }
      }, {
        key: "offset",
        get: function get() {
          return this.isValid ? +this.o : NaN;
        }
      }, {
        key: "offsetNameShort",
        get: function get() {
          if (this.isValid) {
            return this.zone.offsetName(this.ts, {
              format: "short",
              locale: this.locale
            });
          } else {
            return null;
          }
        }
      }, {
        key: "offsetNameLong",
        get: function get() {
          if (this.isValid) {
            return this.zone.offsetName(this.ts, {
              format: "long",
              locale: this.locale
            });
          } else {
            return null;
          }
        }
      }, {
        key: "isOffsetFixed",
        get: function get() {
          return this.isValid ? this.zone.isUniversal : null;
        }
      }, {
        key: "isInDST",
        get: function get() {
          if (this.isOffsetFixed) {
            return false;
          } else {
            return this.offset > this.set({
              month: 1
            }).offset || this.offset > this.set({
              month: 5
            }).offset;
          }
        }
      }, {
        key: "isInLeapYear",
        get: function get() {
          return isLeapYear(this.year);
        }
      }, {
        key: "daysInMonth",
        get: function get() {
          return daysInMonth(this.year, this.month);
        }
      }, {
        key: "daysInYear",
        get: function get() {
          return this.isValid ? daysInYear(this.year) : NaN;
        }
      }, {
        key: "weeksInWeekYear",
        get: function get() {
          return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
        }
      }], [{
        key: "DATE_SHORT",
        get: function get() {
          return DATE_SHORT;
        }
      }, {
        key: "DATE_MED",
        get: function get() {
          return DATE_MED;
        }
      }, {
        key: "DATE_MED_WITH_WEEKDAY",
        get: function get() {
          return DATE_MED_WITH_WEEKDAY;
        }
      }, {
        key: "DATE_FULL",
        get: function get() {
          return DATE_FULL;
        }
      }, {
        key: "DATE_HUGE",
        get: function get() {
          return DATE_HUGE;
        }
      }, {
        key: "TIME_SIMPLE",
        get: function get() {
          return TIME_SIMPLE;
        }
      }, {
        key: "TIME_WITH_SECONDS",
        get: function get() {
          return TIME_WITH_SECONDS;
        }
      }, {
        key: "TIME_WITH_SHORT_OFFSET",
        get: function get() {
          return TIME_WITH_SHORT_OFFSET;
        }
      }, {
        key: "TIME_WITH_LONG_OFFSET",
        get: function get() {
          return TIME_WITH_LONG_OFFSET;
        }
      }, {
        key: "TIME_24_SIMPLE",
        get: function get() {
          return TIME_24_SIMPLE;
        }
      }, {
        key: "TIME_24_WITH_SECONDS",
        get: function get() {
          return TIME_24_WITH_SECONDS;
        }
      }, {
        key: "TIME_24_WITH_SHORT_OFFSET",
        get: function get() {
          return TIME_24_WITH_SHORT_OFFSET;
        }
      }, {
        key: "TIME_24_WITH_LONG_OFFSET",
        get: function get() {
          return TIME_24_WITH_LONG_OFFSET;
        }
      }, {
        key: "DATETIME_SHORT",
        get: function get() {
          return DATETIME_SHORT;
        }
      }, {
        key: "DATETIME_SHORT_WITH_SECONDS",
        get: function get() {
          return DATETIME_SHORT_WITH_SECONDS;
        }
      }, {
        key: "DATETIME_MED",
        get: function get() {
          return DATETIME_MED;
        }
      }, {
        key: "DATETIME_MED_WITH_SECONDS",
        get: function get() {
          return DATETIME_MED_WITH_SECONDS;
        }
      }, {
        key: "DATETIME_MED_WITH_WEEKDAY",
        get: function get() {
          return DATETIME_MED_WITH_WEEKDAY;
        }
      }, {
        key: "DATETIME_FULL",
        get: function get() {
          return DATETIME_FULL;
        }
      }, {
        key: "DATETIME_FULL_WITH_SECONDS",
        get: function get() {
          return DATETIME_FULL_WITH_SECONDS;
        }
      }, {
        key: "DATETIME_HUGE",
        get: function get() {
          return DATETIME_HUGE;
        }
      }, {
        key: "DATETIME_HUGE_WITH_SECONDS",
        get: function get() {
          return DATETIME_HUGE_WITH_SECONDS;
        }
      }]);
      return DateTime4;
    }();
    function friendlyDateTime(dateTimeish) {
      if (DateTime3.isDateTime(dateTimeish)) {
        return dateTimeish;
      } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
        return DateTime3.fromJSDate(dateTimeish);
      } else if (dateTimeish && typeof dateTimeish === "object") {
        return DateTime3.fromObject(dateTimeish);
      } else {
        throw new InvalidArgumentError("Unknown datetime argument: " + dateTimeish + ", of type " + typeof dateTimeish);
      }
    }
    var VERSION = "2.3.0";
    exports.DateTime = DateTime3;
    exports.Duration = Duration;
    exports.FixedOffsetZone = FixedOffsetZone;
    exports.IANAZone = IANAZone;
    exports.Info = Info;
    exports.Interval = Interval;
    exports.InvalidZone = InvalidZone;
    exports.Settings = Settings;
    exports.SystemZone = SystemZone;
    exports.VERSION = VERSION;
    exports.Zone = Zone;
  }
});

// node_modules/json2csv/dist/json2csv.umd.js
var require_json2csv_umd = __commonJS({
  "node_modules/json2csv/dist/json2csv.umd.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.json2csv = {}));
    })(exports, function(exports2) {
      "use strict";
      var domain;
      function EventHandlers() {
      }
      EventHandlers.prototype = Object.create(null);
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.usingDomains = false;
      EventEmitter.prototype.domain = void 0;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._maxListeners = void 0;
      EventEmitter.defaultMaxListeners = 10;
      EventEmitter.init = function() {
        this.domain = null;
        if (EventEmitter.usingDomains) {
          if (domain.active && !(this instanceof domain.Domain))
            ;
        }
        if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || isNaN(n))
          throw new TypeError('"n" argument must be a positive number');
        this._maxListeners = n;
        return this;
      };
      function $getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return $getMaxListeners(this);
      };
      function emitNone(handler, isFn, self2) {
        if (isFn)
          handler.call(self2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2);
        }
      }
      function emitOne(handler, isFn, self2, arg1) {
        if (isFn)
          handler.call(self2, arg1);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2, arg1);
        }
      }
      function emitTwo(handler, isFn, self2, arg1, arg2) {
        if (isFn)
          handler.call(self2, arg1, arg2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2, arg1, arg2);
        }
      }
      function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
        if (isFn)
          handler.call(self2, arg1, arg2, arg3);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].call(self2, arg1, arg2, arg3);
        }
      }
      function emitMany(handler, isFn, self2, args) {
        if (isFn)
          handler.apply(self2, args);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            listeners[i].apply(self2, args);
        }
      }
      EventEmitter.prototype.emit = function emit(type2) {
        var er, handler, len, args, i, events, domain2;
        var doError = type2 === "error";
        events = this._events;
        if (events)
          doError = doError && events.error == null;
        else if (!doError)
          return false;
        domain2 = this.domain;
        if (doError) {
          er = arguments[1];
          if (domain2) {
            if (!er)
              er = new Error('Uncaught, unspecified "error" event');
            er.domainEmitter = this;
            er.domain = domain2;
            er.domainThrown = false;
            domain2.emit("error", er);
          } else if (er instanceof Error) {
            throw er;
          } else {
            var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
            err.context = er;
            throw err;
          }
          return false;
        }
        handler = events[type2];
        if (!handler)
          return false;
        var isFn = typeof handler === "function";
        len = arguments.length;
        switch (len) {
          case 1:
            emitNone(handler, isFn, this);
            break;
          case 2:
            emitOne(handler, isFn, this, arguments[1]);
            break;
          case 3:
            emitTwo(handler, isFn, this, arguments[1], arguments[2]);
            break;
          case 4:
            emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
            break;
          default:
            args = new Array(len - 1);
            for (i = 1; i < len; i++)
              args[i - 1] = arguments[i];
            emitMany(handler, isFn, this, args);
        }
        return true;
      };
      function _addListener(target, type2, listener, prepend) {
        var m;
        var events;
        var existing;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = target._events;
        if (!events) {
          events = target._events = new EventHandlers();
          target._eventsCount = 0;
        } else {
          if (events.newListener) {
            target.emit("newListener", type2, listener.listener ? listener.listener : listener);
            events = target._events;
          }
          existing = events[type2];
        }
        if (!existing) {
          existing = events[type2] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type2] = prepend ? [listener, existing] : [existing, listener];
          } else {
            if (prepend) {
              existing.unshift(listener);
            } else {
              existing.push(listener);
            }
          }
          if (!existing.warned) {
            m = $getMaxListeners(target);
            if (m && m > 0 && existing.length > m) {
              existing.warned = true;
              var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
              w.name = "MaxListenersExceededWarning";
              w.emitter = target;
              w.type = type2;
              w.count = existing.length;
              emitWarning(w);
            }
          }
        }
        return target;
      }
      function emitWarning(e) {
        typeof console.warn === "function" ? console.warn(e) : console.log(e);
      }
      EventEmitter.prototype.addListener = function addListener2(type2, listener) {
        return _addListener(this, type2, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener2(type2, listener) {
        return _addListener(this, type2, listener, true);
      };
      function _onceWrap(target, type2, listener) {
        var fired = false;
        function g() {
          target.removeListener(type2, g);
          if (!fired) {
            fired = true;
            listener.apply(target, arguments);
          }
        }
        g.listener = listener;
        return g;
      }
      EventEmitter.prototype.once = function once(type2, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.on(type2, _onceWrap(this, type2, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type2, _onceWrap(this, type2, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener2(type2, listener) {
        var list, events, position, i, originalListener;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = this._events;
        if (!events)
          return this;
        list = events[type2];
        if (!list)
          return this;
        if (list === listener || list.listener && list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else {
            delete events[type2];
            if (events.removeListener)
              this.emit("removeListener", type2, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length; i-- > 0; ) {
            if (list[i] === listener || list[i].listener && list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (list.length === 1) {
            list[0] = void 0;
            if (--this._eventsCount === 0) {
              this._events = new EventHandlers();
              return this;
            } else {
              delete events[type2];
            }
          } else {
            spliceOne(list, position);
          }
          if (events.removeListener)
            this.emit("removeListener", type2, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type2) {
        var listeners, events;
        events = this._events;
        if (!events)
          return this;
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = new EventHandlers();
            this._eventsCount = 0;
          } else if (events[type2]) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else
              delete events[type2];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys2 = Object.keys(events);
          for (var i = 0, key; i < keys2.length; ++i) {
            key = keys2[i];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = new EventHandlers();
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type2];
        if (typeof listeners === "function") {
          this.removeListener(type2, listeners);
        } else if (listeners) {
          do {
            this.removeListener(type2, listeners[listeners.length - 1]);
          } while (listeners[0]);
        }
        return this;
      };
      EventEmitter.prototype.listeners = function listeners(type2) {
        var evlistener;
        var ret;
        var events = this._events;
        if (!events)
          ret = [];
        else {
          evlistener = events[type2];
          if (!evlistener)
            ret = [];
          else if (typeof evlistener === "function")
            ret = [evlistener.listener || evlistener];
          else
            ret = unwrapListeners(evlistener);
        }
        return ret;
      };
      EventEmitter.listenerCount = function(emitter, type2) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type2);
        } else {
          return listenerCount.call(emitter, type2);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type2) {
        var events = this._events;
        if (events) {
          var evlistener = events[type2];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
      };
      function spliceOne(list, index) {
        for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
          list[i] = list[k];
        list.pop();
      }
      function arrayClone(arr, i) {
        var copy = new Array(i);
        while (i--)
          copy[i] = arr[i];
        return copy;
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var inited = false;
      function init2() {
        inited = true;
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i];
          revLookup[code.charCodeAt(i)] = i;
        }
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
      }
      function toByteArray(b64) {
        if (!inited) {
          init2();
        }
        var i, j, l, tmp, placeHolders, arr;
        var len = b64.length;
        if (len % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
        arr = new Arr(len * 3 / 4 - placeHolders);
        l = placeHolders > 0 ? len - 4 : len;
        var L = 0;
        for (i = 0, j = 0; i < l; i += 4, j += 3) {
          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
          arr[L++] = tmp >> 16 & 255;
          arr[L++] = tmp >> 8 & 255;
          arr[L++] = tmp & 255;
        }
        if (placeHolders === 2) {
          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
          arr[L++] = tmp & 255;
        } else if (placeHolders === 1) {
          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
          arr[L++] = tmp >> 8 & 255;
          arr[L++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i = start; i < end; i += 3) {
          tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        if (!inited) {
          init2();
        }
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3;
        var output = "";
        var parts = [];
        var maxChunkLength = 16383;
        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len - 1];
          output += lookup[tmp >> 2];
          output += lookup[tmp << 4 & 63];
          output += "==";
        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + uint8[len - 1];
          output += lookup[tmp >> 10];
          output += lookup[tmp >> 4 & 63];
          output += lookup[tmp << 2 & 63];
          output += "=";
        }
        parts.push(output);
        return parts.join("");
      }
      function read(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      }
      function write(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      }
      var toString = {}.toString;
      var isArray2 = Array.isArray || function(arr) {
        return toString.call(arr) == "[object Array]";
      };
      var INSPECT_MAX_BYTES = 50;
      Buffer2.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
      function kMaxLength() {
        return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
      }
      function createBuffer(that, length) {
        if (kMaxLength() < length) {
          throw new RangeError("Invalid typed array length");
        }
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          that = new Uint8Array(length);
          that.__proto__ = Buffer2.prototype;
        } else {
          if (that === null) {
            that = new Buffer2(length);
          }
          that.length = length;
        }
        return that;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
          return new Buffer2(arg, encodingOrOffset, length);
        }
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new Error("If encoding is specified then the first argument must be a string");
          }
          return allocUnsafe(this, arg);
        }
        return from(this, arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      Buffer2._augment = function(arr) {
        arr.__proto__ = Buffer2.prototype;
        return arr;
      };
      function from(that, value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('"value" argument must not be a number');
        }
        if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
          return fromArrayBuffer(that, value, encodingOrOffset, length);
        }
        if (typeof value === "string") {
          return fromString(that, value, encodingOrOffset);
        }
        return fromObject2(that, value);
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(null, value, encodingOrOffset, length);
      };
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        Buffer2.prototype.__proto__ = Uint8Array.prototype;
        Buffer2.__proto__ = Uint8Array;
      }
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be a number');
        } else if (size < 0) {
          throw new RangeError('"size" argument must not be negative');
        }
      }
      function alloc(that, size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(that, size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
        }
        return createBuffer(that, size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(null, size, fill, encoding);
      };
      function allocUnsafe(that, size) {
        assertSize(size);
        that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
        if (!Buffer2.TYPED_ARRAY_SUPPORT) {
          for (var i = 0; i < size; ++i) {
            that[i] = 0;
          }
        }
        return that;
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(null, size);
      };
      function fromString(that, string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError('"encoding" must be a valid string encoding');
        }
        var length = byteLength(string, encoding) | 0;
        that = createBuffer(that, length);
        var actual = that.write(string, encoding);
        if (actual !== length) {
          that = that.slice(0, actual);
        }
        return that;
      }
      function fromArrayLike(that, array) {
        var length = array.length < 0 ? 0 : checked(array.length) | 0;
        that = createBuffer(that, length);
        for (var i = 0; i < length; i += 1) {
          that[i] = array[i] & 255;
        }
        return that;
      }
      function fromArrayBuffer(that, array, byteOffset, length) {
        array.byteLength;
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError("'offset' is out of bounds");
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError("'length' is out of bounds");
        }
        if (byteOffset === void 0 && length === void 0) {
          array = new Uint8Array(array);
        } else if (length === void 0) {
          array = new Uint8Array(array, byteOffset);
        } else {
          array = new Uint8Array(array, byteOffset, length);
        }
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          that = array;
          that.__proto__ = Buffer2.prototype;
        } else {
          that = fromArrayLike(that, array);
        }
        return that;
      }
      function fromObject2(that, obj) {
        if (internalIsBuffer(obj)) {
          var len = checked(obj.length) | 0;
          that = createBuffer(that, len);
          if (that.length === 0) {
            return that;
          }
          obj.copy(that, 0, 0, len);
          return that;
        }
        if (obj) {
          if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
            if (typeof obj.length !== "number" || isnan(obj.length)) {
              return createBuffer(that, 0);
            }
            return fromArrayLike(that, obj);
          }
          if (obj.type === "Buffer" && isArray2(obj.data)) {
            return fromArrayLike(that, obj.data);
          }
        }
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
      }
      function checked(length) {
        if (length >= kMaxLength()) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
        }
        return length | 0;
      }
      Buffer2.isBuffer = isBuffer;
      function internalIsBuffer(b) {
        return !!(b != null && b._isBuffer);
      }
      Buffer2.compare = function compare(a, b) {
        if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
          throw new TypeError("Arguments must be Buffers");
        }
        if (a === b)
          return 0;
        var x = a.length;
        var y = b.length;
        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!isArray2(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        var i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        var buffer = Buffer2.allocUnsafe(length);
        var pos = 0;
        for (i = 0; i < list.length; ++i) {
          var buf = list[i];
          if (!internalIsBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          buf.copy(buffer, pos);
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (internalIsBuffer(string)) {
          return string.length;
        }
        if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          string = "" + string;
        }
        var len = string.length;
        if (len === 0)
          return 0;
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
            case void 0:
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase)
                return utf8ToBytes(string).length;
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        var loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap2(b, n, m) {
        var i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i = 0; i < len; i += 2) {
          swap2(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i = 0; i < len; i += 4) {
          swap2(this, i, i + 3);
          swap2(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i = 0; i < len; i += 8) {
          swap2(this, i, i + 7);
          swap2(this, i + 1, i + 6);
          swap2(this, i + 2, i + 5);
          swap2(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString2() {
        var length = this.length | 0;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.equals = function equals(b) {
        if (!internalIsBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect2() {
        var str = "";
        var max = INSPECT_MAX_BYTES;
        if (this.length > 0) {
          str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
          if (this.length > max)
            str += " ... ";
        }
        return "<Buffer " + str + ">";
      };
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (!internalIsBuffer(target)) {
          throw new TypeError("Argument must be a Buffer");
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        var x = thisEnd - thisStart;
        var y = end - start;
        var len = Math.min(x, y);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (isNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (internalIsBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        var indexSize = 1;
        var arrLength = arr.length;
        var valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read2(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        var i;
        if (dir) {
          var foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            var found = true;
            for (var j = 0; j < valLength; j++) {
              if (read2(arr, i + j) !== read2(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        var strLen = string.length;
        if (strLen % 2 !== 0)
          throw new TypeError("Invalid hex string");
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        for (var i = 0; i < length; ++i) {
          var parsed = parseInt(string.substr(i * 2, 2), 16);
          if (isNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function latin1Write(buf, string, offset, length) {
        return asciiWrite(buf, string, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write2(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset | 0;
          if (isFinite(length)) {
            length = length | 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        }
        var remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
              return asciiWrite(this, string, offset, length);
            case "latin1":
            case "binary":
              return latin1Write(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return fromByteArray(buf);
        } else {
          return fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i = start;
        while (i < end) {
          var firstByte = buf[i];
          var codePoint = null;
          var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        var res = "";
        var i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        var ret = "";
        end = Math.min(buf.length, end);
        for (var i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        var out = "";
        for (var i = start; i < end; ++i) {
          out += toHex(buf[i]);
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = "";
        for (var i = 0; i < bytes.length; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end);
          newBuf.__proto__ = Buffer2.prototype;
        } else {
          var sliceLen = end - start;
          newBuf = new Buffer2(sliceLen, void 0);
          for (var i = 0; i < sliceLen; ++i) {
            newBuf[i] = this[i + start];
          }
        }
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        var val = this[offset + --byteLength2];
        var mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var i = byteLength2;
        var mul = 1;
        var val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!internalIsBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var mul = 1;
        var i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var i = byteLength2 - 1;
        var mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        if (!Buffer2.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        this[offset] = value & 255;
        return offset + 1;
      };
      function objectWriteUInt16(buf, value, offset, littleEndian) {
        if (value < 0)
          value = 65535 + value + 1;
        for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
          buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
        }
      }
      Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      function objectWriteUInt32(buf, value, offset, littleEndian) {
        if (value < 0)
          value = 4294967295 + value + 1;
        for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
          buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
        }
      }
      Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset + 3] = value >>> 24;
          this[offset + 2] = value >>> 16;
          this[offset + 1] = value >>> 8;
          this[offset] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i = byteLength2 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (!Buffer2.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
          this[offset + 2] = value >>> 16;
          this[offset + 3] = value >>> 24;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4);
        }
        write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8);
        }
        write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        var i;
        if (this === target && start < targetStart && targetStart < end) {
          for (i = len - 1; i >= 0; --i) {
            target[i + targetStart] = this[i + start];
          }
        } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
          for (i = 0; i < len; ++i) {
            target[i + targetStart] = this[i + start];
          }
        } else {
          Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (code < 256) {
              val = code;
            }
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
        } else if (typeof val === "number") {
          val = val & 255;
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        var i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
          var len = bytes.length;
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = stringtrim(str).replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function stringtrim(str) {
        if (str.trim)
          return str.trim();
        return str.replace(/^\s+|\s+$/g, "");
      }
      function toHex(n) {
        if (n < 16)
          return "0" + n.toString(16);
        return n.toString(16);
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        var codePoint;
        var length = string.length;
        var leadSurrogate = null;
        var bytes = [];
        for (var i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        var c, hi, lo;
        var byteArray = [];
        for (var i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        for (var i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isnan(val) {
        return val !== val;
      }
      function isBuffer(obj) {
        return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
      }
      function isFastBuffer(obj) {
        return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
      }
      function isSlowBuffer(obj) {
        return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
      }
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      var cachedSetTimeout = defaultSetTimout;
      var cachedClearTimeout = defaultClearTimeout;
      if (typeof global$1.setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      }
      if (typeof global$1.clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      }
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      }
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      var performance = global$1.performance || {};
      var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
        return new Date().getTime();
      };
      var inherits;
      if (typeof Object.create === "function") {
        inherits = function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        };
      } else {
        inherits = function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        };
      }
      var inherits$1 = inherits;
      var formatRegExp = /%[sdj%]/g;
      function format(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(" ");
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%")
            return "%";
          if (i >= len)
            return x2;
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject2(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      }
      function deprecate(fn, msg) {
        if (isUndefined(global$1.process)) {
          return function() {
            return deprecate(fn, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      }
      var debugs = {};
      var debugEnviron;
      function debuglog(set2) {
        if (isUndefined(debugEnviron))
          debugEnviron = "";
        set2 = set2.toUpperCase();
        if (!debugs[set2]) {
          if (new RegExp("\\b" + set2 + "\\b", "i").test(debugEnviron)) {
            var pid = 0;
            debugs[set2] = function() {
              var msg = format.apply(null, arguments);
              console.error("%s %d: %s", set2, pid, msg);
            };
          } else {
            debugs[set2] = function() {
            };
          }
        }
        return debugs[set2];
      }
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          _extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction2(value.inspect) && value.inspect !== inspect && !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys2 = Object.keys(value);
        var visibleKeys = arrayToHash(keys2);
        if (ctx.showHidden) {
          keys2 = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys2.length === 0) {
          if (isFunction2(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = "", array = false, braces = ["{", "}"];
        if (isArray$1(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction2(value)) {
          var n = value.name ? ": " + value.name : "";
          base = " [Function" + n + "]";
        }
        if (isRegExp(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = " " + formatError(value);
        }
        if (keys2.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
        } else {
          output = keys2.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber2(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
          } else {
            output.push("");
          }
        }
        keys2.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = "[" + key + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").substr(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      function reduceToSingleString(output, base, braces) {
        var length = output.reduce(function(prev, cur) {
          if (cur.indexOf("\n") >= 0)
            ;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output.join(", ") + " " + braces[1];
      }
      function isArray$1(ar) {
        return Array.isArray(ar);
      }
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      function isNull(arg) {
        return arg === null;
      }
      function isNumber2(arg) {
        return typeof arg === "number";
      }
      function isString(arg) {
        return typeof arg === "string";
      }
      function isUndefined(arg) {
        return arg === void 0;
      }
      function isRegExp(re) {
        return isObject2(re) && objectToString(re) === "[object RegExp]";
      }
      function isObject2(arg) {
        return typeof arg === "object" && arg !== null;
      }
      function isDate(d) {
        return isObject2(d) && objectToString(d) === "[object Date]";
      }
      function isError(e) {
        return isObject2(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
      }
      function isFunction2(arg) {
        return typeof arg === "function";
      }
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function _extend(origin, add) {
        if (!add || !isObject2(add))
          return origin;
        var keys2 = Object.keys(add);
        var i = keys2.length;
        while (i--) {
          origin[keys2[i]] = add[keys2[i]];
        }
        return origin;
      }
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      function BufferList() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function(v2) {
        var entry = { data: v2, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function(v2) {
        var entry = { data: v2, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          p.data.copy(ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function assertEncoding(encoding) {
        if (encoding && !isBufferEncoding(encoding)) {
          throw new Error("Unknown encoding: " + encoding);
        }
      }
      function StringDecoder(encoding) {
        this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
        assertEncoding(encoding);
        switch (this.encoding) {
          case "utf8":
            this.surrogateSize = 3;
            break;
          case "ucs2":
          case "utf16le":
            this.surrogateSize = 2;
            this.detectIncompleteChar = utf16DetectIncompleteChar;
            break;
          case "base64":
            this.surrogateSize = 3;
            this.detectIncompleteChar = base64DetectIncompleteChar;
            break;
          default:
            this.write = passThroughWrite;
            return;
        }
        this.charBuffer = new Buffer2(6);
        this.charReceived = 0;
        this.charLength = 0;
      }
      StringDecoder.prototype.write = function(buffer) {
        var charStr = "";
        while (this.charLength) {
          var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
          buffer.copy(this.charBuffer, this.charReceived, 0, available);
          this.charReceived += available;
          if (this.charReceived < this.charLength) {
            return "";
          }
          buffer = buffer.slice(available, buffer.length);
          charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
          var charCode = charStr.charCodeAt(charStr.length - 1);
          if (charCode >= 55296 && charCode <= 56319) {
            this.charLength += this.surrogateSize;
            charStr = "";
            continue;
          }
          this.charReceived = this.charLength = 0;
          if (buffer.length === 0) {
            return charStr;
          }
          break;
        }
        this.detectIncompleteChar(buffer);
        var end = buffer.length;
        if (this.charLength) {
          buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
          end -= this.charReceived;
        }
        charStr += buffer.toString(this.encoding, 0, end);
        var end = charStr.length - 1;
        var charCode = charStr.charCodeAt(end);
        if (charCode >= 55296 && charCode <= 56319) {
          var size = this.surrogateSize;
          this.charLength += size;
          this.charReceived += size;
          this.charBuffer.copy(this.charBuffer, size, 0, size);
          buffer.copy(this.charBuffer, 0, 0, size);
          return charStr.substring(0, end);
        }
        return charStr;
      };
      StringDecoder.prototype.detectIncompleteChar = function(buffer) {
        var i = buffer.length >= 3 ? 3 : buffer.length;
        for (; i > 0; i--) {
          var c = buffer[buffer.length - i];
          if (i == 1 && c >> 5 == 6) {
            this.charLength = 2;
            break;
          }
          if (i <= 2 && c >> 4 == 14) {
            this.charLength = 3;
            break;
          }
          if (i <= 3 && c >> 3 == 30) {
            this.charLength = 4;
            break;
          }
        }
        this.charReceived = i;
      };
      StringDecoder.prototype.end = function(buffer) {
        var res = "";
        if (buffer && buffer.length)
          res = this.write(buffer);
        if (this.charReceived) {
          var cr = this.charReceived;
          var buf = this.charBuffer;
          var enc = this.encoding;
          res += buf.slice(0, cr).toString(enc);
        }
        return res;
      };
      function passThroughWrite(buffer) {
        return buffer.toString(this.encoding);
      }
      function utf16DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 2;
        this.charLength = this.charReceived ? 2 : 0;
      }
      function base64DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 3;
        this.charLength = this.charReceived ? 3 : 0;
      }
      Readable.ReadableState = ReadableState;
      var debug = debuglog("stream");
      inherits$1(Readable, EventEmitter);
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function") {
          return emitter.prependListener(event, fn);
        } else {
          if (!emitter._events || !emitter._events[event])
            emitter.on(event, fn);
          else if (Array.isArray(emitter._events[event]))
            emitter._events[event].unshift(fn);
          else
            emitter._events[event] = [fn, emitter._events[event]];
        }
      }
      function listenerCount$1(emitter, type2) {
        return emitter.listeners(type2).length;
      }
      function ReadableState(options, stream) {
        options = options || {};
        this.objectMode = !!options.objectMode;
        if (stream instanceof Duplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        var hwm = options.highWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
        this.highWaterMark = ~~this.highWaterMark;
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.ranOut = false;
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable(options) {
        if (!(this instanceof Readable))
          return new Readable(options);
        this._readableState = new ReadableState(options, this);
        this.readable = true;
        if (options && typeof options.read === "function")
          this._read = options.read;
        EventEmitter.call(this);
      }
      Readable.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        if (!state.objectMode && typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
        }
        return readableAddChunk(this, state, chunk, encoding, false);
      };
      Readable.prototype.unshift = function(chunk) {
        var state = this._readableState;
        return readableAddChunk(this, state, chunk, "", true);
      };
      Readable.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      function readableAddChunk(stream, state, chunk, encoding, addToFront) {
        var er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (state.ended && !addToFront) {
            var e = new Error("stream.push() after EOF");
            stream.emit("error", e);
          } else if (state.endEmitted && addToFront) {
            var _e = new Error("stream.unshift() after end event");
            stream.emit("error", _e);
          } else {
            var skipAdd;
            if (state.decoder && !addToFront && !encoding) {
              chunk = state.decoder.write(chunk);
              skipAdd = !state.objectMode && chunk.length === 0;
            }
            if (!addToFront)
              state.reading = false;
            if (!skipAdd) {
              if (state.flowing && state.length === 0 && !state.sync) {
                stream.emit("data", chunk);
                stream.read(0);
              } else {
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront)
                  state.buffer.unshift(chunk);
                else
                  state.buffer.push(chunk);
                if (state.needReadable)
                  emitReadable(stream);
              }
            }
            maybeReadMore(stream, state);
          }
        } else if (!addToFront) {
          state.reading = false;
        }
        return needMoreData(state);
      }
      function needMoreData(state) {
        return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
      }
      Readable.prototype.setEncoding = function(enc) {
        this._readableState.decoder = new StringDecoder(enc);
        this._readableState.encoding = enc;
        return this;
      };
      var MAX_HWM = 8388608;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = true;
          n = 0;
        } else {
          state.length -= n;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function chunkInvalid(state, chunk) {
        var er = null;
        if (!isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
          er = new TypeError("Invalid non-string/buffer chunk");
        }
        return er;
      }
      function onEofChunk(stream, state) {
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        emitReadable(stream);
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          if (state.sync)
            nextTick(emitReadable_, stream);
          else
            emitReadable_(stream);
        }
      }
      function emitReadable_(stream) {
        debug("emit readable");
        stream.emit("readable");
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        var len = state.length;
        while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
          else
            len = state.length;
        }
        state.readingMore = false;
      }
      Readable.prototype._read = function(n) {
        this.emit("error", new Error("not implemented"));
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = !pipeOpts || pipeOpts.end !== false;
        var endFn = doEnd ? onend2 : cleanup;
        if (state.endEmitted)
          nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable) {
          debug("onunpipe");
          if (readable === src) {
            cleanup();
          }
        }
        function onend2() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", cleanup);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        var increasedAwaitDrain = false;
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          increasedAwaitDrain = false;
          var ret = dest.write(chunk);
          if (ret === false && !increasedAwaitDrain) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", src._readableState.awaitDrain);
              src._readableState.awaitDrain++;
              increasedAwaitDrain = true;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (listenerCount$1(dest, "error") === 0)
            dest.emit("error", er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && src.listeners("data").length) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable.prototype.unpipe = function(dest) {
        var state = this._readableState;
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var _i = 0; _i < len; _i++) {
            dests[_i].emit("unpipe", this);
          }
          return this;
        }
        var i = indexOf(state.pipes, dest);
        if (i === -1)
          return this;
        state.pipes.splice(i, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this);
        return this;
      };
      Readable.prototype.on = function(ev, fn) {
        var res = EventEmitter.prototype.on.call(this, ev, fn);
        if (ev === "data") {
          if (this._readableState.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          var state = this._readableState;
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) {
              nextTick(nReadingNextTick, this);
            } else if (state.length) {
              emitReadable(this);
            }
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = true;
          resume(this, state);
        }
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        if (!state.reading) {
          debug("resume read 0");
          stream.read(0);
        }
        state.resumeScheduled = false;
        state.awaitDrain = 0;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
        }
      }
      Readable.prototype.wrap = function(stream) {
        var state = this._readableState;
        var paused = false;
        var self2 = this;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              self2.push(chunk);
          }
          self2.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = self2.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function(method2) {
              return function() {
                return stream[method2].apply(stream, arguments);
              };
            }(i);
          }
        }
        var events = ["error", "close", "destroy", "pause", "resume"];
        forEach(events, function(ev) {
          stream.on(ev, self2.emit.bind(self2, ev));
        });
        self2._read = function(n) {
          debug("wrapped _read", n);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return self2;
      };
      Readable._fromList = fromList;
      function fromList(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.head.data;
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = fromListPartial(n, state.buffer, state.decoder);
        }
        return ret;
      }
      function fromListPartial(n, list, hasStrings) {
        var ret;
        if (n < list.head.data.length) {
          ret = list.head.data.slice(0, n);
          list.head.data = list.head.data.slice(n);
        } else if (n === list.head.data.length) {
          ret = list.shift();
        } else {
          ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
        }
        return ret;
      }
      function copyFromBufferString(n, list) {
        var p = list.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                list.head = p.next;
              else
                list.head = list.tail = null;
            } else {
              list.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        list.length -= c;
        return ret;
      }
      function copyFromBuffer(n, list) {
        var ret = Buffer2.allocUnsafe(n);
        var p = list.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                list.head = p.next;
              else
                list.head = list.tail = null;
            } else {
              list.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        list.length -= c;
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        if (state.length > 0)
          throw new Error('"endReadable()" called on non-empty stream');
        if (!state.endEmitted) {
          state.ended = true;
          nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
        }
      }
      function forEach(xs, f) {
        for (var i = 0, l = xs.length; i < l; i++) {
          f(xs[i], i);
        }
      }
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
      Writable.WritableState = WritableState;
      inherits$1(Writable, EventEmitter);
      function nop() {
      }
      function WriteReq(chunk, encoding, cb) {
        this.chunk = chunk;
        this.encoding = encoding;
        this.callback = cb;
        this.next = null;
      }
      function WritableState(options, stream) {
        Object.defineProperty(this, "buffer", {
          get: deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
        });
        options = options || {};
        this.objectMode = !!options.objectMode;
        if (stream instanceof Duplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        var hwm = options.highWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
        this.highWaterMark = ~~this.highWaterMark;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function writableStateGetBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      function Writable(options) {
        if (!(this instanceof Writable) && !(this instanceof Duplex))
          return new Writable(options);
        this._writableState = new WritableState(options, this);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
        }
        EventEmitter.call(this);
      }
      Writable.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"));
      };
      function writeAfterEnd(stream, cb) {
        var er = new Error("write after end");
        stream.emit("error", er);
        nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var valid = true;
        var er = false;
        if (chunk === null) {
          er = new TypeError("May not write null values to stream");
        } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new TypeError("Invalid non-string/buffer chunk");
        }
        if (er) {
          stream.emit("error", er);
          nextTick(cb, er);
          valid = false;
        }
        return valid;
      }
      Writable.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (Buffer2.isBuffer(chunk))
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ended)
          writeAfterEnd(this, cb);
        else if (validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, chunk, encoding, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        var state = this._writableState;
        state.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new TypeError("Unknown encoding: " + encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      function decodeChunk(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer2.from(chunk, encoding);
        }
        return chunk;
      }
      function writeOrBuffer(stream, state, chunk, encoding, cb) {
        chunk = decodeChunk(state, chunk, encoding);
        if (Buffer2.isBuffer(chunk))
          encoding = "buffer";
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync)
          nextTick(cb, er);
        else
          cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        onwriteStateUpdate(state);
        if (er)
          onwriteError(stream, state, sync, er, cb);
        else {
          var finished = needFinish(state);
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            nextTick(afterWrite, stream, state, finished, cb);
          } else {
            afterWrite(stream, state, finished, cb);
          }
        }
      }
      function afterWrite(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          while (entry) {
            buffer[count] = entry;
            entry = entry.next;
            count += 1;
          }
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequestCount = 0;
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding, cb) {
        cb(new Error("not implemented"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending && !state.finished)
          endWritable(this, state, cb);
      };
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function prefinish(stream, state) {
        if (!state.prefinished) {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          if (state.pendingcb === 0) {
            prefinish(stream, state);
            state.finished = true;
            stream.emit("finish");
          } else {
            prefinish(stream, state);
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished)
            nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function(err) {
          var entry = _this.entry;
          _this.entry = null;
          while (entry) {
            var cb = entry.callback;
            state.pendingcb--;
            cb(err);
            entry = entry.next;
          }
          if (state.corkedRequestsFree) {
            state.corkedRequestsFree.next = _this;
          } else {
            state.corkedRequestsFree = _this;
          }
        };
      }
      inherits$1(Duplex, Readable);
      var keys = Object.keys(Writable.prototype);
      for (var v = 0; v < keys.length; v++) {
        var method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        if (options && options.readable === false)
          this.readable = false;
        if (options && options.writable === false)
          this.writable = false;
        this.allowHalfOpen = true;
        if (options && options.allowHalfOpen === false)
          this.allowHalfOpen = false;
        this.once("end", onend);
      }
      function onend() {
        if (this.allowHalfOpen || this._writableState.ended)
          return;
        nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      inherits$1(Transform, Duplex);
      function TransformState(stream) {
        this.afterTransform = function(er, data) {
          return afterTransform(stream, er, data);
        };
        this.needTransform = false;
        this.transforming = false;
        this.writecb = null;
        this.writechunk = null;
        this.writeencoding = null;
      }
      function afterTransform(stream, er, data) {
        var ts = stream._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (!cb)
          return stream.emit("error", new Error("no writecb in Transform class"));
        ts.writechunk = null;
        ts.writecb = null;
        if (data !== null && data !== void 0)
          stream.push(data);
        cb(er);
        var rs = stream._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          stream._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = new TransformState(this);
        var stream = this;
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.once("prefinish", function() {
          if (typeof this._flush === "function")
            this._flush(function(er) {
              done(stream, er);
            });
          else
            done(stream);
        });
      }
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        throw new Error("Not implemented");
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      function done(stream, er) {
        if (er)
          return stream.emit("error", er);
        var ws = stream._writableState;
        var ts = stream._transformState;
        if (ws.length)
          throw new Error("Calling transform done when ws.length != 0");
        if (ts.transforming)
          throw new Error("Calling transform done when still transforming");
        return stream.push(null);
      }
      inherits$1(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
      inherits$1(Stream, EventEmitter);
      Stream.Readable = Readable;
      Stream.Writable = Writable;
      Stream.Duplex = Duplex;
      Stream.Transform = Transform;
      Stream.PassThrough = PassThrough;
      Stream.Stream = Stream;
      function Stream() {
        EventEmitter.call(this);
      }
      Stream.prototype.pipe = function(dest, options) {
        var source = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (dest.write(chunk) === false && source.pause) {
              source.pause();
            }
          }
        }
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on("end", onend2);
          source.on("close", onclose);
        }
        var didOnEnd = false;
        function onend2() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          if (typeof dest.destroy === "function")
            dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (EventEmitter.listenerCount(this, "error") === 0) {
            throw er;
          }
        }
        source.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
          source.removeListener("data", ondata);
          dest.removeListener("drain", ondrain);
          source.removeListener("end", onend2);
          source.removeListener("close", onclose);
          source.removeListener("error", onerror);
          dest.removeListener("error", onerror);
          source.removeListener("end", cleanup);
          source.removeListener("close", cleanup);
          dest.removeListener("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
      };
      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance7, Constructor) {
        if (!(instance7 instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (typeof call === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _toArray(arr) {
        return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();
      }
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        }
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function _iterableToArray(iter) {
        if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
          return Array.from(iter);
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance");
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
      var _endianness;
      function endianness() {
        if (typeof _endianness === "undefined") {
          var a = new ArrayBuffer(2);
          var b = new Uint8Array(a);
          var c = new Uint16Array(a);
          b[0] = 1;
          b[1] = 2;
          if (c[0] === 258) {
            _endianness = "BE";
          } else if (c[0] === 513) {
            _endianness = "LE";
          } else {
            throw new Error("unable to figure out endianess");
          }
        }
        return _endianness;
      }
      function hostname() {
        if (typeof global$1.location !== "undefined") {
          return global$1.location.hostname;
        } else
          return "";
      }
      function loadavg() {
        return [];
      }
      function uptime() {
        return 0;
      }
      function freemem() {
        return Number.MAX_VALUE;
      }
      function totalmem() {
        return Number.MAX_VALUE;
      }
      function cpus() {
        return [];
      }
      function type() {
        return "Browser";
      }
      function release() {
        if (typeof global$1.navigator !== "undefined") {
          return global$1.navigator.appVersion;
        }
        return "";
      }
      function networkInterfaces() {
      }
      function getNetworkInterfaces() {
      }
      function tmpDir() {
        return "/tmp";
      }
      var tmpdir = tmpDir;
      var EOL = "\n";
      var os = {
        EOL,
        tmpdir,
        tmpDir,
        networkInterfaces,
        getNetworkInterfaces,
        release,
        type,
        cpus,
        totalmem,
        freemem,
        uptime,
        loadavg,
        hostname,
        endianness
      };
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      var FUNC_ERROR_TEXT = "Expected a function";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var INFINITY2 = 1 / 0;
      var funcTag = "[object Function]", genTag = "[object GeneratorFunction]", symbolTag = "[object Symbol]";
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reEscapeChar = /\\(\\)?/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      function isHostObject(value) {
        var result = false;
        if (value != null && typeof value.toString != "function") {
          try {
            result = !!(value + "");
          } catch (e) {
          }
        }
        return result;
      }
      var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      var funcToString = funcProto.toString;
      var hasOwnProperty$1 = objectProto.hasOwnProperty;
      var objectToString$1 = objectProto.toString;
      var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$1).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Symbol$1 = root.Symbol, splice = arrayProto.splice;
      var Map2 = getNative(root, "Map"), nativeCreate = getNative(Object, "create");
      var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
      function Hash(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
      }
      function hashDelete(key) {
        return this.has(key) && delete this.__data__[key];
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty$1.call(data, key) ? data[key] : void 0;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty$1.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        return getMapData(this, key)["delete"](key);
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        getMapData(this, key).set(key, value);
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq2(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseGet(object, path) {
        path = isKey(path, object) ? [path] : castPath(path);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : void 0;
      }
      function baseIsNative(value) {
        if (!isObject$1(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction$1(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
      }
      function castPath(value) {
        return isArray$2(value) ? value : stringToPath(value);
      }
      function getMapData(map3, key) {
        var data = map3.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      function isKey(value, object) {
        if (isArray$2(value)) {
          return false;
        }
        var type2 = typeof value;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      function isKeyable(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var stringToPath = memoize(function(string) {
        string = toString$1(string);
        var result = [];
        if (reLeadingDot.test(string)) {
          result.push("");
        }
        string.replace(rePropName, function(match, number, quote, string2) {
          result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result);
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      var isArray$2 = Array.isArray;
      function isFunction$1(value) {
        var tag = isObject$1(value) ? objectToString$1.call(value) : "";
        return tag == funcTag || tag == genTag;
      }
      function isObject$1(value) {
        var type2 = typeof value;
        return !!value && (type2 == "object" || type2 == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString$1.call(value) == symbolTag;
      }
      function toString$1(value) {
        return value == null ? "" : baseToString(value);
      }
      function get(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      var lodash_get = get;
      function getProp(obj, path, defaultValue) {
        return obj[path] === void 0 ? defaultValue : obj[path];
      }
      function setProp(obj, path, value) {
        var pathArray = Array.isArray(path) ? path : path.split(".");
        var _pathArray = _toArray(pathArray), key = _pathArray[0], restPath = _pathArray.slice(1);
        var newValue = pathArray.length > 1 ? setProp(obj[key] || {}, restPath, value) : value;
        return Object.assign({}, obj, _defineProperty({}, key, newValue));
      }
      function unsetProp(obj, path) {
        var pathArray = Array.isArray(path) ? path : path.split(".");
        var _pathArray2 = _toArray(pathArray), key = _pathArray2[0], restPath = _pathArray2.slice(1);
        if (_typeof(obj[key]) !== "object") {
          return obj;
        }
        if (pathArray.length === 1) {
          return Object.keys(obj).filter(function(prop) {
            return prop !== key;
          }).reduce(function(acc, prop) {
            return Object.assign(acc, _defineProperty({}, prop, obj[prop]));
          }, {});
        }
        return unsetProp(obj[key], restPath);
      }
      function flattenReducer(acc, arr) {
        try {
          acc.push.apply(acc, _toConsumableArray(arr));
          return acc;
        } catch (err) {
          return acc.concat(arr);
        }
      }
      function fastJoin(arr, separator) {
        var isFirst = true;
        return arr.reduce(function(acc, elem) {
          if (elem === null || elem === void 0) {
            elem = "";
          }
          if (isFirst) {
            isFirst = false;
            return "".concat(elem);
          }
          return "".concat(acc).concat(separator).concat(elem);
        }, "");
      }
      var utils = {
        getProp,
        setProp,
        unsetProp,
        fastJoin,
        flattenReducer
      };
      var getProp$1 = utils.getProp, fastJoin$1 = utils.fastJoin, flattenReducer$1 = utils.flattenReducer;
      var JSON2CSVBase = /* @__PURE__ */ function() {
        function JSON2CSVBase2(opts) {
          _classCallCheck(this, JSON2CSVBase2);
          this.opts = this.preprocessOpts(opts);
        }
        _createClass(JSON2CSVBase2, [{
          key: "preprocessOpts",
          value: function preprocessOpts(opts) {
            var processedOpts = Object.assign({}, opts);
            processedOpts.transforms = !Array.isArray(processedOpts.transforms) ? processedOpts.transforms ? [processedOpts.transforms] : [] : processedOpts.transforms;
            processedOpts.delimiter = processedOpts.delimiter || ",";
            processedOpts.eol = processedOpts.eol || os.EOL;
            processedOpts.quote = typeof processedOpts.quote === "string" ? processedOpts.quote : '"';
            processedOpts.escapedQuote = typeof processedOpts.escapedQuote === "string" ? processedOpts.escapedQuote : "".concat(processedOpts.quote).concat(processedOpts.quote);
            processedOpts.header = processedOpts.header !== false;
            processedOpts.includeEmptyRows = processedOpts.includeEmptyRows || false;
            processedOpts.withBOM = processedOpts.withBOM || false;
            return processedOpts;
          }
        }, {
          key: "preprocessFieldsInfo",
          value: function preprocessFieldsInfo(fields) {
            var _this = this;
            return fields.map(function(fieldInfo) {
              if (typeof fieldInfo === "string") {
                return {
                  label: fieldInfo,
                  value: fieldInfo.includes(".") || fieldInfo.includes("[") ? function(row) {
                    return lodash_get(row, fieldInfo, _this.opts.defaultValue);
                  } : function(row) {
                    return getProp$1(row, fieldInfo, _this.opts.defaultValue);
                  }
                };
              }
              if (_typeof(fieldInfo) === "object") {
                var defaultValue = "default" in fieldInfo ? fieldInfo.default : _this.opts.defaultValue;
                if (typeof fieldInfo.value === "string") {
                  return {
                    label: fieldInfo.label || fieldInfo.value,
                    value: fieldInfo.value.includes(".") || fieldInfo.value.includes("[") ? function(row) {
                      return lodash_get(row, fieldInfo.value, defaultValue);
                    } : function(row) {
                      return getProp$1(row, fieldInfo.value, defaultValue);
                    }
                  };
                }
                if (typeof fieldInfo.value === "function") {
                  var label = fieldInfo.label || fieldInfo.value.name || "";
                  var field = {
                    label,
                    default: defaultValue
                  };
                  return {
                    label,
                    value: function value(row) {
                      var value2 = fieldInfo.value(row, field);
                      return value2 === null || value2 === void 0 ? defaultValue : value2;
                    }
                  };
                }
              }
              throw new Error("Invalid field info option. " + JSON.stringify(fieldInfo));
            });
          }
        }, {
          key: "getHeader",
          value: function getHeader() {
            var _this2 = this;
            return fastJoin$1(this.opts.fields.map(function(fieldInfo) {
              return _this2.processValue(fieldInfo.label);
            }), this.opts.delimiter);
          }
        }, {
          key: "preprocessRow",
          value: function preprocessRow(row) {
            return this.opts.transforms.reduce(function(rows, transform) {
              return rows.map(function(row2) {
                return transform(row2);
              }).reduce(flattenReducer$1, []);
            }, [row]);
          }
        }, {
          key: "processRow",
          value: function processRow(row) {
            var _this3 = this;
            if (!row) {
              return void 0;
            }
            var processedRow = this.opts.fields.map(function(fieldInfo) {
              return _this3.processCell(row, fieldInfo);
            });
            if (!this.opts.includeEmptyRows && processedRow.every(function(field) {
              return field === void 0;
            })) {
              return void 0;
            }
            return fastJoin$1(processedRow, this.opts.delimiter);
          }
        }, {
          key: "processCell",
          value: function processCell(row, fieldInfo) {
            return this.processValue(fieldInfo.value(row));
          }
        }, {
          key: "processValue",
          value: function processValue(value) {
            if (value === null || value === void 0) {
              return void 0;
            }
            var valueType = _typeof(value);
            if (valueType !== "boolean" && valueType !== "number" && valueType !== "string") {
              value = JSON.stringify(value);
              if (value === void 0) {
                return void 0;
              }
              if (value[0] === '"') {
                value = value.replace(/^"(.+)"$/, "$1");
              }
            }
            if (typeof value === "string") {
              if (this.opts.excelStrings) {
                if (value.includes(this.opts.quote)) {
                  value = value.replace(new RegExp(this.opts.quote, "g"), "".concat(this.opts.escapedQuote).concat(this.opts.escapedQuote));
                }
                value = '"=""'.concat(value, '"""');
              } else {
                if (value.includes(this.opts.quote)) {
                  value = value.replace(new RegExp(this.opts.quote, "g"), this.opts.escapedQuote);
                }
                value = "".concat(this.opts.quote).concat(value).concat(this.opts.quote);
              }
            }
            return value;
          }
        }]);
        return JSON2CSVBase2;
      }();
      var JSON2CSVBase_1 = JSON2CSVBase;
      var fastJoin$2 = utils.fastJoin, flattenReducer$2 = utils.flattenReducer;
      var JSON2CSVParser = /* @__PURE__ */ function(_JSON2CSVBase) {
        _inherits(JSON2CSVParser2, _JSON2CSVBase);
        function JSON2CSVParser2(opts) {
          var _this;
          _classCallCheck(this, JSON2CSVParser2);
          _this = _possibleConstructorReturn(this, _getPrototypeOf(JSON2CSVParser2).call(this, opts));
          if (_this.opts.fields) {
            _this.opts.fields = _this.preprocessFieldsInfo(_this.opts.fields);
          }
          return _this;
        }
        _createClass(JSON2CSVParser2, [{
          key: "parse",
          value: function parse3(data) {
            var processedData = this.preprocessData(data);
            if (!this.opts.fields) {
              this.opts.fields = processedData.reduce(function(fields, item) {
                Object.keys(item).forEach(function(field) {
                  if (!fields.includes(field)) {
                    fields.push(field);
                  }
                });
                return fields;
              }, []);
              this.opts.fields = this.preprocessFieldsInfo(this.opts.fields);
            }
            var header = this.opts.header ? this.getHeader() : "";
            var rows = this.processData(processedData);
            var csv = (this.opts.withBOM ? "\uFEFF" : "") + header + (header && rows ? this.opts.eol : "") + rows;
            return csv;
          }
        }, {
          key: "preprocessData",
          value: function preprocessData(data) {
            var _this2 = this;
            var processedData = Array.isArray(data) ? data : [data];
            if (!this.opts.fields && (processedData.length === 0 || _typeof(processedData[0]) !== "object")) {
              throw new Error('Data should not be empty or the "fields" option should be included');
            }
            if (this.opts.transforms.length === 0)
              return processedData;
            return processedData.map(function(row) {
              return _this2.preprocessRow(row);
            }).reduce(flattenReducer$2, []);
          }
        }, {
          key: "processData",
          value: function processData(data) {
            var _this3 = this;
            return fastJoin$2(data.map(function(row) {
              return _this3.processRow(row);
            }).filter(function(row) {
              return row;
            }), this.opts.eol);
          }
        }]);
        return JSON2CSVParser2;
      }(JSON2CSVBase_1);
      var JSON2CSVParser_1 = JSON2CSVParser;
      var C = {};
      var LEFT_BRACE = C.LEFT_BRACE = 1;
      var RIGHT_BRACE = C.RIGHT_BRACE = 2;
      var LEFT_BRACKET = C.LEFT_BRACKET = 3;
      var RIGHT_BRACKET = C.RIGHT_BRACKET = 4;
      var COLON = C.COLON = 5;
      var COMMA = C.COMMA = 6;
      var TRUE = C.TRUE = 7;
      var FALSE = C.FALSE = 8;
      var NULL = C.NULL = 9;
      var STRING = C.STRING = 10;
      var NUMBER = C.NUMBER = 11;
      var START = C.START = 17;
      var STOP = C.STOP = 18;
      var TRUE1 = C.TRUE1 = 33;
      var TRUE2 = C.TRUE2 = 34;
      var TRUE3 = C.TRUE3 = 35;
      var FALSE1 = C.FALSE1 = 49;
      var FALSE2 = C.FALSE2 = 50;
      var FALSE3 = C.FALSE3 = 51;
      var FALSE4 = C.FALSE4 = 52;
      var NULL1 = C.NULL1 = 65;
      var NULL2 = C.NULL2 = 66;
      var NULL3 = C.NULL3 = 67;
      var NUMBER1 = C.NUMBER1 = 81;
      var NUMBER3 = C.NUMBER3 = 83;
      var STRING1 = C.STRING1 = 97;
      var STRING2 = C.STRING2 = 98;
      var STRING3 = C.STRING3 = 99;
      var STRING4 = C.STRING4 = 100;
      var STRING5 = C.STRING5 = 101;
      var STRING6 = C.STRING6 = 102;
      var VALUE = C.VALUE = 113;
      var KEY = C.KEY = 114;
      var OBJECT = C.OBJECT = 129;
      var ARRAY = C.ARRAY = 130;
      var BACK_SLASH = "\\".charCodeAt(0);
      var FORWARD_SLASH = "/".charCodeAt(0);
      var BACKSPACE = "\b".charCodeAt(0);
      var FORM_FEED = "\f".charCodeAt(0);
      var NEWLINE = "\n".charCodeAt(0);
      var CARRIAGE_RETURN = "\r".charCodeAt(0);
      var TAB = "	".charCodeAt(0);
      var STRING_BUFFER_SIZE = 64 * 1024;
      function Parser2() {
        this.tState = START;
        this.value = void 0;
        this.string = void 0;
        this.stringBuffer = Buffer2.alloc ? Buffer2.alloc(STRING_BUFFER_SIZE) : new Buffer2(STRING_BUFFER_SIZE);
        this.stringBufferOffset = 0;
        this.unicode = void 0;
        this.highSurrogate = void 0;
        this.key = void 0;
        this.mode = void 0;
        this.stack = [];
        this.state = VALUE;
        this.bytes_remaining = 0;
        this.bytes_in_sequence = 0;
        this.temp_buffs = { "2": new Buffer2(2), "3": new Buffer2(3), "4": new Buffer2(4) };
        this.offset = -1;
      }
      Parser2.toknam = function(code) {
        var keys2 = Object.keys(C);
        for (var i = 0, l = keys2.length; i < l; i++) {
          var key = keys2[i];
          if (C[key] === code) {
            return key;
          }
        }
        return code && "0x" + code.toString(16);
      };
      var proto = Parser2.prototype;
      proto.onError = function(err) {
        throw err;
      };
      proto.charError = function(buffer, i) {
        this.tState = STOP;
        this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(buffer[i])) + " at position " + i + " in state " + Parser2.toknam(this.tState)));
      };
      proto.appendStringChar = function(char) {
        if (this.stringBufferOffset >= STRING_BUFFER_SIZE) {
          this.string += this.stringBuffer.toString("utf8");
          this.stringBufferOffset = 0;
        }
        this.stringBuffer[this.stringBufferOffset++] = char;
      };
      proto.appendStringBuf = function(buf, start, end) {
        var size = buf.length;
        if (typeof start === "number") {
          if (typeof end === "number") {
            if (end < 0) {
              size = buf.length - start + end;
            } else {
              size = end - start;
            }
          } else {
            size = buf.length - start;
          }
        }
        if (size < 0) {
          size = 0;
        }
        if (this.stringBufferOffset + size > STRING_BUFFER_SIZE) {
          this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset);
          this.stringBufferOffset = 0;
        }
        buf.copy(this.stringBuffer, this.stringBufferOffset, start, end);
        this.stringBufferOffset += size;
      };
      proto.write = function(buffer) {
        if (typeof buffer === "string")
          buffer = new Buffer2(buffer);
        var n;
        for (var i = 0, l = buffer.length; i < l; i++) {
          if (this.tState === START) {
            n = buffer[i];
            this.offset++;
            if (n === 123) {
              this.onToken(LEFT_BRACE, "{");
            } else if (n === 125) {
              this.onToken(RIGHT_BRACE, "}");
            } else if (n === 91) {
              this.onToken(LEFT_BRACKET, "[");
            } else if (n === 93) {
              this.onToken(RIGHT_BRACKET, "]");
            } else if (n === 58) {
              this.onToken(COLON, ":");
            } else if (n === 44) {
              this.onToken(COMMA, ",");
            } else if (n === 116) {
              this.tState = TRUE1;
            } else if (n === 102) {
              this.tState = FALSE1;
            } else if (n === 110) {
              this.tState = NULL1;
            } else if (n === 34) {
              this.string = "";
              this.stringBufferOffset = 0;
              this.tState = STRING1;
            } else if (n === 45) {
              this.string = "-";
              this.tState = NUMBER1;
            } else {
              if (n >= 48 && n < 64) {
                this.string = String.fromCharCode(n);
                this.tState = NUMBER3;
              } else if (n === 32 || n === 9 || n === 10 || n === 13)
                ;
              else {
                return this.charError(buffer, i);
              }
            }
          } else if (this.tState === STRING1) {
            n = buffer[i];
            if (this.bytes_remaining > 0) {
              for (var j = 0; j < this.bytes_remaining; j++) {
                this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];
              }
              this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]);
              this.bytes_in_sequence = this.bytes_remaining = 0;
              i = i + j - 1;
            } else if (this.bytes_remaining === 0 && n >= 128) {
              if (n <= 193 || n > 244) {
                return this.onError(new Error("Invalid UTF-8 character at position " + i + " in state " + Parser2.toknam(this.tState)));
              }
              if (n >= 194 && n <= 223)
                this.bytes_in_sequence = 2;
              if (n >= 224 && n <= 239)
                this.bytes_in_sequence = 3;
              if (n >= 240 && n <= 244)
                this.bytes_in_sequence = 4;
              if (this.bytes_in_sequence + i > buffer.length) {
                for (var k = 0; k <= buffer.length - 1 - i; k++) {
                  this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k];
                }
                this.bytes_remaining = i + this.bytes_in_sequence - buffer.length;
                i = buffer.length - 1;
              } else {
                this.appendStringBuf(buffer, i, i + this.bytes_in_sequence);
                i = i + this.bytes_in_sequence - 1;
              }
            } else if (n === 34) {
              this.tState = START;
              this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset);
              this.stringBufferOffset = 0;
              this.onToken(STRING, this.string);
              this.offset += Buffer2.byteLength(this.string, "utf8") + 1;
              this.string = void 0;
            } else if (n === 92) {
              this.tState = STRING2;
            } else if (n >= 32) {
              this.appendStringChar(n);
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === STRING2) {
            n = buffer[i];
            if (n === 34) {
              this.appendStringChar(n);
              this.tState = STRING1;
            } else if (n === 92) {
              this.appendStringChar(BACK_SLASH);
              this.tState = STRING1;
            } else if (n === 47) {
              this.appendStringChar(FORWARD_SLASH);
              this.tState = STRING1;
            } else if (n === 98) {
              this.appendStringChar(BACKSPACE);
              this.tState = STRING1;
            } else if (n === 102) {
              this.appendStringChar(FORM_FEED);
              this.tState = STRING1;
            } else if (n === 110) {
              this.appendStringChar(NEWLINE);
              this.tState = STRING1;
            } else if (n === 114) {
              this.appendStringChar(CARRIAGE_RETURN);
              this.tState = STRING1;
            } else if (n === 116) {
              this.appendStringChar(TAB);
              this.tState = STRING1;
            } else if (n === 117) {
              this.unicode = "";
              this.tState = STRING3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6) {
            n = buffer[i];
            if (n >= 48 && n < 64 || n > 64 && n <= 70 || n > 96 && n <= 102) {
              this.unicode += String.fromCharCode(n);
              if (this.tState++ === STRING6) {
                var intVal = parseInt(this.unicode, 16);
                this.unicode = void 0;
                if (this.highSurrogate !== void 0 && intVal >= 56320 && intVal < 57343 + 1) {
                  this.appendStringBuf(new Buffer2(String.fromCharCode(this.highSurrogate, intVal)));
                  this.highSurrogate = void 0;
                } else if (this.highSurrogate === void 0 && intVal >= 55296 && intVal < 56319 + 1) {
                  this.highSurrogate = intVal;
                } else {
                  if (this.highSurrogate !== void 0) {
                    this.appendStringBuf(new Buffer2(String.fromCharCode(this.highSurrogate)));
                    this.highSurrogate = void 0;
                  }
                  this.appendStringBuf(new Buffer2(String.fromCharCode(intVal)));
                }
                this.tState = STRING1;
              }
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NUMBER1 || this.tState === NUMBER3) {
            n = buffer[i];
            switch (n) {
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
              case 46:
              case 101:
              case 69:
              case 43:
              case 45:
                this.string += String.fromCharCode(n);
                this.tState = NUMBER3;
                break;
              default:
                this.tState = START;
                var result = Number(this.string);
                if (isNaN(result)) {
                  return this.charError(buffer, i);
                }
                if (this.string.match(/[0-9]+/) == this.string && result.toString() != this.string) {
                  this.onToken(STRING, this.string);
                } else {
                  this.onToken(NUMBER, result);
                }
                this.offset += this.string.length - 1;
                this.string = void 0;
                i--;
                break;
            }
          } else if (this.tState === TRUE1) {
            if (buffer[i] === 114) {
              this.tState = TRUE2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === TRUE2) {
            if (buffer[i] === 117) {
              this.tState = TRUE3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === TRUE3) {
            if (buffer[i] === 101) {
              this.tState = START;
              this.onToken(TRUE, true);
              this.offset += 3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE1) {
            if (buffer[i] === 97) {
              this.tState = FALSE2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE2) {
            if (buffer[i] === 108) {
              this.tState = FALSE3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE3) {
            if (buffer[i] === 115) {
              this.tState = FALSE4;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE4) {
            if (buffer[i] === 101) {
              this.tState = START;
              this.onToken(FALSE, false);
              this.offset += 4;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL1) {
            if (buffer[i] === 117) {
              this.tState = NULL2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL2) {
            if (buffer[i] === 108) {
              this.tState = NULL3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL3) {
            if (buffer[i] === 108) {
              this.tState = START;
              this.onToken(NULL, null);
              this.offset += 3;
            } else {
              return this.charError(buffer, i);
            }
          }
        }
      };
      proto.onToken = function(token, value) {
      };
      proto.parseError = function(token, value) {
        this.tState = STOP;
        this.onError(new Error("Unexpected " + Parser2.toknam(token) + (value ? "(" + JSON.stringify(value) + ")" : "") + " in state " + Parser2.toknam(this.state)));
      };
      proto.push = function() {
        this.stack.push({ value: this.value, key: this.key, mode: this.mode });
      };
      proto.pop = function() {
        var value = this.value;
        var parent = this.stack.pop();
        this.value = parent.value;
        this.key = parent.key;
        this.mode = parent.mode;
        this.emit(value);
        if (!this.mode) {
          this.state = VALUE;
        }
      };
      proto.emit = function(value) {
        if (this.mode) {
          this.state = COMMA;
        }
        this.onValue(value);
      };
      proto.onValue = function(value) {
      };
      proto.onToken = function(token, value) {
        if (this.state === VALUE) {
          if (token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL) {
            if (this.value) {
              this.value[this.key] = value;
            }
            this.emit(value);
          } else if (token === LEFT_BRACE) {
            this.push();
            if (this.value) {
              this.value = this.value[this.key] = {};
            } else {
              this.value = {};
            }
            this.key = void 0;
            this.state = KEY;
            this.mode = OBJECT;
          } else if (token === LEFT_BRACKET) {
            this.push();
            if (this.value) {
              this.value = this.value[this.key] = [];
            } else {
              this.value = [];
            }
            this.key = 0;
            this.mode = ARRAY;
            this.state = VALUE;
          } else if (token === RIGHT_BRACE) {
            if (this.mode === OBJECT) {
              this.pop();
            } else {
              return this.parseError(token, value);
            }
          } else if (token === RIGHT_BRACKET) {
            if (this.mode === ARRAY) {
              this.pop();
            } else {
              return this.parseError(token, value);
            }
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === KEY) {
          if (token === STRING) {
            this.key = value;
            this.state = COLON;
          } else if (token === RIGHT_BRACE) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === COLON) {
          if (token === COLON) {
            this.state = VALUE;
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === COMMA) {
          if (token === COMMA) {
            if (this.mode === ARRAY) {
              this.key++;
              this.state = VALUE;
            } else if (this.mode === OBJECT) {
              this.state = KEY;
            }
          } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else {
          return this.parseError(token, value);
        }
      };
      Parser2.C = C;
      var jsonparse = Parser2;
      var Transform$1 = Stream.Transform;
      var JSON2CSVTransform = /* @__PURE__ */ function(_Transform) {
        _inherits(JSON2CSVTransform2, _Transform);
        function JSON2CSVTransform2(opts, transformOpts) {
          var _this;
          _classCallCheck(this, JSON2CSVTransform2);
          _this = _possibleConstructorReturn(this, _getPrototypeOf(JSON2CSVTransform2).call(this, transformOpts));
          Object.getOwnPropertyNames(JSON2CSVBase_1.prototype).forEach(function(key) {
            return _this[key] = JSON2CSVBase_1.prototype[key];
          });
          _this.opts = _this.preprocessOpts(opts);
          _this._data = "";
          _this._hasWritten = false;
          if (_this._readableState.objectMode) {
            _this.initObjectModeParse();
          } else if (_this.opts.ndjson) {
            _this.initNDJSONParse();
          } else {
            _this.initJSONParser();
          }
          if (_this.opts.withBOM) {
            _this.push("\uFEFF");
          }
          if (_this.opts.fields) {
            _this.opts.fields = _this.preprocessFieldsInfo(_this.opts.fields);
            _this.pushHeader();
          }
          return _this;
        }
        _createClass(JSON2CSVTransform2, [{
          key: "initObjectModeParse",
          value: function initObjectModeParse() {
            var transform = this;
            this.parser = {
              write: function write2(line) {
                transform.pushLine(line);
              },
              getPendingData: function getPendingData() {
                return void 0;
              }
            };
          }
        }, {
          key: "initNDJSONParse",
          value: function initNDJSONParse() {
            var transform = this;
            this.parser = {
              _data: "",
              write: function write2(chunk) {
                this._data += chunk.toString();
                var lines = this._data.split("\n").map(function(line) {
                  return line.trim();
                }).filter(function(line) {
                  return line !== "";
                });
                var pendingData = false;
                lines.forEach(function(line, i) {
                  try {
                    transform.pushLine(JSON.parse(line));
                  } catch (e) {
                    if (i === lines.length - 1) {
                      pendingData = true;
                    } else {
                      e.message = "Invalid JSON (".concat(line, ")");
                      transform.emit("error", e);
                    }
                  }
                });
                this._data = pendingData ? this._data.slice(this._data.lastIndexOf("\n")) : "";
              },
              getPendingData: function getPendingData() {
                return this._data;
              }
            };
          }
        }, {
          key: "initJSONParser",
          value: function initJSONParser() {
            var transform = this;
            this.parser = new jsonparse();
            this.parser.onValue = function(value) {
              if (this.stack.length !== this.depthToEmit)
                return;
              transform.pushLine(value);
            };
            this.parser._onToken = this.parser.onToken;
            this.parser.onToken = function(token, value) {
              transform.parser._onToken(token, value);
              if (this.stack.length === 0 && !transform.opts.fields && this.mode !== jsonparse.C.ARRAY && this.mode !== jsonparse.C.OBJECT) {
                this.onError(new Error('Data should not be empty or the "fields" option should be included'));
              }
              if (this.stack.length === 1) {
                if (this.depthToEmit === void 0) {
                  this.depthToEmit = this.mode === jsonparse.C.ARRAY ? 1 : 0;
                }
                if (this.depthToEmit !== 0 && this.stack.length === 1) {
                  this.value = void 0;
                }
              }
            };
            this.parser.getPendingData = function() {
              return this.value;
            };
            this.parser.onError = function(err) {
              if (err.message.includes("Unexpected")) {
                err.message = "Invalid JSON (".concat(err.message, ")");
              }
              transform.emit("error", err);
            };
          }
        }, {
          key: "_transform",
          value: function _transform(chunk, encoding, done2) {
            this.parser.write(chunk);
            done2();
          }
        }, {
          key: "_flush",
          value: function _flush(done2) {
            if (this.parser.getPendingData()) {
              done2(new Error("Invalid data received from stdin", this.parser.getPendingData()));
            }
            done2();
          }
        }, {
          key: "pushHeader",
          value: function pushHeader() {
            if (this.opts.header) {
              var header = this.getHeader();
              this.emit("header", header);
              this.push(header);
              this._hasWritten = true;
            }
          }
        }, {
          key: "pushLine",
          value: function pushLine(data) {
            var _this2 = this;
            var processedData = this.preprocessRow(data);
            if (!this._hasWritten) {
              this.opts.fields = this.opts.fields || this.preprocessFieldsInfo(Object.keys(processedData[0]));
              this.pushHeader();
            }
            processedData.forEach(function(row) {
              var line = _this2.processRow(row, _this2.opts);
              if (line === void 0)
                return;
              _this2.emit("line", line);
              _this2.push(_this2._hasWritten ? _this2.opts.eol + line : line);
              _this2._hasWritten = true;
            });
          }
        }]);
        return JSON2CSVTransform2;
      }(Transform$1);
      var JSON2CSVTransform_1 = JSON2CSVTransform;
      var Transform$2 = Stream.Transform;
      var fastJoin$3 = utils.fastJoin;
      var JSON2CSVAsyncParser = /* @__PURE__ */ function() {
        function JSON2CSVAsyncParser2(opts, transformOpts) {
          _classCallCheck(this, JSON2CSVAsyncParser2);
          this.input = new Transform$2(transformOpts);
          this.input._read = function() {
          };
          this.transform = new JSON2CSVTransform_1(opts, transformOpts);
          this.processor = this.input.pipe(this.transform);
        }
        _createClass(JSON2CSVAsyncParser2, [{
          key: "fromInput",
          value: function fromInput(input) {
            if (this._input) {
              throw new Error("Async parser already has an input.");
            }
            this._input = input;
            this.input = this._input.pipe(this.processor);
            return this;
          }
        }, {
          key: "throughTransform",
          value: function throughTransform(transform) {
            if (this._output) {
              throw new Error("Can't add transforms once an output has been added.");
            }
            this.processor = this.processor.pipe(transform);
            return this;
          }
        }, {
          key: "toOutput",
          value: function toOutput(output) {
            if (this._output) {
              throw new Error("Async parser already has an output.");
            }
            this._output = output;
            this.processor = this.processor.pipe(output);
            return this;
          }
        }, {
          key: "promise",
          value: function promise() {
            var _this = this;
            var returnCSV = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
            return new Promise(function(resolve2, reject) {
              if (!returnCSV) {
                _this.processor.on("finish", function() {
                  return resolve2();
                }).on("error", function(err) {
                  return reject(err);
                });
                return;
              }
              var csvBuffer = [];
              _this.processor.on("data", function(chunk) {
                return csvBuffer.push(chunk.toString());
              }).on("finish", function() {
                return resolve2(fastJoin$3(csvBuffer, ""));
              }).on("error", function(err) {
                return reject(err);
              });
            });
          }
        }]);
        return JSON2CSVAsyncParser2;
      }();
      var JSON2CSVAsyncParser_1 = JSON2CSVAsyncParser;
      function flatten() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$objects = _ref.objects, objects = _ref$objects === void 0 ? true : _ref$objects, _ref$arrays = _ref.arrays, arrays = _ref$arrays === void 0 ? false : _ref$arrays, _ref$separator = _ref.separator, separator = _ref$separator === void 0 ? "." : _ref$separator;
        function step(obj, flatDataRow, currentPath) {
          Object.keys(obj).forEach(function(key) {
            var newPath = currentPath ? "".concat(currentPath).concat(separator).concat(key) : key;
            var value = obj[key];
            if (objects && _typeof(value) === "object" && value !== null && !Array.isArray(value) && Object.prototype.toString.call(value.toJSON) !== "[object Function]" && Object.keys(value).length) {
              step(value, flatDataRow, newPath);
              return;
            }
            if (arrays && Array.isArray(value)) {
              step(value, flatDataRow, newPath);
              return;
            }
            flatDataRow[newPath] = value;
          });
          return flatDataRow;
        }
        return function(dataRow) {
          return step(dataRow, {});
        };
      }
      var flatten_1 = flatten;
      var setProp$1 = utils.setProp, unsetProp$1 = utils.unsetProp, flattenReducer$3 = utils.flattenReducer;
      function getUnwindablePaths(obj, currentPath) {
        return Object.keys(obj).reduce(function(unwindablePaths, key) {
          var newPath = currentPath ? "".concat(currentPath, ".").concat(key) : key;
          var value = obj[key];
          if (_typeof(value) === "object" && value !== null && !Array.isArray(value) && Object.prototype.toString.call(value.toJSON) !== "[object Function]" && Object.keys(value).length) {
            unwindablePaths = unwindablePaths.concat(getUnwindablePaths(value, newPath));
          } else if (Array.isArray(value)) {
            unwindablePaths.push(newPath);
            unwindablePaths = unwindablePaths.concat(value.map(function(arrObj) {
              return getUnwindablePaths(arrObj, newPath);
            }).reduce(flattenReducer$3, []).filter(function(item, index, arr) {
              return arr.indexOf(item) !== index;
            }));
          }
          return unwindablePaths;
        }, []);
      }
      function unwind() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$paths = _ref.paths, paths = _ref$paths === void 0 ? void 0 : _ref$paths, _ref$blankOut = _ref.blankOut, blankOut = _ref$blankOut === void 0 ? false : _ref$blankOut;
        function unwindReducer(rows, unwindPath) {
          return rows.map(function(row) {
            var unwindArray = lodash_get(row, unwindPath);
            if (!Array.isArray(unwindArray)) {
              return row;
            }
            if (!unwindArray.length) {
              return unsetProp$1(row, unwindPath);
            }
            return unwindArray.map(function(unwindRow, index) {
              var clonedRow = blankOut && index > 0 ? {} : row;
              return setProp$1(clonedRow, unwindPath, unwindRow);
            });
          }).reduce(flattenReducer$3, []);
        }
        paths = Array.isArray(paths) ? paths : paths ? [paths] : void 0;
        return function(dataRow) {
          return (paths || getUnwindablePaths(dataRow)).reduce(unwindReducer, [dataRow]);
        };
      }
      var unwind_1 = unwind;
      var Readable$1 = Stream.Readable;
      var Parser$1 = JSON2CSVParser_1;
      var AsyncParser = JSON2CSVAsyncParser_1;
      var Transform$3 = JSON2CSVTransform_1;
      var parse2 = function parse3(data, opts) {
        return new JSON2CSVParser_1(opts).parse(data);
      };
      var parseAsync = function parseAsync2(data, opts, transformOpts) {
        try {
          if (!(data instanceof Readable$1)) {
            transformOpts = Object.assign({}, transformOpts, {
              objectMode: true
            });
          }
          var asyncParser = new JSON2CSVAsyncParser_1(opts, transformOpts);
          var promise = asyncParser.promise();
          if (Array.isArray(data)) {
            data.forEach(function(item) {
              return asyncParser.input.push(item);
            });
            asyncParser.input.push(null);
          } else if (data instanceof Readable$1) {
            asyncParser.fromInput(data);
          } else {
            asyncParser.input.push(data);
            asyncParser.input.push(null);
          }
          return promise;
        } catch (err) {
          return Promise.reject(err);
        }
      };
      var transforms2 = {
        flatten: flatten_1,
        unwind: unwind_1
      };
      var json2csv = {
        Parser: Parser$1,
        AsyncParser,
        Transform: Transform$3,
        parse: parse2,
        parseAsync,
        transforms: transforms2
      };
      exports2.AsyncParser = AsyncParser;
      exports2.Parser = Parser$1;
      exports2.Transform = Transform$3;
      exports2.default = json2csv;
      exports2.parse = parse2;
      exports2.parseAsync = parseAsync;
      exports2.transforms = transforms2;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/obsidian-dataview/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-dataview/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DATAVIEW_PLACEHOLDER_VALUE = null;
    exports.DATAVIEW_PLACEHOLDER_VALUE = DATAVIEW_PLACEHOLDER_VALUE;
  }
});

// src/main.ts
__export(exports, {
  default: () => DataAnalysisPlugin
});
var import_luxon2 = __toModule(require_luxon());
var import_json2csv = __toModule(require_json2csv_umd());
var import_obsidian4 = __toModule(require("obsidian"));

// src/ChartModal.ts
var import_obsidian = __toModule(require("obsidian"));

// node_modules/svelte/internal/index.mjs
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
var tasks = new Set();
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_attributes(node, attributes) {
  const descriptors2 = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors2[key] && descriptors2[key].set) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function get_binding_group_value(group, __value, checked) {
  const value = new Set();
  for (let i = 0; i < group.length; i += 1) {
    if (group[i].checked)
      value.add(group[i].__value);
  }
  if (!checked) {
    value.delete(__value);
  }
  return Array.from(value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function select_option(select, value) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  select.selectedIndex = -1;
}
function select_value(select) {
  const selected_option = select.querySelector(":checked") || select.options[0];
  return selected_option && selected_option.__value;
}
var active_docs = new Set();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback2 = render_callbacks[i];
      if (!seen_callbacks.has(callback2)) {
        seen_callbacks.add(callback2);
        callback2();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = new Set();
var outros;
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback2) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback2) {
        if (detach2)
          block.d(1);
        callback2();
      }
    });
    block.o(local);
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
function bind(component, name, callback2) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback2;
    callback2(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance7, create_fragment7, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment7 ? create_fragment7($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback2) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback2);
      return () => {
        const index = callbacks.indexOf(callback2);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback2) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback2);
    return () => {
      const index = callbacks.indexOf(callback2);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// src/Components/Checkboxes.svelte
function add_css(target) {
  append_styles(target, "svelte-1ikdg1z", ".grid.svelte-1ikdg1z{display:grid;grid-template-columns:repeat(auto-fit, minmax(100px, 1fr))}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let div;
  let label;
  let input;
  let input_value_value;
  let t0;
  let t1_value = ctx[7] + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      label = element("label");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(input, "type", "checkbox");
      input.__value = input_value_value = ctx[7];
      input.value = input.__value;
      ctx[6][0].push(input);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, input);
      input.checked = ~ctx[0].indexOf(input.__value);
      append(label, t0);
      append(label, t1);
      append(div, t2);
      if (!mounted) {
        dispose = listen(input, "change", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input_value_value !== (input_value_value = ctx2[7])) {
        input.__value = input_value_value;
        input.value = input.__value;
      }
      if (dirty & 1) {
        input.checked = ~ctx2[0].indexOf(input.__value);
      }
      if (dirty & 2 && t1_value !== (t1_value = ctx2[7] + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[6][0].splice(ctx[6][0].indexOf(input), 1);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment(ctx) {
  let div0;
  let button;
  let t0_value = (ctx[2] ? "None" : "All") + "";
  let t0;
  let t1;
  let div1;
  let mounted;
  let dispose;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div0 = element("div");
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div1, "class", "grid svelte-1ikdg1z");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, button);
      append(button, t0);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4 && t0_value !== (t0_value = (ctx2[2] ? "None" : "All") + ""))
        set_data(t0, t0_value);
      if (dirty & 3) {
        each_value = ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let { options } = $$props;
  let { selected } = $$props;
  let toNone = selected.length === 0 ? false : true;
  const $$binding_groups = [[]];
  const click_handler = async () => {
    if (toNone)
      $$invalidate(0, selected = []);
    else
      $$invalidate(0, selected = options);
  };
  function input_change_handler() {
    selected = get_binding_group_value($$binding_groups[0], this.__value, this.checked);
    $$invalidate(0, selected);
  }
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(3, plugin = $$props2.plugin);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(2, toNone = selected.length === 0 ? false : true);
    }
  };
  return [
    selected,
    options,
    toNone,
    plugin,
    click_handler,
    input_change_handler,
    $$binding_groups
  ];
}
var Checkboxes = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { plugin: 3, options: 1, selected: 0 }, add_css);
  }
};
var Checkboxes_default = Checkboxes;

// src/Components/ChartOptions.svelte
var import_luxon = __toModule(require_luxon());
function create_if_block(ctx) {
  let label0;
  let t0;
  let input0;
  let t1;
  let label1;
  let t2;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      label0 = element("label");
      t0 = text("Start\r\n		");
      input0 = element("input");
      t1 = space();
      label1 = element("label");
      t2 = text("End\r\n		");
      input1 = element("input");
      attr(input0, "type", "date");
      input0.value = ctx[4];
      attr(input0, "min", ctx[4]);
      attr(input0, "max", ctx[5]);
      attr(input1, "type", "date");
      input1.value = ctx[5];
      attr(input1, "min", ctx[4]);
      attr(input1, "max", ctx[5]);
    },
    m(target, anchor) {
      insert(target, label0, anchor);
      append(label0, t0);
      append(label0, input0);
      insert(target, t1, anchor);
      insert(target, label1, anchor);
      append(label1, t2);
      append(label1, input1);
      if (!mounted) {
        dispose = [
          listen(input0, "change", ctx[8]),
          listen(input1, "change", ctx[9])
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(label0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(label1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment2(ctx) {
  let input0;
  let t0;
  let label;
  let t1;
  let input1;
  let t2;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = ctx[3] && create_if_block(ctx);
  return {
    c() {
      input0 = element("input");
      t0 = space();
      label = element("label");
      t1 = text("Date Range");
      input1 = element("input");
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input0, "type", "color");
      attr(input1, "type", "checkbox");
      input1.checked = ctx[3];
    },
    m(target, anchor) {
      insert(target, input0, anchor);
      set_input_value(input0, ctx[0]);
      insert(target, t0, anchor);
      insert(target, label, anchor);
      append(label, t1);
      append(label, input1);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[6]),
          listen(input1, "change", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        set_input_value(input0, ctx2[0]);
      }
      if (dirty & 8) {
        input1.checked = ctx2[3];
      }
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(label);
      if (detaching)
        detach(t2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { colour } = $$props;
  let { startDate } = $$props;
  let { endDate } = $$props;
  let { dnOnly } = $$props;
  const minDateStr = startDate.toISODate();
  const maxDateStr = endDate.toISODate();
  function input0_input_handler() {
    colour = this.value;
    $$invalidate(0, colour);
  }
  const change_handler = () => $$invalidate(3, dnOnly = !dnOnly);
  const change_handler_1 = (e) => $$invalidate(1, startDate = import_luxon.DateTime.fromISO(e.target.value));
  const change_handler_2 = (e) => $$invalidate(2, endDate = import_luxon.DateTime.fromISO(e.target.value));
  $$self.$$set = ($$props2) => {
    if ("colour" in $$props2)
      $$invalidate(0, colour = $$props2.colour);
    if ("startDate" in $$props2)
      $$invalidate(1, startDate = $$props2.startDate);
    if ("endDate" in $$props2)
      $$invalidate(2, endDate = $$props2.endDate);
    if ("dnOnly" in $$props2)
      $$invalidate(3, dnOnly = $$props2.dnOnly);
  };
  return [
    colour,
    startDate,
    endDate,
    dnOnly,
    minDateStr,
    maxDateStr,
    input0_input_handler,
    change_handler,
    change_handler_1,
    change_handler_2
  ];
}
var ChartOptions = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      colour: 0,
      startDate: 1,
      endDate: 2,
      dnOnly: 3
    });
  }
};
var ChartOptions_default = ChartOptions;

// node_modules/svelte-chartjs/src/utils.js
function clean($$props, extra_keys) {
  let keys = ["children", "$$scope", "$$slots"].concat(extra_keys);
  const rest = {};
  for (const key of Object.keys($$props)) {
    if (!keys.includes(key)) {
      rest[key] = $$props[key];
    }
  }
  return rest;
}

// node_modules/chart.js/dist/chunks/helpers.segment.js
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg, updateFn) {
  const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
  let ticking = false;
  let args = [];
  return function(...rest) {
    args = updateArgs(rest);
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, args);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function noop2() {
}
var uid = function() {
  let id = 0;
  return function() {
    return id++;
  };
}();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.substr(0, 7) === "[object" && type.substr(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
var isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone$1(source) {
  if (isArray(source)) {
    return source.map(clone$1);
  }
  if (isObject(source)) {
    const target = Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone$1(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone$1(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [source];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  for (let i = 0; i < ilen; ++i) {
    source = sources[i];
    if (!isObject(source)) {
      continue;
    }
    const keys = Object.keys(source);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, source, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, { merger: _mergerIf });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone$1(sval);
  }
}
var emptyString = "";
var dot = ".";
function indexOfDotOrLength(key, start) {
  const idx = key.indexOf(dot, start);
  return idx === -1 ? key.length : idx;
}
function resolveObjectKey(obj, key) {
  if (key === emptyString) {
    return obj;
  }
  let pos = 0;
  let idx = indexOfDotOrLength(key, pos);
  while (obj && idx > pos) {
    obj = obj[key.substr(pos, idx - pos)];
    pos = idx + 1;
    idx = indexOfDotOrLength(key, pos);
  }
  return obj;
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
var atEdge = (t) => t === 0 || t === 1;
var elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
var elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
var effects = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: (t) => Math.sin(t * HALF_PI),
  easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
  },
  easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < 1 / d) {
      return m * t * t;
    }
    if (t < 2 / d) {
      return m * (t -= 1.5 / d) * t + 0.75;
    }
    if (t < 2.5 / d) {
      return m * (t -= 2.25 / d) * t + 0.9375;
    }
    return m * (t -= 2.625 / d) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
var map = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = "0123456789ABCDEF";
var h1 = (b) => hex[b & 15];
var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
var eq = (b) => (b & 240) >> 4 === (b & 15);
function isShort(v) {
  return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
}
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map[str[1]] * 17,
        g: 255 & map[str[2]] * 17,
        b: 255 & map[str[3]] * 17,
        a: len === 5 ? map[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map[str[1]] << 4 | map[str[2]],
        g: map[str[3]] << 4 | map[str[4]],
        b: map[str[5]] << 4 | map[str[6]],
        a: len === 9 ? map[str[7]] << 4 | map[str[8]] : 255
      };
    }
  }
  return ret;
}
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : "") : v;
}
function round(v) {
  return v + 0.5 | 0;
}
var lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = 255 & (m[8] ? p2b(v) : v * 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : r);
  g = 255 & (m[4] ? p2b(g) : g);
  b = 255 & (m[6] ? p2b(b) : b);
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
    h = h * 60 + 0.5;
  }
  return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h, s, l) {
  return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
  return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
}
var map$1 = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names);
  const tkeys = Object.keys(map$1);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map$1[k]);
    }
    k = parseInt(names[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
var names$1;
function nameParse(str) {
  if (!names$1) {
    names$1 = unpack();
    names$1.transparent = [0, 0, 0, 0];
  }
  const a = names$1[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : this._rgb;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : this._rgb;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : this._rgb;
  }
  mix(color2, weight) {
    const me = this;
    if (color2) {
      const c1 = me.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      me.rgb = c1;
    }
    return me;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};
function index_esm(input) {
  return new Color(input);
}
var isPatternOrGradient = (value) => value instanceof CanvasGradient || value instanceof CanvasPattern;
function color(value) {
  return isPatternOrGradient(value) ? value : index_esm(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
}
var overrides = Object.create(null);
var descriptors = Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
};
var defaults = new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
});
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  let type, xOffset, yOffset, size, cornerRadius;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      ctx.arc(x, y, radius, 0, TAU);
      ctx.closePath();
      break;
    case "triangle":
      ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        ctx.rect(x - size, y - size, 2 * size, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + yOffset, y - xOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      break;
    case "star":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      rad += QUARTER_PI;
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      ctx.moveTo(x + yOffset, y - xOffset);
      ctx.lineTo(x - yOffset, y + xOffset);
      break;
    case "line":
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function renderText(ctx, text2, x, y, font, opts = {}) {
  const lines = isArray(text2) ? text2 : [text2];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += font.lineHeight;
  }
  ctx.restore();
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
var LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
var FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
var numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, { top: "y", right: "x", bottom: "y", left: "x" });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = "";
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index !== void 0 && isArray(value)) {
      value = value[index % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index) => table[index] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return { lo, hi };
}
var _lookupByKey = (table, key, value) => _lookup(table, value, (index) => table[index][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index) => table[index][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [listener]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index = listeners.indexOf(listener);
  if (index !== -1) {
    listeners.splice(index, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = new Set();
  let i, ilen;
  for (i = 0, ilen = items.length; i < ilen; ++i) {
    set2.add(items[i]);
  }
  if (set2.size === ilen) {
    return items;
  }
  return Array.from(set2);
}
function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget2 = () => scopes[0]) {
  if (!defined(fallback)) {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: rootScopes,
    _fallback: fallback,
    _getTarget: getTarget2,
    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget2());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = { scriptable: true, indexable: true }) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, value, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  value = value(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (defined(_context.index) && isIndexable(prop)) {
    value = value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s) => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [...parentScopes, ...rootScopes];
  const set2 = new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (defined(fallback) && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [""], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target;
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (defined(value)) {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (defined(value)) {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
var EPSILON = Number.EPSILON || 1e-14;
var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle2 = (element2) => window.getComputedStyle(element2, null);
function getStyle(el, property) {
  return getComputedStyle2(el).getPropertyValue(property);
}
var positions = ["top", "right", "bottom", "left"];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(evt, canvas) {
  const e = evt.native || evt;
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return { x, y, box };
}
function getRelativePosition(evt, chart) {
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle2(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(evt, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle2(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle2(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = deviceHeight / pixelRatio;
  chart.width = deviceWidth / pixelRatio;
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener("test", null, options);
    window.removeEventListener("test", null, options);
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element2, property) {
  const value = getStyle(element2, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = { x: p1.cp2x, y: p1.cp2y };
  const cp2 = { x: p2.cp1x, y: p2.cp1y };
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}
var intlCache = new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: (x) => x
  };
}
function normalizeSegment({ start, end, count, loop, style }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property);
  const count = points.length;
  let { start, end, loop } = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return { start, end, loop, style: segment.style };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [segment];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({ start: subStart, end: i, loop, count, style }));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({ start: subStart, end, loop, count, style }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return { start, end };
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({ start: start % count, end: (end - 1) % count, loop });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({ start: start % count, end: last % count, loop });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [{ start, end, loop }], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({ start: s % count, end: e % count, loop: l, style: st });
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
}

// node_modules/chart.js/dist/chart.esm.js
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw2 = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw2 = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from, to, factor) {
    return factor > 0.5 ? to : from;
  },
  color(from, to, factor) {
    const c0 = color(from || transparent);
    const c1 = c0.valid && color(to || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
  },
  number(from, to, factor) {
    return from + (to - from) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to) {
    const currentValue = target[prop];
    to = resolve([cfg.to, to, currentValue, cfg.from]);
    const from = resolve([cfg.from, currentValue, to]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from;
    this._to = to;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([cfg.to, to, currentValue, cfg.from]);
      this._from = resolve([cfg.from, currentValue, to]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from = this._from;
    const loop = this._loop;
    const to = this._to;
    let factor;
    this._active = from !== to && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from, to, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({ res, rej });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
};
var numbers = ["x", "y", "borderWidth", "radius", "tension"];
var colors = ["color", "borderColor", "backgroundColor"];
defaults.set("animation", {
  delay: void 0,
  duration: 1e3,
  easing: "easeOutQuart",
  fn: void 0,
  from: void 0,
  loop: void 0,
  to: void 0,
  type: void 0
});
var animationOptions = Object.keys(defaults.animation);
defaults.describe("animation", {
  _fallback: false,
  _indexable: false,
  _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
});
defaults.set("animations", {
  colors: {
    type: "color",
    properties: colors
  },
  numbers: {
    type: "number",
    properties: numbers
  }
});
defaults.describe("animations", {
  _fallback: "animation"
});
defaults.set("transitions", {
  active: {
    animation: {
      duration: 400
    }
  },
  resize: {
    animation: {
      duration: 0
    }
  },
  show: {
    animations: {
      colors: {
        from: "transparent"
      },
      visible: {
        type: "boolean",
        duration: 0
      }
    }
  },
  hide: {
    animations: {
      colors: {
        to: "transparent"
      },
      visible: {
        type: "boolean",
        easing: "linear",
        fn: (v) => v | 0
      }
    }
  }
});
var Animations = class {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, { $shared: false, $animations: {} });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l;
  if (isObject(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
  }
}
function getFirstScaleId(chart, axis) {
  const scales2 = chart.scales;
  return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
}
function createDatasetContext(parent, index) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index,
    index,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index, element2) {
  return createContext(parent, {
    active: false,
    dataIndex: index,
    parsed: void 0,
    raw: void 0,
    element: element2,
    index,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && { keys: getSortedDatasetIndices(chart, true), values: null };
var DatasetController = class {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.$context = void 0;
    this._syncList = [];
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index], index),
        [vAxis]: vScale.parse(data[index], index)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(item[0], index),
        y: yScale.parse(item[1], index)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
      };
    }
    return parsed;
  }
  getParsed(index) {
    return this._cachedMeta._parsed[index];
  }
  getDataElement(index) {
    return this._cachedMeta.data[index];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]
    };
    return applyStack(stack, value, meta.index, { mode });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements2 = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element2 = elements2[i];
      if (element2.hidden) {
        continue;
      }
      if (element2.active && drawActiveElementsOnTop) {
        active.push(element2);
      } else {
        element2.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index, active) {
    const mode = active ? "active" : "default";
    return index === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
  }
  getContext(index, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index >= 0 && index < this._cachedMeta.data.length) {
      const element2 = this._cachedMeta.data[index];
      context = element2.$context || (element2.$context = createDataContext(this.getContext(), index, element2));
      context.parsed = this.getParsed(index);
      context.raw = dataset.data[index];
      context.index = context.dataIndex = index;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index);
  }
  _resolveElementOptions(elementType, mode = "default", index) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index, active);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  updateElement(element2, index, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element2, properties);
    } else {
      this._resolveAnimations(index, mode).update(element2, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element2, index, mode, active) {
    element2.active = active;
    const options = this.getStyle(index, active);
    this._resolveAnimations(index, mode, active).update(element2, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element2, datasetIndex, index) {
    this._setStyle(element2, index, "active", false);
  }
  setHoverStyle(element2, datasetIndex, index) {
    this._setStyle(element2, index, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element2 = this._cachedMeta.dataset;
    if (element2) {
      this._setStyle(element2, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element2 = this._cachedMeta.dataset;
    if (element2) {
      this._setStyle(element2, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element2, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([this.index, ...args]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync(["_insertElements", this.getDataset().data.length - count, count]);
  }
  _onDataPop() {
    this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
  }
  _onDataShift() {
    this._sync(["_removeElements", 0, 1]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync(["_removeElements", start, count]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync(["_insertElements", start, newCount]);
    }
  }
  _onDataUnshift() {
    this._sync(["_insertElements", 0, arguments.length]);
  }
};
DatasetController.defaults = {};
DatasetController.prototype.datasetElementType = null;
DatasetController.prototype.dataElementType = null;
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index] - size / 2
  };
}
function computeFlexCategoryTraits(index, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index];
  let prev = index > 0 ? pixels[index - 1] : null;
  let next = index < pixels.length - 1 ? pixels[index + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return { start, end, reverse, top, bottom };
}
function setBorderSkipped(properties, options, stack, index) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index) {
      edge = top;
    } else if ((stack._bottom || 0) === index) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = class extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === "reset";
    const { index, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? { base, head: base } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const metasets = iScale.getMatchingVisibleMetas(this._type);
    const stacked = iScale.options.stacked;
    const ilen = metasets.length;
    const stacks = [];
    let i, item;
    for (i = 0; i < ilen; ++i) {
      item = metasets[i];
      if (!item.controller.options.grouped) {
        continue;
      }
      if (typeof dataIndex !== "undefined") {
        const val = item.controller.getParsed(dataIndex)[item.controller._cachedMeta.vScale.axis];
        if (isNullOrUndef(val) || isNaN(val)) {
          continue;
        }
      }
      if (stacked === false || stacks.indexOf(item.stack) === -1 || stacked === void 0 && item.stack === void 0) {
        stacks.push(item.stack);
      }
      if (item.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index) {
    return this._getStacks(void 0, index).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index = name !== void 0 ? stacks.indexOf(name) : -1;
    return index === -1 ? stacks.length - 1 : index;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index) {
    const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      head = base + size;
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
      const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : void 0);
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }
};
BarController.id = "bar";
BarController.defaults = {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "base", "width", "height"]
    }
  }
};
BarController.overrides = {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
};
var BubbleController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: meta.label,
      value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  resolveDataElementOptions(index, mode) {
    const parsed = this.getParsed(index);
    let values = super.resolveDataElementOptions(index, mode);
    if (values.$shared) {
      values = Object.assign({}, values, { $shared: false });
    }
    const radius = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
};
BubbleController.id = "bubble";
BubbleController.defaults = {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "borderWidth", "radius"]
    }
  }
};
BubbleController.overrides = {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        }
      }
    }
  }
};
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return { ratioX, ratioY, offsetX, offsetY };
}
var DoughnutController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i2) => +data[i2];
      if (isObject(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data[i2], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index], chart.options.locale);
    return {
      label: labels[index] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== "inner") {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
DoughnutController.id = "doughnut";
DoughnutController.defaults = {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
};
DoughnutController.descriptors = {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing"
};
DoughnutController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(tooltipItem) {
          let dataLabel = tooltipItem.label;
          const value = ": " + tooltipItem.formattedValue;
          if (isArray(dataLabel)) {
            dataLabel = dataLabel.slice();
            dataLabel[0] += value;
          } else {
            dataLabel += value;
          }
          return dataLabel;
        }
      }
    }
  }
};
var LineController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && parsed[iAxis] - prevParsed[iAxis] > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
};
LineController.id = "line";
LineController.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
};
LineController.overrides = {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
};
function getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, _parsed } = meta;
    const axis = iScale.axis;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1), start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return { start, count };
}
function scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
var PolarAreaController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index].r, chart.options.locale);
    return {
      label: labels[index] || "",
      value
    };
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const dataset = this.getDataset();
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const dataset = this.getDataset();
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element2, index) => {
      if (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index, mode, defaultAngle) {
    return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
  }
};
PolarAreaController.id = "polarArea";
PolarAreaController.defaults = {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
    }
  },
  indexAxis: "r",
  startAngle: 0
};
PolarAreaController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(context) {
          return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
        }
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
};
var PieController = class extends DoughnutController {
};
PieController.id = "pie";
PieController.defaults = {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
};
var RadarController = class extends DatasetController {
  getLabelAndValue(index) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: vScale.getLabels()[index],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const dataset = this.getDataset();
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
};
RadarController.id = "radar";
RadarController.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
};
RadarController.overrides = {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
};
var ScatterController = class extends LineController {
};
ScatterController.id = "scatter";
ScatterController.defaults = {
  showLine: false,
  fill: false
};
ScatterController.overrides = {
  interaction: {
    mode: "point"
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(item) {
          return "(" + item.label + ", " + item.formattedValue + ")";
        }
      }
    }
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
};
var controllers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PolarAreaController,
  PieController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapter = class {
  constructor(options) {
    this.options = options || {};
  }
  formats() {
    return abstract();
  }
  parse(value, format) {
    return abstract();
  }
  format(timestamp, format) {
    return abstract();
  }
  add(timestamp, amount, unit) {
    return abstract();
  }
  diff(a, b, unit) {
    return abstract();
  }
  startOf(timestamp, unit, weekday) {
    return abstract();
  }
  endOf(timestamp, unit) {
    return abstract();
  }
};
DateAdapter.override = function(members) {
  Object.assign(DateAdapter.prototype, members);
};
var adapters = {
  _date: DateAdapter
};
function getRelativePosition2(e, chart) {
  if ("native" in e) {
    return {
      x: e.x,
      y: e.y
    };
  }
  return getRelativePosition(e, chart);
}
function evaluateAllVisibleItems(chart, handler) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  let index, data, element2;
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    ({ index, data } = metasets[i]);
    for (let j = 0, jlen = data.length; j < jlen; ++j) {
      element2 = data[j];
      if (!element2.skip) {
        handler(element2, index, j);
      }
    }
  }
}
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return { lo: start.lo, hi: end.hi };
      }
    }
  }
  return { lo: 0, hi: data.length - 1 };
}
function optimizedEvaluateItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index, data } = metasets[i];
    const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element2 = data[j];
      if (!element2.skip) {
        handler(element2, index, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition) {
  const items = [];
  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
    return items;
  }
  const evaluationFunc = function(element2, datasetIndex, index) {
    if (element2.inRange(position.x, position.y, useFinalPosition)) {
      items.push({ element: element2, datasetIndex, index });
    }
  };
  optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element2, datasetIndex, index) {
    const { startAngle, endAngle } = element2.getProps(["startAngle", "endAngle"], useFinalPosition);
    const { angle } = getAngleFromPoint(element2, { x: position.x, y: position.y });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({ element: element2, datasetIndex, index });
    }
  }
  optimizedEvaluateItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element2, datasetIndex, index) {
    const inRange2 = element2.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element2.getCenterPoint(useFinalPosition);
    const pointInArea = _isPointInArea(center, chart.chartArea, chart._minPadding);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [{ element: element2, datasetIndex, index }];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({ element: element2, datasetIndex, index });
    }
  }
  optimizedEvaluateItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition) {
  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition);
}
function getAxisItems(chart, e, options, useFinalPosition) {
  const position = getRelativePosition2(e, chart);
  const items = [];
  const axis = options.axis;
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateAllVisibleItems(chart, (element2, datasetIndex, index) => {
    if (element2[rangeMethod](position[axis], useFinalPosition)) {
      items.push({ element: element2, datasetIndex, index });
    }
    if (element2.inRange(position.x, position.y, useFinalPosition)) {
      intersectsItem = true;
    }
  });
  if (options.intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition2(e, chart);
      const axis = options.axis || "x";
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index = items[0].index;
        const element2 = meta.data[index];
        if (element2 && !element2.skip) {
          elements2.push({ element: element2, datasetIndex: meta.index, index });
        }
      });
      return elements2;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition2(e, chart);
      const axis = options.axis || "xy";
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({ element: data[i], datasetIndex, index: i });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition2(e, chart);
      const axis = options.axis || "xy";
      return getIntersectItems(chart, position, axis, useFinalPosition);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition2(e, chart);
      const axis = options.axis || "xy";
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition);
    },
    x(chart, e, options, useFinalPosition) {
      return getAxisItems(chart, e, { axis: "x", intersect: options.intersect }, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      return getAxisItems(chart, e, { axis: "y", intersect: options.intersect }, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = ["left", "top", "right", "bottom"];
function filterByPosition(array, position) {
  return array.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || { size: 0, count: 1 };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = { left: 0, top: 0, right: 0, bottom: 0 };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
defaults.set("layout", {
  autoPadding: true,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
});
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [{
        z: 0,
        draw(chartArea) {
          item.draw(chartArea);
        }
      }];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index !== -1) {
      chart.boxes.splice(index, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, { left: 0, top: 0, right: 0, bottom: 0 });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element2, width, height, aspectRatio) {
    width = Math.max(0, width || element2.width);
    height = height || element2.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, { childList: true, subtree: true });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, { childList: true, subtree: true });
  return observer;
}
var drpListeningCharts = new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart, (args) => {
    const event = args[0];
    return [event, event.offsetX, event.offsetY];
  });
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    ["height", "width"].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var Element = class {
  constructor() {
    this.x = void 0;
    this.y = void 0;
    this.active = false;
    this.options = void 0;
    this.$animations = void 0;
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return { x, y };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
Element.defaults = {};
Element.defaultRoutes = void 0;
var formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if (remain === 1 || remain === 2 || remain === 5) {
      return formatters.numeric.call(this, tickValue, index, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = { formatters };
defaults.set("scale", {
  display: true,
  offset: false,
  reverse: false,
  beginAtZero: false,
  bounds: "ticks",
  grace: 0,
  grid: {
    display: true,
    lineWidth: 1,
    drawBorder: true,
    drawOnChartArea: true,
    drawTicks: true,
    tickLength: 8,
    tickWidth: (_ctx, options) => options.lineWidth,
    tickColor: (_ctx, options) => options.color,
    offset: false,
    borderDash: [],
    borderDashOffset: 0,
    borderWidth: 1
  },
  title: {
    display: false,
    text: "",
    padding: {
      top: 4,
      bottom: 4
    }
  },
  ticks: {
    minRotation: 0,
    maxRotation: 50,
    mirror: false,
    textStrokeWidth: 0,
    textStrokeColor: "",
    padding: 3,
    display: true,
    autoSkip: true,
    autoSkipPadding: 3,
    labelOffset: 0,
    callback: Ticks.formatters.values,
    minor: {},
    major: {},
    align: "center",
    crossAlign: "near",
    showLabelBackdrop: false,
    backdropColor: "rgba(255, 255, 255, 0.75)",
    backdropPadding: 2
  }
});
defaults.route("scale.ticks", "color", "", "color");
defaults.route("scale.grid", "color", "", "borderColor");
defaults.route("scale.grid", "borderColor", "", "borderColor");
defaults.route("scale.title", "color", "", "color");
defaults.describe("scale", {
  _fallback: false,
  _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
  _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash"
});
defaults.describe("scales", {
  _fallback: "scale"
});
defaults.describe("scale.ticks", {
  _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
  _indexable: (name) => name !== "backdropPadding"
});
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index, tick2) {
  return createContext(parent, {
    tick: tick2,
    index,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales: scales2 } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return { titleX, titleY, maxWidth, rotation };
}
var Scale = class extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return { min, max };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [this]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [this]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [this]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [this]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [this]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [this]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick2;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick2 = ticks[i];
      tick2.label = callback(tickOpts.callback, [tick2.value, i, ticks], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [this]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [this]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = this.ticks.length;
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [this]);
  }
  beforeFit() {
    callback(this.options.beforeFit, [this]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [this]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; ++i) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || { data: {}, gc: [] };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index) {
    const ticks = this.ticks || [];
    if (index >= 0 && index < ticks.length) {
      const tick2 = ticks[index];
      return tick2.$context || (tick2.$context = createTickContext(this.getContext(), index, tick2));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const optsAtIndex = grid.setContext(this.getContext(i));
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = grid.borderDash || [];
      const borderDashOffset = optsAtIndex.borderDashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick2, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick2 = ticks[i];
      label = tick2.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      if (isHorizontal) {
        x = pixel;
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = y + textOffset - labelPadding.top;
        let left = x - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        rotation,
        label,
        font,
        color: color2,
        strokeColor,
        strokeWidth,
        textOffset,
        textAlign,
        textBaseline,
        translation: [x, y],
        backdrop
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return { textAlign, x };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return { top: 0, left: this.left, bottom: chart.height, right: this.right };
    }
    if (position === "top" || position === "bottom") {
      return { top: this.top, left: 0, bottom: this.bottom, right: chart.width };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index = ticks.findIndex((t) => t.value === value);
    if (index >= 0) {
      const opts = grid.setContext(this.getContext(index));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine({ x: item.x1, y: item.y1 }, { x: item.x2, y: item.y2 }, item);
        }
        if (grid.drawTicks) {
          drawLine({ x: item.tx1, y: item.ty1 }, { x: item.tx2, y: item.ty2 }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { grid } } = this;
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.borderWidth;
    ctx.strokeStyle = borderOpts.borderColor;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    let i, ilen;
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      const item = items[i];
      const tickFont = item.font;
      const label = item.label;
      if (item.backdrop) {
        ctx.fillStyle = item.backdrop.color;
        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
      }
      let y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, item);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [titleX, titleY]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [{
        z: tz,
        draw: (chartArea) => {
          this.draw(chartArea);
        }
      }];
    }
    return [{
      z: gz,
      draw: (chartArea) => {
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawTitle();
      }
    }, {
      z: gz + 1,
      draw: () => {
        this.drawBorder();
      }
    }, {
      z: tz,
      draw: (chartArea) => {
        this.drawLabels(chartArea);
      }
    }];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index) {
    const opts = this.options.ticks.setContext(this.getContext(index));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [scope].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [this.controllers, this.scales, this.elements];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [...args].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = new Registry();
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [chart, args, descriptor.options];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins2 = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
};
function allPlugins(config) {
  const plugins2 = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins2.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins2.indexOf(plugin) === -1) {
      plugins2.push(plugin);
    }
  }
  return plugins2;
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, plugins2, options, all) {
  const result = [];
  const context = chart.getContext();
  for (let i = 0; i < plugins2.length; i++) {
    const plugin = plugins2[i];
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, plugin, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, plugin, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  return config.createResolver(scopes, context, [""], { scriptable: false, indexable: false, allKeys: true });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, scaleOptions) {
  if (id === "x" || id === "y") {
    return id;
  }
  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || { scales: {} };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const firstIDs = Object.create(null);
  const scales2 = Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    firstIDs[axis] = firstIDs[axis] || id;
    scales2[id] = mergeIf(Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
      scales2[id] = scales2[id] || Object.create(null);
      mergeIf(scales2[id], [{ axis }, configScales[id], defaultScaleOptions[defaultID]]);
    });
  });
  Object.keys(scales2).forEach((key) => {
    const scale = scales2[key];
    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
  });
  return scales2;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = new Map();
var keysCached = new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
var addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = new Map();
    this._resolverCache = new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [[
      `datasets.${datasetType}`,
      ""
    ]]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [[
      `datasets.${datasetType}.elements.${elementType}`,
      `datasets.${datasetType}`,
      `elements.${elementType}`,
      ""
    ]]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [[
      `plugins.${id}`,
      ...plugin.additionalOptionScopes || []
    ]]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      { type },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
    const result = { $shared: true };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "3.7.0";
var KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions2 = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions2 && animationOptions2.onComplete, [context], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions2 = chart.options.animation;
  callback(animationOptions2 && animationOptions2.onProgress, [context], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
var Chart = class {
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = { width, height };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", { size: newSize });
    callback(options.onResize, [this, newSize], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales2 && scales2[id].type === scaleType) {
        scale = scales2[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales2[id];
      }
    });
    each(scales2, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index) => {
      if (datasets.filter((x) => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass.prototype, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", { mode });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({ method: a[1], start: +a[2], count: +a[3] }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index) => {
      item._idx = index;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction(mode) ? mode({ datasetIndex: i }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", { mode });
  }
  _updateDataset(index, mode) {
    const meta = this.getDatasetMeta(index);
    const args = { meta, index, mode, cancelable: true };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({ chart: this });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = this.chartArea;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, { chart: this, type: "chart" }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index) {
    this._hiddenIndices[index] = !this._hiddenIndices[index];
  }
  getDataVisibility(index) {
    return !this._hiddenIndices[index];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, { visible });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    this.notifyPlugins("destroy");
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: _isPointInArea(e, this.chartArea, this._minPadding)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [e, active, this], this);
      if (isClick) {
        callback(options.onClick, [e, active, this], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
var invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());
var enumerable = true;
Object.defineProperties(Chart, {
  defaults: {
    enumerable,
    value: defaults
  },
  instances: {
    enumerable,
    value: instances
  },
  overrides: {
    enumerable,
    value: overrides
  },
  registry: {
    enumerable,
    value: registry
  },
  version: {
    enumerable,
    value: version
  },
  getChart: {
    enumerable,
    value: getChart
  },
  register: {
    enumerable,
    value: (...items) => {
      registry.add(...items);
      invalidatePlugins();
    }
  },
  unregister: {
    enumerable,
    value: (...items) => {
      registry.remove(...items);
      invalidatePlugins();
    }
  }
});
function clipArc(ctx, element2, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element2;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx, element2, offset, spacing, end) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element2;
  const outerRadius = Math.max(element2.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
    spacingOffset = (alpha - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element2, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
  if (outerEnd > 0) {
    const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
  }
  const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
  ctx.lineTo(p4.x, p4.y);
  if (innerEnd > 0) {
    const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
  }
  ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
  if (innerStart > 0) {
    const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
  }
  const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
  ctx.lineTo(p8.x, p8.y);
  if (outerStart > 0) {
    const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
  }
  ctx.closePath();
}
function drawArc(ctx, element2, offset, spacing) {
  const { fullCircles, startAngle, circumference } = element2;
  let endAngle = element2.endAngle;
  if (fullCircles) {
    pathArc(ctx, element2, offset, spacing, startAngle + TAU);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + circumference % TAU;
      if (circumference % TAU === 0) {
        endAngle += TAU;
      }
    }
  }
  pathArc(ctx, element2, offset, spacing, endAngle);
  ctx.fill();
  return endAngle;
}
function drawFullCircleBorders(ctx, element2, inner) {
  const { x, y, startAngle, pixelMargin, fullCircles } = element2;
  const outerRadius = Math.max(element2.outerRadius - pixelMargin, 0);
  const innerRadius = element2.innerRadius + pixelMargin;
  let i;
  if (inner) {
    clipArc(ctx, element2, startAngle + TAU);
  }
  ctx.beginPath();
  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
}
function drawBorder(ctx, element2, offset, spacing, endAngle) {
  const { options } = element2;
  const { borderWidth, borderJoinStyle } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  if (element2.fullCircles) {
    drawFullCircleBorders(ctx, element2, inner);
  }
  if (inner) {
    clipArc(ctx, element2, endAngle);
  }
  pathArc(ctx, element2, offset, spacing, endAngle);
  ctx.stroke();
}
var ArcElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps(["x", "y"], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, { x: chartX, y: chartY });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = this.options.spacing / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 2;
    const spacing = (options.spacing || 0) / 2;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    let radiusOffset = 0;
    if (offset) {
      radiusOffset = offset / 2;
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
      if (this.circumference >= PI) {
        radiusOffset = offset;
      }
    }
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    const endAngle = drawArc(ctx, this, radiusOffset, spacing);
    drawBorder(ctx, this, radiusOffset, spacing, endAngle);
    ctx.restore();
  }
};
ArcElement.id = "arc";
ArcElement.defaults = {
  borderAlign: "center",
  borderColor: "#fff",
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0
};
ArcElement.defaultRoutes = {
  backgroundColor: "backgroundColor"
};
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, { start, end: start + count - 1 })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
var usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
var LineElement = class extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, { property, start: value, end: value });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const { start, end } = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, { start, end: start + count - 1 });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
};
LineElement.id = "line";
LineElement.defaults = {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
};
LineElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
LineElement.descriptors = {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
};
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([axis], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
var PointElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y } = this.getProps(["x", "y"], useFinalPosition);
    return { x, y };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
};
PointElement.id = "point";
PointElement.defaults = {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
};
PointElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return { left, top, right, bottom };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
var BarElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
BarElement.id = "bar";
BarElement.defaults = {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
};
BarElement.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
var elements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement,
  LineElement,
  PointElement,
  BarElement
});
function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const { x: pointAx, y: pointAy } = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i = start; i < start + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", { value: data });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const { iScale } = meta;
  const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return { start, count };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([indexAxis, chart.options.indexAxis]) === "y") {
        return;
      }
      if (meta.type !== "line") {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data, start, count, availableWidth, options);
          break;
        case "min-max":
          decimated = minMaxDecimation(data, start, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
function getLineByIndex(chart, index) {
  const meta = chart.getDatasetMeta(index);
  const visible = meta && chart.isDatasetVisible(index);
  return visible ? meta.dataset : null;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill === void 0) {
    fill = !!options.backgroundColor;
  }
  if (fill === false || fill === null) {
    return false;
  }
  if (fill === true) {
    return "origin";
  }
  return fill;
}
function decodeFill(line, index, count) {
  const fill = parseFillOption(line);
  if (isObject(fill)) {
    return isNaN(fill.value) ? false : fill;
  }
  let target = parseFloat(fill);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    if (fill[0] === "-" || fill[0] === "+") {
      target = index + target;
    }
    if (target === index || target < 0 || target >= count) {
      return false;
    }
    return target;
  }
  return ["origin", "start", "end", "stack", "shape"].indexOf(fill) >= 0 && fill;
}
function computeLinearBoundary(source) {
  const { scale = {}, fill } = source;
  let target = null;
  let horizontal;
  if (fill === "start") {
    target = scale.bottom;
  } else if (fill === "end") {
    target = scale.top;
  } else if (isObject(fill)) {
    target = scale.getPixelForValue(fill.value);
  } else if (scale.getBasePixel) {
    target = scale.getBasePixel();
  }
  if (isNumberFinite(target)) {
    horizontal = scale.isHorizontal();
    return {
      x: horizontal ? target : null,
      y: horizontal ? null : target
    };
  }
  return null;
}
var simpleArc = class {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const { x, y, radius } = this;
    bounds = bounds || { start: 0, end: TAU };
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x, y, radius } = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
};
function computeCircularBoundary(source) {
  const { scale, fill } = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const target = [];
  const start = options.reverse ? scale.max : scale.min;
  const end = options.reverse ? scale.min : scale.max;
  let i, center, value;
  if (fill === "start") {
    value = start;
  } else if (fill === "end") {
    value = end;
  } else if (isObject(fill)) {
    value = fill.value;
  } else {
    value = scale.getBaseValue();
  }
  if (options.grid.circular) {
    center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value));
  }
  return target;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function pointsFromSegments(boundary, line) {
  const { x = null, y = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start, end }) => {
    end = findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({ x: first.x, y });
      points.push({ x: last.x, y });
    } else if (x !== null) {
      points.push({ x, y: first.y });
      points.push({ x, y: last.y });
    }
  });
  return points;
}
function buildStackLine(source) {
  const { scale, index, line } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index);
  linesBelow.push(createBoundaryLine({ x: null, y: scale.bottom }, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({ points, options: {} });
}
function getLinesBelow(scale, index) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas("line");
  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];
    if (meta.index === index) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return { first, last, point };
}
function getTarget(source) {
  const { chart, fill, line } = source;
  if (isNumberFinite(fill)) {
    return getLineByIndex(chart, fill);
  }
  if (fill === "stack") {
    return buildStackLine(source);
  }
  if (fill === "shape") {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return createBoundaryLine(boundary, line);
}
function createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: { tension: 0 },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function resolveTarget(sources, index, propagate) {
  const source = sources[index];
  let fill = source.fill;
  const visited = [index];
  let target;
  if (!propagate) {
    return fill;
  }
  while (fill !== false && visited.indexOf(fill) === -1) {
    if (!isNumberFinite(fill)) {
      return fill;
    }
    target = sources[fill];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill;
    }
    visited.push(fill);
    fill = target.fill;
  }
  return false;
}
function _clip(ctx, target, clipY) {
  ctx.beginPath();
  target.path(ctx);
  ctx.lineTo(target.last().x, clipY);
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === "angle") {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return { property, start, end };
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start, end } = segment;
    end = findSegmentEnd(start, end, points);
    const bounds = getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function clipBounds(ctx, scale, bounds) {
  const { top, bottom } = scale.chart.chartArea;
  const { property, start, end } = bounds || {};
  if (property === "x") {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
function _fill(ctx, cfg) {
  const { line, target, property, color: color2, scale } = cfg;
  const segments = _segments(line, target, property);
  for (const { source: src, target: tgt, start, end } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, { move: lineLoop, reverse: true });
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? "evenodd" : "nonzero");
    ctx.restore();
  }
}
function doFill(ctx, cfg) {
  const { line, target, above, below, area, scale } = cfg;
  const property = line._loop ? "angle" : cfg.axis;
  ctx.save();
  if (property === "x" && below !== above) {
    _clip(ctx, target, area.top);
    _fill(ctx, { line, target, color: above, scale, property });
    ctx.restore();
    ctx.save();
    _clip(ctx, target, area.bottom);
  }
  _fill(ctx, { line, target, color: below, scale, property });
  ctx.restore();
}
function drawfill(ctx, source, area) {
  const target = getTarget(source);
  const { line, scale, axis } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, { line, target, above, below, area, scale, axis });
    unclipArea(ctx);
  }
}
var plugin_filler = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source;
    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: decodeFill(line, i, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i = 0; i < count; ++i) {
      source = sources[i];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw2 = options.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw2) {
        drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (source) {
        drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!source || source.fill === false || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
var Legend = class extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [0];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = { left: 0, top, row, width: itemWidth, height: itemHeight };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({ width: currentColWidth, height: currentColHeight });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = { left, top: currentColHeight, col, width: itemWidth, height: itemHeight };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({ width: currentColWidth, height: currentColHeight });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { color: fontColor, padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxWidth * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor || fontColor;
      ctx.fillStyle = legendItem.fontColor || fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [e, previous, this], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [e, hoveredItem, this], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [e, hoveredItem, this], this);
    }
  }
};
function isListened(type, opts) {
  if (type === "mousemove" && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({ ctx: chart.ctx, options, chart });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index)) {
        ci.hide(index);
        legendItem.hidden = true;
      } else {
        ci.show(index);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2 } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: 0,
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => !["generateLabels", "filter", "sort"].includes(name)
    }
  }
};
var Title = class extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return { titleX, titleY, maxWidth, rotation };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [titleX, titleY]
    });
  }
};
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var map2 = new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map2.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map2.get(chart));
    map2.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map2.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let x = 0;
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }
    return {
      x: x / count,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element: element2, datasetIndex, index } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index);
  return {
    chart,
    label,
    parsed: controller.getParsed(index),
    raw: chart.data.datasets[datasetIndex].data[index],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index,
    datasetIndex,
    element: element2
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return { width, height };
}
function determineYAlign(chart, size) {
  const { y, height } = size;
  if (y < height / 2) {
    return "top";
  } else if (y > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width } = size;
  if (xAlign === "right") {
    x -= width;
  } else if (xAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var Tooltip = class extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart || config._chart;
    this._chart = this.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
    const title = callbacks.title.apply(this, [context]);
    const afterTitle = callbacks.afterTitle.apply(this, [context]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
    const footer = callbacks.footer.apply(this, [tooltipItems]);
    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element2, index, array) => options.filter(element2, index, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(scoped.labelColor.call(this, context));
      labelPointStyles.push(scoped.labelPointStyle.call(this, context));
      labelTextColors.push(scoped.labelTextColor.call(this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, { chart: this.chart, tooltip: this, replay });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return { x1, x2, x3, y1, y2, y3 };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColors = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColors.borderColor;
      ctx.fillStyle = labelColors.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = labelColors.borderWidth || 1;
      ctx.strokeStyle = labelColors.borderColor;
      ctx.setLineDash(labelColors.borderDash || []);
      ctx.lineDashOffset = labelColors.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
      const borderRadius = toTRBLCorners(labelColors.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
Tooltip.positioners = positioners;
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({ chart, options });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    const args = {
      tooltip
    };
    if (chart.notifyPlugins("beforeTooltipDraw", args) === false) {
      return;
    }
    if (tooltip) {
      tooltip.draw(chart.ctx);
    }
    chart.notifyPlugins("afterTooltipDraw", args);
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "width", "height", "caretX", "caretY"]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: {
      beforeTitle: noop2,
      title(tooltipItems) {
        if (tooltipItems.length > 0) {
          const item = tooltipItems[0];
          const labels = item.chart.data.labels;
          const labelCount = labels ? labels.length : 0;
          if (this && this.options && this.options.mode === "dataset") {
            return item.dataset.label || "";
          } else if (item.label) {
            return item.label;
          } else if (labelCount > 0 && item.dataIndex < labelCount) {
            return labels[item.dataIndex];
          }
        }
        return "";
      },
      afterTitle: noop2,
      beforeBody: noop2,
      beforeLabel: noop2,
      label(tooltipItem) {
        if (this && this.options && this.options.mode === "dataset") {
          return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
        }
        let label = tooltipItem.dataset.label || "";
        if (label) {
          label += ": ";
        }
        const value = tooltipItem.formattedValue;
        if (!isNullOrUndef(value)) {
          label += value;
        }
        return label;
      },
      labelColor(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          borderColor: options.borderColor,
          backgroundColor: options.backgroundColor,
          borderWidth: options.borderWidth,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderRadius: 0
        };
      },
      labelTextColor() {
        return this.options.bodyColor;
      },
      labelPointStyle(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          pointStyle: options.pointStyle,
          rotation: options.rotation
        };
      },
      afterLabel: noop2,
      afterBody: noop2,
      beforeFooter: noop2,
      footer: noop2,
      afterFooter: noop2
    }
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: ["interaction"]
};
var plugins = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Decimation: plugin_decimation,
  Filler: plugin_filler,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
var addIfString = (labels, raw, index, addedLabels) => {
  if (typeof raw === "string") {
    index = labels.push(raw) - 1;
    addedLabels.unshift({ index, label: raw });
  } else if (isNaN(raw)) {
    index = null;
  }
  return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index : first;
}
var validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);
var CategoryScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index, label } of added) {
        if (labels[index] === label) {
          labels.splice(index, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
    return validIndex(index, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({ value });
    }
    return ticks;
  }
  getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
CategoryScale.id = "category";
CategoryScale.defaults = {
  ticks: {
    callback: CategoryScale.prototype.getLabelForValue
  }
};
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [{ value: rmin }, { value: rmax }];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({ value: min });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    ticks.push({ value: Math.round((niceMin + j * spacing) * factor) / factor });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({ value: max });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({ value: niceMax });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = 1;
      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
        offset = Math.abs(max * 0.05);
      }
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
LinearScale.id = "linear";
LinearScale.defaults = {
  ticks: {
    callback: Ticks.formatters.numeric
  }
};
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
  return remain === 1;
}
function generateTicks(generationOptions, dataRange) {
  const endExp = Math.floor(log10(dataRange.max));
  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
  const ticks = [];
  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
  let exp = Math.floor(log10(tickVal));
  let significand = Math.floor(tickVal / Math.pow(10, exp));
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  do {
    ticks.push({ value: tickVal, major: isMajor(tickVal) });
    ++significand;
    if (significand === 10) {
      significand = 1;
      ++exp;
      precision = exp >= 0 ? 1 : precision;
    }
    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
  } while (exp < endExp || exp === endExp && significand < endSignificand);
  const lastTick = finiteOrDefault(generationOptions.max, tickVal);
  ticks.push({ value: lastTick, major: isMajor(tickVal) });
  return ticks;
}
var LogarithmicScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index) {
    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(exp(min, -1));
        setMax(exp(max, 1));
      }
    }
    if (min <= 0) {
      setMin(exp(max, -1));
    }
    if (max <= 0) {
      setMax(exp(min, 1));
    }
    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
      setMin(exp(min, -1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
LogarithmicScale.id = "logarithmic";
LogarithmicScale.defaults = {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
};
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [label];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const extra = getTickBackdropHeight(opts) / 2;
  const outerDistance = scale.drawingArea;
  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const size = labelSizes[i];
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    items.push({
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    });
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= h / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];
    const { backdropColor } = optsAtIndex;
    if (!isNullOrUndef(backdropColor)) {
      const padding = toPadding(optsAtIndex.backdropPadding);
      ctx.fillStyle = backdropColor;
      ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);
    }
    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(gridLineOpts.borderDash);
  ctx.lineDashOffset = gridLineOpts.borderDashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index, label) {
  return createContext(parent, {
    label,
    index,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index) => {
      const label = callback(this.options.pointLabels.callback, [value, index], this);
      return label || label === 0 ? label : "";
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index) {
    const pointLabels = this._pointLabels || [];
    if (index >= 0 && index < pointLabels.length) {
      const pointLabel = pointLabels[index];
      return createPointLabelContext(this.getContext(), index, pointLabel);
    }
  }
  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index, value) {
    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index) {
    return this.getPointPositionForValue(index || 0, this.getBaseValue());
  }
  getPointLabelPosition(index) {
    const { left, top, right, bottom } = this._pointLabelItems[index];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick2, index) => {
        if (index !== 0) {
          offset = this.getDistanceFromCenterForValue(tick2.value);
          const optsAtIndex = grid.setContext(this.getContext(index - 1));
          drawRadiusLine(this, optsAtIndex, offset, labelCount);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick2, index) => {
      if (index === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick2.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick2.label, 0, -offset, tickFont, {
        color: optsAtIndex.color
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
RadialLinearScale.id = "radialLinear";
RadialLinearScale.defaults = {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
};
RadialLinearScale.defaultRoutes = {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
};
RadialLinearScale.descriptors = {
  angleLines: {
    _fallback: "grid"
  }
};
var INTERVALS = {
  millisecond: { common: true, size: 1, steps: 1e3 },
  second: { common: true, size: 1e3, steps: 60 },
  minute: { common: true, size: 6e4, steps: 60 },
  hour: { common: true, size: 36e5, steps: 24 },
  day: { common: true, size: 864e5, steps: 30 },
  week: { common: false, size: 6048e5, steps: 4 },
  month: { common: true, size: 2628e6, steps: 12 },
  quarter: { common: false, size: 7884e6, steps: 4 },
  year: { common: true, size: 3154e7 }
};
var UNITS = Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map3, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index = map3[major];
    if (index >= 0) {
      ticks[index].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map3 = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map3[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return { min, max };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  initOffsets(timestamps) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = { start, end, factor: 1 / (start + 1 + end) };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(timeOpts.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  _tickFormatFunction(time, index, ticks, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick2 = ticks[index];
    const major = majorUnit && majorFormat && tick2 && tick2.major;
    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    const formatter = options.ticks.callback;
    return formatter ? callback(formatter, [label, index, ticks], this) : label;
  }
  generateTickLabels(ticks) {
    let i, ilen, tick2;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick2 = ticks[i];
      tick2.label = this._tickFormatFunction(tick2.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
TimeScale.id = "time";
TimeScale.defaults = {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    major: {
      enabled: false
    }
  }
};
function interpolate(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate(table, this.min);
    this._tableRange = interpolate(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        { time: min, pos: 0 },
        { time: max, pos: 1 }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({ time: curr, pos: i / (ilen - 1) });
      }
    }
    return table;
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
TimeSeriesScale.id = "timeseries";
TimeSeriesScale.defaults = TimeScale.defaults;
var scales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
var registerables = [
  controllers,
  elements,
  plugins,
  scales
];

// node_modules/svelte-chartjs/src/Base.svelte
function create_fragment3(ctx) {
  let canvas;
  let canvas_levels = [ctx[1]];
  let canvas_data = {};
  for (let i = 0; i < canvas_levels.length; i += 1) {
    canvas_data = assign(canvas_data, canvas_levels[i]);
  }
  return {
    c() {
      canvas = element("canvas");
      set_attributes(canvas, canvas_data);
    },
    m(target, anchor) {
      insert(target, canvas, anchor);
      ctx[6](canvas);
    },
    p(ctx2, [dirty]) {
      set_attributes(canvas, canvas_data = get_spread_update(canvas_levels, [ctx2[1]]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(canvas);
      ctx[6](null);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  Chart.register(...registerables);
  let { data = {
    labels: [],
    datasets: [{ data: [] }],
    yMarkers: {},
    yRegions: []
  } } = $$props;
  let { type = "line" } = $$props;
  let { options = {} } = $$props;
  let { plugins: plugins2 = [] } = $$props;
  let chart = null;
  let chartRef;
  let props = clean($$props, ["data", "type", "options", "plugins"]);
  onMount(() => {
    chart = new Chart(chartRef, { type, data, options, plugins: plugins2 });
  });
  afterUpdate(() => {
    if (!chart)
      return;
    chart.data = data;
    chart.type = type;
    chart.options = options;
    chart.plugins = plugins2;
    chart.update();
  });
  onDestroy(() => {
    chart = null;
  });
  function canvas_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      chartRef = $$value;
      $$invalidate(0, chartRef);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("data" in $$new_props)
      $$invalidate(2, data = $$new_props.data);
    if ("type" in $$new_props)
      $$invalidate(3, type = $$new_props.type);
    if ("options" in $$new_props)
      $$invalidate(4, options = $$new_props.options);
    if ("plugins" in $$new_props)
      $$invalidate(5, plugins2 = $$new_props.plugins);
  };
  $$props = exclude_internal_props($$props);
  return [chartRef, props, data, type, options, plugins2, canvas_binding];
}
var Base = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { data: 2, type: 3, options: 4, plugins: 5 });
  }
};
var Base_default = Base;

// node_modules/svelte-chartjs/src/Scatter.svelte
function create_fragment4(ctx) {
  let base;
  let current;
  const base_spread_levels = [ctx[0], { type: "scatter" }];
  let base_props = {};
  for (let i = 0; i < base_spread_levels.length; i += 1) {
    base_props = assign(base_props, base_spread_levels[i]);
  }
  base = new Base_default({ props: base_props });
  return {
    c() {
      create_component(base.$$.fragment);
    },
    m(target, anchor) {
      mount_component(base, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const base_changes = dirty & 1 ? get_spread_update(base_spread_levels, [get_spread_object(ctx2[0]), base_spread_levels[1]]) : {};
      base.$set(base_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(base.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(base.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(base, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  $$self.$$set = ($$new_props) => {
    $$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$props = exclude_internal_props($$props);
  return [$$props];
}
var Scatter = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
  }
};
var Scatter_default = Scatter;

// src/analyses.ts
function getPearsonCorrelation(xs, ys) {
  const n = xs.length;
  if (n !== ys.length)
    throw new Error("Arrays must be the same length");
  let sum_x = 0;
  let sum_y = 0;
  let sum_xy = 0;
  let sum_xx = 0;
  let sum_yy = 0;
  for (let i = 0; i < n; i++) {
    const x = xs[i];
    const y = ys[i];
    sum_x += x;
    sum_y += y;
    sum_xx += x * x;
    sum_yy += y * y;
    sum_xy += x * y;
  }
  const corr = (n * sum_xy - sum_x * sum_y) / Math.sqrt((n * sum_xx - sum_x * sum_x) * (n * sum_yy - sum_y * sum_y));
  return corr;
}
function getPointBiserialCorrelation(xs, ys) {
  if (xs.length <= 1 || ys.length <= 1 || !isBinary(xs) && !isQuant(ys))
    return null;
  const m0 = [], m1 = [];
  xs.forEach((x, i) => {
    const y = ys[i];
    if (!x)
      m0.push(y);
    else
      m1.push(y);
  });
  return (m1.length - m0.length) / getStdDev(ys) * Math.sqrt(m1.length * m0.length / xs.length);
}
function isQuant(xs) {
  return xs.length && xs.every((x) => typeof x === "number");
}
function isBinary(xs) {
  return xs.length && xs.every((x) => x === 0 || x === 1 || x === false || x === true);
}
function getMean(xs) {
  if (!isQuant(xs))
    return null;
  return xs.reduce((a, b) => a + b) / xs.length;
}
function getMedian(xs) {
  if (!isQuant(xs))
    return null;
  const sorted = xs.slice().sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  return sorted[mid];
}
function getMode(xs) {
  const flattened = xs.flat();
  const counts = {};
  flattened.forEach((x) => {
    if (counts[x])
      counts[x] = counts[x] + 1;
    else
      counts[x] = 1;
  });
  const max = Math.max(...Object.values(counts));
  return Object.keys(counts).filter((x) => counts[x] === max);
}
function getVariance(xs) {
  if (!isQuant(xs))
    return null;
  const mean_x = getMean(xs);
  return xs.reduce((a, b) => a + Math.pow(b - mean_x, 2), 0) / xs.length;
}
function getStdDev(xs) {
  if (!isQuant(xs))
    return null;
  return Math.sqrt(getVariance(xs));
}

// src/Components/Chart.svelte
var import_obsidian_dataview = __toModule(require_lib());
function add_css2(target) {
  append_styles(target, "svelte-1y359ls", "div.checkboxes.svelte-1y359ls{border-radius:5px;border:1px solid var(--background-modifier-border)}");
}
function create_fragment5(ctx) {
  let div0;
  let checkboxes;
  let updating_selected;
  let t0;
  let chartoptions;
  let updating_colour;
  let updating_startDate;
  let updating_endDate;
  let updating_dnOnly;
  let t1;
  let scatter;
  let t2;
  let div1;
  let t3;
  let t4_value = (ctx[7]?.toFixed(4) ?? "Select 2 fields") + "";
  let t4;
  let current;
  function checkboxes_selected_binding(value) {
    ctx[12](value);
  }
  let checkboxes_props = {
    options: ctx[9],
    plugin: ctx[8]
  };
  if (ctx[0] !== void 0) {
    checkboxes_props.selected = ctx[0];
  }
  checkboxes = new Checkboxes_default({ props: checkboxes_props });
  binding_callbacks.push(() => bind(checkboxes, "selected", checkboxes_selected_binding));
  function chartoptions_colour_binding(value) {
    ctx[13](value);
  }
  function chartoptions_startDate_binding(value) {
    ctx[14](value);
  }
  function chartoptions_endDate_binding(value) {
    ctx[15](value);
  }
  function chartoptions_dnOnly_binding(value) {
    ctx[16](value);
  }
  let chartoptions_props = {};
  if (ctx[1] !== void 0) {
    chartoptions_props.colour = ctx[1];
  }
  if (ctx[2] !== void 0) {
    chartoptions_props.startDate = ctx[2];
  }
  if (ctx[3] !== void 0) {
    chartoptions_props.endDate = ctx[3];
  }
  if (ctx[4] !== void 0) {
    chartoptions_props.dnOnly = ctx[4];
  }
  chartoptions = new ChartOptions_default({ props: chartoptions_props });
  binding_callbacks.push(() => bind(chartoptions, "colour", chartoptions_colour_binding));
  binding_callbacks.push(() => bind(chartoptions, "startDate", chartoptions_startDate_binding));
  binding_callbacks.push(() => bind(chartoptions, "endDate", chartoptions_endDate_binding));
  binding_callbacks.push(() => bind(chartoptions, "dnOnly", chartoptions_dnOnly_binding));
  scatter = new Scatter_default({
    props: {
      data: ctx[6],
      options: ctx[5]
    }
  });
  return {
    c() {
      div0 = element("div");
      create_component(checkboxes.$$.fragment);
      t0 = space();
      create_component(chartoptions.$$.fragment);
      t1 = space();
      create_component(scatter.$$.fragment);
      t2 = space();
      div1 = element("div");
      t3 = text("Correlation: ");
      t4 = text(t4_value);
      attr(div0, "class", "checkboxes svelte-1y359ls");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      mount_component(checkboxes, div0, null);
      insert(target, t0, anchor);
      mount_component(chartoptions, target, anchor);
      insert(target, t1, anchor);
      mount_component(scatter, target, anchor);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      append(div1, t3);
      append(div1, t4);
      current = true;
    },
    p(ctx2, [dirty]) {
      const checkboxes_changes = {};
      if (!updating_selected && dirty & 1) {
        updating_selected = true;
        checkboxes_changes.selected = ctx2[0];
        add_flush_callback(() => updating_selected = false);
      }
      checkboxes.$set(checkboxes_changes);
      const chartoptions_changes = {};
      if (!updating_colour && dirty & 2) {
        updating_colour = true;
        chartoptions_changes.colour = ctx2[1];
        add_flush_callback(() => updating_colour = false);
      }
      if (!updating_startDate && dirty & 4) {
        updating_startDate = true;
        chartoptions_changes.startDate = ctx2[2];
        add_flush_callback(() => updating_startDate = false);
      }
      if (!updating_endDate && dirty & 8) {
        updating_endDate = true;
        chartoptions_changes.endDate = ctx2[3];
        add_flush_callback(() => updating_endDate = false);
      }
      if (!updating_dnOnly && dirty & 16) {
        updating_dnOnly = true;
        chartoptions_changes.dnOnly = ctx2[4];
        add_flush_callback(() => updating_dnOnly = false);
      }
      chartoptions.$set(chartoptions_changes);
      const scatter_changes = {};
      if (dirty & 64)
        scatter_changes.data = ctx2[6];
      if (dirty & 32)
        scatter_changes.options = ctx2[5];
      scatter.$set(scatter_changes);
      if ((!current || dirty & 128) && t4_value !== (t4_value = (ctx2[7]?.toFixed(4) ?? "Select 2 fields") + ""))
        set_data(t4, t4_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(checkboxes.$$.fragment, local);
      transition_in(chartoptions.$$.fragment, local);
      transition_in(scatter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkboxes.$$.fragment, local);
      transition_out(chartoptions.$$.fragment, local);
      transition_out(scatter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      destroy_component(checkboxes);
      if (detaching)
        detach(t0);
      destroy_component(chartoptions, detaching);
      if (detaching)
        detach(t1);
      destroy_component(scatter, detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div1);
    }
  };
}
function isValidSelection(selected) {
  return selected.length === 2;
}
function refreshChartOptions(selected) {
  return {
    title: {
      display: true,
      text: "Scatter Chart - Logarithmic X-Axis"
    },
    scales: {
      xAxes: {
        title: {
          display: isValidSelection(selected),
          text: selected[0] ?? ""
        },
        type: "linear",
        position: "bottom",
        scaleLabel: { labelString: "Frequency", display: true }
      },
      yAxes: {
        type: "linear",
        scaleLabel: { labelString: "Voltage", display: true },
        title: {
          display: isValidSelection(selected),
          text: selected[1] ?? ""
        }
      }
    },
    plugins: {
      tooltip: {
        callbacks: {
          label(tooltipItem) {
            const { raw } = tooltipItem;
            return `${raw.name}:
(${raw.x}, ${raw.y})`;
          }
        }
      }
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let innerData;
  let correlation;
  let data;
  let chartOptions;
  let { modal } = $$props;
  const { app, plugin } = modal;
  const { index, settings } = plugin;
  const { fieldsToCheck } = settings;
  let allFields = fieldsToCheck;
  let selected = [];
  let colour = "#15a252";
  let startDate = index.minDate;
  let endDate = index.maxDate;
  let dnOnly = false;
  function refreshInnerData(selected2, dnOnly2, startDate2, endDate2) {
    const fileRange = dnOnly2 ? index.data.filter((item) => {
      const { day } = item.file;
      return day && startDate2.ts <= day.ts && day.ts <= endDate2.ts;
    }) : index.data;
    const innerData2 = fileRange.map((page) => {
      return {
        x: page[selected2[0]],
        y: page[selected2[1]],
        name: page.file.name
      };
    }).filter((point) => {
      return point.x && point.y;
    });
    return innerData2;
  }
  function refreshCorrelation(selected2, innerData2) {
    return isValidSelection(selected2) ? getPearsonCorrelation(innerData2.map((p) => p.x), innerData2.map((p) => p.y)) : null;
  }
  function refreshData(colour2, innerData2) {
    return {
      labels: ["Scatter"],
      datasets: [
        {
          borderColor: colour2,
          backgroundColor: colour2,
          label: "V(node2)",
          data: innerData2
        }
      ]
    };
  }
  function checkboxes_selected_binding(value) {
    selected = value;
    $$invalidate(0, selected);
  }
  function chartoptions_colour_binding(value) {
    colour = value;
    $$invalidate(1, colour);
  }
  function chartoptions_startDate_binding(value) {
    startDate = value;
    $$invalidate(2, startDate);
  }
  function chartoptions_endDate_binding(value) {
    endDate = value;
    $$invalidate(3, endDate);
  }
  function chartoptions_dnOnly_binding(value) {
    dnOnly = value;
    $$invalidate(4, dnOnly);
  }
  $$self.$$set = ($$props2) => {
    if ("modal" in $$props2)
      $$invalidate(10, modal = $$props2.modal);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 29) {
      $:
        $$invalidate(11, innerData = refreshInnerData(selected, dnOnly, startDate, endDate));
    }
    if ($$self.$$.dirty & 2049) {
      $:
        $$invalidate(7, correlation = refreshCorrelation(selected, innerData));
    }
    if ($$self.$$.dirty & 2050) {
      $:
        $$invalidate(6, data = refreshData(colour, innerData));
    }
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(5, chartOptions = refreshChartOptions(selected));
    }
  };
  return [
    selected,
    colour,
    startDate,
    endDate,
    dnOnly,
    chartOptions,
    data,
    correlation,
    plugin,
    allFields,
    modal,
    innerData,
    checkboxes_selected_binding,
    chartoptions_colour_binding,
    chartoptions_startDate_binding,
    chartoptions_endDate_binding,
    chartoptions_dnOnly_binding
  ];
}
var Chart2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { modal: 10 }, add_css2);
  }
};
var Chart_default = Chart2;

// src/ChartModal.ts
var ChartModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.modal = this;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    new Chart_default({
      target: contentEl,
      props: {
        modal: this
      }
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/const.ts
var DEFAULT_SETTINGS = {
  fieldsToCheck: [],
  fieldLists: [],
  dateFormat: "YYYY-MM-DD",
  defaultSavePath: "/",
  nullValue: "null",
  undefinedValue: "undefined",
  addFileData: false,
  addNoteContent: false
};
var splitLinksRegex = new RegExp(/\[\[(.*?)\]\]/g);
var dropHeaderOrAlias = new RegExp(/\[\[([^#|]*)\]\]/);

// src/SettingTab.ts
var import_obsidian2 = __toModule(require("obsidian"));

// src/utils.ts
var splitAndTrim = (fields) => {
  if (fields === "")
    return [];
  else
    return fields.split(",").map((str) => str.trim());
};
function makeArr(input) {
  return [input].flat();
}
function stringToNullOrUndefined(current) {
  if (current === "undefined")
    return void 0;
  else if (current === "null")
    return null;
  else
    return current;
}
function arrayOverlap(A, B) {
  const iA = [];
  A.forEach((a, i) => {
    if (a !== void 0)
      iA.push(i);
  });
  const iB = [];
  B.forEach((b, i) => {
    if (b !== void 0)
      iB.push(i);
  });
  const aOverlap = A.filter((a, i) => iA.includes(i) && iB.includes(i));
  const bOverlap = B.filter((b, i) => iA.includes(i) && iB.includes(i));
  if (!aOverlap.length || !bOverlap.length)
    return [[], []];
  return [aOverlap, bOverlap];
}

// src/SettingTab.ts
var SettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl, plugin } = this;
    const { settings } = plugin;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setClass("fields-to-check").setName("Fields to Check").setDesc("A comma-separated list of fields to look for data in.").addTextArea((text2) => {
      text2.setValue(settings.fieldsToCheck.join(", "));
      text2.inputEl.onblur = async () => {
        const splits = splitAndTrim(text2.getValue());
        settings.fieldsToCheck = splits;
        await plugin.saveSettings();
        await plugin.refreshIndex(plugin.app.plugins.plugins.dataview?.api);
      };
    });
    new import_obsidian2.Setting(containerEl).setName("Add All Numeric Fields").setDesc("Add all fields with numeric values to the list of fields to check").addButton((but) => {
      but.setButtonText("Add").onClick(async () => {
        const { data } = plugin.index;
        for (const page of data) {
          for (const field in page) {
            if (typeof page[field] === "number" && !settings.fieldsToCheck.includes(field)) {
              settings.fieldsToCheck.push(field);
              await plugin.saveSettings();
            }
          }
        }
        this.display();
        new import_obsidian2.Notice("Numeric fields added");
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Field Lists").setDesc("A comma-separated list of files that you keep fields in. Each field must be on a new line. It can be a wikilink, or not.").addText((text2) => {
      text2.setValue(settings.fieldLists.join(", "));
      text2.inputEl.onblur = async () => {
        const splits = splitAndTrim(text2.getValue());
        settings.fieldLists = splits;
        await plugin.saveSettings();
        await plugin.refreshIndex(this.app.plugins.plugins.dataview?.api);
      };
    });
    new import_obsidian2.Setting(containerEl).setName("Date Format").setDesc("The date format you use in your vault.").addMomentFormat((format) => {
      format.setDefaultFormat(DEFAULT_SETTINGS.dateFormat).setValue(settings.dateFormat).onChange(async (value) => {
        settings.dateFormat = value;
        await plugin.saveSettings();
      });
    });
    containerEl.createEl("h2", { text: "Exporting Data" });
    new import_obsidian2.Setting(containerEl).setName("Default save path").setDesc(`The full file path to save the metadataframe to. Don't include the file extension. For example, this is a correct file path: SubFolder/metadataframe. Use "/" to save to the root of your vault.`).addText((text2) => text2.setValue(settings.defaultSavePath).onChange(async (value) => {
      settings.defaultSavePath = value;
      await plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Null value").setDesc("What should the default value be for missing field values? Default is 'null'. Don't use quotes, just enter the value.").addText((text2) => text2.setValue(settings.nullValue).onChange(async (value) => {
      settings.nullValue = value;
      await plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Add inherent file metadata").setDesc("Each file has alot of inherent metadata to it (besides the fields you add). Should metadataframe add these fields too? It can be alot, so there is the option to disable this behaviour.").addToggle((toggle) => toggle.setValue(settings.addFileData).onChange(async (value) => {
      settings.addFileData = value;
      await plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Add content of each note").setDesc("Add a column for the content of each note. This will add alot of size to the CSV file, so it is off by default.").addToggle((toggle) => toggle.setValue(settings.addNoteContent).onChange(async (value) => {
      settings.addNoteContent = value;
      await plugin.saveSettings();
    }));
  }
};

// src/StatsModal.ts
var import_obsidian3 = __toModule(require("obsidian"));

// src/Components/Stats.svelte
function add_css3(target) {
  append_styles(target, "svelte-l76002", "table.svelte-l76002{margin-top:5px;border-collapse:collapse}th.svelte-l76002,td.svelte-l76002{border:1px solid var(--background-modifier-border)}td.svelte-l76002{padding:0.2rem 0.5rem}td.svelte-l76002:first-child{text-align:right}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let option;
  let t_value = ctx[1] + "";
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[1];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block2(ctx) {
  let tr;
  let td0;
  let t0_value = ctx[15][0] + "";
  let t0;
  let t1;
  let td1;
  let t2_value = ctx[15][1] + "";
  let t2;
  let t3;
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      attr(td0, "class", "svelte-l76002");
      attr(td1, "class", "svelte-l76002");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = ctx2[15][0] + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && t2_value !== (t2_value = ctx2[15][1] + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_each_block2(ctx) {
  let if_block_anchor;
  let if_block = ctx[15] && create_if_block2(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[15]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment6(ctx) {
  let label;
  let t0;
  let select;
  let t1;
  let table;
  let thead;
  let t5;
  let mounted;
  let dispose;
  let each_value_1 = ctx[2];
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  return {
    c() {
      label = element("label");
      t0 = text("Field:\r\n	");
      select = element("select");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t1 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th class="svelte-l76002">Stat</th> 
			<th class="svelte-l76002">Value</th></tr>`;
      t5 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(select, "class", "dropdown");
      if (ctx[1] === void 0)
        add_render_callback(() => ctx[9].call(select));
      attr(table, "class", "svelte-l76002");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, t0);
      append(label, select);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(select, null);
      }
      select_option(select, ctx[1]);
      insert(target, t1, anchor);
      insert(target, table, anchor);
      append(table, thead);
      append(table, t5);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(table, null);
      }
      if (!mounted) {
        dispose = listen(select, "change", ctx[9]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4) {
        each_value_1 = ctx2[2];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(select, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & 6) {
        select_option(select, ctx2[1]);
      }
      if (dirty & 1) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(table, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(label);
      destroy_each(each_blocks_1, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(table);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let data;
  let mean;
  let median;
  let mode;
  let std;
  let stats;
  let { modal } = $$props;
  const { app, plugin } = modal;
  const { index, settings } = plugin;
  const { fieldsToCheck } = settings;
  let field = fieldsToCheck[0];
  const updateData = (field2) => index.data.map((d) => d[field2]).filter((d) => d);
  function select_change_handler() {
    field = select_value(this);
    $$invalidate(1, field);
    $$invalidate(2, fieldsToCheck);
  }
  $$self.$$set = ($$props2) => {
    if ("modal" in $$props2)
      $$invalidate(3, modal = $$props2.modal);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $:
        $$invalidate(8, data = updateData(field));
    }
    if ($$self.$$.dirty & 256) {
      $:
        $$invalidate(7, mean = getMean(data));
    }
    if ($$self.$$.dirty & 256) {
      $:
        $$invalidate(6, median = getMedian(data));
    }
    if ($$self.$$.dirty & 256) {
      $:
        $$invalidate(5, mode = getMode(data));
    }
    if ($$self.$$.dirty & 256) {
      $:
        $$invalidate(4, std = getStdDev(data));
    }
    if ($$self.$$.dirty & 240) {
      $:
        $$invalidate(0, stats = [
          mean ? ["Mean", mean] : null,
          median ? ["Median", median] : null,
          ["Mode", mode],
          std ? ["Std Dev.", std?.toFixed(4)] : null
        ]);
    }
    if ($$self.$$.dirty & 1) {
      $:
        console.log({ stats });
    }
  };
  return [
    stats,
    field,
    fieldsToCheck,
    modal,
    std,
    mode,
    median,
    mean,
    data,
    select_change_handler
  ];
}
var Stats = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, { modal: 3 }, add_css3);
  }
};
var Stats_default = Stats;

// src/StatsModal.ts
var StatsModal = class extends import_obsidian3.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.modal = this;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    new Stats_default({
      target: contentEl,
      props: {
        modal: this
      }
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/main.ts
var DataAnalysisPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.index = {
      data: void 0,
      minDate: void 0,
      maxDate: void 0
    };
    this.unwrappedFields = {};
  }
  async onload() {
    console.log("Loading data-analysis plugin");
    await this.loadSettings();
    this.addSettingTab(new SettingTab(this.app, this));
    if (this.app.plugins.enabledPlugins.has("dataview")) {
      const api = this.app.plugins.plugins.dataview?.api;
      if (api)
        this.refreshIndex(api);
      else {
        this.registerEvent(this.app.metadataCache.on("dataview:api-ready", (api2) => {
          this.refreshIndex(api2);
        }));
      }
    } else {
      new import_obsidian4.Notice("Dataview must be enabled for the Data Analysis plugin to work");
    }
    this.addCommand({
      id: "refresh-index",
      name: "Refresh Index",
      callback: async () => await this.refreshIndex(this.app.plugins.plugins.dataview?.api)
    });
    this.addCommand({
      id: "chart-view",
      name: "Open Chart Modal",
      callback: async () => new ChartModal(this.app, this).open()
    });
    this.addCommand({
      id: "stats-view",
      name: "Open Stats Modal",
      callback: async () => new StatsModal(this.app, this).open()
    });
    this.addCommand({
      id: "builds-corrs",
      name: "Build Correlations",
      callback: async () => console.log(this.buildAllCorrelations())
    });
    this.addCommand({
      id: "write-metadataframe",
      name: "Write Metadataframe",
      callback: async () => {
        try {
          const jsDF = await this.createJSDF();
          console.log(jsDF);
          await this.writeMetadataframe(jsDF);
        } catch (error) {
          new import_obsidian4.Notice("An error occured. Please check the console.");
          console.log(error);
        }
      }
    });
  }
  onunload() {
  }
  unproxy(item) {
    const unproxied = [];
    const queue = [item];
    while (queue.length) {
      const currItem = queue.shift();
      if (typeof currItem.defaultComparator === "function") {
        const possibleUnproxied = Object.assign({}, currItem);
        const { values } = possibleUnproxied;
        if (values)
          queue.push(...values);
        else
          unproxied.push(possibleUnproxied);
      } else
        unproxied.push(currItem);
    }
    return unproxied;
  }
  getInnerValue(value) {
    const unproxied = this.unproxy(value);
    if (unproxied.length === 1) {
      if (typeof unproxied[0] === "string") {
        let list = unproxied[0];
        if (list.startsWith("[") && list.endsWith("]")) {
          list = list.slice(1, -1);
        }
        const splits = splitAndTrim(list).map((item) => {
          if (item.startsWith(`"`) && item.endsWith(`"`)) {
            return item.slice(1, -1);
          } else
            return item;
        });
        if (splits.length === 1)
          return splits[0];
        else
          return splits;
      } else {
        if (unproxied[0].type === "file") {
          return unproxied[0].path;
        } else
          return unproxied[0];
      }
    } else {
      if (unproxied[0].type === "file") {
        return unproxied.map((link) => link.path);
      } else
        return unproxied;
    }
  }
  unwrapStrLists(data) {
    const { unwrappedFields } = this;
    const { fieldsToCheck } = this.settings;
    for (const field of fieldsToCheck) {
      unwrappedFields[field] = [];
      data.forEach((d) => {
        const val = d[field];
        if (val) {
          if (typeof val === "string") {
            d[val] = true;
            if (!unwrappedFields[field].includes(val))
              unwrappedFields[field].push(val);
          } else if (val?.every && val.every((x) => typeof x === "string")) {
            val.forEach((str) => {
              d[str] = true;
              if (!unwrappedFields[field].includes(str))
                unwrappedFields[field].push(str);
            });
          }
        }
      });
    }
  }
  async refreshIndex(dvApi) {
    const notice = new import_obsidian4.Notice("Index refreshing...");
    if (!dvApi) {
      notice.setMessage("Dataview must be enabled");
      return;
    }
    const { fieldsToCheck, fieldLists } = this.settings;
    for (const path of fieldLists) {
      const file = this.app.metadataCache.getFirstLinkpathDest(path, "");
      if (!file)
        continue;
      const content = await this.app.vault.cachedRead(file);
      const lines = content.split("\n");
      lines.forEach((line) => {
        const field = line.startsWith("[[") ? line.slice(2, -2) : line;
        if (!fieldsToCheck.includes(field))
          fieldsToCheck.push(field);
      });
      this.settings.fieldsToCheck = fieldsToCheck;
      await this.saveSettings();
    }
    const pages = dvApi.pages().values;
    const dates = [];
    pages.forEach((page) => {
      const potentialDate = import_luxon2.DateTime.fromISO(page.file.name);
      if (potentialDate.isValid)
        dates.push(potentialDate);
      fieldsToCheck.forEach((field) => {
        const value = page[field];
        if (value)
          page[field] = this.getInnerValue(value);
      });
    });
    this.unwrapStrLists(pages);
    this.index = {
      data: pages,
      minDate: import_luxon2.DateTime.min(...dates),
      maxDate: import_luxon2.DateTime.max(...dates)
    };
    console.log(this.index);
    notice.setMessage("Index refreshed \u2705");
  }
  allUniqueValuesForField(field) {
    const values = [];
    this.index.data.forEach((page) => {
      const value = page[field];
      if (value)
        values.push(...makeArr(value));
    });
    return [...new Set([...values])];
  }
  inferType(xs) {
    const defineds = xs.filter((x) => x);
    const types = defineds.map((x) => typeof x);
    if (!defineds.length)
      return "undefined";
    const thresh = defineds.length / 2;
    if (types.filter((x) => x === "number").length >= thresh)
      return "number";
    else if (types.filter((x) => x === "string").length >= thresh)
      return "string";
    else
      return "object";
  }
  replaceMissing(xs) {
    const type = this.inferType(xs);
    return xs.map((x) => x ?? (type === "number" ? 0 : "N/A"));
  }
  buildAllCorrelations() {
    const { data } = this.index;
    const { fieldsToCheck } = this.settings;
    const corrs = {};
    for (const fA of fieldsToCheck) {
      corrs[fA] = {};
      const vA = data.map((d) => d[fA]);
      const tA = this.inferType(vA);
      for (const fB of fieldsToCheck) {
        if (fA === fB)
          continue;
        const vB = data.map((d) => d[fB]);
        const tB = this.inferType(vB);
        if (tA === "number" && tB === "number") {
          const [oA, oB] = arrayOverlap(vA, vB);
          if (oA.length <= 1 || oB.length <= 1) {
            corrs[fA][fB] = null;
            continue;
          }
          const corr = getPearsonCorrelation(oA, oB);
          corrs[fA][fB] = corr;
        } else if (tA === "number" && tB === "string") {
          const oA = vA.filter((a) => a);
          const oB = vB.filter((b, i) => vA[i] !== void 0).map((b) => b ?? 0);
          const uniqueStrs = [...new Set(oB)].filter((str) => typeof str === "string");
          uniqueStrs.forEach((subF) => {
            const subA = oA;
            const subB = oB.map((b) => b === subF ? 1 : 0);
            const corr = getPointBiserialCorrelation(subB, subA);
            corrs[fA][subF] = corr;
          });
        } else if (tA === "number" && tB === "object") {
          const oA = vA.filter((a) => a);
          console.log({ vB });
          const oB = vB;
          console.log({ vA, vB, oA, oB });
          const uniqueStrs = [...new Set(oB)].filter((str) => typeof str === "string");
          uniqueStrs.forEach((subF) => {
            const subA = oA;
            const subB = oB.map((b) => b === subF ? 1 : 0);
            const corr = getPointBiserialCorrelation(subB, subA);
            corrs[fA][subF] = corr;
          });
        } else if (tA === "string" && tB === "string") {
        } else if (tA === "string" && tB === "number") {
        } else if (tA === "string" && tB === "object") {
        } else if (tA === "object" && tB === "object") {
        } else if (tA === "object" && tB === "number") {
        } else if (tA === "object" && tB === "string") {
        }
      }
    }
    console.log({ corrs });
  }
  getAllCorrsForField(fieldA) {
    const { data } = this.index;
    const { fieldsToCheck } = this.settings;
    const correlations = {};
    const fieldsForA = this.allUniqueValuesForField(fieldA);
    fieldsToCheck.forEach((fieldB) => {
      const fieldsForB = this.allUniqueValuesForField(fieldB);
      const valsInCommon = {};
      if (!valsInCommon.hasOwnProperty(fieldA)) {
        valsInCommon[fieldA] = {};
      }
      const valsA = data.map((d) => d[fieldA]);
      const valsB = data.map((d) => d[fieldB]);
      valsA.forEach((valA) => {
        if (typeof valA === "string") {
        }
      });
      valsInCommon[fieldA][fieldB] = [valsA, valsB];
      console.log(valsInCommon);
    });
  }
  async createJSDF() {
    const { settings } = this;
    const {
      addNoteContent,
      addFileData,
      nullValue,
      undefinedValue,
      fieldsToCheck
    } = settings;
    let yamldf = [];
    let uniqueKeys = [];
    let actualNullValue = stringToNullOrUndefined(nullValue);
    for (const page of this.index.data) {
      const { file } = page;
      const currRow = { file: { path: file.path }, content: "" };
      if (addNoteContent) {
        const content = await this.app.vault.cachedRead(file);
        currRow["content"] = content;
      }
      for (const key of fieldsToCheck) {
        if (key !== "position") {
          if (key !== "file" || addFileData) {
            const value = page[key];
            const arrValues = [value].flat(4);
            if (!uniqueKeys.includes(key))
              uniqueKeys.push(key);
            if (!value) {
              currRow[key] = actualNullValue;
            } else if (typeof value === "string") {
              const splits = value.match(splitLinksRegex);
              if (splits !== null) {
                const strs = splits.map((link) => {
                  const dropped = link.match(dropHeaderOrAlias)?.[1];
                  if (dropped) {
                    return `[[${dropped}]]`;
                  } else {
                    return link;
                  }
                }).join(", ");
                currRow[key] = strs;
              } else {
                currRow[key] = value;
              }
            } else if (arrValues?.[0]?.ts) {
              currRow[key] = arrValues.map((val) => val?.ts).join(", ");
            } else if (arrValues?.[0]?.path) {
              currRow[key] = arrValues.map((val) => `[[${val?.path}]]`).join(", ");
            } else if (Object.prototype.toString.call(value) === "[object Object]") {
              currRow[key] = value;
            } else {
              currRow[key] = arrValues.join(", ");
            }
          }
        }
      }
      yamldf.push(currRow);
    }
    let actualUndefinedValue = stringToNullOrUndefined(undefinedValue);
    for (let i = 0; i < Object.keys(yamldf).length; i++) {
      uniqueKeys.forEach((key) => {
        if (yamldf[i][key] === void 0) {
          yamldf[i][key] = actualUndefinedValue;
        }
      });
    }
    return yamldf;
  }
  async writeMetadataframe(jsDF) {
    const { nullValue, defaultSavePath } = this.settings;
    const defaultValue = nullValue;
    const opts = { defaultValue, transforms: [import_json2csv.transforms.flatten()] };
    let csv = "";
    try {
      const parser = new import_json2csv.Parser(opts);
      csv = parser.parse(jsDF);
      if (defaultSavePath === "" && csv !== "") {
        new import_obsidian4.Notice("Please choose a path to save to in settings");
      } else {
        try {
          console.log("here");
          const savePath = (0, import_obsidian4.normalizePath)(defaultSavePath);
          const now = window.moment().format("YYYY-MM-DD HHmmss");
          await this.app.vault.create(`${savePath} ${now}.csv`, csv);
          new import_obsidian4.Notice("Write Metadataframe complete");
        } catch (error) {
          new import_obsidian4.Notice("File already exists");
        }
      }
    } catch (err) {
      console.error(err);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*!
 * @kurkle/color v0.1.9
 * https://github.com/kurkle/color#readme
 * (c) 2020 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v3.7.0
 * https://www.chartjs.org
 * (c) 2021 Chart.js Contributors
 * Released under the MIT License
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9lcnJvcnMuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHMuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3V0aWwuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2VuZ2xpc2guanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHRlci5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvaW52YWxpZC5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmUuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9zeXN0ZW1ab25lLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvSUFOQVpvbmUuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9maXhlZE9mZnNldFpvbmUuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lcy9pbnZhbGlkWm9uZS5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvem9uZVV0aWwuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9zZXR0aW5ncy5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvbG9jYWxlLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9yZWdleFBhcnNlci5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2R1cmF0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW50ZXJ2YWwuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbmZvLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9kaWZmLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9kaWdpdHMuanMiLCAibm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3Rva2VuUGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9jb252ZXJzaW9ucy5qcyIsICJub2RlX21vZHVsZXMvbHV4b24vc3JjL2RhdGV0aW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9sdXhvbi9zcmMvbHV4b24uanMiLCAibm9kZV9tb2R1bGVzL2pzb24yY3N2L2Rpc3QvanNvbjJjc3YudW1kLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9saWIvaW5kZXguanMiLCAic3JjL21haW4udHMiLCAic3JjL0NoYXJ0TW9kYWwudHMiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS9pbnRlcm5hbC9pbmRleC5tanMiLCAic3JjL0NvbXBvbmVudHMvQ2hlY2tib3hlcy5zdmVsdGUiLCAic3JjL0NvbXBvbmVudHMvQ2hhcnRPcHRpb25zLnN2ZWx0ZSIsICJub2RlX21vZHVsZXMvc3ZlbHRlLWNoYXJ0anMvc3JjL3V0aWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NodW5rcy9oZWxwZXJzLnNlZ21lbnQuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvY2hhcnQuZXNtLmpzIiwgIm5vZGVfbW9kdWxlcy9zdmVsdGUtY2hhcnRqcy9zcmMvQmFzZS5zdmVsdGUiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS1jaGFydGpzL3NyYy9TY2F0dGVyLnN2ZWx0ZSIsICJzcmMvYW5hbHlzZXMudHMiLCAic3JjL0NvbXBvbmVudHMvQ2hhcnQuc3ZlbHRlIiwgInNyYy9jb25zdC50cyIsICJzcmMvU2V0dGluZ1RhYi50cyIsICJzcmMvdXRpbHMudHMiLCAic3JjL1N0YXRzTW9kYWwudHMiLCAic3JjL0NvbXBvbmVudHMvU3RhdHMuc3ZlbHRlIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyB0aGVzZSBhcmVuJ3QgcmVhbGx5IHByaXZhdGUsIGJ1dCBub3IgYXJlIHRoZXkgcmVhbGx5IHVzZWZ1bCB0byBkb2N1bWVudFxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEx1eG9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkRGF0ZVRpbWVFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihgSW52YWxpZCBEYXRlVGltZTogJHtyZWFzb24udG9NZXNzYWdlKCl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEludGVydmFsRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIoYEludmFsaWQgSW50ZXJ2YWw6ICR7cmVhc29uLnRvTWVzc2FnZSgpfWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWREdXJhdGlvbkVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKGBJbnZhbGlkIER1cmF0aW9uOiAke3JlYXNvbi50b01lc3NhZ2UoKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige31cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFVuaXRFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih1bml0KSB7XG4gICAgc3VwZXIoYEludmFsaWQgdW5pdCAke3VuaXR9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEFyZ3VtZW50RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHt9XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFpvbmVJc0Fic3RyYWN0RXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJab25lIGlzIGFuIGFic3RyYWN0IGNsYXNzXCIpO1xuICB9XG59XG4iLCAiLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNvbnN0IG4gPSBcIm51bWVyaWNcIixcbiAgcyA9IFwic2hvcnRcIixcbiAgbCA9IFwibG9uZ1wiO1xuXG5leHBvcnQgY29uc3QgREFURV9TSE9SVCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IG4sXG4gIGRheTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX01FRCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX01FRF9XSVRIX1dFRUtEQVkgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9GVUxMID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfSFVHRSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1NJTVBMRSA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfV0lUSF9TRUNPTkRTID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FX1dJVEhfU0hPUlRfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfV0lUSF9MT05HX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1NJTVBMRSA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9XSVRIX1NFQ09ORFMgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICBob3VyQ3ljbGU6IFwiaDIzXCIsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbiAgdGltZVpvbmVOYW1lOiBzLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX1NIT1JUID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbixcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbixcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9NRUQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBzLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfRlVMTCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfSFVHRSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuIiwgIi8qXG4gIFRoaXMgaXMganVzdCBhIGp1bmsgZHJhd2VyLCBjb250YWluaW5nIGFueXRoaW5nIHVzZWQgYWNyb3NzIG11bHRpcGxlIGNsYXNzZXMuXG4gIEJlY2F1c2UgTHV4b24gaXMgc21hbGwoaXNoKSwgdGhpcyBzaG91bGQgc3RheSBzbWFsbCBhbmQgd2Ugd29uJ3Qgd29ycnkgYWJvdXQgc3BsaXR0aW5nXG4gIGl0IHVwIGludG8sIHNheSwgcGFyc2luZ1V0aWwuanMgYW5kIGJhc2ljVXRpbC5qcyBhbmQgc28gb24uIEJ1dCB0aGV5IGFyZSBkaXZpZGVkIHVwIGJ5IGZlYXR1cmUgYXJlYS5cbiovXG5cbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuLy8gVFlQRVNcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcInVuZGVmaW5lZFwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVnZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCIgJiYgbyAlIDEgPT09IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyhvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZShvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBEYXRlXVwiO1xufVxuXG4vLyBDQVBBQklMSVRJRVNcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1JlbGF0aXZlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgSW50bCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhIUludGwuUmVsYXRpdmVUaW1lRm9ybWF0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIE9CSkVDVFMgQU5EIEFSUkFZU1xuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVBcnJheSh0aGluZykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGluZykgPyB0aGluZyA6IFt0aGluZ107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiZXN0QnkoYXJyLCBieSwgY29tcGFyZSkge1xuICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGFyci5yZWR1Y2UoKGJlc3QsIG5leHQpID0+IHtcbiAgICBjb25zdCBwYWlyID0gW2J5KG5leHQpLCBuZXh0XTtcbiAgICBpZiAoIWJlc3QpIHtcbiAgICAgIHJldHVybiBwYWlyO1xuICAgIH0gZWxzZSBpZiAoY29tcGFyZShiZXN0WzBdLCBwYWlyWzBdKSA9PT0gYmVzdFswXSkge1xuICAgICAgcmV0dXJuIGJlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYWlyO1xuICAgIH1cbiAgfSwgbnVsbClbMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaWNrKG9iaiwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoKGEsIGspID0+IHtcbiAgICBhW2tdID0gb2JqW2tdO1xuICAgIHJldHVybiBhO1xuICB9LCB7fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG4vLyBOVU1CRVJTIEFORCBTVFJJTkdTXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlZ2VyQmV0d2Vlbih0aGluZywgYm90dG9tLCB0b3ApIHtcbiAgcmV0dXJuIGlzSW50ZWdlcih0aGluZykgJiYgdGhpbmcgPj0gYm90dG9tICYmIHRoaW5nIDw9IHRvcDtcbn1cblxuLy8geCAlIG4gYnV0IHRha2VzIHRoZSBzaWduIG9mIG4gaW5zdGVhZCBvZiB4XG5leHBvcnQgZnVuY3Rpb24gZmxvb3JNb2QoeCwgbikge1xuICByZXR1cm4geCAtIG4gKiBNYXRoLmZsb29yKHggLyBuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZFN0YXJ0KGlucHV0LCBuID0gMikge1xuICBjb25zdCBpc05lZyA9IGlucHV0IDwgMDtcbiAgbGV0IHBhZGRlZDtcbiAgaWYgKGlzTmVnKSB7XG4gICAgcGFkZGVkID0gXCItXCIgKyAoXCJcIiArIC1pbnB1dCkucGFkU3RhcnQobiwgXCIwXCIpO1xuICB9IGVsc2Uge1xuICAgIHBhZGRlZCA9IChcIlwiICsgaW5wdXQpLnBhZFN0YXJ0KG4sIFwiMFwiKTtcbiAgfVxuICByZXR1cm4gcGFkZGVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbnRlZ2VyKHN0cmluZykge1xuICBpZiAoaXNVbmRlZmluZWQoc3RyaW5nKSB8fCBzdHJpbmcgPT09IG51bGwgfHwgc3RyaW5nID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nLCAxMCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmxvYXRpbmcoc3RyaW5nKSB7XG4gIGlmIChpc1VuZGVmaW5lZChzdHJpbmcpIHx8IHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cmluZyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWlsbGlzKGZyYWN0aW9uKSB7XG4gIC8vIFJldHVybiB1bmRlZmluZWQgKGluc3RlYWQgb2YgMCkgaW4gdGhlc2UgY2FzZXMsIHdoZXJlIGZyYWN0aW9uIGlzIG5vdCBzZXRcbiAgaWYgKGlzVW5kZWZpbmVkKGZyYWN0aW9uKSB8fCBmcmFjdGlvbiA9PT0gbnVsbCB8fCBmcmFjdGlvbiA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZiA9IHBhcnNlRmxvYXQoXCIwLlwiICsgZnJhY3Rpb24pICogMTAwMDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihmKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcm91bmRUbyhudW1iZXIsIGRpZ2l0cywgdG93YXJkWmVybyA9IGZhbHNlKSB7XG4gIGNvbnN0IGZhY3RvciA9IDEwICoqIGRpZ2l0cyxcbiAgICByb3VuZGVyID0gdG93YXJkWmVybyA/IE1hdGgudHJ1bmMgOiBNYXRoLnJvdW5kO1xuICByZXR1cm4gcm91bmRlcihudW1iZXIgKiBmYWN0b3IpIC8gZmFjdG9yO1xufVxuXG4vLyBEQVRFIEJBU0lDU1xuXG5leHBvcnQgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gIGNvbnN0IG1vZE1vbnRoID0gZmxvb3JNb2QobW9udGggLSAxLCAxMikgKyAxLFxuICAgIG1vZFllYXIgPSB5ZWFyICsgKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG5cbiAgaWYgKG1vZE1vbnRoID09PSAyKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIobW9kWWVhcikgPyAyOSA6IDI4O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbMzEsIG51bGwsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVttb2RNb250aCAtIDFdO1xuICB9XG59XG5cbi8vIGNvdmVydCBhIGNhbGVuZGFyIG9iamVjdCB0byBhIGxvY2FsIHRpbWVzdGFtcCAoZXBvY2gsIGJ1dCB3aXRoIHRoZSBvZmZzZXQgYmFrZWQgaW4pXG5leHBvcnQgZnVuY3Rpb24gb2JqVG9Mb2NhbFRTKG9iaikge1xuICBsZXQgZCA9IERhdGUuVVRDKFxuICAgIG9iai55ZWFyLFxuICAgIG9iai5tb250aCAtIDEsXG4gICAgb2JqLmRheSxcbiAgICBvYmouaG91cixcbiAgICBvYmoubWludXRlLFxuICAgIG9iai5zZWNvbmQsXG4gICAgb2JqLm1pbGxpc2Vjb25kXG4gICk7XG5cbiAgLy8gZm9yIGxlZ2FjeSByZWFzb25zLCB5ZWFycyBiZXR3ZWVuIDAgYW5kIDk5IGFyZSBpbnRlcnByZXRlZCBhcyAxOVhYOyByZXZlcnQgdGhhdFxuICBpZiAob2JqLnllYXIgPCAxMDAgJiYgb2JqLnllYXIgPj0gMCkge1xuICAgIGQgPSBuZXcgRGF0ZShkKTtcbiAgICBkLnNldFVUQ0Z1bGxZZWFyKGQuZ2V0VVRDRnVsbFllYXIoKSAtIDE5MDApO1xuICB9XG4gIHJldHVybiArZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtzSW5XZWVrWWVhcih3ZWVrWWVhcikge1xuICBjb25zdCBwMSA9XG4gICAgICAod2Vla1llYXIgK1xuICAgICAgICBNYXRoLmZsb29yKHdlZWtZZWFyIC8gNCkgLVxuICAgICAgICBNYXRoLmZsb29yKHdlZWtZZWFyIC8gMTAwKSArXG4gICAgICAgIE1hdGguZmxvb3Iod2Vla1llYXIgLyA0MDApKSAlXG4gICAgICA3LFxuICAgIGxhc3QgPSB3ZWVrWWVhciAtIDEsXG4gICAgcDIgPSAobGFzdCArIE1hdGguZmxvb3IobGFzdCAvIDQpIC0gTWF0aC5mbG9vcihsYXN0IC8gMTAwKSArIE1hdGguZmxvb3IobGFzdCAvIDQwMCkpICUgNztcbiAgcmV0dXJuIHAxID09PSA0IHx8IHAyID09PSAzID8gNTMgOiA1Mjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXIpIHtcbiAgaWYgKHllYXIgPiA5OSkge1xuICAgIHJldHVybiB5ZWFyO1xuICB9IGVsc2UgcmV0dXJuIHllYXIgPiA2MCA/IDE5MDAgKyB5ZWFyIDogMjAwMCArIHllYXI7XG59XG5cbi8vIFBBUlNJTkdcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlWm9uZUluZm8odHMsIG9mZnNldEZvcm1hdCwgbG9jYWxlLCB0aW1lWm9uZSA9IG51bGwpIHtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRzKSxcbiAgICBpbnRsT3B0cyA9IHtcbiAgICAgIGhvdXJDeWNsZTogXCJoMjNcIixcbiAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICB9O1xuXG4gIGlmICh0aW1lWm9uZSkge1xuICAgIGludGxPcHRzLnRpbWVab25lID0gdGltZVpvbmU7XG4gIH1cblxuICBjb25zdCBtb2RpZmllZCA9IHsgdGltZVpvbmVOYW1lOiBvZmZzZXRGb3JtYXQsIC4uLmludGxPcHRzIH07XG5cbiAgY29uc3QgcGFyc2VkID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBtb2RpZmllZClcbiAgICAuZm9ybWF0VG9QYXJ0cyhkYXRlKVxuICAgIC5maW5kKChtKSA9PiBtLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0aW1lem9uZW5hbWVcIik7XG4gIHJldHVybiBwYXJzZWQgPyBwYXJzZWQudmFsdWUgOiBudWxsO1xufVxuXG4vLyBzaWduZWRPZmZzZXQoJy01JywgJzMwJykgLT4gLTMzMFxuZXhwb3J0IGZ1bmN0aW9uIHNpZ25lZE9mZnNldChvZmZIb3VyU3RyLCBvZmZNaW51dGVTdHIpIHtcbiAgbGV0IG9mZkhvdXIgPSBwYXJzZUludChvZmZIb3VyU3RyLCAxMCk7XG5cbiAgLy8gZG9uJ3QgfHwgdGhpcyBiZWNhdXNlIHdlIHdhbnQgdG8gcHJlc2VydmUgLTBcbiAgaWYgKE51bWJlci5pc05hTihvZmZIb3VyKSkge1xuICAgIG9mZkhvdXIgPSAwO1xuICB9XG5cbiAgY29uc3Qgb2ZmTWluID0gcGFyc2VJbnQob2ZmTWludXRlU3RyLCAxMCkgfHwgMCxcbiAgICBvZmZNaW5TaWduZWQgPSBvZmZIb3VyIDwgMCB8fCBPYmplY3QuaXMob2ZmSG91ciwgLTApID8gLW9mZk1pbiA6IG9mZk1pbjtcbiAgcmV0dXJuIG9mZkhvdXIgKiA2MCArIG9mZk1pblNpZ25lZDtcbn1cblxuLy8gQ09FUkNJT05cblxuZXhwb3J0IGZ1bmN0aW9uIGFzTnVtYmVyKHZhbHVlKSB7XG4gIGNvbnN0IG51bWVyaWNWYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHZhbHVlID09PSBcIlwiIHx8IE51bWJlci5pc05hTihudW1lcmljVmFsdWUpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgSW52YWxpZCB1bml0IHZhbHVlICR7dmFsdWV9YCk7XG4gIHJldHVybiBudW1lcmljVmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVPYmplY3Qob2JqLCBub3JtYWxpemVyKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgZm9yIChjb25zdCB1IGluIG9iaikge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIHUpKSB7XG4gICAgICBjb25zdCB2ID0gb2JqW3VdO1xuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplcih1KV0gPSBhc051bWJlcih2KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRPZmZzZXQob2Zmc2V0LCBmb3JtYXQpIHtcbiAgY29uc3QgaG91cnMgPSBNYXRoLnRydW5jKE1hdGguYWJzKG9mZnNldCAvIDYwKSksXG4gICAgbWludXRlcyA9IE1hdGgudHJ1bmMoTWF0aC5hYnMob2Zmc2V0ICUgNjApKSxcbiAgICBzaWduID0gb2Zmc2V0ID49IDAgPyBcIitcIiA6IFwiLVwiO1xuXG4gIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gYCR7c2lnbn0ke3BhZFN0YXJ0KGhvdXJzLCAyKX06JHtwYWRTdGFydChtaW51dGVzLCAyKX1gO1xuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBgJHtzaWdufSR7aG91cnN9JHttaW51dGVzID4gMCA/IGA6JHttaW51dGVzfWAgOiBcIlwifWA7XG4gICAgY2FzZSBcInRlY2hpZVwiOlxuICAgICAgcmV0dXJuIGAke3NpZ259JHtwYWRTdGFydChob3VycywgMil9JHtwYWRTdGFydChtaW51dGVzLCAyKX1gO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVmFsdWUgZm9ybWF0ICR7Zm9ybWF0fSBpcyBvdXQgb2YgcmFuZ2UgZm9yIHByb3BlcnR5IGZvcm1hdGApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lT2JqZWN0KG9iaikge1xuICByZXR1cm4gcGljayhvYmosIFtcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXSk7XG59XG5cbmV4cG9ydCBjb25zdCBpYW5hUmVnZXggPSAvW0EtWmEtel8rLV17MSwyNTZ9KDo/XFwvW0EtWmEtejAtOV8rLV17MSwyNTZ9KFxcL1tBLVphLXowLTlfKy1dezEsMjU2fSk/KT8vO1xuIiwgImltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHsgcGljayB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBPYmplY3Qua2V5cyhvYmopLnNvcnQoKSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgY29uc3QgbW9udGhzTG9uZyA9IFtcbiAgXCJKYW51YXJ5XCIsXG4gIFwiRmVicnVhcnlcIixcbiAgXCJNYXJjaFwiLFxuICBcIkFwcmlsXCIsXG4gIFwiTWF5XCIsXG4gIFwiSnVuZVwiLFxuICBcIkp1bHlcIixcbiAgXCJBdWd1c3RcIixcbiAgXCJTZXB0ZW1iZXJcIixcbiAgXCJPY3RvYmVyXCIsXG4gIFwiTm92ZW1iZXJcIixcbiAgXCJEZWNlbWJlclwiLFxuXTtcblxuZXhwb3J0IGNvbnN0IG1vbnRoc1Nob3J0ID0gW1xuICBcIkphblwiLFxuICBcIkZlYlwiLFxuICBcIk1hclwiLFxuICBcIkFwclwiLFxuICBcIk1heVwiLFxuICBcIkp1blwiLFxuICBcIkp1bFwiLFxuICBcIkF1Z1wiLFxuICBcIlNlcFwiLFxuICBcIk9jdFwiLFxuICBcIk5vdlwiLFxuICBcIkRlY1wiLFxuXTtcblxuZXhwb3J0IGNvbnN0IG1vbnRoc05hcnJvdyA9IFtcIkpcIiwgXCJGXCIsIFwiTVwiLCBcIkFcIiwgXCJNXCIsIFwiSlwiLCBcIkpcIiwgXCJBXCIsIFwiU1wiLCBcIk9cIiwgXCJOXCIsIFwiRFwiXTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1vbnRocyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLm1vbnRoc05hcnJvd107XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gWy4uLm1vbnRoc1Nob3J0XTtcbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNMb25nXTtcbiAgICBjYXNlIFwibnVtZXJpY1wiOlxuICAgICAgcmV0dXJuIFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiLCBcIjEwXCIsIFwiMTFcIiwgXCIxMlwiXTtcbiAgICBjYXNlIFwiMi1kaWdpdFwiOlxuICAgICAgcmV0dXJuIFtcIjAxXCIsIFwiMDJcIiwgXCIwM1wiLCBcIjA0XCIsIFwiMDVcIiwgXCIwNlwiLCBcIjA3XCIsIFwiMDhcIiwgXCIwOVwiLCBcIjEwXCIsIFwiMTFcIiwgXCIxMlwiXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHdlZWtkYXlzTG9uZyA9IFtcbiAgXCJNb25kYXlcIixcbiAgXCJUdWVzZGF5XCIsXG4gIFwiV2VkbmVzZGF5XCIsXG4gIFwiVGh1cnNkYXlcIixcbiAgXCJGcmlkYXlcIixcbiAgXCJTYXR1cmRheVwiLFxuICBcIlN1bmRheVwiLFxuXTtcblxuZXhwb3J0IGNvbnN0IHdlZWtkYXlzU2hvcnQgPSBbXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiwgXCJTdW5cIl07XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c05hcnJvdyA9IFtcIk1cIiwgXCJUXCIsIFwiV1wiLCBcIlRcIiwgXCJGXCIsIFwiU1wiLCBcIlNcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrZGF5cyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLndlZWtkYXlzTmFycm93XTtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNTaG9ydF07XG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiBbLi4ud2Vla2RheXNMb25nXTtcbiAgICBjYXNlIFwibnVtZXJpY1wiOlxuICAgICAgcmV0dXJuIFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIl07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBtZXJpZGllbXMgPSBbXCJBTVwiLCBcIlBNXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc0xvbmcgPSBbXCJCZWZvcmUgQ2hyaXN0XCIsIFwiQW5ubyBEb21pbmlcIl07XG5cbmV4cG9ydCBjb25zdCBlcmFzU2hvcnQgPSBbXCJCQ1wiLCBcIkFEXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc05hcnJvdyA9IFtcIkJcIiwgXCJBXCJdO1xuXG5leHBvcnQgZnVuY3Rpb24gZXJhcyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNOYXJyb3ddO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFsuLi5lcmFzU2hvcnRdO1xuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gWy4uLmVyYXNMb25nXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmlkaWVtRm9yRGF0ZVRpbWUoZHQpIHtcbiAgcmV0dXJuIG1lcmlkaWVtc1tkdC5ob3VyIDwgMTIgPyAwIDogMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrZGF5Rm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gd2Vla2RheXMobGVuZ3RoKVtkdC53ZWVrZGF5IC0gMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb250aEZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG1vbnRocyhsZW5ndGgpW2R0Lm1vbnRoIC0gMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcmFGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiBlcmFzKGxlbmd0aClbZHQueWVhciA8IDAgPyAwIDogMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRSZWxhdGl2ZVRpbWUodW5pdCwgY291bnQsIG51bWVyaWMgPSBcImFsd2F5c1wiLCBuYXJyb3cgPSBmYWxzZSkge1xuICBjb25zdCB1bml0cyA9IHtcbiAgICB5ZWFyczogW1wieWVhclwiLCBcInlyLlwiXSxcbiAgICBxdWFydGVyczogW1wicXVhcnRlclwiLCBcInF0ci5cIl0sXG4gICAgbW9udGhzOiBbXCJtb250aFwiLCBcIm1vLlwiXSxcbiAgICB3ZWVrczogW1wid2Vla1wiLCBcIndrLlwiXSxcbiAgICBkYXlzOiBbXCJkYXlcIiwgXCJkYXlcIiwgXCJkYXlzXCJdLFxuICAgIGhvdXJzOiBbXCJob3VyXCIsIFwiaHIuXCJdLFxuICAgIG1pbnV0ZXM6IFtcIm1pbnV0ZVwiLCBcIm1pbi5cIl0sXG4gICAgc2Vjb25kczogW1wic2Vjb25kXCIsIFwic2VjLlwiXSxcbiAgfTtcblxuICBjb25zdCBsYXN0YWJsZSA9IFtcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIl0uaW5kZXhPZih1bml0KSA9PT0gLTE7XG5cbiAgaWYgKG51bWVyaWMgPT09IFwiYXV0b1wiICYmIGxhc3RhYmxlKSB7XG4gICAgY29uc3QgaXNEYXkgPSB1bml0ID09PSBcImRheXNcIjtcbiAgICBzd2l0Y2ggKGNvdW50KSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwidG9tb3Jyb3dcIiA6IGBuZXh0ICR7dW5pdHNbdW5pdF1bMF19YDtcbiAgICAgIGNhc2UgLTE6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwieWVzdGVyZGF5XCIgOiBgbGFzdCAke3VuaXRzW3VuaXRdWzBdfWA7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwidG9kYXlcIiA6IGB0aGlzICR7dW5pdHNbdW5pdF1bMF19YDtcbiAgICAgIGRlZmF1bHQ6IC8vIGZhbGwgdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGlzSW5QYXN0ID0gT2JqZWN0LmlzKGNvdW50LCAtMCkgfHwgY291bnQgPCAwLFxuICAgIGZtdFZhbHVlID0gTWF0aC5hYnMoY291bnQpLFxuICAgIHNpbmd1bGFyID0gZm10VmFsdWUgPT09IDEsXG4gICAgbGlsVW5pdHMgPSB1bml0c1t1bml0XSxcbiAgICBmbXRVbml0ID0gbmFycm93XG4gICAgICA/IHNpbmd1bGFyXG4gICAgICAgID8gbGlsVW5pdHNbMV1cbiAgICAgICAgOiBsaWxVbml0c1syXSB8fCBsaWxVbml0c1sxXVxuICAgICAgOiBzaW5ndWxhclxuICAgICAgPyB1bml0c1t1bml0XVswXVxuICAgICAgOiB1bml0O1xuICByZXR1cm4gaXNJblBhc3QgPyBgJHtmbXRWYWx1ZX0gJHtmbXRVbml0fSBhZ29gIDogYGluICR7Zm10VmFsdWV9ICR7Zm10VW5pdH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0U3RyaW5nKGtub3duRm9ybWF0KSB7XG4gIC8vIHRoZXNlIGFsbCBoYXZlIHRoZSBvZmZzZXRzIHJlbW92ZWQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGFjY2VzcyB0byB0aGVtXG4gIC8vIHdpdGhvdXQgYWxsIHRoZSBpbnRsIHN0dWZmIHRoaXMgaXMgYmFja2ZpbGxpbmdcbiAgY29uc3QgZmlsdGVyZWQgPSBwaWNrKGtub3duRm9ybWF0LCBbXG4gICAgICBcIndlZWtkYXlcIixcbiAgICAgIFwiZXJhXCIsXG4gICAgICBcInllYXJcIixcbiAgICAgIFwibW9udGhcIixcbiAgICAgIFwiZGF5XCIsXG4gICAgICBcImhvdXJcIixcbiAgICAgIFwibWludXRlXCIsXG4gICAgICBcInNlY29uZFwiLFxuICAgICAgXCJ0aW1lWm9uZU5hbWVcIixcbiAgICAgIFwiaG91ckN5Y2xlXCIsXG4gICAgXSksXG4gICAga2V5ID0gc3RyaW5naWZ5KGZpbHRlcmVkKSxcbiAgICBkYXRlVGltZUh1Z2UgPSBcIkVFRUUsIExMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX1NIT1JUKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX01FRCk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9NRURfV0lUSF9XRUVLREFZKTpcbiAgICAgIHJldHVybiBcIkVFRSwgTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfRlVMTCk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfSFVHRSk6XG4gICAgICByZXR1cm4gXCJFRUVFLCBMTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfU0lNUExFKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9TSU1QTEUpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkhIOm1tOnNzXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX1NIT1JUKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5LCBoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX01FRCk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9GVUxMKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9IVUdFKTpcbiAgICAgIHJldHVybiBkYXRlVGltZUh1Z2U7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXksIGg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9XRUVLREFZKTpcbiAgICAgIHJldHVybiBcIkVFRSwgZCBMTEwgeXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiRUVFRSwgTExMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRhdGVUaW1lSHVnZTtcbiAgfVxufVxuIiwgImltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9mb3JtYXRzLmpzXCI7XG5pbXBvcnQgeyBwYWRTdGFydCB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZnVuY3Rpb24gc3RyaW5naWZ5VG9rZW5zKHNwbGl0cywgdG9rZW5Ub1N0cmluZykge1xuICBsZXQgcyA9IFwiXCI7XG4gIGZvciAoY29uc3QgdG9rZW4gb2Ygc3BsaXRzKSB7XG4gICAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICAgIHMgKz0gdG9rZW4udmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzICs9IHRva2VuVG9TdHJpbmcodG9rZW4udmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbmNvbnN0IG1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHMgPSB7XG4gIEQ6IEZvcm1hdHMuREFURV9TSE9SVCxcbiAgREQ6IEZvcm1hdHMuREFURV9NRUQsXG4gIERERDogRm9ybWF0cy5EQVRFX0ZVTEwsXG4gIEREREQ6IEZvcm1hdHMuREFURV9IVUdFLFxuICB0OiBGb3JtYXRzLlRJTUVfU0lNUExFLFxuICB0dDogRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUyxcbiAgdHR0OiBGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQsXG4gIHR0dHQ6IEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VULFxuICBUOiBGb3JtYXRzLlRJTUVfMjRfU0lNUExFLFxuICBUVDogRm9ybWF0cy5USU1FXzI0X1dJVEhfU0VDT05EUyxcbiAgVFRUOiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQsXG4gIFRUVFQ6IEZvcm1hdHMuVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VULFxuICBmOiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JULFxuICBmZjogRm9ybWF0cy5EQVRFVElNRV9NRUQsXG4gIGZmZjogRm9ybWF0cy5EQVRFVElNRV9GVUxMLFxuICBmZmZmOiBGb3JtYXRzLkRBVEVUSU1FX0hVR0UsXG4gIEY6IEZvcm1hdHMuREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTLFxuICBGRjogRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTLFxuICBGRkY6IEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMsXG4gIEZGRkY6IEZvcm1hdHMuREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMsXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9ybWF0dGVyIHtcbiAgc3RhdGljIGNyZWF0ZShsb2NhbGUsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgRm9ybWF0dGVyKGxvY2FsZSwgb3B0cyk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VGb3JtYXQoZm10KSB7XG4gICAgbGV0IGN1cnJlbnQgPSBudWxsLFxuICAgICAgY3VycmVudEZ1bGwgPSBcIlwiLFxuICAgICAgYnJhY2tldGVkID0gZmFsc2U7XG4gICAgY29uc3Qgc3BsaXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBmbXQuY2hhckF0KGkpO1xuICAgICAgaWYgKGMgPT09IFwiJ1wiKSB7XG4gICAgICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3BsaXRzLnB1c2goeyBsaXRlcmFsOiBicmFja2V0ZWQsIHZhbDogY3VycmVudEZ1bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRGdWxsID0gXCJcIjtcbiAgICAgICAgYnJhY2tldGVkID0gIWJyYWNrZXRlZDtcbiAgICAgIH0gZWxzZSBpZiAoYnJhY2tldGVkKSB7XG4gICAgICAgIGN1cnJlbnRGdWxsICs9IGM7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgY3VycmVudEZ1bGwgKz0gYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3BsaXRzLnB1c2goeyBsaXRlcmFsOiBmYWxzZSwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50RnVsbCA9IGM7XG4gICAgICAgIGN1cnJlbnQgPSBjO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICBzcGxpdHMucHVzaCh7IGxpdGVyYWw6IGJyYWNrZXRlZCwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3BsaXRzO1xuICB9XG5cbiAgc3RhdGljIG1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHModG9rZW4pIHtcbiAgICByZXR1cm4gbWFjcm9Ub2tlblRvRm9ybWF0T3B0c1t0b2tlbl07XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihsb2NhbGUsIGZvcm1hdE9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSBmb3JtYXRPcHRzO1xuICAgIHRoaXMubG9jID0gbG9jYWxlO1xuICAgIHRoaXMuc3lzdGVtTG9jID0gbnVsbDtcbiAgfVxuXG4gIGZvcm1hdFdpdGhTeXN0ZW1EZWZhdWx0KGR0LCBvcHRzKSB7XG4gICAgaWYgKHRoaXMuc3lzdGVtTG9jID09PSBudWxsKSB7XG4gICAgICB0aGlzLnN5c3RlbUxvYyA9IHRoaXMubG9jLnJlZGVmYXVsdFRvU3lzdGVtKCk7XG4gICAgfVxuICAgIGNvbnN0IGRmID0gdGhpcy5zeXN0ZW1Mb2MuZHRGb3JtYXR0ZXIoZHQsIHsgLi4udGhpcy5vcHRzLCAuLi5vcHRzIH0pO1xuICAgIHJldHVybiBkZi5mb3JtYXQoKTtcbiAgfVxuXG4gIGZvcm1hdERhdGVUaW1lKGR0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBkZiA9IHRoaXMubG9jLmR0Rm9ybWF0dGVyKGR0LCB7IC4uLnRoaXMub3B0cywgLi4ub3B0cyB9KTtcbiAgICByZXR1cm4gZGYuZm9ybWF0KCk7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZVBhcnRzKGR0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBkZiA9IHRoaXMubG9jLmR0Rm9ybWF0dGVyKGR0LCB7IC4uLnRoaXMub3B0cywgLi4ub3B0cyB9KTtcbiAgICByZXR1cm4gZGYuZm9ybWF0VG9QYXJ0cygpO1xuICB9XG5cbiAgcmVzb2x2ZWRPcHRpb25zKGR0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBkZiA9IHRoaXMubG9jLmR0Rm9ybWF0dGVyKGR0LCB7IC4uLnRoaXMub3B0cywgLi4ub3B0cyB9KTtcbiAgICByZXR1cm4gZGYucmVzb2x2ZWRPcHRpb25zKCk7XG4gIH1cblxuICBudW0obiwgcCA9IDApIHtcbiAgICAvLyB3ZSBnZXQgc29tZSBwZXJmIG91dCBvZiBkb2luZyB0aGlzIGhlcmUsIGFubm95aW5nbHlcbiAgICBpZiAodGhpcy5vcHRzLmZvcmNlU2ltcGxlKSB7XG4gICAgICByZXR1cm4gcGFkU3RhcnQobiwgcCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0cyA9IHsgLi4udGhpcy5vcHRzIH07XG5cbiAgICBpZiAocCA+IDApIHtcbiAgICAgIG9wdHMucGFkVG8gPSBwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxvYy5udW1iZXJGb3JtYXR0ZXIob3B0cykuZm9ybWF0KG4pO1xuICB9XG5cbiAgZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKGR0LCBmbXQpIHtcbiAgICBjb25zdCBrbm93bkVuZ2xpc2ggPSB0aGlzLmxvYy5saXN0aW5nTW9kZSgpID09PSBcImVuXCIsXG4gICAgICB1c2VEYXRlVGltZUZvcm1hdHRlciA9IHRoaXMubG9jLm91dHB1dENhbGVuZGFyICYmIHRoaXMubG9jLm91dHB1dENhbGVuZGFyICE9PSBcImdyZWdvcnlcIixcbiAgICAgIHN0cmluZyA9IChvcHRzLCBleHRyYWN0KSA9PiB0aGlzLmxvYy5leHRyYWN0KGR0LCBvcHRzLCBleHRyYWN0KSxcbiAgICAgIGZvcm1hdE9mZnNldCA9IChvcHRzKSA9PiB7XG4gICAgICAgIGlmIChkdC5pc09mZnNldEZpeGVkICYmIGR0Lm9mZnNldCA9PT0gMCAmJiBvcHRzLmFsbG93Wikge1xuICAgICAgICAgIHJldHVybiBcIlpcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkdC5pc1ZhbGlkID8gZHQuem9uZS5mb3JtYXRPZmZzZXQoZHQudHMsIG9wdHMuZm9ybWF0KSA6IFwiXCI7XG4gICAgICB9LFxuICAgICAgbWVyaWRpZW0gPSAoKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2hcbiAgICAgICAgICA/IEVuZ2xpc2gubWVyaWRpZW1Gb3JEYXRlVGltZShkdClcbiAgICAgICAgICA6IHN0cmluZyh7IGhvdXI6IFwibnVtZXJpY1wiLCBob3VyQ3ljbGU6IFwiaDEyXCIgfSwgXCJkYXlwZXJpb2RcIiksXG4gICAgICBtb250aCA9IChsZW5ndGgsIHN0YW5kYWxvbmUpID0+XG4gICAgICAgIGtub3duRW5nbGlzaFxuICAgICAgICAgID8gRW5nbGlzaC5tb250aEZvckRhdGVUaW1lKGR0LCBsZW5ndGgpXG4gICAgICAgICAgOiBzdHJpbmcoc3RhbmRhbG9uZSA/IHsgbW9udGg6IGxlbmd0aCB9IDogeyBtb250aDogbGVuZ3RoLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIiksXG4gICAgICB3ZWVrZGF5ID0gKGxlbmd0aCwgc3RhbmRhbG9uZSkgPT5cbiAgICAgICAga25vd25FbmdsaXNoXG4gICAgICAgICAgPyBFbmdsaXNoLndlZWtkYXlGb3JEYXRlVGltZShkdCwgbGVuZ3RoKVxuICAgICAgICAgIDogc3RyaW5nKFxuICAgICAgICAgICAgICBzdGFuZGFsb25lID8geyB3ZWVrZGF5OiBsZW5ndGggfSA6IHsgd2Vla2RheTogbGVuZ3RoLCBtb250aDogXCJsb25nXCIsIGRheTogXCJudW1lcmljXCIgfSxcbiAgICAgICAgICAgICAgXCJ3ZWVrZGF5XCJcbiAgICAgICAgICAgICksXG4gICAgICBtYXliZU1hY3JvID0gKHRva2VuKSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdE9wdHMgPSBGb3JtYXR0ZXIubWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbik7XG4gICAgICAgIGlmIChmb3JtYXRPcHRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0V2l0aFN5c3RlbURlZmF1bHQoZHQsIGZvcm1hdE9wdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVyYSA9IChsZW5ndGgpID0+XG4gICAgICAgIGtub3duRW5nbGlzaCA/IEVuZ2xpc2guZXJhRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkgOiBzdHJpbmcoeyBlcmE6IGxlbmd0aCB9LCBcImVyYVwiKSxcbiAgICAgIHRva2VuVG9TdHJpbmcgPSAodG9rZW4pID0+IHtcbiAgICAgICAgLy8gV2hlcmUgcG9zc2libGU6IGh0dHA6Ly9jbGRyLnVuaWNvZGUub3JnL3RyYW5zbGF0aW9uL2RhdGUtdGltZS0xL2RhdGUtdGltZSNUT0MtU3RhbmRhbG9uZS12cy4tRm9ybWF0LVN0eWxlc1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgLy8gbXNcbiAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbGxpc2Vjb25kKTtcbiAgICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICBjYXNlIFwiU1NTXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWlsbGlzZWNvbmQsIDMpO1xuICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LnNlY29uZCk7XG4gICAgICAgICAgY2FzZSBcInNzXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuc2Vjb25kLCAyKTtcbiAgICAgICAgICAvLyBmcmFjdGlvbmFsIHNlY29uZHNcbiAgICAgICAgICBjYXNlIFwidXVcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0Lm1pbGxpc2Vjb25kIC8gMTApLCAyKTtcbiAgICAgICAgICBjYXNlIFwidXV1XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oTWF0aC5mbG9vcihkdC5taWxsaXNlY29uZCAvIDEwMCkpO1xuICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbnV0ZSk7XG4gICAgICAgICAgY2FzZSBcIm1tXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWludXRlLCAyKTtcbiAgICAgICAgICAvLyBob3Vyc1xuICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91ciAlIDEyID09PSAwID8gMTIgOiBkdC5ob3VyICUgMTIpO1xuICAgICAgICAgIGNhc2UgXCJoaFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIgJSAxMiA9PT0gMCA/IDEyIDogZHQuaG91ciAlIDEyLCAyKTtcbiAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIpO1xuICAgICAgICAgIGNhc2UgXCJISFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIsIDIpO1xuICAgICAgICAgIC8vIG9mZnNldFxuICAgICAgICAgIGNhc2UgXCJaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICs2XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHsgZm9ybWF0OiBcIm5hcnJvd1wiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICswNjowMFxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJzaG9ydFwiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSArMDYwMFxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJ0ZWNoaWVcIiwgYWxsb3daOiB0aGlzLm9wdHMuYWxsb3daIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEVTVFxuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmUub2Zmc2V0TmFtZShkdC50cywgeyBmb3JtYXQ6IFwic2hvcnRcIiwgbG9jYWxlOiB0aGlzLmxvYy5sb2NhbGUgfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEVhc3Rlcm4gU3RhbmRhcmQgVGltZVxuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmUub2Zmc2V0TmFtZShkdC50cywgeyBmb3JtYXQ6IFwibG9uZ1wiLCBsb2NhbGU6IHRoaXMubG9jLmxvY2FsZSB9KTtcbiAgICAgICAgICAvLyB6b25lXG4gICAgICAgICAgY2FzZSBcInpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQW1lcmljYS9OZXdfWW9ya1xuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmVOYW1lO1xuICAgICAgICAgIC8vIG1lcmlkaWVtc1xuICAgICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgICByZXR1cm4gbWVyaWRpZW0oKTtcbiAgICAgICAgICAvLyBkYXRlc1xuICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyBkYXk6IFwibnVtZXJpY1wiIH0sIFwiZGF5XCIpIDogdGhpcy5udW0oZHQuZGF5KTtcbiAgICAgICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7IGRheTogXCIyLWRpZ2l0XCIgfSwgXCJkYXlcIikgOiB0aGlzLm51bShkdC5kYXksIDIpO1xuICAgICAgICAgIC8vIHdlZWtkYXlzIC0gc3RhbmRhbG9uZVxuICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrZGF5KTtcbiAgICAgICAgICBjYXNlIFwiY2NjXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJzaG9ydFwiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiY2NjY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlc2RheSdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibG9uZ1wiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiY2NjY2NcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1QnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcIm5hcnJvd1wiLCB0cnVlKTtcbiAgICAgICAgICAvLyB3ZWVrZGF5cyAtIGZvcm1hdFxuICAgICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrZGF5KTtcbiAgICAgICAgICBjYXNlIFwiRUVFXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJzaG9ydFwiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIkVFRUVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXNkYXknXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcImxvbmdcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJFRUVFRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVCdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibmFycm93XCIsIGZhbHNlKTtcbiAgICAgICAgICAvLyBtb250aHMgLSBzdGFuZGFsb25lXG4gICAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwibnVtZXJpY1wiLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCk7XG4gICAgICAgICAgY2FzZSBcIkxMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxLCBkb2Vzbid0IHNlZW0gdG8gd29ya1xuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwiMi1kaWdpdFwiLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCwgMik7XG4gICAgICAgICAgY2FzZSBcIkxMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW5cbiAgICAgICAgICAgIHJldHVybiBtb250aChcInNob3J0XCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJMTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphbnVhcnlcbiAgICAgICAgICAgIHJldHVybiBtb250aChcImxvbmdcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcIkxMTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEpcbiAgICAgICAgICAgIHJldHVybiBtb250aChcIm5hcnJvd1wiLCB0cnVlKTtcbiAgICAgICAgICAvLyBtb250aHMgLSBmb3JtYXRcbiAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoKTtcbiAgICAgICAgICBjYXNlIFwiTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDFcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIjItZGlnaXRcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgsIDIpO1xuICAgICAgICAgIGNhc2UgXCJNTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFuXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJzaG9ydFwiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFudWFyeVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibG9uZ1wiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIk1NTU1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEpcbiAgICAgICAgICAgIHJldHVybiBtb250aChcIm5hcnJvd1wiLCBmYWxzZSk7XG4gICAgICAgICAgLy8geWVhcnNcbiAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAyMDE0XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIikgOiB0aGlzLm51bShkdC55ZWFyKTtcbiAgICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMTRcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwiMi1kaWdpdFwiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIudG9TdHJpbmcoKS5zbGljZSgtMiksIDIpO1xuICAgICAgICAgIGNhc2UgXCJ5eXl5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAwMTJcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwibnVtZXJpY1wiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIsIDQpO1xuICAgICAgICAgIGNhc2UgXCJ5eXl5eXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDAwMDEyXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC55ZWFyLCA2KTtcbiAgICAgICAgICAvLyBlcmFzXG4gICAgICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQURcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJzaG9ydFwiKTtcbiAgICAgICAgICBjYXNlIFwiR0dcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQW5ubyBEb21pbmlcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJsb25nXCIpO1xuICAgICAgICAgIGNhc2UgXCJHR0dHR1wiOlxuICAgICAgICAgICAgcmV0dXJuIGVyYShcIm5hcnJvd1wiKTtcbiAgICAgICAgICBjYXNlIFwia2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrWWVhci50b1N0cmluZygpLnNsaWNlKC0yKSwgMik7XG4gICAgICAgICAgY2FzZSBcImtra2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrWWVhciwgNCk7XG4gICAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrTnVtYmVyKTtcbiAgICAgICAgICBjYXNlIFwiV1dcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrTnVtYmVyLCAyKTtcbiAgICAgICAgICBjYXNlIFwib1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm9yZGluYWwpO1xuICAgICAgICAgIGNhc2UgXCJvb29cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5vcmRpbmFsLCAzKTtcbiAgICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQucXVhcnRlcik7XG4gICAgICAgICAgY2FzZSBcInFxXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQucXVhcnRlciwgMik7XG4gICAgICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0LnRzIC8gMTAwMCkpO1xuICAgICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQudHMpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbWF5YmVNYWNybyh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5VG9rZW5zKEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLCB0b2tlblRvU3RyaW5nKTtcbiAgfVxuXG4gIGZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyhkdXIsIGZtdCkge1xuICAgIGNvbnN0IHRva2VuVG9GaWVsZCA9ICh0b2tlbikgPT4ge1xuICAgICAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kXCI7XG4gICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgIHJldHVybiBcInNlY29uZFwiO1xuICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJtaW51dGVcIjtcbiAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaG91clwiO1xuICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJkYXlcIjtcbiAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwibW9udGhcIjtcbiAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwieWVhclwiO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRva2VuVG9TdHJpbmcgPSAobGlsZHVyKSA9PiAodG9rZW4pID0+IHtcbiAgICAgICAgY29uc3QgbWFwcGVkID0gdG9rZW5Ub0ZpZWxkKHRva2VuKTtcbiAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm51bShsaWxkdXIuZ2V0KG1hcHBlZCksIHRva2VuLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9rZW5zID0gRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZtdCksXG4gICAgICByZWFsVG9rZW5zID0gdG9rZW5zLnJlZHVjZShcbiAgICAgICAgKGZvdW5kLCB7IGxpdGVyYWwsIHZhbCB9KSA9PiAobGl0ZXJhbCA/IGZvdW5kIDogZm91bmQuY29uY2F0KHZhbCkpLFxuICAgICAgICBbXVxuICAgICAgKSxcbiAgICAgIGNvbGxhcHNlZCA9IGR1ci5zaGlmdFRvKC4uLnJlYWxUb2tlbnMubWFwKHRva2VuVG9GaWVsZCkuZmlsdGVyKCh0KSA9PiB0KSk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVRva2Vucyh0b2tlbnMsIHRva2VuVG9TdHJpbmcoY29sbGFwc2VkKSk7XG4gIH1cbn1cbiIsICJleHBvcnQgZGVmYXVsdCBjbGFzcyBJbnZhbGlkIHtcbiAgY29uc3RydWN0b3IocmVhc29uLCBleHBsYW5hdGlvbikge1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuZXhwbGFuYXRpb24gPSBleHBsYW5hdGlvbjtcbiAgfVxuXG4gIHRvTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5leHBsYW5hdGlvbikge1xuICAgICAgcmV0dXJuIGAke3RoaXMucmVhc29ufTogJHt0aGlzLmV4cGxhbmF0aW9ufWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYXNvbjtcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBab25lSXNBYnN0cmFjdEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5cbi8qKlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBab25lIHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHpvbmVcbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoaXMgem9uZS5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgb2Zmc2V0IGlzIGtub3duIHRvIGJlIGZpeGVkIGZvciB0aGUgd2hvbGUgeWVhci5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgY29tbW9uIG5hbWUgKHN1Y2ggYXMgRVNUKSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcFxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIHRvIGFmZmVjdCB0aGUgZm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi4gQWNjZXB0cyAnbG9uZycgb3IgJ3Nob3J0Jy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubG9jYWxlIC0gV2hhdCBsb2NhbGUgdG8gcmV0dXJuIHRoZSBvZmZzZXQgbmFtZSBpbi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgb2Zmc2V0TmFtZSh0cywgb3B0cykge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgdmFsdWUgYXMgYSBzdHJpbmdcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBvZmZzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdHMgJ25hcnJvdycsICdzaG9ydCcsIG9yICd0ZWNoaWUnLiBSZXR1cm5pbmcgJys2JywgJyswNjowMCcsIG9yICcrMDYwMCcgcmVzcGVjdGl2ZWx5XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG9mZnNldCBpbiBtaW51dGVzIGZvciB0aGlzIHpvbmUgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGNvbXB1dGUgdGhlIG9mZnNldFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBvZmZzZXQodHMpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyBlcXVhbCB0byBhbm90aGVyIHpvbmVcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7Wm9uZX0gb3RoZXJab25lIC0gdGhlIHpvbmUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIHZhbGlkLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgZm9ybWF0T2Zmc2V0LCBwYXJzZVpvbmVJbmZvIH0gZnJvbSBcIi4uL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgbG9jYWwgem9uZSBmb3IgdGhpcyBKYXZhU2NyaXB0IGVudmlyb25tZW50LlxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5c3RlbVpvbmUgZXh0ZW5kcyBab25lIHtcbiAgLyoqXG4gICAqIEdldCBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGUgbG9jYWwgem9uZVxuICAgKiBAcmV0dXJuIHtTeXN0ZW1ab25lfVxuICAgKi9cbiAgc3RhdGljIGdldCBpbnN0YW5jZSgpIHtcbiAgICBpZiAoc2luZ2xldG9uID09PSBudWxsKSB7XG4gICAgICBzaW5nbGV0b24gPSBuZXcgU3lzdGVtWm9uZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc2luZ2xldG9uO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwic3lzdGVtXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKHRzLCB7IGZvcm1hdCwgbG9jYWxlIH0pIHtcbiAgICByZXR1cm4gcGFyc2Vab25lSW5mbyh0cywgZm9ybWF0LCBsb2NhbGUpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMub2Zmc2V0KHRzKSwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCh0cykge1xuICAgIHJldHVybiAtbmV3IERhdGUodHMpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcInN5c3RlbVwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBmb3JtYXRPZmZzZXQsIHBhcnNlWm9uZUluZm8sIGlzVW5kZWZpbmVkLCBpYW5hUmVnZXgsIG9ialRvTG9jYWxUUyB9IGZyb20gXCIuLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbmNvbnN0IG1hdGNoaW5nUmVnZXggPSBSZWdFeHAoYF4ke2lhbmFSZWdleC5zb3VyY2V9JGApO1xuXG5sZXQgZHRmQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIG1ha2VEVEYoem9uZSkge1xuICBpZiAoIWR0ZkNhY2hlW3pvbmVdKSB7XG4gICAgZHRmQ2FjaGVbem9uZV0gPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHtcbiAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICB0aW1lWm9uZTogem9uZSxcbiAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICAgIHNlY29uZDogXCIyLWRpZ2l0XCIsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGR0ZkNhY2hlW3pvbmVdO1xufVxuXG5jb25zdCB0eXBlVG9Qb3MgPSB7XG4gIHllYXI6IDAsXG4gIG1vbnRoOiAxLFxuICBkYXk6IDIsXG4gIGhvdXI6IDMsXG4gIG1pbnV0ZTogNCxcbiAgc2Vjb25kOiA1LFxufTtcblxuZnVuY3Rpb24gaGFja3lPZmZzZXQoZHRmLCBkYXRlKSB7XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGR0Zi5mb3JtYXQoZGF0ZSkucmVwbGFjZSgvXFx1MjAwRS9nLCBcIlwiKSxcbiAgICBwYXJzZWQgPSAvKFxcZCspXFwvKFxcZCspXFwvKFxcZCspLD8gKFxcZCspOihcXGQrKTooXFxkKykvLmV4ZWMoZm9ybWF0dGVkKSxcbiAgICBbLCBmTW9udGgsIGZEYXksIGZZZWFyLCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF0gPSBwYXJzZWQ7XG4gIHJldHVybiBbZlllYXIsIGZNb250aCwgZkRheSwgZkhvdXIsIGZNaW51dGUsIGZTZWNvbmRdO1xufVxuXG5mdW5jdGlvbiBwYXJ0c09mZnNldChkdGYsIGRhdGUpIHtcbiAgY29uc3QgZm9ybWF0dGVkID0gZHRmLmZvcm1hdFRvUGFydHMoZGF0ZSksXG4gICAgZmlsbGVkID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gZm9ybWF0dGVkW2ldLFxuICAgICAgcG9zID0gdHlwZVRvUG9zW3R5cGVdO1xuXG4gICAgaWYgKCFpc1VuZGVmaW5lZChwb3MpKSB7XG4gICAgICBmaWxsZWRbcG9zXSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWxsZWQ7XG59XG5cbmxldCBpYW5hWm9uZUNhY2hlID0ge307XG4vKipcbiAqIEEgem9uZSBpZGVudGlmaWVkIGJ5IGFuIElBTkEgaWRlbnRpZmllciwgbGlrZSBBbWVyaWNhL05ld19Zb3JrXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSUFOQVpvbmUgZXh0ZW5kcyBab25lIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gWm9uZSBuYW1lXG4gICAqIEByZXR1cm4ge0lBTkFab25lfVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZShuYW1lKSB7XG4gICAgaWYgKCFpYW5hWm9uZUNhY2hlW25hbWVdKSB7XG4gICAgICBpYW5hWm9uZUNhY2hlW25hbWVdID0gbmV3IElBTkFab25lKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gaWFuYVpvbmVDYWNoZVtuYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBsb2NhbCBjYWNoZXMuIFNob3VsZCBvbmx5IGJlIG5lY2Vzc2FyeSBpbiB0ZXN0aW5nIHNjZW5hcmlvcy5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHN0YXRpYyByZXNldENhY2hlKCkge1xuICAgIGlhbmFab25lQ2FjaGUgPSB7fTtcbiAgICBkdGZDYWNoZSA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgc3RyaW5nIGlzIGEgdmFsaWQgc3BlY2lmaWVyLiBUaGlzIG9ubHkgY2hlY2tzIHRoZSBzdHJpbmcncyBmb3JtYXQsIG5vdCB0aGF0IHRoZSBzcGVjaWZpZXIgaWRlbnRpZmllcyBhIGtub3duIHpvbmU7IHNlZSBpc1ZhbGlkWm9uZSBmb3IgdGhhdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgLSBUaGUgc3RyaW5nIHRvIGNoZWNrIHZhbGlkaXR5IG9uXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRTcGVjaWZpZXIoXCJBbWVyaWNhL05ld19Zb3JrXCIpIC8vPT4gdHJ1ZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkU3BlY2lmaWVyKFwiRmFudGFzaWEvQ2FzdGxlXCIpIC8vPT4gdHJ1ZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkU3BlY2lmaWVyKFwiU3BvcnR+fmJsb3JwXCIpIC8vPT4gZmFsc2VcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkU3BlY2lmaWVyKHMpIHtcbiAgICByZXR1cm4gISEocyAmJiBzLm1hdGNoKG1hdGNoaW5nUmVnZXgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHN0cmluZyBpZGVudGlmaWVzIGEgcmVhbCB6b25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6b25lIC0gVGhlIHN0cmluZyB0byBjaGVja1xuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIkFtZXJpY2EvTmV3X1lvcmtcIikgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiRmFudGFzaWEvQ2FzdGxlXCIpIC8vPT4gZmFsc2VcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJTcG9ydH5+YmxvcnBcIikgLy89PiBmYWxzZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRab25lKHpvbmUpIHtcbiAgICBpZiAoIXpvbmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwgeyB0aW1lWm9uZTogem9uZSB9KS5mb3JtYXQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy56b25lTmFtZSA9IG5hbWU7XG4gICAgLyoqIEBwcml2YXRlICoqL1xuICAgIHRoaXMudmFsaWQgPSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShuYW1lKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImlhbmFcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnpvbmVOYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUodHMsIHsgZm9ybWF0LCBsb2NhbGUgfSkge1xuICAgIHJldHVybiBwYXJzZVpvbmVJbmZvKHRzLCBmb3JtYXQsIGxvY2FsZSwgdGhpcy5uYW1lKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdE9mZnNldCh0aGlzLm9mZnNldCh0cyksIGZvcm1hdCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXQodHMpIHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodHMpO1xuXG4gICAgaWYgKGlzTmFOKGRhdGUpKSByZXR1cm4gTmFOO1xuXG4gICAgY29uc3QgZHRmID0gbWFrZURURih0aGlzLm5hbWUpLFxuICAgICAgW3llYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kXSA9IGR0Zi5mb3JtYXRUb1BhcnRzXG4gICAgICAgID8gcGFydHNPZmZzZXQoZHRmLCBkYXRlKVxuICAgICAgICA6IGhhY2t5T2Zmc2V0KGR0ZiwgZGF0ZSk7XG5cbiAgICAvLyBiZWNhdXNlIHdlJ3JlIHVzaW5nIGhvdXIxMiBhbmQgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTAyNTU2NCZjYW49MiZxPSUyMjI0JTNBMDAlMjIlMjBkYXRldGltZWZvcm1hdFxuICAgIGNvbnN0IGFkanVzdGVkSG91ciA9IGhvdXIgPT09IDI0ID8gMCA6IGhvdXI7XG5cbiAgICBjb25zdCBhc1VUQyA9IG9ialRvTG9jYWxUUyh7XG4gICAgICB5ZWFyLFxuICAgICAgbW9udGgsXG4gICAgICBkYXksXG4gICAgICBob3VyOiBhZGp1c3RlZEhvdXIsXG4gICAgICBtaW51dGUsXG4gICAgICBzZWNvbmQsXG4gICAgICBtaWxsaXNlY29uZDogMCxcbiAgICB9KTtcblxuICAgIGxldCBhc1RTID0gK2RhdGU7XG4gICAgY29uc3Qgb3ZlciA9IGFzVFMgJSAxMDAwO1xuICAgIGFzVFMgLT0gb3ZlciA+PSAwID8gb3ZlciA6IDEwMDAgKyBvdmVyO1xuICAgIHJldHVybiAoYXNVVEMgLSBhc1RTKSAvICg2MCAqIDEwMDApO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHJldHVybiBvdGhlclpvbmUudHlwZSA9PT0gXCJpYW5hXCIgJiYgb3RoZXJab25lLm5hbWUgPT09IHRoaXMubmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgZm9ybWF0T2Zmc2V0LCBzaWduZWRPZmZzZXQgfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5sZXQgc2luZ2xldG9uID0gbnVsbDtcblxuLyoqXG4gKiBBIHpvbmUgd2l0aCBhIGZpeGVkIG9mZnNldCAobWVhbmluZyBubyBEU1QpXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRml4ZWRPZmZzZXRab25lIGV4dGVuZHMgWm9uZSB7XG4gIC8qKlxuICAgKiBHZXQgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgVVRDXG4gICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBnZXQgdXRjSW5zdGFuY2UoKSB7XG4gICAgaWYgKHNpbmdsZXRvbiA9PT0gbnVsbCkge1xuICAgICAgc2luZ2xldG9uID0gbmV3IEZpeGVkT2Zmc2V0Wm9uZSgwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbmdsZXRvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugd2l0aCBhIHNwZWNpZmllZCBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgaW4gbWludXRlc1xuICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAqL1xuICBzdGF0aWMgaW5zdGFuY2Uob2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCA9PT0gMCA/IEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZSA6IG5ldyBGaXhlZE9mZnNldFpvbmUob2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugb2YgRml4ZWRPZmZzZXRab25lIGZyb20gYSBVVEMgb2Zmc2V0IHN0cmluZywgbGlrZSBcIlVUQys2XCJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgLSBUaGUgb2Zmc2V0IHN0cmluZyB0byBwYXJzZVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMrNlwiKVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMrMDZcIilcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDLTY6MDBcIilcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgc3RhdGljIHBhcnNlU3BlY2lmaWVyKHMpIHtcbiAgICBpZiAocykge1xuICAgICAgY29uc3QgciA9IHMubWF0Y2goL151dGMoPzooWystXVxcZHsxLDJ9KSg/OjooXFxkezJ9KSk/KT8kL2kpO1xuICAgICAgaWYgKHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE9mZnNldFpvbmUoc2lnbmVkT2Zmc2V0KHJbMV0sIHJbMl0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihvZmZzZXQpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBAcHJpdmF0ZSAqKi9cbiAgICB0aGlzLmZpeGVkID0gb2Zmc2V0O1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwiZml4ZWRcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmZpeGVkID09PSAwID8gXCJVVENcIiA6IGBVVEMke2Zvcm1hdE9mZnNldCh0aGlzLmZpeGVkLCBcIm5hcnJvd1wiKX1gO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMuZml4ZWQsIGZvcm1hdCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNVbml2ZXJzYWwoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZml4ZWQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcImZpeGVkXCIgJiYgb3RoZXJab25lLmZpeGVkID09PSB0aGlzLmZpeGVkO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsICJpbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG4vKipcbiAqIEEgem9uZSB0aGF0IGZhaWxlZCB0byBwYXJzZS4gWW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW52YWxpZFpvbmUgZXh0ZW5kcyBab25lIHtcbiAgY29uc3RydWN0b3Ioem9uZU5hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiAgQHByaXZhdGUgKi9cbiAgICB0aGlzLnpvbmVOYW1lID0gem9uZU5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gXCJpbnZhbGlkXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy56b25lTmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgb2Zmc2V0KCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iLCAiLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBJbnZhbGlkWm9uZSBmcm9tIFwiLi4vem9uZXMvaW52YWxpZFpvbmUuanNcIjtcblxuaW1wb3J0IHsgaXNVbmRlZmluZWQsIGlzU3RyaW5nLCBpc051bWJlciB9IGZyb20gXCIuL3V0aWwuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVpvbmUoaW5wdXQsIGRlZmF1bHRab25lKSB7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChpc1VuZGVmaW5lZChpbnB1dCkgfHwgaW5wdXQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZGVmYXVsdFpvbmU7XG4gIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBab25lKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKGlucHV0KSkge1xuICAgIGNvbnN0IGxvd2VyZWQgPSBpbnB1dC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlcmVkID09PSBcImxvY2FsXCIgfHwgbG93ZXJlZCA9PT0gXCJzeXN0ZW1cIikgcmV0dXJuIGRlZmF1bHRab25lO1xuICAgIGVsc2UgaWYgKGxvd2VyZWQgPT09IFwidXRjXCIgfHwgbG93ZXJlZCA9PT0gXCJnbXRcIikgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZTtcbiAgICBlbHNlIGlmIChJQU5BWm9uZS5pc1ZhbGlkU3BlY2lmaWVyKGxvd2VyZWQpKSByZXR1cm4gSUFOQVpvbmUuY3JlYXRlKGlucHV0KTtcbiAgICBlbHNlIHJldHVybiBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIobG93ZXJlZCkgfHwgbmV3IEludmFsaWRab25lKGlucHV0KTtcbiAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICByZXR1cm4gRml4ZWRPZmZzZXRab25lLmluc3RhbmNlKGlucHV0KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIgJiYgaW5wdXQub2Zmc2V0ICYmIHR5cGVvZiBpbnB1dC5vZmZzZXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAvLyBUaGlzIGlzIGR1bWIsIGJ1dCB0aGUgaW5zdGFuY2VvZiBjaGVjayBhYm92ZSBkb2Vzbid0IHNlZW0gdG8gcmVhbGx5IHdvcmtcbiAgICAvLyBzbyB3ZSdyZSBkdWNrIGNoZWNraW5nIGl0XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgSW52YWxpZFpvbmUoaW5wdXQpO1xuICB9XG59XG4iLCAiaW1wb3J0IFN5c3RlbVpvbmUgZnJvbSBcIi4vem9uZXMvc3lzdGVtWm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuL3pvbmVzL0lBTkFab25lLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5cbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5cbmxldCBub3cgPSAoKSA9PiBEYXRlLm5vdygpLFxuICBkZWZhdWx0Wm9uZSA9IFwic3lzdGVtXCIsXG4gIGRlZmF1bHRMb2NhbGUgPSBudWxsLFxuICBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtID0gbnVsbCxcbiAgZGVmYXVsdE91dHB1dENhbGVuZGFyID0gbnVsbCxcbiAgdGhyb3dPbkludmFsaWQ7XG5cbi8qKlxuICogU2V0dGluZ3MgY29udGFpbnMgc3RhdGljIGdldHRlcnMgYW5kIHNldHRlcnMgdGhhdCBjb250cm9sIEx1eG9uJ3Mgb3ZlcmFsbCBiZWhhdmlvci4gTHV4b24gaXMgYSBzaW1wbGUgbGlicmFyeSB3aXRoIGZldyBvcHRpb25zLCBidXQgdGhlIG9uZXMgaXQgZG9lcyBoYXZlIGxpdmUgaGVyZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2V0dGluZ3Mge1xuICAvKipcbiAgICogR2V0IHRoZSBjYWxsYmFjayBmb3IgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHRpbWVzdGFtcC5cbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKi9cbiAgc3RhdGljIGdldCBub3coKSB7XG4gICAgcmV0dXJuIG5vdztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNhbGxiYWNrIGZvciByZXR1cm5pbmcgdGhlIGN1cnJlbnQgdGltZXN0YW1wLlxuICAgKiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIG51bWJlciwgd2hpY2ggd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBhbiBFcG9jaCBtaWxsaXNlY29uZCBjb3VudFxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqIEBleGFtcGxlIFNldHRpbmdzLm5vdyA9ICgpID0+IERhdGUubm93KCkgKyAzMDAwIC8vIHByZXRlbmQgaXQgaXMgMyBzZWNvbmRzIGluIHRoZSBmdXR1cmVcbiAgICogQGV4YW1wbGUgU2V0dGluZ3Mubm93ID0gKCkgPT4gMCAvLyBhbHdheXMgcHJldGVuZCBpdCdzIEphbiAxLCAxOTcwIGF0IG1pZG5pZ2h0IGluIFVUQyB0aW1lXG4gICAqL1xuICBzdGF0aWMgc2V0IG5vdyhuKSB7XG4gICAgbm93ID0gbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgdGltZSB6b25lIHRvIGNyZWF0ZSBEYXRlVGltZXMgaW4uIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIFVzZSB0aGUgdmFsdWUgXCJzeXN0ZW1cIiB0byByZXNldCB0aGlzIHZhbHVlIHRvIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRab25lKHpvbmUpIHtcbiAgICBkZWZhdWx0Wm9uZSA9IHpvbmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IHRpbWUgem9uZSBvYmplY3QgY3VycmVudGx5IHVzZWQgdG8gY3JlYXRlIERhdGVUaW1lcy4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdGhlIHN5c3RlbSdzIHRpbWUgem9uZSAodGhlIG9uZSBzZXQgb24gdGhlIG1hY2hpbmUgdGhhdCBydW5zIHRoaXMgY29kZSkuXG4gICAqIEB0eXBlIHtab25lfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0Wm9uZSgpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplWm9uZShkZWZhdWx0Wm9uZSwgU3lzdGVtWm9uZS5pbnN0YW5jZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IGxvY2FsZSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRMb2NhbGUoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRMb2NhbGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IGxvY2FsZSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRMb2NhbGUobG9jYWxlKSB7XG4gICAgZGVmYXVsdExvY2FsZSA9IGxvY2FsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgbnVtYmVyaW5nIHN5c3RlbSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW07XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IG51bWJlcmluZyBzeXN0ZW0gdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtKG51bWJlcmluZ1N5c3RlbSkge1xuICAgIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gPSBudW1iZXJpbmdTeXN0ZW07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IG91dHB1dCBjYWxlbmRhciB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRPdXRwdXRDYWxlbmRhcigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE91dHB1dENhbGVuZGFyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBvdXRwdXQgY2FsZW5kYXIgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHNldCBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIob3V0cHV0Q2FsZW5kYXIpIHtcbiAgICBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIgPSBvdXRwdXRDYWxlbmRhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciBMdXhvbiB3aWxsIHRocm93IHdoZW4gaXQgZW5jb3VudGVycyBpbnZhbGlkIERhdGVUaW1lcywgRHVyYXRpb25zLCBvciBJbnRlcnZhbHNcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRocm93T25JbnZhbGlkKCkge1xuICAgIHJldHVybiB0aHJvd09uSW52YWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciBMdXhvbiB3aWxsIHRocm93IHdoZW4gaXQgZW5jb3VudGVycyBpbnZhbGlkIERhdGVUaW1lcywgRHVyYXRpb25zLCBvciBJbnRlcnZhbHNcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgc2V0IHRocm93T25JbnZhbGlkKHQpIHtcbiAgICB0aHJvd09uSW52YWxpZCA9IHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgTHV4b24ncyBnbG9iYWwgY2FjaGVzLiBTaG91bGQgb25seSBiZSBuZWNlc3NhcnkgaW4gdGVzdGluZyBzY2VuYXJpb3MuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBzdGF0aWMgcmVzZXRDYWNoZXMoKSB7XG4gICAgTG9jYWxlLnJlc2V0Q2FjaGUoKTtcbiAgICBJQU5BWm9uZS5yZXNldENhY2hlKCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBwYWRTdGFydCwgcm91bmRUbywgaGFzUmVsYXRpdmUgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcblxuLy8gdG9kbyAtIHJlbWFwIGNhY2hpbmdcblxubGV0IGludGxMRkNhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRMRihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBkdGYgPSBpbnRsTEZDYWNoZVtrZXldO1xuICBpZiAoIWR0Zikge1xuICAgIGR0ZiA9IG5ldyBJbnRsLkxpc3RGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsTEZDYWNoZVtrZXldID0gZHRmO1xuICB9XG4gIHJldHVybiBkdGY7XG59XG5cbmxldCBpbnRsRFRDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVkRFRGKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIG9wdHNdKTtcbiAgbGV0IGR0ZiA9IGludGxEVENhY2hlW2tleV07XG4gIGlmICghZHRmKSB7XG4gICAgZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsRFRDYWNoZVtrZXldID0gZHRmO1xuICB9XG4gIHJldHVybiBkdGY7XG59XG5cbmxldCBpbnRsTnVtQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldENhY2hlZElORihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIGxldCBpbmYgPSBpbnRsTnVtQ2FjaGVba2V5XTtcbiAgaWYgKCFpbmYpIHtcbiAgICBpbmYgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsTnVtQ2FjaGVba2V5XSA9IGluZjtcbiAgfVxuICByZXR1cm4gaW5mO1xufVxuXG5sZXQgaW50bFJlbENhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWRSVEYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBiYXNlLCAuLi5jYWNoZUtleU9wdHMgfSA9IG9wdHM7IC8vIGV4Y2x1ZGUgYGJhc2VgIGZyb20gdGhlIG9wdGlvbnNcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgY2FjaGVLZXlPcHRzXSk7XG4gIGxldCBpbmYgPSBpbnRsUmVsQ2FjaGVba2V5XTtcbiAgaWYgKCFpbmYpIHtcbiAgICBpbmYgPSBuZXcgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQobG9jU3RyaW5nLCBvcHRzKTtcbiAgICBpbnRsUmVsQ2FjaGVba2V5XSA9IGluZjtcbiAgfVxuICByZXR1cm4gaW5mO1xufVxuXG5sZXQgc3lzTG9jYWxlQ2FjaGUgPSBudWxsO1xuZnVuY3Rpb24gc3lzdGVtTG9jYWxlKCkge1xuICBpZiAoc3lzTG9jYWxlQ2FjaGUpIHtcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH0gZWxzZSB7XG4gICAgc3lzTG9jYWxlQ2FjaGUgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZTtcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VMb2NhbGVTdHJpbmcobG9jYWxlU3RyKSB7XG4gIC8vIEkgcmVhbGx5IHdhbnQgdG8gYXZvaWQgd3JpdGluZyBhIEJDUCA0NyBwYXJzZXJcbiAgLy8gc2VlLCBlLmcuIGh0dHBzOi8vZ2l0aHViLmNvbS93b29vcm0vYmNwLTQ3XG4gIC8vIEluc3RlYWQsIHdlJ2xsIGRvIHRoaXM6XG5cbiAgLy8gYSkgaWYgdGhlIHN0cmluZyBoYXMgbm8gLXUgZXh0ZW5zaW9ucywganVzdCBsZWF2ZSBpdCBhbG9uZVxuICAvLyBiKSBpZiBpdCBkb2VzLCB1c2UgSW50bCB0byByZXNvbHZlIGV2ZXJ5dGhpbmdcbiAgLy8gYykgaWYgSW50bCBmYWlscywgdHJ5IGFnYWluIHdpdGhvdXQgdGhlIC11XG5cbiAgY29uc3QgdUluZGV4ID0gbG9jYWxlU3RyLmluZGV4T2YoXCItdS1cIik7XG4gIGlmICh1SW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIFtsb2NhbGVTdHJdO1xuICB9IGVsc2Uge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGNvbnN0IHNtYWxsZXIgPSBsb2NhbGVTdHIuc3Vic3RyaW5nKDAsIHVJbmRleCk7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMgPSBnZXRDYWNoZWREVEYobG9jYWxlU3RyKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvcHRpb25zID0gZ2V0Q2FjaGVkRFRGKHNtYWxsZXIpLnJlc29sdmVkT3B0aW9ucygpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhciB9ID0gb3B0aW9ucztcbiAgICAvLyByZXR1cm4gdGhlIHNtYWxsZXIgb25lIHNvIHRoYXQgd2UgY2FuIGFwcGVuZCB0aGUgY2FsZW5kYXIgYW5kIG51bWJlcmluZyBvdmVycmlkZXMgdG8gaXRcbiAgICByZXR1cm4gW3NtYWxsZXIsIG51bWJlcmluZ1N5c3RlbSwgY2FsZW5kYXJdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGxDb25maWdTdHJpbmcobG9jYWxlU3RyLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyKSB7XG4gIGlmIChvdXRwdXRDYWxlbmRhciB8fCBudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICBsb2NhbGVTdHIgKz0gXCItdVwiO1xuXG4gICAgaWYgKG91dHB1dENhbGVuZGFyKSB7XG4gICAgICBsb2NhbGVTdHIgKz0gYC1jYS0ke291dHB1dENhbGVuZGFyfWA7XG4gICAgfVxuXG4gICAgaWYgKG51bWJlcmluZ1N5c3RlbSkge1xuICAgICAgbG9jYWxlU3RyICs9IGAtbnUtJHtudW1iZXJpbmdTeXN0ZW19YDtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZVN0cjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbG9jYWxlU3RyO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcE1vbnRocyhmKSB7XG4gIGNvbnN0IG1zID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IDEyOyBpKyspIHtcbiAgICBjb25zdCBkdCA9IERhdGVUaW1lLnV0YygyMDE2LCBpLCAxKTtcbiAgICBtcy5wdXNoKGYoZHQpKTtcbiAgfVxuICByZXR1cm4gbXM7XG59XG5cbmZ1bmN0aW9uIG1hcFdlZWtkYXlzKGYpIHtcbiAgY29uc3QgbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gNzsgaSsrKSB7XG4gICAgY29uc3QgZHQgPSBEYXRlVGltZS51dGMoMjAxNiwgMTEsIDEzICsgaSk7XG4gICAgbXMucHVzaChmKGR0KSk7XG4gIH1cbiAgcmV0dXJuIG1zO1xufVxuXG5mdW5jdGlvbiBsaXN0U3R1ZmYobG9jLCBsZW5ndGgsIGRlZmF1bHRPSywgZW5nbGlzaEZuLCBpbnRsRm4pIHtcbiAgY29uc3QgbW9kZSA9IGxvYy5saXN0aW5nTW9kZShkZWZhdWx0T0spO1xuXG4gIGlmIChtb2RlID09PSBcImVycm9yXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChtb2RlID09PSBcImVuXCIpIHtcbiAgICByZXR1cm4gZW5nbGlzaEZuKGxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGludGxGbihsZW5ndGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzRmFzdE51bWJlcnMobG9jKSB7XG4gIGlmIChsb2MubnVtYmVyaW5nU3lzdGVtICYmIGxvYy5udW1iZXJpbmdTeXN0ZW0gIT09IFwibGF0blwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXG4gICAgICBsb2MubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIiB8fFxuICAgICAgIWxvYy5sb2NhbGUgfHxcbiAgICAgIGxvYy5sb2NhbGUuc3RhcnRzV2l0aChcImVuXCIpIHx8XG4gICAgICBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2MuaW50bCkucmVzb2x2ZWRPcHRpb25zKCkubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIlxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNsYXNzIFBvbHlOdW1iZXJGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihpbnRsLCBmb3JjZVNpbXBsZSwgb3B0cykge1xuICAgIHRoaXMucGFkVG8gPSBvcHRzLnBhZFRvIHx8IDA7XG4gICAgdGhpcy5mbG9vciA9IG9wdHMuZmxvb3IgfHwgZmFsc2U7XG5cbiAgICBjb25zdCB7IHBhZFRvLCBmbG9vciwgLi4ub3RoZXJPcHRzIH0gPSBvcHRzO1xuXG4gICAgaWYgKCFmb3JjZVNpbXBsZSB8fCBPYmplY3Qua2V5cyhvdGhlck9wdHMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGludGxPcHRzID0geyB1c2VHcm91cGluZzogZmFsc2UsIC4uLm9wdHMgfTtcbiAgICAgIGlmIChvcHRzLnBhZFRvID4gMCkgaW50bE9wdHMubWluaW11bUludGVnZXJEaWdpdHMgPSBvcHRzLnBhZFRvO1xuICAgICAgdGhpcy5pbmYgPSBnZXRDYWNoZWRJTkYoaW50bCwgaW50bE9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdChpKSB7XG4gICAgaWYgKHRoaXMuaW5mKSB7XG4gICAgICBjb25zdCBmaXhlZCA9IHRoaXMuZmxvb3IgPyBNYXRoLmZsb29yKGkpIDogaTtcbiAgICAgIHJldHVybiB0aGlzLmluZi5mb3JtYXQoZml4ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0byBtYXRjaCB0aGUgYnJvd3NlcidzIG51bWJlcmZvcm1hdHRlciBkZWZhdWx0c1xuICAgICAgY29uc3QgZml4ZWQgPSB0aGlzLmZsb29yID8gTWF0aC5mbG9vcihpKSA6IHJvdW5kVG8oaSwgMyk7XG4gICAgICByZXR1cm4gcGFkU3RhcnQoZml4ZWQsIHRoaXMucGFkVG8pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuY2xhc3MgUG9seURhdGVGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihkdCwgaW50bCwgb3B0cykge1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG5cbiAgICBsZXQgejtcbiAgICBpZiAoZHQuem9uZS5pc1VuaXZlcnNhbCkge1xuICAgICAgLy8gVVRDLTggb3IgRXRjL1VUQy04IGFyZSBub3QgcGFydCBvZiB0emRhdGEsIG9ubHkgRXRjL0dNVCs4IGFuZCB0aGUgbGlrZS5cbiAgICAgIC8vIFRoYXQgaXMgd2h5IGZpeGVkLW9mZnNldCBUWiBpcyBzZXQgdG8gdGhhdCB1bmxlc3MgaXQgaXM6XG4gICAgICAvLyAxLiBSZXByZXNlbnRpbmcgb2Zmc2V0IDAgd2hlbiBVVEMgaXMgdXNlZCB0byBtYWludGFpbiBwcmV2aW91cyBiZWhhdmlvciBhbmQgZG9lcyBub3QgYmVjb21lIEdNVC5cbiAgICAgIC8vIDIuIFVuc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyOlxuICAgICAgLy8gICAgLSBzb21lIGRvIG5vdCBzdXBwb3J0IEV0Yy9cbiAgICAgIC8vICAgIC0gPCBFdGMvR01ULTE0LCA+IEV0Yy9HTVQrMTIsIGFuZCAzMC1taW51dGUgb3IgNDUtbWludXRlIG9mZnNldHMgYXJlIG5vdCBwYXJ0IG9mIHR6ZGF0YVxuICAgICAgY29uc3QgZ210T2Zmc2V0ID0gLTEgKiAoZHQub2Zmc2V0IC8gNjApO1xuICAgICAgY29uc3Qgb2Zmc2V0WiA9IGdtdE9mZnNldCA+PSAwID8gYEV0Yy9HTVQrJHtnbXRPZmZzZXR9YCA6IGBFdGMvR01UJHtnbXRPZmZzZXR9YDtcbiAgICAgIGlmIChkdC5vZmZzZXQgIT09IDAgJiYgSUFOQVpvbmUuY3JlYXRlKG9mZnNldFopLnZhbGlkKSB7XG4gICAgICAgIHogPSBvZmZzZXRaO1xuICAgICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3QgYWxsIGZpeGVkLW9mZnNldCB6b25lcyBsaWtlIEV0Yy8rNDozMCBhcmUgcHJlc2VudCBpbiB0emRhdGEuXG4gICAgICAgIC8vIFNvIHdlIGhhdmUgdG8gbWFrZSBkby4gVHdvIGNhc2VzOlxuICAgICAgICAvLyAxLiBUaGUgZm9ybWF0IG9wdGlvbnMgdGVsbCB1cyB0byBzaG93IHRoZSB6b25lLiBXZSBjYW4ndCBkbyB0aGF0LCBzbyB0aGUgYmVzdFxuICAgICAgICAvLyB3ZSBjYW4gZG8gaXMgZm9ybWF0IHRoZSBkYXRlIGluIFVUQy5cbiAgICAgICAgLy8gMi4gVGhlIGZvcm1hdCBvcHRpb25zIGRvbid0IHRlbGwgdXMgdG8gc2hvdyB0aGUgem9uZS4gVGhlbiB3ZSBjYW4gYWRqdXN0IHRoZW1cbiAgICAgICAgLy8gdGhlIHRpbWUgYW5kIHRlbGwgdGhlIGZvcm1hdHRlciB0byBzaG93IGl0IHRvIHVzIGluIFVUQywgc28gdGhhdCB0aGUgdGltZSBpcyByaWdodFxuICAgICAgICAvLyBhbmQgdGhlIGJhZCB6b25lIGRvZXNuJ3Qgc2hvdyB1cC5cbiAgICAgICAgeiA9IFwiVVRDXCI7XG4gICAgICAgIGlmIChvcHRzLnRpbWVab25lTmFtZSkge1xuICAgICAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmR0ID0gZHQub2Zmc2V0ID09PSAwID8gZHQgOiBEYXRlVGltZS5mcm9tTWlsbGlzKGR0LnRzICsgZHQub2Zmc2V0ICogNjAgKiAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZHQuem9uZS50eXBlID09PSBcInN5c3RlbVwiKSB7XG4gICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgIHogPSBkdC56b25lLm5hbWU7XG4gICAgfVxuXG4gICAgY29uc3QgaW50bE9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuICAgIGlmICh6KSB7XG4gICAgICBpbnRsT3B0cy50aW1lWm9uZSA9IHo7XG4gICAgfVxuICAgIHRoaXMuZHRmID0gZ2V0Q2FjaGVkRFRGKGludGwsIGludGxPcHRzKTtcbiAgfVxuXG4gIGZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5kdGYuZm9ybWF0KHRoaXMuZHQudG9KU0RhdGUoKSk7XG4gIH1cblxuICBmb3JtYXRUb1BhcnRzKCkge1xuICAgIHJldHVybiB0aGlzLmR0Zi5mb3JtYXRUb1BhcnRzKHRoaXMuZHQudG9KU0RhdGUoKSk7XG4gIH1cblxuICByZXNvbHZlZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRmLnJlc29sdmVkT3B0aW9ucygpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUG9seVJlbEZvcm1hdHRlciB7XG4gIGNvbnN0cnVjdG9yKGludGwsIGlzRW5nbGlzaCwgb3B0cykge1xuICAgIHRoaXMub3B0cyA9IHsgc3R5bGU6IFwibG9uZ1wiLCAuLi5vcHRzIH07XG4gICAgaWYgKCFpc0VuZ2xpc2ggJiYgaGFzUmVsYXRpdmUoKSkge1xuICAgICAgdGhpcy5ydGYgPSBnZXRDYWNoZWRSVEYoaW50bCwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0KGNvdW50LCB1bml0KSB7XG4gICAgaWYgKHRoaXMucnRmKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydGYuZm9ybWF0KGNvdW50LCB1bml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEVuZ2xpc2guZm9ybWF0UmVsYXRpdmVUaW1lKHVuaXQsIGNvdW50LCB0aGlzLm9wdHMubnVtZXJpYywgdGhpcy5vcHRzLnN0eWxlICE9PSBcImxvbmdcIik7XG4gICAgfVxuICB9XG5cbiAgZm9ybWF0VG9QYXJ0cyhjb3VudCwgdW5pdCkge1xuICAgIGlmICh0aGlzLnJ0Zikge1xuICAgICAgcmV0dXJuIHRoaXMucnRmLmZvcm1hdFRvUGFydHMoY291bnQsIHVuaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhbGUge1xuICBzdGF0aWMgZnJvbU9wdHMob3B0cykge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKG9wdHMubG9jYWxlLCBvcHRzLm51bWJlcmluZ1N5c3RlbSwgb3B0cy5vdXRwdXRDYWxlbmRhciwgb3B0cy5kZWZhdWx0VG9FTik7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciwgZGVmYXVsdFRvRU4gPSBmYWxzZSkge1xuICAgIGNvbnN0IHNwZWNpZmllZExvY2FsZSA9IGxvY2FsZSB8fCBTZXR0aW5ncy5kZWZhdWx0TG9jYWxlO1xuICAgIC8vIHRoZSBzeXN0ZW0gbG9jYWxlIGlzIHVzZWZ1bCBmb3IgaHVtYW4gcmVhZGFibGUgc3RyaW5ncyBidXQgYW5ub3lpbmcgZm9yIHBhcnNpbmcvZm9ybWF0dGluZyBrbm93biBmb3JtYXRzXG4gICAgY29uc3QgbG9jYWxlUiA9IHNwZWNpZmllZExvY2FsZSB8fCAoZGVmYXVsdFRvRU4gPyBcImVuLVVTXCIgOiBzeXN0ZW1Mb2NhbGUoKSk7XG4gICAgY29uc3QgbnVtYmVyaW5nU3lzdGVtUiA9IG51bWJlcmluZ1N5c3RlbSB8fCBTZXR0aW5ncy5kZWZhdWx0TnVtYmVyaW5nU3lzdGVtO1xuICAgIGNvbnN0IG91dHB1dENhbGVuZGFyUiA9IG91dHB1dENhbGVuZGFyIHx8IFNldHRpbmdzLmRlZmF1bHRPdXRwdXRDYWxlbmRhcjtcbiAgICByZXR1cm4gbmV3IExvY2FsZShsb2NhbGVSLCBudW1iZXJpbmdTeXN0ZW1SLCBvdXRwdXRDYWxlbmRhclIsIHNwZWNpZmllZExvY2FsZSk7XG4gIH1cblxuICBzdGF0aWMgcmVzZXRDYWNoZSgpIHtcbiAgICBzeXNMb2NhbGVDYWNoZSA9IG51bGw7XG4gICAgaW50bERUQ2FjaGUgPSB7fTtcbiAgICBpbnRsTnVtQ2FjaGUgPSB7fTtcbiAgICBpbnRsUmVsQ2FjaGUgPSB7fTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tT2JqZWN0KHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcik7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihsb2NhbGUsIG51bWJlcmluZywgb3V0cHV0Q2FsZW5kYXIsIHNwZWNpZmllZExvY2FsZSkge1xuICAgIGNvbnN0IFtwYXJzZWRMb2NhbGUsIHBhcnNlZE51bWJlcmluZ1N5c3RlbSwgcGFyc2VkT3V0cHV0Q2FsZW5kYXJdID0gcGFyc2VMb2NhbGVTdHJpbmcobG9jYWxlKTtcblxuICAgIHRoaXMubG9jYWxlID0gcGFyc2VkTG9jYWxlO1xuICAgIHRoaXMubnVtYmVyaW5nU3lzdGVtID0gbnVtYmVyaW5nIHx8IHBhcnNlZE51bWJlcmluZ1N5c3RlbSB8fCBudWxsO1xuICAgIHRoaXMub3V0cHV0Q2FsZW5kYXIgPSBvdXRwdXRDYWxlbmRhciB8fCBwYXJzZWRPdXRwdXRDYWxlbmRhciB8fCBudWxsO1xuICAgIHRoaXMuaW50bCA9IGludGxDb25maWdTdHJpbmcodGhpcy5sb2NhbGUsIHRoaXMubnVtYmVyaW5nU3lzdGVtLCB0aGlzLm91dHB1dENhbGVuZGFyKTtcblxuICAgIHRoaXMud2Vla2RheXNDYWNoZSA9IHsgZm9ybWF0OiB7fSwgc3RhbmRhbG9uZToge30gfTtcbiAgICB0aGlzLm1vbnRoc0NhY2hlID0geyBmb3JtYXQ6IHt9LCBzdGFuZGFsb25lOiB7fSB9O1xuICAgIHRoaXMubWVyaWRpZW1DYWNoZSA9IG51bGw7XG4gICAgdGhpcy5lcmFDYWNoZSA9IHt9O1xuXG4gICAgdGhpcy5zcGVjaWZpZWRMb2NhbGUgPSBzcGVjaWZpZWRMb2NhbGU7XG4gICAgdGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9IG51bGw7XG4gIH1cblxuICBnZXQgZmFzdE51bWJlcnMoKSB7XG4gICAgaWYgKHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5mYXN0TnVtYmVyc0NhY2hlZCA9IHN1cHBvcnRzRmFzdE51bWJlcnModGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQ7XG4gIH1cblxuICBsaXN0aW5nTW9kZSgpIHtcbiAgICBjb25zdCBpc0FjdHVhbGx5RW4gPSB0aGlzLmlzRW5nbGlzaCgpO1xuICAgIGNvbnN0IGhhc05vV2VpcmRuZXNzID1cbiAgICAgICh0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gbnVsbCB8fCB0aGlzLm51bWJlcmluZ1N5c3RlbSA9PT0gXCJsYXRuXCIpICYmXG4gICAgICAodGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gbnVsbCB8fCB0aGlzLm91dHB1dENhbGVuZGFyID09PSBcImdyZWdvcnlcIik7XG4gICAgcmV0dXJuIGlzQWN0dWFsbHlFbiAmJiBoYXNOb1dlaXJkbmVzcyA/IFwiZW5cIiA6IFwiaW50bFwiO1xuICB9XG5cbiAgY2xvbmUoYWx0cykge1xuICAgIGlmICghYWx0cyB8fCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhbHRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShcbiAgICAgICAgYWx0cy5sb2NhbGUgfHwgdGhpcy5zcGVjaWZpZWRMb2NhbGUsXG4gICAgICAgIGFsdHMubnVtYmVyaW5nU3lzdGVtIHx8IHRoaXMubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBhbHRzLm91dHB1dENhbGVuZGFyIHx8IHRoaXMub3V0cHV0Q2FsZW5kYXIsXG4gICAgICAgIGFsdHMuZGVmYXVsdFRvRU4gfHwgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmVkZWZhdWx0VG9FTihhbHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7IC4uLmFsdHMsIGRlZmF1bHRUb0VOOiB0cnVlIH0pO1xuICB9XG5cbiAgcmVkZWZhdWx0VG9TeXN0ZW0oYWx0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoeyAuLi5hbHRzLCBkZWZhdWx0VG9FTjogZmFsc2UgfSk7XG4gIH1cblxuICBtb250aHMobGVuZ3RoLCBmb3JtYXQgPSBmYWxzZSwgZGVmYXVsdE9LID0gdHJ1ZSkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBkZWZhdWx0T0ssIEVuZ2xpc2gubW9udGhzLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnRsID0gZm9ybWF0ID8geyBtb250aDogbGVuZ3RoLCBkYXk6IFwibnVtZXJpY1wiIH0gOiB7IG1vbnRoOiBsZW5ndGggfSxcbiAgICAgICAgZm9ybWF0U3RyID0gZm9ybWF0ID8gXCJmb3JtYXRcIiA6IFwic3RhbmRhbG9uZVwiO1xuICAgICAgaWYgKCF0aGlzLm1vbnRoc0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSkge1xuICAgICAgICB0aGlzLm1vbnRoc0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSA9IG1hcE1vbnRocygoZHQpID0+IHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJtb250aFwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF07XG4gICAgfSk7XG4gIH1cblxuICB3ZWVrZGF5cyhsZW5ndGgsIGZvcm1hdCA9IGZhbHNlLCBkZWZhdWx0T0sgPSB0cnVlKSB7XG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIGRlZmF1bHRPSywgRW5nbGlzaC53ZWVrZGF5cywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IGZvcm1hdFxuICAgICAgICAgID8geyB3ZWVrZGF5OiBsZW5ndGgsIHllYXI6IFwibnVtZXJpY1wiLCBtb250aDogXCJsb25nXCIsIGRheTogXCJudW1lcmljXCIgfVxuICAgICAgICAgIDogeyB3ZWVrZGF5OiBsZW5ndGggfSxcbiAgICAgICAgZm9ybWF0U3RyID0gZm9ybWF0ID8gXCJmb3JtYXRcIiA6IFwic3RhbmRhbG9uZVwiO1xuICAgICAgaWYgKCF0aGlzLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdKSB7XG4gICAgICAgIHRoaXMud2Vla2RheXNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0gPSBtYXBXZWVrZGF5cygoZHQpID0+XG4gICAgICAgICAgdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcIndlZWtkYXlcIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdO1xuICAgIH0pO1xuICB9XG5cbiAgbWVyaWRpZW1zKGRlZmF1bHRPSyA9IHRydWUpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKFxuICAgICAgdGhpcyxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGRlZmF1bHRPSyxcbiAgICAgICgpID0+IEVuZ2xpc2gubWVyaWRpZW1zLFxuICAgICAgKCkgPT4ge1xuICAgICAgICAvLyBJbiB0aGVvcnkgdGhlcmUgY291bGQgYmUgYXJpYml0cmFyeSBkYXkgcGVyaW9kcy4gV2UncmUgZ29ubmEgYXNzdW1lIHRoZXJlIGFyZSBleGFjdGx5IHR3b1xuICAgICAgICAvLyBmb3IgQU0gYW5kIFBNLiBUaGlzIGlzIHByb2JhYmx5IHdyb25nLCBidXQgaXQncyBtYWtlcyBwYXJzaW5nIHdheSBlYXNpZXIuXG4gICAgICAgIGlmICghdGhpcy5tZXJpZGllbUNhY2hlKSB7XG4gICAgICAgICAgY29uc3QgaW50bCA9IHsgaG91cjogXCJudW1lcmljXCIsIGhvdXJDeWNsZTogXCJoMTJcIiB9O1xuICAgICAgICAgIHRoaXMubWVyaWRpZW1DYWNoZSA9IFtEYXRlVGltZS51dGMoMjAxNiwgMTEsIDEzLCA5KSwgRGF0ZVRpbWUudXRjKDIwMTYsIDExLCAxMywgMTkpXS5tYXAoXG4gICAgICAgICAgICAoZHQpID0+IHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJkYXlwZXJpb2RcIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubWVyaWRpZW1DYWNoZTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgZXJhcyhsZW5ndGgsIGRlZmF1bHRPSyA9IHRydWUpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKHRoaXMsIGxlbmd0aCwgZGVmYXVsdE9LLCBFbmdsaXNoLmVyYXMsICgpID0+IHtcbiAgICAgIGNvbnN0IGludGwgPSB7IGVyYTogbGVuZ3RoIH07XG5cbiAgICAgIC8vIFRoaXMgaXMgcHJvYmxlbWF0aWMuIERpZmZlcmVudCBjYWxlbmRhcnMgYXJlIGdvaW5nIHRvIGRlZmluZSBlcmFzIHRvdGFsbHkgZGlmZmVyZW50bHkuIFdoYXQgSSBuZWVkIGlzIHRoZSBtaW5pbXVtIHNldCBvZiBkYXRlc1xuICAgICAgLy8gdG8gZGVmaW5pdGVseSBlbnVtZXJhdGUgdGhlbS5cbiAgICAgIGlmICghdGhpcy5lcmFDYWNoZVtsZW5ndGhdKSB7XG4gICAgICAgIHRoaXMuZXJhQ2FjaGVbbGVuZ3RoXSA9IFtEYXRlVGltZS51dGMoLTQwLCAxLCAxKSwgRGF0ZVRpbWUudXRjKDIwMTcsIDEsIDEpXS5tYXAoKGR0KSA9PlxuICAgICAgICAgIHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJlcmFcIilcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZXJhQ2FjaGVbbGVuZ3RoXTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4dHJhY3QoZHQsIGludGxPcHRzLCBmaWVsZCkge1xuICAgIGNvbnN0IGRmID0gdGhpcy5kdEZvcm1hdHRlcihkdCwgaW50bE9wdHMpLFxuICAgICAgcmVzdWx0cyA9IGRmLmZvcm1hdFRvUGFydHMoKSxcbiAgICAgIG1hdGNoaW5nID0gcmVzdWx0cy5maW5kKChtKSA9PiBtLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZmllbGQpO1xuICAgIHJldHVybiBtYXRjaGluZyA/IG1hdGNoaW5nLnZhbHVlIDogbnVsbDtcbiAgfVxuXG4gIG51bWJlckZvcm1hdHRlcihvcHRzID0ge30pIHtcbiAgICAvLyB0aGlzIGZvcmNlc2ltcGxlIG9wdGlvbiBpcyBuZXZlciB1c2VkICh0aGUgb25seSBjYWxsZXIgc2hvcnQtY2lyY3VpdHMgb24gaXQsIGJ1dCBpdCBzZWVtcyBzYWZlciB0byBsZWF2ZSlcbiAgICAvLyAoaW4gY29udHJhc3QsIHRoZSByZXN0IG9mIHRoZSBjb25kaXRpb24gaXMgdXNlZCBoZWF2aWx5KVxuICAgIHJldHVybiBuZXcgUG9seU51bWJlckZvcm1hdHRlcih0aGlzLmludGwsIG9wdHMuZm9yY2VTaW1wbGUgfHwgdGhpcy5mYXN0TnVtYmVycywgb3B0cyk7XG4gIH1cblxuICBkdEZvcm1hdHRlcihkdCwgaW50bE9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUG9seURhdGVGb3JtYXR0ZXIoZHQsIHRoaXMuaW50bCwgaW50bE9wdHMpO1xuICB9XG5cbiAgcmVsRm9ybWF0dGVyKG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUG9seVJlbEZvcm1hdHRlcih0aGlzLmludGwsIHRoaXMuaXNFbmdsaXNoKCksIG9wdHMpO1xuICB9XG5cbiAgbGlzdEZvcm1hdHRlcihvcHRzID0ge30pIHtcbiAgICByZXR1cm4gZ2V0Q2FjaGVkTEYodGhpcy5pbnRsLCBvcHRzKTtcbiAgfVxuXG4gIGlzRW5nbGlzaCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5sb2NhbGUgPT09IFwiZW5cIiB8fFxuICAgICAgdGhpcy5sb2NhbGUudG9Mb3dlckNhc2UoKSA9PT0gXCJlbi11c1wiIHx8XG4gICAgICBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmludGwpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZS5zdGFydHNXaXRoKFwiZW4tdXNcIilcbiAgICApO1xuICB9XG5cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubG9jYWxlID09PSBvdGhlci5sb2NhbGUgJiZcbiAgICAgIHRoaXMubnVtYmVyaW5nU3lzdGVtID09PSBvdGhlci5udW1iZXJpbmdTeXN0ZW0gJiZcbiAgICAgIHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IG90aGVyLm91dHB1dENhbGVuZGFyXG4gICAgKTtcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIHVudHJ1bmNhdGVZZWFyLFxuICBzaWduZWRPZmZzZXQsXG4gIHBhcnNlSW50ZWdlcixcbiAgcGFyc2VNaWxsaXMsXG4gIGlhbmFSZWdleCxcbiAgaXNVbmRlZmluZWQsXG4gIHBhcnNlRmxvYXRpbmcsXG59IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0IEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIFwiLi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4uL3pvbmVzL0lBTkFab25lLmpzXCI7XG5cbi8qXG4gKiBUaGlzIGZpbGUgaGFuZGxlcyBwYXJzaW5nIGZvciB3ZWxsLXNwZWNpZmllZCBmb3JtYXRzLiBIZXJlJ3MgaG93IGl0IHdvcmtzOlxuICogVHdvIHRoaW5ncyBnbyBpbnRvIHBhcnNpbmc6IGEgcmVnZXggdG8gbWF0Y2ggd2l0aCBhbmQgYW4gZXh0cmFjdG9yIHRvIHRha2UgYXBhcnQgdGhlIGdyb3VwcyBpbiB0aGUgbWF0Y2guXG4gKiBBbiBleHRyYWN0b3IgaXMganVzdCBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSByZWdleCBtYXRjaCBhcnJheSBhbmQgcmV0dXJucyBhIHsgeWVhcjogLi4uLCBtb250aDogLi4uIH0gb2JqZWN0XG4gKiBwYXJzZSgpIGRvZXMgdGhlIHdvcmsgb2YgZXhlY3V0aW5nIHRoZSByZWdleCBhbmQgYXBwbHlpbmcgdGhlIGV4dHJhY3Rvci4gSXQgdGFrZXMgbXVsdGlwbGUgcmVnZXgvZXh0cmFjdG9yIHBhaXJzIHRvIHRyeSBpbiBzZXF1ZW5jZS5cbiAqIEV4dHJhY3RvcnMgY2FuIHRha2UgYSBcImN1cnNvclwiIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0IGluIHRoZSBtYXRjaCB0byBsb29rIGF0LiBUaGlzIG1ha2VzIGl0IGVhc3kgdG8gY29tYmluZSBleHRyYWN0b3JzLlxuICogY29tYmluZUV4dHJhY3RvcnMoKSBkb2VzIHRoZSB3b3JrIG9mIGNvbWJpbmluZyB0aGVtLCBrZWVwaW5nIHRyYWNrIG9mIHRoZSBjdXJzb3IgdGhyb3VnaCBtdWx0aXBsZSBleHRyYWN0aW9ucy5cbiAqIFNvbWUgZXh0cmFjdGlvbnMgYXJlIHN1cGVyIGR1bWIgYW5kIHNpbXBsZVBhcnNlIGFuZCBmcm9tU3RyaW5ncyBoZWxwIERSWSB0aGVtLlxuICovXG5cbmZ1bmN0aW9uIGNvbWJpbmVSZWdleGVzKC4uLnJlZ2V4ZXMpIHtcbiAgY29uc3QgZnVsbCA9IHJlZ2V4ZXMucmVkdWNlKChmLCByKSA9PiBmICsgci5zb3VyY2UsIFwiXCIpO1xuICByZXR1cm4gUmVnRXhwKGBeJHtmdWxsfSRgKTtcbn1cblxuZnVuY3Rpb24gY29tYmluZUV4dHJhY3RvcnMoLi4uZXh0cmFjdG9ycykge1xuICByZXR1cm4gKG0pID0+XG4gICAgZXh0cmFjdG9yc1xuICAgICAgLnJlZHVjZShcbiAgICAgICAgKFttZXJnZWRWYWxzLCBtZXJnZWRab25lLCBjdXJzb3JdLCBleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IFt2YWwsIHpvbmUsIG5leHRdID0gZXgobSwgY3Vyc29yKTtcbiAgICAgICAgICByZXR1cm4gW3sgLi4ubWVyZ2VkVmFscywgLi4udmFsIH0sIG1lcmdlZFpvbmUgfHwgem9uZSwgbmV4dF07XG4gICAgICAgIH0sXG4gICAgICAgIFt7fSwgbnVsbCwgMV1cbiAgICAgIClcbiAgICAgIC5zbGljZSgwLCAyKTtcbn1cblxuZnVuY3Rpb24gcGFyc2UocywgLi4ucGF0dGVybnMpIHtcbiAgaWYgKHMgPT0gbnVsbCkge1xuICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gIH1cblxuICBmb3IgKGNvbnN0IFtyZWdleCwgZXh0cmFjdG9yXSBvZiBwYXR0ZXJucykge1xuICAgIGNvbnN0IG0gPSByZWdleC5leGVjKHMpO1xuICAgIGlmIChtKSB7XG4gICAgICByZXR1cm4gZXh0cmFjdG9yKG0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW251bGwsIG51bGxdO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVQYXJzZSguLi5rZXlzKSB7XG4gIHJldHVybiAobWF0Y2gsIGN1cnNvcikgPT4ge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldFtrZXlzW2ldXSA9IHBhcnNlSW50ZWdlcihtYXRjaFtjdXJzb3IgKyBpXSk7XG4gICAgfVxuICAgIHJldHVybiBbcmV0LCBudWxsLCBjdXJzb3IgKyBpXTtcbiAgfTtcbn1cblxuLy8gSVNPIGFuZCBTUUwgcGFyc2luZ1xuY29uc3Qgb2Zmc2V0UmVnZXggPSAvKD86KFopfChbKy1dXFxkXFxkKSg/Ojo/KFxcZFxcZCkpPykvLFxuICBpc29UaW1lQmFzZVJlZ2V4ID0gLyhcXGRcXGQpKD86Oj8oXFxkXFxkKSg/Ojo/KFxcZFxcZCkoPzpbLixdKFxcZHsxLDMwfSkpPyk/KT8vLFxuICBpc29UaW1lUmVnZXggPSBSZWdFeHAoYCR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9JHtvZmZzZXRSZWdleC5zb3VyY2V9P2ApLFxuICBpc29UaW1lRXh0ZW5zaW9uUmVnZXggPSBSZWdFeHAoYCg/OlQke2lzb1RpbWVSZWdleC5zb3VyY2V9KT9gKSxcbiAgaXNvWW1kUmVnZXggPSAvKFsrLV1cXGR7Nn18XFxkezR9KSg/Oi0/KFxcZFxcZCkoPzotPyhcXGRcXGQpKT8pPy8sXG4gIGlzb1dlZWtSZWdleCA9IC8oXFxkezR9KS0/VyhcXGRcXGQpKD86LT8oXFxkKSk/LyxcbiAgaXNvT3JkaW5hbFJlZ2V4ID0gLyhcXGR7NH0pLT8oXFxkezN9KS8sXG4gIGV4dHJhY3RJU09XZWVrRGF0YSA9IHNpbXBsZVBhcnNlKFwid2Vla1llYXJcIiwgXCJ3ZWVrTnVtYmVyXCIsIFwid2Vla0RheVwiKSxcbiAgZXh0cmFjdElTT09yZGluYWxEYXRhID0gc2ltcGxlUGFyc2UoXCJ5ZWFyXCIsIFwib3JkaW5hbFwiKSxcbiAgc3FsWW1kUmVnZXggPSAvKFxcZHs0fSktKFxcZFxcZCktKFxcZFxcZCkvLCAvLyBkdW1iZWQtZG93biB2ZXJzaW9uIG9mIHRoZSBJU08gb25lXG4gIHNxbFRpbWVSZWdleCA9IFJlZ0V4cChcbiAgICBgJHtpc29UaW1lQmFzZVJlZ2V4LnNvdXJjZX0gPyg/OiR7b2Zmc2V0UmVnZXguc291cmNlfXwoJHtpYW5hUmVnZXguc291cmNlfSkpP2BcbiAgKSxcbiAgc3FsVGltZUV4dGVuc2lvblJlZ2V4ID0gUmVnRXhwKGAoPzogJHtzcWxUaW1lUmVnZXguc291cmNlfSk/YCk7XG5cbmZ1bmN0aW9uIGludChtYXRjaCwgcG9zLCBmYWxsYmFjaykge1xuICBjb25zdCBtID0gbWF0Y2hbcG9zXTtcbiAgcmV0dXJuIGlzVW5kZWZpbmVkKG0pID8gZmFsbGJhY2sgOiBwYXJzZUludGVnZXIobSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09ZbWQobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBpdGVtID0ge1xuICAgIHllYXI6IGludChtYXRjaCwgY3Vyc29yKSxcbiAgICBtb250aDogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAxKSxcbiAgICBkYXk6IGludChtYXRjaCwgY3Vyc29yICsgMiwgMSksXG4gIH07XG5cbiAgcmV0dXJuIFtpdGVtLCBudWxsLCBjdXJzb3IgKyAzXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdElTT1RpbWUobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBpdGVtID0ge1xuICAgIGhvdXJzOiBpbnQobWF0Y2gsIGN1cnNvciwgMCksXG4gICAgbWludXRlczogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAwKSxcbiAgICBzZWNvbmRzOiBpbnQobWF0Y2gsIGN1cnNvciArIDIsIDApLFxuICAgIG1pbGxpc2Vjb25kczogcGFyc2VNaWxsaXMobWF0Y2hbY3Vyc29yICsgM10pLFxuICB9O1xuXG4gIHJldHVybiBbaXRlbSwgbnVsbCwgY3Vyc29yICsgNF07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09PZmZzZXQobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCBsb2NhbCA9ICFtYXRjaFtjdXJzb3JdICYmICFtYXRjaFtjdXJzb3IgKyAxXSxcbiAgICBmdWxsT2Zmc2V0ID0gc2lnbmVkT2Zmc2V0KG1hdGNoW2N1cnNvciArIDFdLCBtYXRjaFtjdXJzb3IgKyAyXSksXG4gICAgem9uZSA9IGxvY2FsID8gbnVsbCA6IEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShmdWxsT2Zmc2V0KTtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgM107XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJQU5BWm9uZShtYXRjaCwgY3Vyc29yKSB7XG4gIGNvbnN0IHpvbmUgPSBtYXRjaFtjdXJzb3JdID8gSUFOQVpvbmUuY3JlYXRlKG1hdGNoW2N1cnNvcl0pIDogbnVsbDtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgMV07XG59XG5cbi8vIElTTyB0aW1lIHBhcnNpbmdcblxuY29uc3QgaXNvVGltZU9ubHkgPSBSZWdFeHAoYF5UPyR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9JGApO1xuXG4vLyBJU08gZHVyYXRpb24gcGFyc2luZ1xuXG5jb25zdCBpc29EdXJhdGlvbiA9XG4gIC9eLT9QKD86KD86KC0/XFxkezEsOX0oPzpcXC5cXGR7MSw5fSk/KVkpPyg/OigtP1xcZHsxLDl9KD86XFwuXFxkezEsOX0pPylNKT8oPzooLT9cXGR7MSw5fSg/OlxcLlxcZHsxLDl9KT8pVyk/KD86KC0/XFxkezEsOX0oPzpcXC5cXGR7MSw5fSk/KUQpPyg/OlQoPzooLT9cXGR7MSw5fSg/OlxcLlxcZHsxLDl9KT8pSCk/KD86KC0/XFxkezEsOX0oPzpcXC5cXGR7MSw5fSk/KU0pPyg/OigtP1xcZHsxLDIwfSkoPzpbLixdKC0/XFxkezEsOX0pKT9TKT8pPykkLztcblxuZnVuY3Rpb24gZXh0cmFjdElTT0R1cmF0aW9uKG1hdGNoKSB7XG4gIGNvbnN0IFtzLCB5ZWFyU3RyLCBtb250aFN0ciwgd2Vla1N0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0ciwgbWlsbGlzZWNvbmRzU3RyXSA9XG4gICAgbWF0Y2g7XG5cbiAgY29uc3QgaGFzTmVnYXRpdmVQcmVmaXggPSBzWzBdID09PSBcIi1cIjtcbiAgY29uc3QgbmVnYXRpdmVTZWNvbmRzID0gc2Vjb25kU3RyICYmIHNlY29uZFN0clswXSA9PT0gXCItXCI7XG5cbiAgY29uc3QgbWF5YmVOZWdhdGUgPSAobnVtLCBmb3JjZSA9IGZhbHNlKSA9PlxuICAgIG51bSAhPT0gdW5kZWZpbmVkICYmIChmb3JjZSB8fCAobnVtICYmIGhhc05lZ2F0aXZlUHJlZml4KSkgPyAtbnVtIDogbnVtO1xuXG4gIHJldHVybiBbXG4gICAge1xuICAgICAgeWVhcnM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcoeWVhclN0cikpLFxuICAgICAgbW9udGhzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKG1vbnRoU3RyKSksXG4gICAgICB3ZWVrczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyh3ZWVrU3RyKSksXG4gICAgICBkYXlzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKGRheVN0cikpLFxuICAgICAgaG91cnM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcoaG91clN0cikpLFxuICAgICAgbWludXRlczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhtaW51dGVTdHIpKSxcbiAgICAgIHNlY29uZHM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcoc2Vjb25kU3RyKSwgc2Vjb25kU3RyID09PSBcIi0wXCIpLFxuICAgICAgbWlsbGlzZWNvbmRzOiBtYXliZU5lZ2F0ZShwYXJzZU1pbGxpcyhtaWxsaXNlY29uZHNTdHIpLCBuZWdhdGl2ZVNlY29uZHMpLFxuICAgIH0sXG4gIF07XG59XG5cbi8vIFRoZXNlIGFyZSBhIGxpdHRsZSBicmFpbmRlYWQuIEVEVCAqc2hvdWxkKiB0ZWxsIHVzIHRoYXQgd2UncmUgaW4sIHNheSwgQW1lcmljYS9OZXdfWW9ya1xuLy8gYW5kIG5vdCBqdXN0IHRoYXQgd2UncmUgaW4gLTI0MCAqcmlnaHQgbm93Ki4gQnV0IHNpbmNlIEkgZG9uJ3QgdGhpbmsgdGhlc2UgYXJlIHVzZWQgdGhhdCBvZnRlblxuLy8gSSdtIGp1c3QgZ29pbmcgdG8gaWdub3JlIHRoYXRcbmNvbnN0IG9ic09mZnNldHMgPSB7XG4gIEdNVDogMCxcbiAgRURUOiAtNCAqIDYwLFxuICBFU1Q6IC01ICogNjAsXG4gIENEVDogLTUgKiA2MCxcbiAgQ1NUOiAtNiAqIDYwLFxuICBNRFQ6IC02ICogNjAsXG4gIE1TVDogLTcgKiA2MCxcbiAgUERUOiAtNyAqIDYwLFxuICBQU1Q6IC04ICogNjAsXG59O1xuXG5mdW5jdGlvbiBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cikge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgeWVhcjogeWVhclN0ci5sZW5ndGggPT09IDIgPyB1bnRydW5jYXRlWWVhcihwYXJzZUludGVnZXIoeWVhclN0cikpIDogcGFyc2VJbnRlZ2VyKHllYXJTdHIpLFxuICAgIG1vbnRoOiBFbmdsaXNoLm1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpICsgMSxcbiAgICBkYXk6IHBhcnNlSW50ZWdlcihkYXlTdHIpLFxuICAgIGhvdXI6IHBhcnNlSW50ZWdlcihob3VyU3RyKSxcbiAgICBtaW51dGU6IHBhcnNlSW50ZWdlcihtaW51dGVTdHIpLFxuICB9O1xuXG4gIGlmIChzZWNvbmRTdHIpIHJlc3VsdC5zZWNvbmQgPSBwYXJzZUludGVnZXIoc2Vjb25kU3RyKTtcbiAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICByZXN1bHQud2Vla2RheSA9XG4gICAgICB3ZWVrZGF5U3RyLmxlbmd0aCA+IDNcbiAgICAgICAgPyBFbmdsaXNoLndlZWtkYXlzTG9uZy5pbmRleE9mKHdlZWtkYXlTdHIpICsgMVxuICAgICAgICA6IEVuZ2xpc2gud2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpICsgMTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIFJGQyAyODIyLzUzMjJcbmNvbnN0IHJmYzI4MjIgPVxuICAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLFxccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoPzooWystXVxcZFxcZCkoXFxkXFxkKSkpJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RSRkMyODIyKG1hdGNoKSB7XG4gIGNvbnN0IFtcbiAgICAgICxcbiAgICAgIHdlZWtkYXlTdHIsXG4gICAgICBkYXlTdHIsXG4gICAgICBtb250aFN0cixcbiAgICAgIHllYXJTdHIsXG4gICAgICBob3VyU3RyLFxuICAgICAgbWludXRlU3RyLFxuICAgICAgc2Vjb25kU3RyLFxuICAgICAgb2JzT2Zmc2V0LFxuICAgICAgbWlsT2Zmc2V0LFxuICAgICAgb2ZmSG91clN0cixcbiAgICAgIG9mZk1pbnV0ZVN0cixcbiAgICBdID0gbWF0Y2gsXG4gICAgcmVzdWx0ID0gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpO1xuXG4gIGxldCBvZmZzZXQ7XG4gIGlmIChvYnNPZmZzZXQpIHtcbiAgICBvZmZzZXQgPSBvYnNPZmZzZXRzW29ic09mZnNldF07XG4gIH0gZWxzZSBpZiAobWlsT2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gMDtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXQgPSBzaWduZWRPZmZzZXQob2ZmSG91clN0ciwgb2ZmTWludXRlU3RyKTtcbiAgfVxuXG4gIHJldHVybiBbcmVzdWx0LCBuZXcgRml4ZWRPZmZzZXRab25lKG9mZnNldCldO1xufVxuXG5mdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gIHJldHVybiBzXG4gICAgLnJlcGxhY2UoL1xcKFteKV0qXFwpfFtcXG5cXHRdL2csIFwiIFwiKVxuICAgIC5yZXBsYWNlKC8oXFxzXFxzKykvZywgXCIgXCIpXG4gICAgLnRyaW0oKTtcbn1cblxuLy8gaHR0cCBkYXRlXG5cbmNvbnN0IHJmYzExMjMgPVxuICAgIC9eKE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksIChcXGRcXGQpIChKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYykgKFxcZHs0fSkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgR01UJC8sXG4gIHJmYzg1MCA9XG4gICAgL14oTW9uZGF5fFR1ZXNkYXl8V2Vkc2RheXxUaHVyc2RheXxGcmlkYXl8U2F0dXJkYXl8U3VuZGF5KSwgKFxcZFxcZCktKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKS0oXFxkXFxkKSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSBHTVQkLyxcbiAgYXNjaWkgPVxuICAgIC9eKE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1bikgKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKSAoIFxcZHxcXGRcXGQpIChcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpIChcXGR7NH0pJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RSRkMxMTIzT3I4NTAobWF0Y2gpIHtcbiAgY29uc3QgWywgd2Vla2RheVN0ciwgZGF5U3RyLCBtb250aFN0ciwgeWVhclN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHJdID0gbWF0Y2gsXG4gICAgcmVzdWx0ID0gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpO1xuICByZXR1cm4gW3Jlc3VsdCwgRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEFTQ0lJKG1hdGNoKSB7XG4gIGNvbnN0IFssIHdlZWtkYXlTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyLCB5ZWFyU3RyXSA9IG1hdGNoLFxuICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcbiAgcmV0dXJuIFtyZXN1bHQsIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZV07XG59XG5cbmNvbnN0IGlzb1ltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29ZbWRSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IGlzb1dlZWtXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvV2Vla1JlZ2V4LCBpc29UaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3QgaXNvT3JkaW5hbFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29PcmRpbmFsUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBpc29UaW1lQ29tYmluZWRSZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1RpbWVSZWdleCk7XG5cbmNvbnN0IGV4dHJhY3RJU09ZbWRUaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09ZbWQsXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0XG4pO1xuY29uc3QgZXh0cmFjdElTT1dlZWtUaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09XZWVrRGF0YSxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXRcbik7XG5jb25zdCBleHRyYWN0SVNPT3JkaW5hbERhdGVBbmRUaW1lID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09PcmRpbmFsRGF0YSxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXRcbik7XG5jb25zdCBleHRyYWN0SVNPVGltZUFuZE9mZnNldCA9IGNvbWJpbmVFeHRyYWN0b3JzKGV4dHJhY3RJU09UaW1lLCBleHRyYWN0SVNPT2Zmc2V0KTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlTT0RhdGUocykge1xuICByZXR1cm4gcGFyc2UoXG4gICAgcyxcbiAgICBbaXNvWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXRdLFxuICAgIFtpc29XZWVrV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT1dlZWtUaW1lQW5kT2Zmc2V0XSxcbiAgICBbaXNvT3JkaW5hbFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09PcmRpbmFsRGF0ZUFuZFRpbWVdLFxuICAgIFtpc29UaW1lQ29tYmluZWRSZWdleCwgZXh0cmFjdElTT1RpbWVBbmRPZmZzZXRdXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJGQzI4MjJEYXRlKHMpIHtcbiAgcmV0dXJuIHBhcnNlKHByZXByb2Nlc3NSRkMyODIyKHMpLCBbcmZjMjgyMiwgZXh0cmFjdFJGQzI4MjJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSFRUUERhdGUocykge1xuICByZXR1cm4gcGFyc2UoXG4gICAgcyxcbiAgICBbcmZjMTEyMywgZXh0cmFjdFJGQzExMjNPcjg1MF0sXG4gICAgW3JmYzg1MCwgZXh0cmFjdFJGQzExMjNPcjg1MF0sXG4gICAgW2FzY2lpLCBleHRyYWN0QVNDSUldXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlTT0R1cmF0aW9uKHMpIHtcbiAgcmV0dXJuIHBhcnNlKHMsIFtpc29EdXJhdGlvbiwgZXh0cmFjdElTT0R1cmF0aW9uXSk7XG59XG5cbmNvbnN0IGV4dHJhY3RJU09UaW1lT25seSA9IGNvbWJpbmVFeHRyYWN0b3JzKGV4dHJhY3RJU09UaW1lKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPVGltZU9ubHkocykge1xuICByZXR1cm4gcGFyc2UocywgW2lzb1RpbWVPbmx5LCBleHRyYWN0SVNPVGltZU9ubHldKTtcbn1cblxuY29uc3Qgc3FsWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKHNxbFltZFJlZ2V4LCBzcWxUaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3Qgc3FsVGltZUNvbWJpbmVkUmVnZXggPSBjb21iaW5lUmVnZXhlcyhzcWxUaW1lUmVnZXgpO1xuXG5jb25zdCBleHRyYWN0SVNPWW1kVGltZU9mZnNldEFuZElBTkFab25lID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09ZbWQsXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5jb25zdCBleHRyYWN0SVNPVGltZU9mZnNldEFuZElBTkFab25lID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNRTChzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtzcWxZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPWW1kVGltZU9mZnNldEFuZElBTkFab25lXSxcbiAgICBbc3FsVGltZUNvbWJpbmVkUmVnZXgsIGV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmVdXG4gICk7XG59XG4iLCAiaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIEludmFsaWREdXJhdGlvbkVycm9yLCBJbnZhbGlkVW5pdEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgSW52YWxpZCBmcm9tIFwiLi9pbXBsL2ludmFsaWQuanNcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4vaW1wbC9sb2NhbGUuanNcIjtcbmltcG9ydCB7IHBhcnNlSVNPRHVyYXRpb24sIHBhcnNlSVNPVGltZU9ubHkgfSBmcm9tIFwiLi9pbXBsL3JlZ2V4UGFyc2VyLmpzXCI7XG5pbXBvcnQge1xuICBhc051bWJlcixcbiAgaGFzT3duUHJvcGVydHksXG4gIGlzSW50ZWdlcixcbiAgaXNOdW1iZXIsXG4gIGlzVW5kZWZpbmVkLFxuICBub3JtYWxpemVPYmplY3QsXG4gIHJvdW5kVG8sXG59IGZyb20gXCIuL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgRHVyYXRpb25cIjtcblxuLy8gdW5pdCBjb252ZXJzaW9uIGNvbnN0YW50c1xuZXhwb3J0IGNvbnN0IGxvd09yZGVyTWF0cml4ID0ge1xuICAgIHdlZWtzOiB7XG4gICAgICBkYXlzOiA3LFxuICAgICAgaG91cnM6IDcgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDcgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBkYXlzOiB7XG4gICAgICBob3VyczogMjQsXG4gICAgICBtaW51dGVzOiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgaG91cnM6IHsgbWludXRlczogNjAsIHNlY29uZHM6IDYwICogNjAsIG1pbGxpc2Vjb25kczogNjAgKiA2MCAqIDEwMDAgfSxcbiAgICBtaW51dGVzOiB7IHNlY29uZHM6IDYwLCBtaWxsaXNlY29uZHM6IDYwICogMTAwMCB9LFxuICAgIHNlY29uZHM6IHsgbWlsbGlzZWNvbmRzOiAxMDAwIH0sXG4gIH0sXG4gIGNhc3VhbE1hdHJpeCA9IHtcbiAgICB5ZWFyczoge1xuICAgICAgcXVhcnRlcnM6IDQsXG4gICAgICBtb250aHM6IDEyLFxuICAgICAgd2Vla3M6IDUyLFxuICAgICAgZGF5czogMzY1LFxuICAgICAgaG91cnM6IDM2NSAqIDI0LFxuICAgICAgbWludXRlczogMzY1ICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDM2NSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIHF1YXJ0ZXJzOiB7XG4gICAgICBtb250aHM6IDMsXG4gICAgICB3ZWVrczogMTMsXG4gICAgICBkYXlzOiA5MSxcbiAgICAgIGhvdXJzOiA5MSAqIDI0LFxuICAgICAgbWludXRlczogOTEgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogOTEgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDkxICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIG1vbnRoczoge1xuICAgICAgd2Vla3M6IDQsXG4gICAgICBkYXlzOiAzMCxcbiAgICAgIGhvdXJzOiAzMCAqIDI0LFxuICAgICAgbWludXRlczogMzAgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogMzAgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDMwICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuXG4gICAgLi4ubG93T3JkZXJNYXRyaXgsXG4gIH0sXG4gIGRheXNJblllYXJBY2N1cmF0ZSA9IDE0NjA5Ny4wIC8gNDAwLFxuICBkYXlzSW5Nb250aEFjY3VyYXRlID0gMTQ2MDk3LjAgLyA0ODAwLFxuICBhY2N1cmF0ZU1hdHJpeCA9IHtcbiAgICB5ZWFyczoge1xuICAgICAgcXVhcnRlcnM6IDQsXG4gICAgICBtb250aHM6IDEyLFxuICAgICAgd2Vla3M6IGRheXNJblllYXJBY2N1cmF0ZSAvIDcsXG4gICAgICBkYXlzOiBkYXlzSW5ZZWFyQWNjdXJhdGUsXG4gICAgICBob3VyczogZGF5c0luWWVhckFjY3VyYXRlICogMjQsXG4gICAgICBtaW51dGVzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgcXVhcnRlcnM6IHtcbiAgICAgIG1vbnRoczogMyxcbiAgICAgIHdlZWtzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyAyOCxcbiAgICAgIGRheXM6IGRheXNJblllYXJBY2N1cmF0ZSAvIDQsXG4gICAgICBob3VyczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0KSAvIDQsXG4gICAgICBtaW51dGVzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCkgLyA0LFxuICAgICAgc2Vjb25kczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCkgLyA0LFxuICAgICAgbWlsbGlzZWNvbmRzOiAoZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMCkgLyA0LFxuICAgIH0sXG4gICAgbW9udGhzOiB7XG4gICAgICB3ZWVrczogZGF5c0luTW9udGhBY2N1cmF0ZSAvIDcsXG4gICAgICBkYXlzOiBkYXlzSW5Nb250aEFjY3VyYXRlLFxuICAgICAgaG91cnM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgICAgc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICAuLi5sb3dPcmRlck1hdHJpeCxcbiAgfTtcblxuLy8gdW5pdHMgb3JkZXJlZCBieSBzaXplXG5jb25zdCBvcmRlcmVkVW5pdHMgPSBbXG4gIFwieWVhcnNcIixcbiAgXCJxdWFydGVyc1wiLFxuICBcIm1vbnRoc1wiLFxuICBcIndlZWtzXCIsXG4gIFwiZGF5c1wiLFxuICBcImhvdXJzXCIsXG4gIFwibWludXRlc1wiLFxuICBcInNlY29uZHNcIixcbiAgXCJtaWxsaXNlY29uZHNcIixcbl07XG5cbmNvbnN0IHJldmVyc2VVbml0cyA9IG9yZGVyZWRVbml0cy5zbGljZSgwKS5yZXZlcnNlKCk7XG5cbi8vIGNsb25lIHJlYWxseSBtZWFucyBcImNyZWF0ZSBhbm90aGVyIGluc3RhbmNlIGp1c3QgbGlrZSB0aGlzIG9uZSwgYnV0IHdpdGggdGhlc2UgY2hhbmdlc1wiXG5mdW5jdGlvbiBjbG9uZShkdXIsIGFsdHMsIGNsZWFyID0gZmFsc2UpIHtcbiAgLy8gZGVlcCBtZXJnZSBmb3IgdmFsc1xuICBjb25zdCBjb25mID0ge1xuICAgIHZhbHVlczogY2xlYXIgPyBhbHRzLnZhbHVlcyA6IHsgLi4uZHVyLnZhbHVlcywgLi4uKGFsdHMudmFsdWVzIHx8IHt9KSB9LFxuICAgIGxvYzogZHVyLmxvYy5jbG9uZShhbHRzLmxvYyksXG4gICAgY29udmVyc2lvbkFjY3VyYWN5OiBhbHRzLmNvbnZlcnNpb25BY2N1cmFjeSB8fCBkdXIuY29udmVyc2lvbkFjY3VyYWN5LFxuICB9O1xuICByZXR1cm4gbmV3IER1cmF0aW9uKGNvbmYpO1xufVxuXG5mdW5jdGlvbiBhbnRpVHJ1bmMobikge1xuICByZXR1cm4gbiA8IDAgPyBNYXRoLmZsb29yKG4pIDogTWF0aC5jZWlsKG4pO1xufVxuXG4vLyBOQjogbXV0YXRlcyBwYXJhbWV0ZXJzXG5mdW5jdGlvbiBjb252ZXJ0KG1hdHJpeCwgZnJvbU1hcCwgZnJvbVVuaXQsIHRvTWFwLCB0b1VuaXQpIHtcbiAgY29uc3QgY29udiA9IG1hdHJpeFt0b1VuaXRdW2Zyb21Vbml0XSxcbiAgICByYXcgPSBmcm9tTWFwW2Zyb21Vbml0XSAvIGNvbnYsXG4gICAgc2FtZVNpZ24gPSBNYXRoLnNpZ24ocmF3KSA9PT0gTWF0aC5zaWduKHRvTWFwW3RvVW5pdF0pLFxuICAgIC8vIG9rLCBzbyB0aGlzIGlzIHdpbGQsIGJ1dCBzZWUgdGhlIG1hdHJpeCBpbiB0aGUgdGVzdHNcbiAgICBhZGRlZCA9XG4gICAgICAhc2FtZVNpZ24gJiYgdG9NYXBbdG9Vbml0XSAhPT0gMCAmJiBNYXRoLmFicyhyYXcpIDw9IDEgPyBhbnRpVHJ1bmMocmF3KSA6IE1hdGgudHJ1bmMocmF3KTtcbiAgdG9NYXBbdG9Vbml0XSArPSBhZGRlZDtcbiAgZnJvbU1hcFtmcm9tVW5pdF0gLT0gYWRkZWQgKiBjb252O1xufVxuXG4vLyBOQjogbXV0YXRlcyBwYXJhbWV0ZXJzXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZXMobWF0cml4LCB2YWxzKSB7XG4gIHJldmVyc2VVbml0cy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh2YWxzW2N1cnJlbnRdKSkge1xuICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgIGNvbnZlcnQobWF0cml4LCB2YWxzLCBwcmV2aW91cywgdmFscywgY3VycmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgIH1cbiAgfSwgbnVsbCk7XG59XG5cbi8qKlxuICogQSBEdXJhdGlvbiBvYmplY3QgcmVwcmVzZW50cyBhIHBlcmlvZCBvZiB0aW1lLCBsaWtlIFwiMiBtb250aHNcIiBvciBcIjEgZGF5LCAxIGhvdXJcIi4gQ29uY2VwdHVhbGx5LCBpdCdzIGp1c3QgYSBtYXAgb2YgdW5pdHMgdG8gdGhlaXIgcXVhbnRpdGllcywgYWNjb21wYW5pZWQgYnkgc29tZSBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gYW5kIG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBwYXJzaW5nLCBpbnRlcnJvZ2F0aW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uIFRoZXkgY2FuIGJlIHVzZWQgb24gdGhlaXIgb3duIG9yIGluIGNvbmp1bmN0aW9uIHdpdGggb3RoZXIgTHV4b24gdHlwZXM7IGZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSB7QGxpbmsgRGF0ZVRpbWUjcGx1c30gdG8gYWRkIGEgRHVyYXRpb24gb2JqZWN0IHRvIGEgRGF0ZVRpbWUsIHByb2R1Y2luZyBhbm90aGVyIERhdGVUaW1lLlxuICpcbiAqIEhlcmUgaXMgYSBicmllZiBvdmVydmlldyBvZiBjb21tb25seSB1c2VkIG1ldGhvZHMgYW5kIGdldHRlcnMgaW4gRHVyYXRpb246XG4gKlxuICogKiAqKkNyZWF0aW9uKiogVG8gY3JlYXRlIGEgRHVyYXRpb24sIHVzZSB7QGxpbmsgRHVyYXRpb24jZnJvbU1pbGxpc30sIHtAbGluayBEdXJhdGlvbiNmcm9tT2JqZWN0fSwgb3Ige0BsaW5rIER1cmF0aW9uI2Zyb21JU099LlxuICogKiAqKlVuaXQgdmFsdWVzKiogU2VlIHRoZSB7QGxpbmsgRHVyYXRpb24jeWVhcnN9LCB7QGxpbmsgRHVyYXRpb24ubW9udGhzfSwge0BsaW5rIER1cmF0aW9uI3dlZWtzfSwge0BsaW5rIER1cmF0aW9uI2RheXN9LCB7QGxpbmsgRHVyYXRpb24jaG91cnN9LCB7QGxpbmsgRHVyYXRpb24jbWludXRlc30sIHtAbGluayBEdXJhdGlvbiNzZWNvbmRzfSwge0BsaW5rIER1cmF0aW9uI21pbGxpc2Vjb25kc30gYWNjZXNzb3JzLlxuICogKiAqKkNvbmZpZ3VyYXRpb24qKiBTZWUgIHtAbGluayBEdXJhdGlvbiNsb2NhbGV9IGFuZCB7QGxpbmsgRHVyYXRpb24jbnVtYmVyaW5nU3lzdGVtfSBhY2Nlc3NvcnMuXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKiBUbyBjcmVhdGUgbmV3IER1cmF0aW9ucyBvdXQgb2Ygb2xkIG9uZXMgdXNlIHtAbGluayBEdXJhdGlvbiNwbHVzfSwge0BsaW5rIER1cmF0aW9uI21pbnVzfSwge0BsaW5rIER1cmF0aW9uI25vcm1hbGl6ZX0sIHtAbGluayBEdXJhdGlvbiNzZXR9LCB7QGxpbmsgRHVyYXRpb24jcmVjb25maWd1cmV9LCB7QGxpbmsgRHVyYXRpb24jc2hpZnRUb30sIGFuZCB7QGxpbmsgRHVyYXRpb24jbmVnYXRlfS5cbiAqICogKipPdXRwdXQqKiBUbyBjb252ZXJ0IHRoZSBEdXJhdGlvbiBpbnRvIG90aGVyIHJlcHJlc2VudGF0aW9ucywgc2VlIHtAbGluayBEdXJhdGlvbiNhc30sIHtAbGluayBEdXJhdGlvbiN0b0lTT30sIHtAbGluayBEdXJhdGlvbiN0b0Zvcm1hdH0sIGFuZCB7QGxpbmsgRHVyYXRpb24jdG9KU09OfVxuICpcbiAqIFRoZXJlJ3MgYXJlIG1vcmUgbWV0aG9kcyBkb2N1bWVudGVkIGJlbG93LiBJbiBhZGRpdGlvbiwgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc3VidGxlciB0b3BpY3MgbGlrZSBpbnRlcm5hdGlvbmFsaXphdGlvbiBhbmQgdmFsaWRpdHksIHNlZSB0aGUgZXh0ZXJuYWwgZG9jdW1lbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHVyYXRpb24ge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGNvbnN0IGFjY3VyYXRlID0gY29uZmlnLmNvbnZlcnNpb25BY2N1cmFjeSA9PT0gXCJsb25ndGVybVwiIHx8IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmFsdWVzID0gY29uZmlnLnZhbHVlcztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxvYyA9IGNvbmZpZy5sb2MgfHwgTG9jYWxlLmNyZWF0ZSgpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY29udmVyc2lvbkFjY3VyYWN5ID0gYWNjdXJhdGUgPyBcImxvbmd0ZXJtXCIgOiBcImNhc3VhbFwiO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW52YWxpZCA9IGNvbmZpZy5pbnZhbGlkIHx8IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXRyaXggPSBhY2N1cmF0ZSA/IGFjY3VyYXRlTWF0cml4IDogY2FzdWFsTWF0cml4O1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNMdXhvbkR1cmF0aW9uID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgRHVyYXRpb24gZnJvbSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBvZiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21NaWxsaXMoY291bnQsIG9wdHMpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogY291bnQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFycycgYW5kICdob3VycycuXG4gICAqIElmIHRoaXMgb2JqZWN0IGlzIGVtcHR5IHRoZW4gYSB6ZXJvIG1pbGxpc2Vjb25kcyBkdXJhdGlvbiBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gY3JlYXRlIHRoZSBEYXRlVGltZSBmcm9tXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoueWVhcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5xdWFydGVyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1vbnRoc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouZGF5c1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmhvdXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWludXRlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnNlY29uZHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPVtdXSAtIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoaXMgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbU9iamVjdChvYmosIG9wdHMgPSB7fSkge1xuICAgIGlmIChvYmogPT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBEdXJhdGlvbi5mcm9tT2JqZWN0OiBhcmd1bWVudCBleHBlY3RlZCB0byBiZSBhbiBvYmplY3QsIGdvdCAke1xuICAgICAgICAgIG9iaiA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIG9ialxuICAgICAgICB9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IER1cmF0aW9uKHtcbiAgICAgIHZhbHVlczogbm9ybWFsaXplT2JqZWN0KG9iaiwgRHVyYXRpb24ubm9ybWFsaXplVW5pdCksXG4gICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpLFxuICAgICAgY29udmVyc2lvbkFjY3VyYWN5OiBvcHRzLmNvbnZlcnNpb25BY2N1cmFjeSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIER1cmF0aW9uTGlrZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3QgfCBudW1iZXIgfCBEdXJhdGlvbn0gZHVyYXRpb25MaWtlXG4gICAqIE9uZSBvZjpcbiAgICogLSBvYmplY3Qgd2l0aCBrZXlzIGxpa2UgJ3llYXJzJyBhbmQgJ2hvdXJzJy5cbiAgICogLSBudW1iZXIgcmVwcmVzZW50aW5nIG1pbGxpc2Vjb25kc1xuICAgKiAtIER1cmF0aW9uIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb25MaWtlKSB7XG4gICAgaWYgKGlzTnVtYmVyKGR1cmF0aW9uTGlrZSkpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tTWlsbGlzKGR1cmF0aW9uTGlrZSk7XG4gICAgfSBlbHNlIGlmIChEdXJhdGlvbi5pc0R1cmF0aW9uKGR1cmF0aW9uTGlrZSkpIHtcbiAgICAgIHJldHVybiBkdXJhdGlvbkxpa2U7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb25MaWtlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdChkdXJhdGlvbkxpa2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAgIGBVbmtub3duIGR1cmF0aW9uIGFyZ3VtZW50ICR7ZHVyYXRpb25MaWtlfSBvZiB0eXBlICR7dHlwZW9mIGR1cmF0aW9uTGlrZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGFuIElTTyA4NjAxIGR1cmF0aW9uIHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI0R1cmF0aW9uc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQM1k2TTFXNERUMTJIMzBNNVMnKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMywgbW9udGhzOiA2LCB3ZWVrczogMSwgZGF5czogNCwgaG91cnM6IDEyLCBtaW51dGVzOiAzMCwgc2Vjb25kczogNSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1BUMjNIJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDIzIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUDVZM00nKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogNSwgbW9udGhzOiAzIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzKSB7XG4gICAgY29uc3QgW3BhcnNlZF0gPSBwYXJzZUlTT0R1cmF0aW9uKHRleHQpO1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KHBhcnNlZCwgb3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGFuIElTTyA4NjAxIHRpbWUgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZXNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJzExOjIyOjMzLjQ0NCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMjIsIHNlY29uZHM6IDMzLCBtaWxsaXNlY29uZHM6IDQ0NCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCcxMTowMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCdUMTE6MDAnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnMTEwMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCdUMTEwMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21JU09UaW1lKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcGFyc2VkXSA9IHBhcnNlSVNPVGltZU9ubHkodGV4dCk7XG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QocGFyc2VkLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnZhbGlkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gc2ltcGxlIHN0cmluZyBvZiB3aHkgdGhpcyBkYXRldGltZSBpcyBpbnZhbGlkLiBTaG91bGQgbm90IGNvbnRhaW4gcGFyYW1ldGVycyBvciBhbnl0aGluZyBlbHNlIGRhdGEtZGVwZW5kZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwbGFuYXRpb249bnVsbF0gLSBsb25nZXIgZXhwbGFuYXRpb24sIG1heSBpbmNsdWRlIHBhcmFtZXRlcnMgYW5kIG90aGVyIHVzZWZ1bCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uID0gbnVsbCkge1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIER1cmF0aW9uIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IHJlYXNvbiBpbnN0YW5jZW9mIEludmFsaWQgPyByZWFzb24gOiBuZXcgSW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKTtcblxuICAgIGlmIChTZXR0aW5ncy50aHJvd09uSW52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREdXJhdGlvbkVycm9yKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IER1cmF0aW9uKHsgaW52YWxpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVVbml0KHVuaXQpIHtcbiAgICBjb25zdCBub3JtYWxpemVkID0ge1xuICAgICAgeWVhcjogXCJ5ZWFyc1wiLFxuICAgICAgeWVhcnM6IFwieWVhcnNcIixcbiAgICAgIHF1YXJ0ZXI6IFwicXVhcnRlcnNcIixcbiAgICAgIHF1YXJ0ZXJzOiBcInF1YXJ0ZXJzXCIsXG4gICAgICBtb250aDogXCJtb250aHNcIixcbiAgICAgIG1vbnRoczogXCJtb250aHNcIixcbiAgICAgIHdlZWs6IFwid2Vla3NcIixcbiAgICAgIHdlZWtzOiBcIndlZWtzXCIsXG4gICAgICBkYXk6IFwiZGF5c1wiLFxuICAgICAgZGF5czogXCJkYXlzXCIsXG4gICAgICBob3VyOiBcImhvdXJzXCIsXG4gICAgICBob3VyczogXCJob3Vyc1wiLFxuICAgICAgbWludXRlOiBcIm1pbnV0ZXNcIixcbiAgICAgIG1pbnV0ZXM6IFwibWludXRlc1wiLFxuICAgICAgc2Vjb25kOiBcInNlY29uZHNcIixcbiAgICAgIHNlY29uZHM6IFwic2Vjb25kc1wiLFxuICAgICAgbWlsbGlzZWNvbmQ6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBtaWxsaXNlY29uZHM6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgfVt1bml0ID8gdW5pdC50b0xvd2VyQ2FzZSgpIDogdW5pdF07XG5cbiAgICBpZiAoIW5vcm1hbGl6ZWQpIHRocm93IG5ldyBJbnZhbGlkVW5pdEVycm9yKHVuaXQpO1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGEgRHVyYXRpb24uIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0R1cmF0aW9uKG8pIHtcbiAgICByZXR1cm4gKG8gJiYgby5pc0x1eG9uRHVyYXRpb24pIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCAgdGhlIGxvY2FsZSBvZiBhIER1cmF0aW9uLCBzdWNoICdlbi1HQidcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBsb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLmxvY2FsZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXJpbmcgc3lzdGVtIG9mIGEgRHVyYXRpb24sIHN1Y2ggJ2JlbmcnLiBUaGUgbnVtYmVyaW5nIHN5c3RlbSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRHVyYXRpb25cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBudW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXQgc3RyaW5nLiBZb3UgbWF5IHVzZSB0aGVzZSB0b2tlbnM6XG4gICAqICogYFNgIGZvciBtaWxsaXNlY29uZHNcbiAgICogKiBgc2AgZm9yIHNlY29uZHNcbiAgICogKiBgbWAgZm9yIG1pbnV0ZXNcbiAgICogKiBgaGAgZm9yIGhvdXJzXG4gICAqICogYGRgIGZvciBkYXlzXG4gICAqICogYE1gIGZvciBtb250aHNcbiAgICogKiBgeWAgZm9yIHllYXJzXG4gICAqIE5vdGVzOlxuICAgKiAqIEFkZCBwYWRkaW5nIGJ5IHJlcGVhdGluZyB0aGUgdG9rZW4sIGUuZy4gXCJ5eVwiIHBhZHMgdGhlIHllYXJzIHRvIHR3byBkaWdpdHMsIFwiaGhoaFwiIHBhZHMgdGhlIGhvdXJzIG91dCB0byBmb3VyIGRpZ2l0c1xuICAgKiAqIFRoZSBkdXJhdGlvbiB3aWxsIGJlIGNvbnZlcnRlZCB0byB0aGUgc2V0IG9mIHVuaXRzIGluIHRoZSBmb3JtYXQgc3RyaW5nIHVzaW5nIHtAbGluayBEdXJhdGlvbiNzaGlmdFRvfSBhbmQgdGhlIER1cmF0aW9ucydzIGNvbnZlcnNpb24gYWNjdXJhY3kgc2V0dGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmZsb29yPXRydWVdIC0gZmxvb3IgbnVtZXJpY2FsIHZhbHVlc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5IGQgc1wiKSAvLz0+IFwiMSA2IDJcIlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5eSBkZCBzc3NcIikgLy89PiBcIjAxIDA2IDAwMlwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcIk0gU1wiKSAvLz0+IFwiMTIgNTE4NDAyMDAwXCJcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZm10LCBvcHRzID0ge30pIHtcbiAgICAvLyByZXZlcnNlLWNvbXBhdCBzaW5jZSAxLjI7IHdlIGFsd2F5cyByb3VuZCBkb3duIG5vdywgbmV2ZXIgdXAsIGFuZCB3ZSBkbyBpdCBieSBkZWZhdWx0XG4gICAgY29uc3QgZm10T3B0cyA9IHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBmbG9vcjogb3B0cy5yb3VuZCAhPT0gZmFsc2UgJiYgb3B0cy5mbG9vciAhPT0gZmFsc2UsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MsIGZtdE9wdHMpLmZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyh0aGlzLCBmbXQpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIER1cmF0aW9uIHdpdGggYWxsIHVuaXRzIGluY2x1ZGVkXG4gICAqIFRvIG1vZGlmeSBpdHMgYmVoYXZpb3IgdXNlIHRoZSBgbGlzdFN0eWxlYCBhbmQgYW55IEludGwuTnVtYmVyRm9ybWF0IG9wdGlvbiwgdGhvdWdoIGB1bml0RGlzcGxheWAgaXMgZXNwZWNpYWxseSByZWxldmFudC4gU2VlIHtAbGluayBJbnRsLk51bWJlckZvcm1hdH0uXG4gICAqIEBwYXJhbSBvcHRzIC0gT24gb3B0aW9uIG9iamVjdCB0byBvdmVycmlkZSB0aGUgZm9ybWF0dGluZy4gQWNjZXB0cyB0aGUgc2FtZSBrZXlzIGFzIHRoZSBvcHRpb25zIHBhcmFtZXRlciBvZiB0aGUgbmF0aXZlIGBJbnQuTnVtYmVyRm9ybWF0YCBjb25zdHJ1Y3RvciwgYXMgd2VsbCBhcyBgbGlzdFN0eWxlYC5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogdmFyIGR1ciA9IER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiAxLCBob3VyczogNSwgbWludXRlczogNiB9KVxuICAgKiBkdXIudG9IdW1hbigpIC8vPT4gJzEgZGF5LCA1IGhvdXJzLCA2IG1pbnV0ZXMnXG4gICAqIGR1ci50b0h1bWFuKHsgbGlzdFN0eWxlOiBcImxvbmdcIiB9KSAvLz0+ICcxIGRheSwgNSBob3VycywgYW5kIDYgbWludXRlcydcbiAgICogZHVyLnRvSHVtYW4oeyB1bml0RGlzcGxheTogXCJzaG9ydFwiIH0pIC8vPT4gJzEgZGF5LCA1IGhyLCA2IG1pbidcbiAgICogYGBgXG4gICAqL1xuICB0b0h1bWFuKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGwgPSBvcmRlcmVkVW5pdHNcbiAgICAgIC5tYXAoKHVuaXQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy52YWx1ZXNbdW5pdF07XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9jXG4gICAgICAgICAgLm51bWJlckZvcm1hdHRlcih7IHN0eWxlOiBcInVuaXRcIiwgdW5pdERpc3BsYXk6IFwibG9uZ1wiLCAuLi5vcHRzLCB1bml0OiB1bml0LnNsaWNlKDAsIC0xKSB9KVxuICAgICAgICAgIC5mb3JtYXQodmFsKTtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKChuKSA9PiBuKTtcblxuICAgIHJldHVybiB0aGlzLmxvY1xuICAgICAgLmxpc3RGb3JtYXR0ZXIoeyB0eXBlOiBcImNvbmp1bmN0aW9uXCIsIHN0eWxlOiBvcHRzLmxpc3RTdHlsZSB8fCBcIm5hcnJvd1wiLCAuLi5vcHRzIH0pXG4gICAgICAuZm9ybWF0KGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIHRoaXMgRHVyYXRpb24ncyB2YWx1ZXMuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvT2JqZWN0KCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4ge307XG4gICAgcmV0dXJuIHsgLi4udGhpcy52YWx1ZXMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbi5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNEdXJhdGlvbnNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAzLCBzZWNvbmRzOiA0NSB9KS50b0lTTygpIC8vPT4gJ1AzWVQ0NVMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDQsIHNlY29uZHM6IDQ1IH0pLnRvSVNPKCkgLy89PiAnUDRNVDQ1UydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogNSB9KS50b0lTTygpIC8vPT4gJ1A1TSdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbnV0ZXM6IDUgfSkudG9JU08oKSAvLz0+ICdQVDVNJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWlsbGlzZWNvbmRzOiA2IH0pLnRvSVNPKCkgLy89PiAnUFQwLjAwNlMnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPKCkge1xuICAgIC8vIHdlIGNvdWxkIHVzZSB0aGUgZm9ybWF0dGVyLCBidXQgdGhpcyBpcyBhbiBlYXNpZXIgd2F5IHRvIGdldCB0aGUgbWluaW11bSBzdHJpbmdcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG5cbiAgICBsZXQgcyA9IFwiUFwiO1xuICAgIGlmICh0aGlzLnllYXJzICE9PSAwKSBzICs9IHRoaXMueWVhcnMgKyBcIllcIjtcbiAgICBpZiAodGhpcy5tb250aHMgIT09IDAgfHwgdGhpcy5xdWFydGVycyAhPT0gMCkgcyArPSB0aGlzLm1vbnRocyArIHRoaXMucXVhcnRlcnMgKiAzICsgXCJNXCI7XG4gICAgaWYgKHRoaXMud2Vla3MgIT09IDApIHMgKz0gdGhpcy53ZWVrcyArIFwiV1wiO1xuICAgIGlmICh0aGlzLmRheXMgIT09IDApIHMgKz0gdGhpcy5kYXlzICsgXCJEXCI7XG4gICAgaWYgKHRoaXMuaG91cnMgIT09IDAgfHwgdGhpcy5taW51dGVzICE9PSAwIHx8IHRoaXMuc2Vjb25kcyAhPT0gMCB8fCB0aGlzLm1pbGxpc2Vjb25kcyAhPT0gMClcbiAgICAgIHMgKz0gXCJUXCI7XG4gICAgaWYgKHRoaXMuaG91cnMgIT09IDApIHMgKz0gdGhpcy5ob3VycyArIFwiSFwiO1xuICAgIGlmICh0aGlzLm1pbnV0ZXMgIT09IDApIHMgKz0gdGhpcy5taW51dGVzICsgXCJNXCI7XG4gICAgaWYgKHRoaXMuc2Vjb25kcyAhPT0gMCB8fCB0aGlzLm1pbGxpc2Vjb25kcyAhPT0gMClcbiAgICAgIC8vIHRoaXMgd2lsbCBoYW5kbGUgXCJmbG9hdGluZyBwb2ludCBtYWRuZXNzXCIgYnkgcmVtb3ZpbmcgZXh0cmEgZGVjaW1hbCBwbGFjZXNcbiAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU4ODAwNC9pcy1mbG9hdGluZy1wb2ludC1tYXRoLWJyb2tlblxuICAgICAgcyArPSByb3VuZFRvKHRoaXMuc2Vjb25kcyArIHRoaXMubWlsbGlzZWNvbmRzIC8gMTAwMCwgMykgKyBcIlNcIjtcbiAgICBpZiAocyA9PT0gXCJQXCIpIHMgKz0gXCJUMFNcIjtcbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiwgZm9ybWF0dGVkIGFzIGEgdGltZSBvZiBkYXkuXG4gICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIGR1cmF0aW9uIGlzIGludmFsaWQsIG5lZ2F0aXZlLCBvciBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMjQgaG91cnMuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NNaWxsaXNlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzU2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIHNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVQcmVmaXg9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgYFRgIHByZWZpeFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoKSAvLz0+ICcxMTowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgc3VwcHJlc3NNaWxsaXNlY29uZHM6IHRydWUgfSkgLy89PiAnMTE6MDA6MDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgc3VwcHJlc3NTZWNvbmRzOiB0cnVlIH0pIC8vPT4gJzExOjAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IGluY2x1ZGVQcmVmaXg6IHRydWUgfSkgLy89PiAnVDExOjAwOjAwLjAwMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMTEwMDAwLjAwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09UaW1lKG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IG1pbGxpcyA9IHRoaXMudG9NaWxsaXMoKTtcbiAgICBpZiAobWlsbGlzIDwgMCB8fCBtaWxsaXMgPj0gODY0MDAwMDApIHJldHVybiBudWxsO1xuXG4gICAgb3B0cyA9IHtcbiAgICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzOiBmYWxzZSxcbiAgICAgIHN1cHByZXNzU2Vjb25kczogZmFsc2UsXG4gICAgICBpbmNsdWRlUHJlZml4OiBmYWxzZSxcbiAgICAgIGZvcm1hdDogXCJleHRlbmRlZFwiLFxuICAgICAgLi4ub3B0cyxcbiAgICB9O1xuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnNoaWZ0VG8oXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCIpO1xuXG4gICAgbGV0IGZtdCA9IG9wdHMuZm9ybWF0ID09PSBcImJhc2ljXCIgPyBcImhobW1cIiA6IFwiaGg6bW1cIjtcblxuICAgIGlmICghb3B0cy5zdXBwcmVzc1NlY29uZHMgfHwgdmFsdWUuc2Vjb25kcyAhPT0gMCB8fCB2YWx1ZS5taWxsaXNlY29uZHMgIT09IDApIHtcbiAgICAgIGZtdCArPSBvcHRzLmZvcm1hdCA9PT0gXCJiYXNpY1wiID8gXCJzc1wiIDogXCI6c3NcIjtcbiAgICAgIGlmICghb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcyB8fCB2YWx1ZS5taWxsaXNlY29uZHMgIT09IDApIHtcbiAgICAgICAgZm10ICs9IFwiLlNTU1wiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzdHIgPSB2YWx1ZS50b0Zvcm1hdChmbXQpO1xuXG4gICAgaWYgKG9wdHMuaW5jbHVkZVByZWZpeCkge1xuICAgICAgc3RyID0gXCJUXCIgKyBzdHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBKU09OLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JU08oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRHVyYXRpb24gYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBkZWJ1Z2dpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBtaWxsaXNlY29uZHMgdmFsdWUgb2YgdGhpcyBEdXJhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9NaWxsaXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXMoXCJtaWxsaXNlY29uZHNcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBtaWxsaXNlY29uZHMgdmFsdWUgb2YgdGhpcyBEdXJhdGlvbi4gQWxpYXMgb2Yge0BsaW5rIHRvTWlsbGlzfVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvTWlsbGlzKCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIER1cmF0aW9uIGxvbmdlciBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIGFkZC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBwbHVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbiksXG4gICAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoY29uc3QgayBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShkdXIudmFsdWVzLCBrKSB8fCBoYXNPd25Qcm9wZXJ0eSh0aGlzLnZhbHVlcywgaykpIHtcbiAgICAgICAgcmVzdWx0W2tdID0gZHVyLmdldChrKSArIHRoaXMuZ2V0KGspO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogcmVzdWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyBEdXJhdGlvbiBzaG9ydGVyIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbWludXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5wbHVzKGR1ci5uZWdhdGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogU2NhbGUgdGhpcyBEdXJhdGlvbiBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdW5pdC4gQXJpdHkgaXMgMSBvciAyOiB0aGUgdmFsdWUgb2YgdGhlIHVuaXQgYW5kLCBvcHRpb25hbGx5LCB0aGUgdW5pdCBuYW1lLiBNdXN0IHJldHVybiBhIG51bWJlci5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBtaW51dGVzOiAzMCB9KS5tYXBVbml0cyh4ID0+IHggKiAyKSAvLz0+IHsgaG91cnM6IDIsIG1pbnV0ZXM6IDYwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBtaW51dGVzOiAzMCB9KS5tYXBVbml0cygoeCwgdSkgPT4gdSA9PT0gXCJob3VyXCIgPyB4ICogMiA6IHgpIC8vPT4geyBob3VyczogMiwgbWludXRlczogMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG1hcFVuaXRzKGZuKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykpIHtcbiAgICAgIHJlc3VsdFtrXSA9IGFzTnVtYmVyKGZuKHRoaXMudmFsdWVzW2tdLCBrKSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogcmVzdWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlJyBvciAnZGF5J1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgneWVhcnMnKSAvLz0+IDJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ21vbnRocycpIC8vPT4gMFxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLmdldCgnZGF5cycpIC8vPT4gM1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQodW5pdCkge1xuICAgIHJldHVybiB0aGlzW0R1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodW5pdCldO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdW5pdHMuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gYSBtYXBwaW5nIG9mIHVuaXRzIHRvIG51bWJlcnNcbiAgICogQGV4YW1wbGUgZHVyLnNldCh7IHllYXJzOiAyMDE3IH0pXG4gICAqIEBleGFtcGxlIGR1ci5zZXQoeyBob3VyczogOCwgbWludXRlczogMzAgfSlcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzZXQodmFsdWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgbWl4ZWQgPSB7IC4uLnRoaXMudmFsdWVzLCAuLi5ub3JtYWxpemVPYmplY3QodmFsdWVzLCBEdXJhdGlvbi5ub3JtYWxpemVVbml0KSB9O1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogbWl4ZWQgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlIGFuZC9vciBudW1iZXJpbmdTeXN0ZW0uICBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBleGFtcGxlIGR1ci5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogJ2VuLUdCJyB9KVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHJlY29uZmlndXJlKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIGNvbnZlcnNpb25BY2N1cmFjeSB9ID0ge30pIHtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmxvYy5jbG9uZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtIH0pLFxuICAgICAgb3B0cyA9IHsgbG9jIH07XG5cbiAgICBpZiAoY29udmVyc2lvbkFjY3VyYWN5KSB7XG4gICAgICBvcHRzLmNvbnZlcnNpb25BY2N1cmFjeSA9IGNvbnZlcnNpb25BY2N1cmFjeTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmUodGhpcywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGR1cmF0aW9uIGluIHRoZSBzcGVjaWZpZWQgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlcycgb3IgJ2RheXMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAxfSkuYXMoJ2RheXMnKSAvLz0+IDM2NVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMX0pLmFzKCdtb250aHMnKSAvLz0+IDEyXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe2hvdXJzOiA2MH0pLmFzKCdkYXlzJykgLy89PiAyLjVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgYXModW5pdCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnNoaWZ0VG8odW5pdCkuZ2V0KHVuaXQpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZHVjZSB0aGlzIER1cmF0aW9uIHRvIGl0cyBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gaW4gaXRzIGN1cnJlbnQgdW5pdHMuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMiwgZGF5czogNTAwMCB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMTUsIGRheXM6IDI1NSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTIsIG1pbnV0ZXM6IC00NSB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDE1IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBub3JtYWxpemUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHZhbHMgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgbm9ybWFsaXplVmFsdWVzKHRoaXMubWF0cml4LCB2YWxzKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHZhbHMgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGlzIER1cmF0aW9uIGludG8gaXRzIHJlcHJlc2VudGF0aW9uIGluIGEgZGlmZmVyZW50IHNldCBvZiB1bml0cy5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBzZWNvbmRzOiAzMCB9KS5zaGlmdFRvKCdtaW51dGVzJywgJ21pbGxpc2Vjb25kcycpLnRvT2JqZWN0KCkgLy89PiB7IG1pbnV0ZXM6IDYwLCBtaWxsaXNlY29uZHM6IDMwMDAwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzaGlmdFRvKC4uLnVuaXRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKHVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdW5pdHMgPSB1bml0cy5tYXAoKHUpID0+IER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodSkpO1xuXG4gICAgY29uc3QgYnVpbHQgPSB7fSxcbiAgICAgIGFjY3VtdWxhdGVkID0ge30sXG4gICAgICB2YWxzID0gdGhpcy50b09iamVjdCgpO1xuICAgIGxldCBsYXN0VW5pdDtcblxuICAgIGZvciAoY29uc3QgayBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmICh1bml0cy5pbmRleE9mKGspID49IDApIHtcbiAgICAgICAgbGFzdFVuaXQgPSBrO1xuXG4gICAgICAgIGxldCBvd24gPSAwO1xuXG4gICAgICAgIC8vIGFueXRoaW5nIHdlIGhhdmVuJ3QgYm9pbGVkIGRvd24geWV0IHNob3VsZCBnZXQgYm9pbGVkIHRvIHRoaXMgdW5pdFxuICAgICAgICBmb3IgKGNvbnN0IGFrIGluIGFjY3VtdWxhdGVkKSB7XG4gICAgICAgICAgb3duICs9IHRoaXMubWF0cml4W2FrXVtrXSAqIGFjY3VtdWxhdGVkW2FrXTtcbiAgICAgICAgICBhY2N1bXVsYXRlZFtha10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGx1cyBhbnl0aGluZyB0aGF0J3MgYWxyZWFkeSBpbiB0aGlzIHVuaXRcbiAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHNba10pKSB7XG4gICAgICAgICAgb3duICs9IHZhbHNba107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpID0gTWF0aC50cnVuYyhvd24pO1xuICAgICAgICBidWlsdFtrXSA9IGk7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gKG93biAqIDEwMDAgLSBpICogMTAwMCkgLyAxMDAwO1xuXG4gICAgICAgIC8vIHBsdXMgYW55dGhpbmcgZnVydGhlciBkb3duIHRoZSBjaGFpbiB0aGF0IHNob3VsZCBiZSByb2xsZWQgdXAgaW4gdG8gdGhpc1xuICAgICAgICBmb3IgKGNvbnN0IGRvd24gaW4gdmFscykge1xuICAgICAgICAgIGlmIChvcmRlcmVkVW5pdHMuaW5kZXhPZihkb3duKSA+IG9yZGVyZWRVbml0cy5pbmRleE9mKGspKSB7XG4gICAgICAgICAgICBjb252ZXJ0KHRoaXMubWF0cml4LCB2YWxzLCBkb3duLCBidWlsdCwgayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSwga2VlcCBpdCBpbiB0aGUgd2luZ3MgdG8gYm9pbCBpdCBsYXRlclxuICAgICAgfSBlbHNlIGlmIChpc051bWJlcih2YWxzW2tdKSkge1xuICAgICAgICBhY2N1bXVsYXRlZFtrXSA9IHZhbHNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYW55dGhpbmcgbGVmdG92ZXIgYmVjb21lcyB0aGUgZGVjaW1hbCBmb3IgdGhlIGxhc3QgdW5pdFxuICAgIC8vIGxhc3RVbml0IG11c3QgYmUgZGVmaW5lZCBzaW5jZSB1bml0cyBpcyBub3QgZW1wdHlcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhY2N1bXVsYXRlZCkge1xuICAgICAgaWYgKGFjY3VtdWxhdGVkW2tleV0gIT09IDApIHtcbiAgICAgICAgYnVpbHRbbGFzdFVuaXRdICs9XG4gICAgICAgICAga2V5ID09PSBsYXN0VW5pdCA/IGFjY3VtdWxhdGVkW2tleV0gOiBhY2N1bXVsYXRlZFtrZXldIC8gdGhpcy5tYXRyaXhbbGFzdFVuaXRdW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiBidWlsdCB9LCB0cnVlKS5ub3JtYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5lZ2F0aXZlIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgc2Vjb25kczogMzAgfSkubmVnYXRlKCkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IC0xLCBzZWNvbmRzOiAtMzAgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG5lZ2F0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgbmVnYXRlZCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykpIHtcbiAgICAgIG5lZ2F0ZWRba10gPSAtdGhpcy52YWx1ZXNba107XG4gICAgfVxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogbmVnYXRlZCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHllYXJzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHllYXJzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy55ZWFycyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcXVhcnRlcnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgcXVhcnRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnF1YXJ0ZXJzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtb250aHMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbW9udGhzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5tb250aHMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWtzXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLndlZWtzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXlzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLmRheXMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhvdXJzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhvdXJzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5ob3VycyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludXRlcy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaW51dGVzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5taW51dGVzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzZWNvbmRzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuc2Vjb25kcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWlsbGlzZWNvbmRzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWlsbGlzZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5taWxsaXNlY29uZHMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIER1cmF0aW9uIGlzIGludmFsaWQuIEludmFsaWQgZHVyYXRpb25zIGFyZSByZXR1cm5lZCBieSBkaWZmIG9wZXJhdGlvbnNcbiAgICogb24gaW52YWxpZCBEYXRlVGltZXMgb3IgSW50ZXJ2YWxzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBEdXJhdGlvbiBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRHVyYXRpb24gaXMgdmFsaWRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgRHVyYXRpb24gYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIER1cmF0aW9uIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEVxdWFsaXR5IGNoZWNrXG4gICAqIFR3byBEdXJhdGlvbnMgYXJlIGVxdWFsIGlmZiB0aGV5IGhhdmUgdGhlIHNhbWUgdW5pdHMgYW5kIHRoZSBzYW1lIHZhbHVlcyBmb3IgZWFjaCB1bml0LlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubG9jLmVxdWFscyhvdGhlci5sb2MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXEodjEsIHYyKSB7XG4gICAgICAvLyBDb25zaWRlciAwIGFuZCB1bmRlZmluZWQgYXMgZXF1YWxcbiAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkIHx8IHYxID09PSAwKSByZXR1cm4gdjIgPT09IHVuZGVmaW5lZCB8fCB2MiA9PT0gMDtcbiAgICAgIHJldHVybiB2MSA9PT0gdjI7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB1IG9mIG9yZGVyZWRVbml0cykge1xuICAgICAgaWYgKCFlcSh0aGlzLnZhbHVlc1t1XSwgb3RoZXIudmFsdWVzW3VdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGVUaW1lLCB7IGZyaWVuZGx5RGF0ZVRpbWUgfSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBJbnZhbGlkSW50ZXJ2YWxFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgSW50ZXJ2YWxcIjtcblxuLy8gY2hlY2tzIGlmIHRoZSBzdGFydCBpcyBlcXVhbCB0byBvciBiZWZvcmUgdGhlIGVuZFxuZnVuY3Rpb24gdmFsaWRhdGVTdGFydEVuZChzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQgfHwgIXN0YXJ0LmlzVmFsaWQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcIm1pc3Npbmcgb3IgaW52YWxpZCBzdGFydFwiKTtcbiAgfSBlbHNlIGlmICghZW5kIHx8ICFlbmQuaXNWYWxpZCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwibWlzc2luZyBvciBpbnZhbGlkIGVuZFwiKTtcbiAgfSBlbHNlIGlmIChlbmQgPCBzdGFydCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFxuICAgICAgXCJlbmQgYmVmb3JlIHN0YXJ0XCIsXG4gICAgICBgVGhlIGVuZCBvZiBhbiBpbnRlcnZhbCBtdXN0IGJlIGFmdGVyIGl0cyBzdGFydCwgYnV0IHlvdSBoYWQgc3RhcnQ9JHtzdGFydC50b0lTTygpfSBhbmQgZW5kPSR7ZW5kLnRvSVNPKCl9YFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBJbnRlcnZhbCBvYmplY3QgcmVwcmVzZW50cyBhIGhhbGYtb3BlbiBpbnRlcnZhbCBvZiB0aW1lLCB3aGVyZSBlYWNoIGVuZHBvaW50IGlzIGEge0BsaW5rIERhdGVUaW1lfS4gQ29uY2VwdHVhbGx5LCBpdCdzIGEgY29udGFpbmVyIGZvciB0aG9zZSB0d28gZW5kcG9pbnRzLCBhY2NvbXBhbmllZCBieSBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgY29tcGFyaW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgbWV0aG9kcyBhbmQgZ2V0dGVycyBpbiBJbnRlcnZhbDpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKiBUbyBjcmVhdGUgYW4gSW50ZXJ2YWwsIHVzZSB7QGxpbmsgSW50ZXJ2YWwjZnJvbURhdGVUaW1lc30sIHtAbGluayBJbnRlcnZhbCNhZnRlcn0sIHtAbGluayBJbnRlcnZhbCNiZWZvcmV9LCBvciB7QGxpbmsgSW50ZXJ2YWwjZnJvbUlTT30uXG4gKiAqICoqQWNjZXNzb3JzKiogVXNlIHtAbGluayBJbnRlcnZhbCNzdGFydH0gYW5kIHtAbGluayBJbnRlcnZhbCNlbmR9IHRvIGdldCB0aGUgc3RhcnQgYW5kIGVuZC5cbiAqICogKipJbnRlcnJvZ2F0aW9uKiogVG8gYW5hbHl6ZSB0aGUgSW50ZXJ2YWwsIHVzZSB7QGxpbmsgSW50ZXJ2YWwjY291bnR9LCB7QGxpbmsgSW50ZXJ2YWwjbGVuZ3RofSwge0BsaW5rIEludGVydmFsI2hhc1NhbWV9LCB7QGxpbmsgSW50ZXJ2YWwjY29udGFpbnN9LCB7QGxpbmsgSW50ZXJ2YWwjaXNBZnRlcn0sIG9yIHtAbGluayBJbnRlcnZhbCNpc0JlZm9yZX0uXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKiBUbyBjcmVhdGUgb3RoZXIgSW50ZXJ2YWxzIG91dCBvZiB0aGlzIG9uZSwgdXNlIHtAbGluayBJbnRlcnZhbCNzZXR9LCB7QGxpbmsgSW50ZXJ2YWwjc3BsaXRBdH0sIHtAbGluayBJbnRlcnZhbCNzcGxpdEJ5fSwge0BsaW5rIEludGVydmFsI2RpdmlkZUVxdWFsbHl9LCB7QGxpbmsgSW50ZXJ2YWwjbWVyZ2V9LCB7QGxpbmsgSW50ZXJ2YWwjeG9yfSwge0BsaW5rIEludGVydmFsI3VuaW9ufSwge0BsaW5rIEludGVydmFsI2ludGVyc2VjdGlvbn0sIG9yIHtAbGluayBJbnRlcnZhbCNkaWZmZXJlbmNlfS5cbiAqICogKipDb21wYXJpc29uKiogVG8gY29tcGFyZSB0aGlzIEludGVydmFsIHRvIGFub3RoZXIgb25lLCB1c2Uge0BsaW5rIEludGVydmFsI2VxdWFsc30sIHtAbGluayBJbnRlcnZhbCNvdmVybGFwc30sIHtAbGluayBJbnRlcnZhbCNhYnV0c1N0YXJ0fSwge0BsaW5rIEludGVydmFsI2FidXRzRW5kfSwge0BsaW5rIEludGVydmFsI2VuZ3VsZnN9XG4gKiAqICoqT3V0cHV0KiogVG8gY29udmVydCB0aGUgSW50ZXJ2YWwgaW50byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHNlZSB7QGxpbmsgSW50ZXJ2YWwjdG9TdHJpbmd9LCB7QGxpbmsgSW50ZXJ2YWwjdG9JU099LCB7QGxpbmsgSW50ZXJ2YWwjdG9JU09EYXRlfSwge0BsaW5rIEludGVydmFsI3RvSVNPVGltZX0sIHtAbGluayBJbnRlcnZhbCN0b0Zvcm1hdH0sIGFuZCB7QGxpbmsgSW50ZXJ2YWwjdG9EdXJhdGlvbn0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVydmFsIHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnMgPSBjb25maWcuc3RhcnQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lID0gY29uZmlnLmVuZDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBjb25maWcuaW52YWxpZCB8fCBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNMdXhvbkludGVydmFsID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgSW50ZXJ2YWwgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbiA9IG51bGwpIHtcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibmVlZCB0byBzcGVjaWZ5IGEgcmVhc29uIHRoZSBJbnRlcnZhbCBpcyBpbnZhbGlkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSW50ZXJ2YWxFcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh7IGludmFsaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGEgc3RhcnQgRGF0ZVRpbWUgYW5kIGFuIGVuZCBEYXRlVGltZS4gSW5jbHVzaXZlIG9mIHRoZSBzdGFydCBidXQgbm90IHRoZSBlbmQuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IHN0YXJ0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IGVuZFxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBmcm9tRGF0ZVRpbWVzKHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBidWlsdFN0YXJ0ID0gZnJpZW5kbHlEYXRlVGltZShzdGFydCksXG4gICAgICBidWlsdEVuZCA9IGZyaWVuZGx5RGF0ZVRpbWUoZW5kKTtcblxuICAgIGNvbnN0IHZhbGlkYXRlRXJyb3IgPSB2YWxpZGF0ZVN0YXJ0RW5kKGJ1aWx0U3RhcnQsIGJ1aWx0RW5kKTtcblxuICAgIGlmICh2YWxpZGF0ZUVycm9yID09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWwoe1xuICAgICAgICBzdGFydDogYnVpbHRTdGFydCxcbiAgICAgICAgZW5kOiBidWlsdEVuZCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGVFcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYSBzdGFydCBEYXRlVGltZSBhbmQgYSBEdXJhdGlvbiB0byBleHRlbmQgdG8uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IHN0YXJ0XG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSB0aGUgbGVuZ3RoIG9mIHRoZSBJbnRlcnZhbC5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgYWZ0ZXIoc3RhcnQsIGR1cmF0aW9uKSB7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbiksXG4gICAgICBkdCA9IGZyaWVuZGx5RGF0ZVRpbWUoc3RhcnQpO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0LCBkdC5wbHVzKGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGFuIGVuZCBEYXRlVGltZSBhbmQgYSBEdXJhdGlvbiB0byBleHRlbmQgYmFja3dhcmRzIHRvLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfERhdGV8T2JqZWN0fSBlbmRcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsLlxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBiZWZvcmUoZW5kLCBkdXJhdGlvbikge1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLFxuICAgICAgZHQgPSBmcmllbmRseURhdGVUaW1lKGVuZCk7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQubWludXMoZHVyKSwgZHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGFuIElTTyA4NjAxIHN0cmluZy5cbiAgICogQWNjZXB0cyBgPHN0YXJ0Pi88ZW5kPmAsIGA8c3RhcnQ+LzxkdXJhdGlvbj5gLCBhbmQgYDxkdXJhdGlvbj4vPGVuZD5gIGZvcm1hdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIElTTyBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIG9wdGlvbnMgdG8gcGFzcyB7QGxpbmsgRGF0ZVRpbWUjZnJvbUlTT30gYW5kIG9wdGlvbmFsbHkge0BsaW5rIER1cmF0aW9uI2Zyb21JU099XG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzKSB7XG4gICAgY29uc3QgW3MsIGVdID0gKHRleHQgfHwgXCJcIikuc3BsaXQoXCIvXCIsIDIpO1xuICAgIGlmIChzICYmIGUpIHtcbiAgICAgIGxldCBzdGFydCwgc3RhcnRJc1ZhbGlkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhcnQgPSBEYXRlVGltZS5mcm9tSVNPKHMsIG9wdHMpO1xuICAgICAgICBzdGFydElzVmFsaWQgPSBzdGFydC5pc1ZhbGlkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzdGFydElzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGVuZCwgZW5kSXNWYWxpZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVuZCA9IERhdGVUaW1lLmZyb21JU08oZSwgb3B0cyk7XG4gICAgICAgIGVuZElzVmFsaWQgPSBlbmQuaXNWYWxpZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZW5kSXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRJc1ZhbGlkICYmIGVuZElzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQsIGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydElzVmFsaWQpIHtcbiAgICAgICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUlTTyhlLCBvcHRzKTtcbiAgICAgICAgaWYgKGR1ci5pc1ZhbGlkKSB7XG4gICAgICAgICAgcmV0dXJuIEludGVydmFsLmFmdGVyKHN0YXJ0LCBkdXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZElzVmFsaWQpIHtcbiAgICAgICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUlTTyhzLCBvcHRzKTtcbiAgICAgICAgaWYgKGR1ci5pc1ZhbGlkKSB7XG4gICAgICAgICAgcmV0dXJuIEludGVydmFsLmJlZm9yZShlbmQsIGR1cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGFuIEludGVydmFsLiBXb3JrcyBhY3Jvc3MgY29udGV4dCBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNJbnRlcnZhbChvKSB7XG4gICAgcmV0dXJuIChvICYmIG8uaXNMdXhvbkludGVydmFsKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGFydCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHR5cGUge0RhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IHN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnMgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVuZCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHR5cGUge0RhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5lIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhdCBsZWFzdCBpdHMgc3RhcnQsIG1lYW5pbmcgdGhhdCB0aGUgSW50ZXJ2YWwgaXNuJ3QgJ2JhY2t3YXJkcycuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZFJlYXNvbiA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBJbnRlcnZhbCBpcyBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBJbnRlcnZhbCBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgSW50ZXJ2YWwgYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIEludGVydmFsIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwgaW4gdGhlIHNwZWNpZmllZCB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byByZXR1cm4gdGhlIGxlbmd0aCBpbi5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgbGVuZ3RoKHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudG9EdXJhdGlvbiguLi5bdW5pdF0pLmdldCh1bml0KSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb3VudCBvZiBtaW51dGVzLCBob3VycywgZGF5cywgbW9udGhzLCBvciB5ZWFycyBpbmNsdWRlZCBpbiB0aGUgSW50ZXJ2YWwsIGV2ZW4gaW4gcGFydC5cbiAgICogVW5saWtlIHtAbGluayBJbnRlcnZhbCNsZW5ndGh9IHRoaXMgY291bnRzIHNlY3Rpb25zIG9mIHRoZSBjYWxlbmRhciwgbm90IHBlcmlvZHMgb2YgdGltZSwgZS5nLiBzcGVjaWZ5aW5nICdkYXknXG4gICAqIGFza3MgJ3doYXQgZGF0ZXMgYXJlIGluY2x1ZGVkIGluIHRoaXMgaW50ZXJ2YWw/Jywgbm90ICdob3cgbWFueSBkYXlzIGxvbmcgaXMgdGhpcyBpbnRlcnZhbD8nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdD0nbWlsbGlzZWNvbmRzJ10gLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjb3VudCh1bml0ID0gXCJtaWxsaXNlY29uZHNcIikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gTmFOO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGFydC5zdGFydE9mKHVuaXQpLFxuICAgICAgZW5kID0gdGhpcy5lbmQuc3RhcnRPZih1bml0KTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihlbmQuZGlmZihzdGFydCwgdW5pdCkuZ2V0KHVuaXQpKSArIDE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBzdGFydCBhbmQgZW5kIGFyZSBib3RoIGluIHRoZSBzYW1lIHVuaXQgb2YgdGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY2hlY2sgc2FtZW5lc3Mgb25cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1NhbWUodW5pdCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmlzRW1wdHkoKSB8fCB0aGlzLmUubWludXMoMSkuaGFzU2FtZSh0aGlzLnMsIHVuaXQpIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBoYXMgdGhlIHNhbWUgc3RhcnQgYW5kIGVuZCBEYXRlVGltZXMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnMudmFsdWVPZigpID09PSB0aGlzLmUudmFsdWVPZigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBzdGFydCBpcyBhZnRlciB0aGUgc3BlY2lmaWVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBkYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNBZnRlcihkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA+IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBlbmQgaXMgYmVmb3JlIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0JlZm9yZShkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuZSA8PSBkYXRlVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWlucyhkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA8PSBkYXRlVGltZSAmJiB0aGlzLmUgPiBkYXRlVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldHNcIiB0aGUgc3RhcnQgYW5kL29yIGVuZCBkYXRlcy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gdGhlIHZhbHVlcyB0byBzZXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gdmFsdWVzLnN0YXJ0IC0gdGhlIHN0YXJ0aW5nIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IHZhbHVlcy5lbmQgLSB0aGUgZW5kaW5nIERhdGVUaW1lXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc2V0KHsgc3RhcnQsIGVuZCB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQgfHwgdGhpcy5zLCBlbmQgfHwgdGhpcy5lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB0aGlzIEludGVydmFsIGF0IGVhY2ggb2YgdGhlIHNwZWNpZmllZCBEYXRlVGltZXNcbiAgICogQHBhcmFtIHsuLi5EYXRlVGltZX0gZGF0ZVRpbWVzIC0gdGhlIHVuaXQgb2YgdGltZSB0byBjb3VudC5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzcGxpdEF0KC4uLmRhdGVUaW1lcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gW107XG4gICAgY29uc3Qgc29ydGVkID0gZGF0ZVRpbWVzXG4gICAgICAgIC5tYXAoZnJpZW5kbHlEYXRlVGltZSlcbiAgICAgICAgLmZpbHRlcigoZCkgPT4gdGhpcy5jb250YWlucyhkKSlcbiAgICAgICAgLnNvcnQoKSxcbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICBsZXQgeyBzIH0gPSB0aGlzLFxuICAgICAgaSA9IDA7XG5cbiAgICB3aGlsZSAocyA8IHRoaXMuZSkge1xuICAgICAgY29uc3QgYWRkZWQgPSBzb3J0ZWRbaV0gfHwgdGhpcy5lLFxuICAgICAgICBuZXh0ID0gK2FkZGVkID4gK3RoaXMuZSA/IHRoaXMuZSA6IGFkZGVkO1xuICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMocywgbmV4dCkpO1xuICAgICAgcyA9IG5leHQ7XG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBpbnRvIHNtYWxsZXIgSW50ZXJ2YWxzLCBlYWNoIG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICAgKiBMZWZ0IG92ZXIgdGltZSBpcyBncm91cGVkIGludG8gYSBzbWFsbGVyIGludGVydmFsXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgbGVuZ3RoIG9mIGVhY2ggcmVzdWx0aW5nIGludGVydmFsLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHNwbGl0QnkoZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFkdXIuaXNWYWxpZCB8fCBkdXIuYXMoXCJtaWxsaXNlY29uZHNcIikgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgeyBzIH0gPSB0aGlzLFxuICAgICAgaWR4ID0gMSxcbiAgICAgIG5leHQ7XG5cbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgd2hpbGUgKHMgPCB0aGlzLmUpIHtcbiAgICAgIGNvbnN0IGFkZGVkID0gdGhpcy5zdGFydC5wbHVzKGR1ci5tYXBVbml0cygoeCkgPT4geCAqIGlkeCkpO1xuICAgICAgbmV4dCA9ICthZGRlZCA+ICt0aGlzLmUgPyB0aGlzLmUgOiBhZGRlZDtcbiAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIG5leHQpKTtcbiAgICAgIHMgPSBuZXh0O1xuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBpbnRvIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHNtYWxsZXIgaW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZQYXJ0cyAtIFRoZSBudW1iZXIgb2YgSW50ZXJ2YWxzIHRvIGRpdmlkZSB0aGUgSW50ZXJ2YWwgaW50by5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBkaXZpZGVFcXVhbGx5KG51bWJlck9mUGFydHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiB0aGlzLnNwbGl0QnkodGhpcy5sZW5ndGgoKSAvIG51bWJlck9mUGFydHMpLnNsaWNlKDAsIG51bWJlck9mUGFydHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgb3ZlcmxhcHMgd2l0aCB0aGUgc3BlY2lmaWVkIEludGVydmFsXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBvdmVybGFwcyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmUgPiBvdGhlci5zICYmIHRoaXMucyA8IG90aGVyLmU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhZGphY2VudCB0byB0aGUgc3BlY2lmaWVkIEludGVydmFsJ3Mgc3RhcnQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c1N0YXJ0KG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gK3RoaXMuZSA9PT0gK290aGVyLnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGlzIGFkamFjZW50IHRvIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwncyBlbmQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c0VuZChvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICtvdGhlci5lID09PSArdGhpcy5zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgZW5ndWxmcyB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZW5ndWxmcyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA8PSBvdGhlci5zICYmIHRoaXMuZSA+PSBvdGhlci5lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgaGFzIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQgYXMgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlci5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucy5lcXVhbHMob3RoZXIucykgJiYgdGhpcy5lLmVxdWFscyhvdGhlci5lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgcmVwcmVzZW50aW5nIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBJbnRlcnZhbCBhbmQgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgcmVzdWx0aW5nIEludGVydmFsIGhhcyB0aGUgbWF4aW11bSBzdGFydCB0aW1lIGFuZCB0aGUgbWluaW11bSBlbmQgdGltZSBvZiB0aGUgdHdvIEludGVydmFscy5cbiAgICogUmV0dXJucyBudWxsIGlmIHRoZSBpbnRlcnNlY3Rpb24gaXMgZW1wdHksIG1lYW5pbmcsIHRoZSBpbnRlcnZhbHMgZG9uJ3QgaW50ZXJzZWN0LlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIGludGVyc2VjdGlvbihvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBzID0gdGhpcy5zID4gb3RoZXIucyA/IHRoaXMucyA6IG90aGVyLnMsXG4gICAgICBlID0gdGhpcy5lIDwgb3RoZXIuZSA/IHRoaXMuZSA6IG90aGVyLmU7XG5cbiAgICBpZiAocyA+PSBlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMocywgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIHVuaW9uIG9mIHRoaXMgSW50ZXJ2YWwgYW5kIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHJlc3VsdGluZyBJbnRlcnZhbCBoYXMgdGhlIG1pbmltdW0gc3RhcnQgdGltZSBhbmQgdGhlIG1heGltdW0gZW5kIHRpbWUgb2YgdGhlIHR3byBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgdW5pb24ob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgcyA9IHRoaXMucyA8IG90aGVyLnMgPyB0aGlzLnMgOiBvdGhlci5zLFxuICAgICAgZSA9IHRoaXMuZSA+IG90aGVyLmUgPyB0aGlzLmUgOiBvdGhlci5lO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGFuIGFycmF5IG9mIEludGVydmFscyBpbnRvIGEgZXF1aXZhbGVudCBtaW5pbWFsIHNldCBvZiBJbnRlcnZhbHMuXG4gICAqIENvbWJpbmVzIG92ZXJsYXBwaW5nIGFuZCBhZGphY2VudCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtZXJnZShpbnRlcnZhbHMpIHtcbiAgICBjb25zdCBbZm91bmQsIGZpbmFsXSA9IGludGVydmFsc1xuICAgICAgLnNvcnQoKGEsIGIpID0+IGEucyAtIGIucylcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChbc29mYXIsIGN1cnJlbnRdLCBpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLCBpdGVtXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQub3ZlcmxhcHMoaXRlbSkgfHwgY3VycmVudC5hYnV0c1N0YXJ0KGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLCBjdXJyZW50LnVuaW9uKGl0ZW0pXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtzb2Zhci5jb25jYXQoW2N1cnJlbnRdKSwgaXRlbV07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbW10sIG51bGxdXG4gICAgICApO1xuICAgIGlmIChmaW5hbCkge1xuICAgICAgZm91bmQucHVzaChmaW5hbCk7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgSW50ZXJ2YWxzIHJlcHJlc2VudGluZyB0aGUgc3BhbnMgb2YgdGltZSB0aGF0IG9ubHkgYXBwZWFyIGluIG9uZSBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFscy5cbiAgICogQHBhcmFtIHtBcnJheX0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHhvcihpbnRlcnZhbHMpIHtcbiAgICBsZXQgc3RhcnQgPSBudWxsLFxuICAgICAgY3VycmVudENvdW50ID0gMDtcbiAgICBjb25zdCByZXN1bHRzID0gW10sXG4gICAgICBlbmRzID0gaW50ZXJ2YWxzLm1hcCgoaSkgPT4gW1xuICAgICAgICB7IHRpbWU6IGkucywgdHlwZTogXCJzXCIgfSxcbiAgICAgICAgeyB0aW1lOiBpLmUsIHR5cGU6IFwiZVwiIH0sXG4gICAgICBdKSxcbiAgICAgIGZsYXR0ZW5lZCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQoLi4uZW5kcyksXG4gICAgICBhcnIgPSBmbGF0dGVuZWQuc29ydCgoYSwgYikgPT4gYS50aW1lIC0gYi50aW1lKTtcblxuICAgIGZvciAoY29uc3QgaSBvZiBhcnIpIHtcbiAgICAgIGN1cnJlbnRDb3VudCArPSBpLnR5cGUgPT09IFwic1wiID8gMSA6IC0xO1xuXG4gICAgICBpZiAoY3VycmVudENvdW50ID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gaS50aW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXJ0ICYmICtzdGFydCAhPT0gK2kudGltZSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0LCBpLnRpbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gSW50ZXJ2YWwubWVyZ2UocmVzdWx0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgc3BhbiBvZiB0aW1lIGluIHRoaXMgSW50ZXJ2YWwgdGhhdCBkb2Vzbid0IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIHNwZWNpZmllZCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7Li4uSW50ZXJ2YWx9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGRpZmZlcmVuY2UoLi4uaW50ZXJ2YWxzKSB7XG4gICAgcmV0dXJuIEludGVydmFsLnhvcihbdGhpc10uY29uY2F0KGludGVydmFscykpXG4gICAgICAubWFwKChpKSA9PiB0aGlzLmludGVyc2VjdGlvbihpKSlcbiAgICAgIC5maWx0ZXIoKGkpID0+IGkgJiYgIWkuaXNFbXB0eSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgYXBwcm9wcmlhdGUgZm9yIGRlYnVnZ2luZy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgWyR7dGhpcy5zLnRvSVNPKCl9IFx1MjAxMyAke3RoaXMuZS50b0lTTygpfSlgO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIHNhbWUgb3B0aW9ucyBhcyB7QGxpbmsgRGF0ZVRpbWUjdG9JU099XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0lTTyhvcHRzKX0vJHt0aGlzLmUudG9JU08ob3B0cyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZGF0ZSBvZiB0aGlzIEludGVydmFsLlxuICAgKiBUaGUgdGltZSBjb21wb25lbnRzIGFyZSBpZ25vcmVkLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPRGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0lTT0RhdGUoKX0vJHt0aGlzLmUudG9JU09EYXRlKCl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGltZSBvZiB0aGlzIEludGVydmFsLlxuICAgKiBUaGUgZGF0ZSBjb21wb25lbnRzIGFyZSBpZ25vcmVkLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIHNhbWUgb3B0aW9ucyBhcyB7QGxpbmsgRGF0ZVRpbWUjdG9JU099XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZShvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9JU09UaW1lKG9wdHMpfS8ke3RoaXMuZS50b0lTT1RpbWUob3B0cyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlRm9ybWF0IC0gdGhlIGZvcm1hdCBzdHJpbmcuIFRoaXMgc3RyaW5nIGZvcm1hdHMgdGhlIHN0YXJ0IGFuZCBlbmQgdGltZS4gU2VlIHtAbGluayBEYXRlVGltZSN0b0Zvcm1hdH0gZm9yIGRldGFpbHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuc2VwYXJhdG9yID0gICcgXHUyMDEzICddIC0gYSBzZXBhcmF0b3IgdG8gcGxhY2UgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCByZXByZXNlbnRhdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZGF0ZUZvcm1hdCwgeyBzZXBhcmF0b3IgPSBcIiBcdTIwMTMgXCIgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9Gb3JtYXQoZGF0ZUZvcm1hdCl9JHtzZXBhcmF0b3J9JHt0aGlzLmUudG9Gb3JtYXQoZGF0ZUZvcm1hdCl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBEdXJhdGlvbiByZXByZXNlbnRpbmcgdGhlIHRpbWUgc3Bhbm5lZCBieSB0aGlzIGludGVydmFsLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3VuaXQ9WydtaWxsaXNlY29uZHMnXV0gLSB0aGUgdW5pdCBvciB1bml0cyAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gaW5jbHVkZSBpbiB0aGUgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCkudG9PYmplY3QoKSAvLz0+IHsgbWlsbGlzZWNvbmRzOiA4ODQ4OTI1NyB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oJ2RheXMnKS50b09iamVjdCgpIC8vPT4geyBkYXlzOiAxLjAyNDE4MTIxNTI3Nzc3NzggfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKFsnaG91cnMnLCAnbWludXRlcyddKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMjQsIG1pbnV0ZXM6IDM0LjgyMDk1IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbihbJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcyddKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMjQsIG1pbnV0ZXM6IDM0LCBzZWNvbmRzOiA0OS4yNTcgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCdzZWNvbmRzJykudG9PYmplY3QoKSAvLz0+IHsgc2Vjb25kczogODg0ODkuMjU3IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICB0b0R1cmF0aW9uKHVuaXQsIG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQodGhpcy5pbnZhbGlkUmVhc29uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZS5kaWZmKHRoaXMucywgdW5pdCwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUnVuIG1hcEZuIG9uIHRoZSBpbnRlcnZhbCBzdGFydCBhbmQgZW5kLCByZXR1cm5pbmcgYSBuZXcgSW50ZXJ2YWwgZnJvbSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtYXBGblxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikubWFwRW5kcG9pbnRzKGVuZHBvaW50ID0+IGVuZHBvaW50LnRvVVRDKCkpXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLm1hcEVuZHBvaW50cyhlbmRwb2ludCA9PiBlbmRwb2ludC5wbHVzKHsgaG91cnM6IDIgfSkpXG4gICAqL1xuICBtYXBFbmRwb2ludHMobWFwRm4pIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhtYXBGbih0aGlzLnMpLCBtYXBGbih0aGlzLmUpKTtcbiAgfVxufVxuIiwgImltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5cbmltcG9ydCB7IGhhc1JlbGF0aXZlIH0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5cbi8qKlxuICogVGhlIEluZm8gY2xhc3MgY29udGFpbnMgc3RhdGljIG1ldGhvZHMgZm9yIHJldHJpZXZpbmcgZ2VuZXJhbCB0aW1lIGFuZCBkYXRlIHJlbGF0ZWQgZGF0YS4gRm9yIGV4YW1wbGUsIGl0IGhhcyBtZXRob2RzIGZvciBmaW5kaW5nIG91dCBpZiBhIHRpbWUgem9uZSBoYXMgYSBEU1QsIGZvciBsaXN0aW5nIHRoZSBtb250aHMgaW4gYW55IHN1cHBvcnRlZCBsb2NhbGUsIGFuZCBmb3IgZGlzY292ZXJpbmcgd2hpY2ggb2YgTHV4b24gZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5mbyB7XG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgY29udGFpbnMgYSBEU1QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFt6b25lPSdsb2NhbCddIC0gWm9uZSB0byBjaGVjay4gRGVmYXVsdHMgdG8gdGhlIGVudmlyb25tZW50J3MgbG9jYWwgem9uZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBoYXNEU1Qoem9uZSA9IFNldHRpbmdzLmRlZmF1bHRab25lKSB7XG4gICAgY29uc3QgcHJvdG8gPSBEYXRlVGltZS5ub3coKS5zZXRab25lKHpvbmUpLnNldCh7IG1vbnRoOiAxMiB9KTtcblxuICAgIHJldHVybiAhem9uZS5pc1VuaXZlcnNhbCAmJiBwcm90by5vZmZzZXQgIT09IHByb3RvLnNldCh7IG1vbnRoOiA2IH0pLm9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgaXMgYSB2YWxpZCBJQU5BIHNwZWNpZmllci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmUgLSBab25lIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZElBTkFab25lKHpvbmUpIHtcbiAgICByZXR1cm4gSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcih6b25lKSAmJiBJQU5BWm9uZS5pc1ZhbGlkWm9uZSh6b25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgaW5wdXQgaW50byBhIHtAbGluayBab25lfSBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBJZiBgaW5wdXRgIGlzIGFscmVhZHkgYSBab25lIGluc3RhbmNlLCBpdCBpcyByZXR1cm5lZCB1bmNoYW5nZWQuXG4gICAqICogSWYgYGlucHV0YCBpcyBhIHN0cmluZyBjb250YWluaW5nIGEgdmFsaWQgdGltZSB6b25lIG5hbWUsIGEgWm9uZSBpbnN0YW5jZVxuICAgKiAgIHdpdGggdGhhdCBuYW1lIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYSBzdHJpbmcgdGhhdCBkb2Vzbid0IHJlZmVyIHRvIGEga25vd24gdGltZSB6b25lLCBhIFpvbmVcbiAgICogICBpbnN0YW5jZSB3aXRoIHtAbGluayBab25lI2lzVmFsaWR9ID09IGZhbHNlIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dCBpcyBhIG51bWJlciwgYSBab25lIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBmaXhlZCBvZmZzZXRcbiAgICogICBpbiBtaW51dGVzIGlzIHJldHVybmVkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLCB0aGUgZGVmYXVsdCB6b25lIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfG51bWJlcn0gW2lucHV0XSAtIHRoZSB2YWx1ZSB0byBiZSBjb252ZXJ0ZWRcbiAgICogQHJldHVybiB7Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVab25lKGlucHV0KSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVpvbmUoaW5wdXQsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2Ygc3RhbmRhbG9uZSBtb250aCBuYW1lcy5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJudW1lcmljXCIsIFwiMi1kaWdpdFwiLCBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRwdXRDYWxlbmRhcj0nZ3JlZ29yeSddIC0gdGhlIGNhbGVuZGFyXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKClbMF0gLy89PiAnSmFudWFyeSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ3Nob3J0JylbMF0gLy89PiAnSmFuJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnbnVtZXJpYycpWzBdIC8vPT4gJzEnXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdzaG9ydCcsIHsgbG9jYWxlOiAnZnItQ0EnIH0gKVswXSAvLz0+ICdqYW52LidcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ251bWVyaWMnLCB7IGxvY2FsZTogJ2FyJyB9KVswXSAvLz0+ICdcdTA2NjEnXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdsb25nJywgeyBvdXRwdXRDYWxlbmRhcjogJ2lzbGFtaWMnIH0pWzBdIC8vPT4gJ1JhYmlcdTAyQkIgSSdcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbW9udGhzKFxuICAgIGxlbmd0aCA9IFwibG9uZ1wiLFxuICAgIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCwgb3V0cHV0Q2FsZW5kYXIgPSBcImdyZWdvcnlcIiB9ID0ge31cbiAgKSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpKS5tb250aHMobGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZm9ybWF0IG1vbnRoIG5hbWVzLlxuICAgKiBGb3JtYXQgbW9udGhzIGRpZmZlciBmcm9tIHN0YW5kYWxvbmUgbW9udGhzIGluIHRoYXQgdGhleSdyZSBtZWFudCB0byBhcHBlYXIgbmV4dCB0byB0aGUgZGF5IG9mIHRoZSBtb250aC4gSW4gc29tZSBsYW5ndWFnZXMsIHRoYXRcbiAgICogY2hhbmdlcyB0aGUgc3RyaW5nLlxuICAgKiBTZWUge0BsaW5rIEluZm8jbW9udGhzfVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJudW1lcmljXCIsIFwiMi1kaWdpdFwiLCBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRwdXRDYWxlbmRhcj0nZ3JlZ29yeSddIC0gdGhlIGNhbGVuZGFyXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1vbnRoc0Zvcm1hdChcbiAgICBsZW5ndGggPSBcImxvbmdcIixcbiAgICB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwsIG91dHB1dENhbGVuZGFyID0gXCJncmVnb3J5XCIgfSA9IHt9XG4gICkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyKSkubW9udGhzKGxlbmd0aCwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIHN0YW5kYWxvbmUgd2VlayBuYW1lcy5cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgd2Vla2RheSByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKClbMF0gLy89PiAnTW9uZGF5J1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcpWzBdIC8vPT4gJ01vbidcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygnc2hvcnQnLCB7IGxvY2FsZTogJ2ZyLUNBJyB9KVswXSAvLz0+ICdsdW4uJ1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcsIHsgbG9jYWxlOiAnYXInIH0pWzBdIC8vPT4gJ1x1MDYyN1x1MDY0NFx1MDYyN1x1MDYyQlx1MDY0Nlx1MDY0QVx1MDY0NidcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgd2Vla2RheXMobGVuZ3RoID0gXCJsb25nXCIsIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCB9ID0ge30pIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBudWxsKSkud2Vla2RheXMobGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZm9ybWF0IHdlZWsgbmFtZXMuXG4gICAqIEZvcm1hdCB3ZWVrZGF5cyBkaWZmZXIgZnJvbSBzdGFuZGFsb25lIHdlZWtkYXlzIGluIHRoYXQgdGhleSdyZSBtZWFudCB0byBhcHBlYXIgbmV4dCB0byBtb3JlIGRhdGUgaW5mb3JtYXRpb24uIEluIHNvbWUgbGFuZ3VhZ2VzLCB0aGF0XG4gICAqIGNoYW5nZXMgdGhlIHN0cmluZy5cbiAgICogU2VlIHtAbGluayBJbmZvI3dlZWtkYXlzfVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9bnVsbF0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyB3ZWVrZGF5c0Zvcm1hdChcbiAgICBsZW5ndGggPSBcImxvbmdcIixcbiAgICB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9XG4gICkge1xuICAgIHJldHVybiAobG9jT2JqIHx8IExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG51bGwpKS53ZWVrZGF5cyhsZW5ndGgsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBtZXJpZGllbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAZXhhbXBsZSBJbmZvLm1lcmlkaWVtcygpIC8vPT4gWyAnQU0nLCAnUE0nIF1cbiAgICogQGV4YW1wbGUgSW5mby5tZXJpZGllbXMoeyBsb2NhbGU6ICdteScgfSkgLy89PiBbICdcdTEwMTRcdTEwMzZcdTEwMTRcdTEwMDBcdTEwM0EnLCAnXHUxMDBBXHUxMDE0XHUxMDMxJyBdXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIG1lcmlkaWVtcyh7IGxvY2FsZSA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlKS5tZXJpZGllbXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZXJhcywgc3VjaCBhcyBbJ0JDJywgJ0FEJ10uIFRoZSBsb2NhbGUgY2FuIGJlIHNwZWNpZmllZCwgYnV0IHRoZSBjYWxlbmRhciBzeXN0ZW0gaXMgYWx3YXlzIEdyZWdvcmlhbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J3Nob3J0J10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBlcmEgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJzaG9ydFwiIG9yIFwibG9uZ1wiLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCkgLy89PiBbICdCQycsICdBRCcgXVxuICAgKiBAZXhhbXBsZSBJbmZvLmVyYXMoJ2xvbmcnKSAvLz0+IFsgJ0JlZm9yZSBDaHJpc3QnLCAnQW5ubyBEb21pbmknIF1cbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCdsb25nJywgeyBsb2NhbGU6ICdmcicgfSkgLy89PiBbICdhdmFudCBKXHUwMEU5c3VzLUNocmlzdCcsICdhcHJcdTAwRThzIEpcdTAwRTlzdXMtQ2hyaXN0JyBdXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIGVyYXMobGVuZ3RoID0gXCJzaG9ydFwiLCB7IGxvY2FsZSA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlLCBudWxsLCBcImdyZWdvcnlcIikuZXJhcyhsZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc2V0IG9mIGF2YWlsYWJsZSBmZWF0dXJlcyBpbiB0aGlzIGVudmlyb25tZW50LlxuICAgKiBTb21lIGZlYXR1cmVzIG9mIEx1eG9uIGFyZSBub3QgYXZhaWxhYmxlIGluIGFsbCBlbnZpcm9ubWVudHMuIEZvciBleGFtcGxlLCBvbiBvbGRlciBicm93c2VycywgcmVsYXRpdmUgdGltZSBmb3JtYXR0aW5nIHN1cHBvcnQgaXMgbm90IGF2YWlsYWJsZS4gVXNlIHRoaXMgZnVuY3Rpb24gdG8gZmlndXJlIG91dCBpZiB0aGF0J3MgdGhlIGNhc2UuXG4gICAqIEtleXM6XG4gICAqICogYHJlbGF0aXZlYDogd2hldGhlciB0aGlzIGVudmlyb25tZW50IHN1cHBvcnRzIHJlbGF0aXZlIHRpbWUgZm9ybWF0dGluZ1xuICAgKiBAZXhhbXBsZSBJbmZvLmZlYXR1cmVzKCkgLy89PiB7IHJlbGF0aXZlOiBmYWxzZSB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBmZWF0dXJlcygpIHtcbiAgICByZXR1cm4geyByZWxhdGl2ZTogaGFzUmVsYXRpdmUoKSB9O1xuICB9XG59XG4iLCAiaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuLi9kdXJhdGlvbi5qc1wiO1xuXG5mdW5jdGlvbiBkYXlEaWZmKGVhcmxpZXIsIGxhdGVyKSB7XG4gIGNvbnN0IHV0Y0RheVN0YXJ0ID0gKGR0KSA9PiBkdC50b1VUQygwLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSkuc3RhcnRPZihcImRheVwiKS52YWx1ZU9mKCksXG4gICAgbXMgPSB1dGNEYXlTdGFydChsYXRlcikgLSB1dGNEYXlTdGFydChlYXJsaWVyKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoRHVyYXRpb24uZnJvbU1pbGxpcyhtcykuYXMoXCJkYXlzXCIpKTtcbn1cblxuZnVuY3Rpb24gaGlnaE9yZGVyRGlmZnMoY3Vyc29yLCBsYXRlciwgdW5pdHMpIHtcbiAgY29uc3QgZGlmZmVycyA9IFtcbiAgICBbXCJ5ZWFyc1wiLCAoYSwgYikgPT4gYi55ZWFyIC0gYS55ZWFyXSxcbiAgICBbXCJxdWFydGVyc1wiLCAoYSwgYikgPT4gYi5xdWFydGVyIC0gYS5xdWFydGVyXSxcbiAgICBbXCJtb250aHNcIiwgKGEsIGIpID0+IGIubW9udGggLSBhLm1vbnRoICsgKGIueWVhciAtIGEueWVhcikgKiAxMl0sXG4gICAgW1xuICAgICAgXCJ3ZWVrc1wiLFxuICAgICAgKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgZGF5cyA9IGRheURpZmYoYSwgYik7XG4gICAgICAgIHJldHVybiAoZGF5cyAtIChkYXlzICUgNykpIC8gNztcbiAgICAgIH0sXG4gICAgXSxcbiAgICBbXCJkYXlzXCIsIGRheURpZmZdLFxuICBdO1xuXG4gIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgbGV0IGxvd2VzdE9yZGVyLCBoaWdoV2F0ZXI7XG5cbiAgZm9yIChjb25zdCBbdW5pdCwgZGlmZmVyXSBvZiBkaWZmZXJzKSB7XG4gICAgaWYgKHVuaXRzLmluZGV4T2YodW5pdCkgPj0gMCkge1xuICAgICAgbG93ZXN0T3JkZXIgPSB1bml0O1xuXG4gICAgICBsZXQgZGVsdGEgPSBkaWZmZXIoY3Vyc29yLCBsYXRlcik7XG4gICAgICBoaWdoV2F0ZXIgPSBjdXJzb3IucGx1cyh7IFt1bml0XTogZGVsdGEgfSk7XG5cbiAgICAgIGlmIChoaWdoV2F0ZXIgPiBsYXRlcikge1xuICAgICAgICBjdXJzb3IgPSBjdXJzb3IucGx1cyh7IFt1bml0XTogZGVsdGEgLSAxIH0pO1xuICAgICAgICBkZWx0YSAtPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yID0gaGlnaFdhdGVyO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRzW3VuaXRdID0gZGVsdGE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtjdXJzb3IsIHJlc3VsdHMsIGhpZ2hXYXRlciwgbG93ZXN0T3JkZXJdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZWFybGllciwgbGF0ZXIsIHVuaXRzLCBvcHRzKSB7XG4gIGxldCBbY3Vyc29yLCByZXN1bHRzLCBoaWdoV2F0ZXIsIGxvd2VzdE9yZGVyXSA9IGhpZ2hPcmRlckRpZmZzKGVhcmxpZXIsIGxhdGVyLCB1bml0cyk7XG5cbiAgY29uc3QgcmVtYWluaW5nTWlsbGlzID0gbGF0ZXIgLSBjdXJzb3I7XG5cbiAgY29uc3QgbG93ZXJPcmRlclVuaXRzID0gdW5pdHMuZmlsdGVyKFxuICAgICh1KSA9PiBbXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCJdLmluZGV4T2YodSkgPj0gMFxuICApO1xuXG4gIGlmIChsb3dlck9yZGVyVW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGhpZ2hXYXRlciA8IGxhdGVyKSB7XG4gICAgICBoaWdoV2F0ZXIgPSBjdXJzb3IucGx1cyh7IFtsb3dlc3RPcmRlcl06IDEgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhpZ2hXYXRlciAhPT0gY3Vyc29yKSB7XG4gICAgICByZXN1bHRzW2xvd2VzdE9yZGVyXSA9IChyZXN1bHRzW2xvd2VzdE9yZGVyXSB8fCAwKSArIHJlbWFpbmluZ01pbGxpcyAvIChoaWdoV2F0ZXIgLSBjdXJzb3IpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGR1cmF0aW9uID0gRHVyYXRpb24uZnJvbU9iamVjdChyZXN1bHRzLCBvcHRzKTtcblxuICBpZiAobG93ZXJPcmRlclVuaXRzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU1pbGxpcyhyZW1haW5pbmdNaWxsaXMsIG9wdHMpXG4gICAgICAuc2hpZnRUbyguLi5sb3dlck9yZGVyVW5pdHMpXG4gICAgICAucGx1cyhkdXJhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9XG59XG4iLCAiY29uc3QgbnVtYmVyaW5nU3lzdGVtcyA9IHtcbiAgYXJhYjogXCJbXFx1MDY2MC1cXHUwNjY5XVwiLFxuICBhcmFiZXh0OiBcIltcXHUwNkYwLVxcdTA2RjldXCIsXG4gIGJhbGk6IFwiW1xcdTFCNTAtXFx1MUI1OV1cIixcbiAgYmVuZzogXCJbXFx1MDlFNi1cXHUwOUVGXVwiLFxuICBkZXZhOiBcIltcXHUwOTY2LVxcdTA5NkZdXCIsXG4gIGZ1bGx3aWRlOiBcIltcXHVGRjEwLVxcdUZGMTldXCIsXG4gIGd1anI6IFwiW1xcdTBBRTYtXFx1MEFFRl1cIixcbiAgaGFuaWRlYzogXCJbXHUzMDA3fFx1NEUwMHxcdTRFOEN8XHU0RTA5fFx1NTZEQnxcdTRFOTR8XHU1MTZEfFx1NEUwM3xcdTUxNkJ8XHU0RTVEXVwiLFxuICBraG1yOiBcIltcXHUxN0UwLVxcdTE3RTldXCIsXG4gIGtuZGE6IFwiW1xcdTBDRTYtXFx1MENFRl1cIixcbiAgbGFvbzogXCJbXFx1MEVEMC1cXHUwRUQ5XVwiLFxuICBsaW1iOiBcIltcXHUxOTQ2LVxcdTE5NEZdXCIsXG4gIG1seW06IFwiW1xcdTBENjYtXFx1MEQ2Rl1cIixcbiAgbW9uZzogXCJbXFx1MTgxMC1cXHUxODE5XVwiLFxuICBteW1yOiBcIltcXHUxMDQwLVxcdTEwNDldXCIsXG4gIG9yeWE6IFwiW1xcdTBCNjYtXFx1MEI2Rl1cIixcbiAgdGFtbGRlYzogXCJbXFx1MEJFNi1cXHUwQkVGXVwiLFxuICB0ZWx1OiBcIltcXHUwQzY2LVxcdTBDNkZdXCIsXG4gIHRoYWk6IFwiW1xcdTBFNTAtXFx1MEU1OV1cIixcbiAgdGlidDogXCJbXFx1MEYyMC1cXHUwRjI5XVwiLFxuICBsYXRuOiBcIlxcXFxkXCIsXG59O1xuXG5jb25zdCBudW1iZXJpbmdTeXN0ZW1zVVRGMTYgPSB7XG4gIGFyYWI6IFsxNjMyLCAxNjQxXSxcbiAgYXJhYmV4dDogWzE3NzYsIDE3ODVdLFxuICBiYWxpOiBbNjk5MiwgNzAwMV0sXG4gIGJlbmc6IFsyNTM0LCAyNTQzXSxcbiAgZGV2YTogWzI0MDYsIDI0MTVdLFxuICBmdWxsd2lkZTogWzY1Mjk2LCA2NTMwM10sXG4gIGd1anI6IFsyNzkwLCAyNzk5XSxcbiAga2htcjogWzYxMTIsIDYxMjFdLFxuICBrbmRhOiBbMzMwMiwgMzMxMV0sXG4gIGxhb286IFszNzkyLCAzODAxXSxcbiAgbGltYjogWzY0NzAsIDY0NzldLFxuICBtbHltOiBbMzQzMCwgMzQzOV0sXG4gIG1vbmc6IFs2MTYwLCA2MTY5XSxcbiAgbXltcjogWzQxNjAsIDQxNjldLFxuICBvcnlhOiBbMjkxOCwgMjkyN10sXG4gIHRhbWxkZWM6IFszMDQ2LCAzMDU1XSxcbiAgdGVsdTogWzMxNzQsIDMxODNdLFxuICB0aGFpOiBbMzY2NCwgMzY3M10sXG4gIHRpYnQ6IFszODcyLCAzODgxXSxcbn07XG5cbmNvbnN0IGhhbmlkZWNDaGFycyA9IG51bWJlcmluZ1N5c3RlbXMuaGFuaWRlYy5yZXBsYWNlKC9bXFxbfFxcXV0vZywgXCJcIikuc3BsaXQoXCJcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURpZ2l0cyhzdHIpIHtcbiAgbGV0IHZhbHVlID0gcGFyc2VJbnQoc3RyLCAxMCk7XG4gIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgaWYgKHN0cltpXS5zZWFyY2gobnVtYmVyaW5nU3lzdGVtcy5oYW5pZGVjKSAhPT0gLTEpIHtcbiAgICAgICAgdmFsdWUgKz0gaGFuaWRlY0NoYXJzLmluZGV4T2Yoc3RyW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG51bWJlcmluZ1N5c3RlbXNVVEYxNikge1xuICAgICAgICAgIGNvbnN0IFttaW4sIG1heF0gPSBudW1iZXJpbmdTeXN0ZW1zVVRGMTZba2V5XTtcbiAgICAgICAgICBpZiAoY29kZSA+PSBtaW4gJiYgY29kZSA8PSBtYXgpIHtcbiAgICAgICAgICAgIHZhbHVlICs9IGNvZGUgLSBtaW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlnaXRSZWdleCh7IG51bWJlcmluZ1N5c3RlbSB9LCBhcHBlbmQgPSBcIlwiKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKGAke251bWJlcmluZ1N5c3RlbXNbbnVtYmVyaW5nU3lzdGVtIHx8IFwibGF0blwiXX0ke2FwcGVuZH1gKTtcbn1cbiIsICJpbXBvcnQgeyBwYXJzZU1pbGxpcywgaXNVbmRlZmluZWQsIHVudHJ1bmNhdGVZZWFyLCBzaWduZWRPZmZzZXQsIGhhc093blByb3BlcnR5IH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IHsgZGlnaXRSZWdleCwgcGFyc2VEaWdpdHMgfSBmcm9tIFwiLi9kaWdpdHMuanNcIjtcbmltcG9ydCB7IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuXG5jb25zdCBNSVNTSU5HX0ZUUCA9IFwibWlzc2luZyBJbnRsLkRhdGVUaW1lRm9ybWF0LmZvcm1hdFRvUGFydHMgc3VwcG9ydFwiO1xuXG5mdW5jdGlvbiBpbnRVbml0KHJlZ2V4LCBwb3N0ID0gKGkpID0+IGkpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoW3NdKSA9PiBwb3N0KHBhcnNlRGlnaXRzKHMpKSB9O1xufVxuXG5jb25zdCBOQlNQID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxNjApO1xuY29uc3Qgc3BhY2VPck5CU1AgPSBgKCB8JHtOQlNQfSlgO1xuY29uc3Qgc3BhY2VPck5CU1BSZWdFeHAgPSBuZXcgUmVnRXhwKHNwYWNlT3JOQlNQLCBcImdcIik7XG5cbmZ1bmN0aW9uIGZpeExpc3RSZWdleChzKSB7XG4gIC8vIG1ha2UgZG90cyBvcHRpb25hbCBhbmQgYWxzbyBtYWtlIHRoZW0gbGl0ZXJhbFxuICAvLyBtYWtlIHNwYWNlIGFuZCBub24gYnJlYWthYmxlIHNwYWNlIGNoYXJhY3RlcnMgaW50ZXJjaGFuZ2VhYmxlXG4gIHJldHVybiBzLnJlcGxhY2UoL1xcLi9nLCBcIlxcXFwuP1wiKS5yZXBsYWNlKHNwYWNlT3JOQlNQUmVnRXhwLCBzcGFjZU9yTkJTUCk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwSW5zZW5zaXRpdml0aWVzKHMpIHtcbiAgcmV0dXJuIHNcbiAgICAucmVwbGFjZSgvXFwuL2csIFwiXCIpIC8vIGlnbm9yZSBkb3RzIHRoYXQgd2VyZSBtYWRlIG9wdGlvbmFsXG4gICAgLnJlcGxhY2Uoc3BhY2VPck5CU1BSZWdFeHAsIFwiIFwiKSAvLyBpbnRlcmNoYW5nZSBzcGFjZSBhbmQgbmJzcFxuICAgIC50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBvbmVPZihzdHJpbmdzLCBzdGFydEluZGV4KSB7XG4gIGlmIChzdHJpbmdzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2V4OiBSZWdFeHAoc3RyaW5ncy5tYXAoZml4TGlzdFJlZ2V4KS5qb2luKFwifFwiKSksXG4gICAgICBkZXNlcjogKFtzXSkgPT5cbiAgICAgICAgc3RyaW5ncy5maW5kSW5kZXgoKGkpID0+IHN0cmlwSW5zZW5zaXRpdml0aWVzKHMpID09PSBzdHJpcEluc2Vuc2l0aXZpdGllcyhpKSkgKyBzdGFydEluZGV4LFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gb2Zmc2V0KHJlZ2V4LCBncm91cHMpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoWywgaCwgbV0pID0+IHNpZ25lZE9mZnNldChoLCBtKSwgZ3JvdXBzIH07XG59XG5cbmZ1bmN0aW9uIHNpbXBsZShyZWdleCkge1xuICByZXR1cm4geyByZWdleCwgZGVzZXI6IChbc10pID0+IHMgfTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlVG9rZW4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiKTtcbn1cblxuZnVuY3Rpb24gdW5pdEZvclRva2VuKHRva2VuLCBsb2MpIHtcbiAgY29uc3Qgb25lID0gZGlnaXRSZWdleChsb2MpLFxuICAgIHR3byA9IGRpZ2l0UmVnZXgobG9jLCBcInsyfVwiKSxcbiAgICB0aHJlZSA9IGRpZ2l0UmVnZXgobG9jLCBcInszfVwiKSxcbiAgICBmb3VyID0gZGlnaXRSZWdleChsb2MsIFwiezR9XCIpLFxuICAgIHNpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns2fVwiKSxcbiAgICBvbmVPclR3byA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDJ9XCIpLFxuICAgIG9uZVRvVGhyZWUgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7MSwzfVwiKSxcbiAgICBvbmVUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDZ9XCIpLFxuICAgIG9uZVRvTmluZSA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDl9XCIpLFxuICAgIHR3b1RvRm91ciA9IGRpZ2l0UmVnZXgobG9jLCBcInsyLDR9XCIpLFxuICAgIGZvdXJUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns0LDZ9XCIpLFxuICAgIGxpdGVyYWwgPSAodCkgPT4gKHsgcmVnZXg6IFJlZ0V4cChlc2NhcGVUb2tlbih0LnZhbCkpLCBkZXNlcjogKFtzXSkgPT4gcywgbGl0ZXJhbDogdHJ1ZSB9KSxcbiAgICB1bml0YXRlID0gKHQpID0+IHtcbiAgICAgIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsKHQpO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0LnZhbCkge1xuICAgICAgICAvLyBlcmFcbiAgICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLmVyYXMoXCJzaG9ydFwiLCBmYWxzZSksIDApO1xuICAgICAgICBjYXNlIFwiR0dcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLmVyYXMoXCJsb25nXCIsIGZhbHNlKSwgMCk7XG4gICAgICAgIC8vIHllYXJzXG4gICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9TaXgpO1xuICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d29Ub0ZvdXIsIHVudHJ1bmNhdGVZZWFyKTtcbiAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcbiAgICAgICAgY2FzZSBcInl5eXl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoZm91clRvU2l4KTtcbiAgICAgICAgY2FzZSBcInl5eXl5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHNpeCk7XG4gICAgICAgIC8vIG1vbnRoc1xuICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIk1NXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIk1NTVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwic2hvcnRcIiwgdHJ1ZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcImxvbmdcIiwgdHJ1ZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJMTFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJMTExcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcInNob3J0XCIsIGZhbHNlLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiTExMTFwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwibG9uZ1wiLCBmYWxzZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgLy8gZGF0ZXNcbiAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIC8vIG9yZGluYWxzXG4gICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9UaHJlZSk7XG4gICAgICAgIGNhc2UgXCJvb29cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0aHJlZSk7XG4gICAgICAgIC8vIHRpbWVcbiAgICAgICAgY2FzZSBcIkhIXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJoaFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwibW1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJxcVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwic3NcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvVGhyZWUpO1xuICAgICAgICBjYXNlIFwiU1NTXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodGhyZWUpO1xuICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUob25lVG9OaW5lKTtcbiAgICAgICAgY2FzZSBcInV1XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZShvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJ1dXVcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmUpO1xuICAgICAgICAvLyBtZXJpZGllbVxuICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubWVyaWRpZW1zKCksIDApO1xuICAgICAgICAvLyB3ZWVrWWVhciAoaylcbiAgICAgICAgY2FzZSBcImtra2tcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcbiAgICAgICAgY2FzZSBcImtrXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvVG9Gb3VyLCB1bnRydW5jYXRlWWVhcik7XG4gICAgICAgIC8vIHdlZWtOdW1iZXIgKFcpXG4gICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiV1dcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICAvLyB3ZWVrZGF5c1xuICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZSk7XG4gICAgICAgIGNhc2UgXCJFRUVcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwic2hvcnRcIiwgZmFsc2UsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJFRUVFXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcImxvbmdcIiwgZmFsc2UsIGZhbHNlKSwgMSk7XG4gICAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwic2hvcnRcIiwgdHJ1ZSwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcImNjY2NcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwibG9uZ1wiLCB0cnVlLCBmYWxzZSksIDEpO1xuICAgICAgICAvLyBvZmZzZXQvem9uZVxuICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICBjYXNlIFwiWlpcIjpcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0KG5ldyBSZWdFeHAoYChbKy1dJHtvbmVPclR3by5zb3VyY2V9KSg/OjooJHt0d28uc291cmNlfSkpP2ApLCAyKTtcbiAgICAgICAgY2FzZSBcIlpaWlwiOlxuICAgICAgICAgIHJldHVybiBvZmZzZXQobmV3IFJlZ0V4cChgKFsrLV0ke29uZU9yVHdvLnNvdXJjZX0pKCR7dHdvLnNvdXJjZX0pP2ApLCAyKTtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgc3VwcG9ydCBaWlpaIChQU1QpIG9yIFpaWlpaIChQYWNpZmljIFN0YW5kYXJkIFRpbWUpIGluIHBhcnNpbmdcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGFueSB3YXkgdG8gZmlndXJlIG91dCB3aGF0IHRoZXkgYXJlXG4gICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZSgvW2Etel8rLS9dezEsMjU2fT8vaSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGxpdGVyYWwodCk7XG4gICAgICB9XG4gICAgfTtcblxuICBjb25zdCB1bml0ID0gdW5pdGF0ZSh0b2tlbikgfHwge1xuICAgIGludmFsaWRSZWFzb246IE1JU1NJTkdfRlRQLFxuICB9O1xuXG4gIHVuaXQudG9rZW4gPSB0b2tlbjtcblxuICByZXR1cm4gdW5pdDtcbn1cblxuY29uc3QgcGFydFR5cGVTdHlsZVRvVG9rZW5WYWwgPSB7XG4gIHllYXI6IHtcbiAgICBcIjItZGlnaXRcIjogXCJ5eVwiLFxuICAgIG51bWVyaWM6IFwieXl5eXlcIixcbiAgfSxcbiAgbW9udGg6IHtcbiAgICBudW1lcmljOiBcIk1cIixcbiAgICBcIjItZGlnaXRcIjogXCJNTVwiLFxuICAgIHNob3J0OiBcIk1NTVwiLFxuICAgIGxvbmc6IFwiTU1NTVwiLFxuICB9LFxuICBkYXk6IHtcbiAgICBudW1lcmljOiBcImRcIixcbiAgICBcIjItZGlnaXRcIjogXCJkZFwiLFxuICB9LFxuICB3ZWVrZGF5OiB7XG4gICAgc2hvcnQ6IFwiRUVFXCIsXG4gICAgbG9uZzogXCJFRUVFXCIsXG4gIH0sXG4gIGRheXBlcmlvZDogXCJhXCIsXG4gIGRheVBlcmlvZDogXCJhXCIsXG4gIGhvdXI6IHtcbiAgICBudW1lcmljOiBcImhcIixcbiAgICBcIjItZGlnaXRcIjogXCJoaFwiLFxuICB9LFxuICBtaW51dGU6IHtcbiAgICBudW1lcmljOiBcIm1cIixcbiAgICBcIjItZGlnaXRcIjogXCJtbVwiLFxuICB9LFxuICBzZWNvbmQ6IHtcbiAgICBudW1lcmljOiBcInNcIixcbiAgICBcIjItZGlnaXRcIjogXCJzc1wiLFxuICB9LFxufTtcblxuZnVuY3Rpb24gdG9rZW5Gb3JQYXJ0KHBhcnQsIGxvY2FsZSwgZm9ybWF0T3B0cykge1xuICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBwYXJ0O1xuXG4gIGlmICh0eXBlID09PSBcImxpdGVyYWxcIikge1xuICAgIHJldHVybiB7XG4gICAgICBsaXRlcmFsOiB0cnVlLFxuICAgICAgdmFsOiB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3Qgc3R5bGUgPSBmb3JtYXRPcHRzW3R5cGVdO1xuXG4gIGxldCB2YWwgPSBwYXJ0VHlwZVN0eWxlVG9Ub2tlblZhbFt0eXBlXTtcbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIpIHtcbiAgICB2YWwgPSB2YWxbc3R5bGVdO1xuICB9XG5cbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXRlcmFsOiBmYWxzZSxcbiAgICAgIHZhbCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYnVpbGRSZWdleCh1bml0cykge1xuICBjb25zdCByZSA9IHVuaXRzLm1hcCgodSkgPT4gdS5yZWdleCkucmVkdWNlKChmLCByKSA9PiBgJHtmfSgke3Iuc291cmNlfSlgLCBcIlwiKTtcbiAgcmV0dXJuIFtgXiR7cmV9JGAsIHVuaXRzXTtcbn1cblxuZnVuY3Rpb24gbWF0Y2goaW5wdXQsIHJlZ2V4LCBoYW5kbGVycykge1xuICBjb25zdCBtYXRjaGVzID0gaW5wdXQubWF0Y2gocmVnZXgpO1xuXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3QgYWxsID0ge307XG4gICAgbGV0IG1hdGNoSW5kZXggPSAxO1xuICAgIGZvciAoY29uc3QgaSBpbiBoYW5kbGVycykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGhhbmRsZXJzLCBpKSkge1xuICAgICAgICBjb25zdCBoID0gaGFuZGxlcnNbaV0sXG4gICAgICAgICAgZ3JvdXBzID0gaC5ncm91cHMgPyBoLmdyb3VwcyArIDEgOiAxO1xuICAgICAgICBpZiAoIWgubGl0ZXJhbCAmJiBoLnRva2VuKSB7XG4gICAgICAgICAgYWxsW2gudG9rZW4udmFsWzBdXSA9IGguZGVzZXIobWF0Y2hlcy5zbGljZShtYXRjaEluZGV4LCBtYXRjaEluZGV4ICsgZ3JvdXBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hJbmRleCArPSBncm91cHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbWF0Y2hlcywgYWxsXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW21hdGNoZXMsIHt9XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRlVGltZUZyb21NYXRjaGVzKG1hdGNoZXMpIHtcbiAgY29uc3QgdG9GaWVsZCA9ICh0b2tlbikgPT4ge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kXCI7XG4gICAgICBjYXNlIFwic1wiOlxuICAgICAgICByZXR1cm4gXCJzZWNvbmRcIjtcbiAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuICAgICAgY2FzZSBcImhcIjpcbiAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgIHJldHVybiBcImhvdXJcIjtcbiAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgIHJldHVybiBcImRheVwiO1xuICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgcmV0dXJuIFwib3JkaW5hbFwiO1xuICAgICAgY2FzZSBcIkxcIjpcbiAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgIHJldHVybiBcIm1vbnRoXCI7XG4gICAgICBjYXNlIFwieVwiOlxuICAgICAgICByZXR1cm4gXCJ5ZWFyXCI7XG4gICAgICBjYXNlIFwiRVwiOlxuICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla2RheVwiO1xuICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla051bWJlclwiO1xuICAgICAgY2FzZSBcImtcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla1llYXJcIjtcbiAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgIHJldHVybiBcInF1YXJ0ZXJcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBsZXQgem9uZSA9IG51bGw7XG4gIGxldCBzcGVjaWZpY09mZnNldDtcbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnopKSB7XG4gICAgem9uZSA9IElBTkFab25lLmNyZWF0ZShtYXRjaGVzLnopO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLlopKSB7XG4gICAgaWYgKCF6b25lKSB7XG4gICAgICB6b25lID0gbmV3IEZpeGVkT2Zmc2V0Wm9uZShtYXRjaGVzLlopO1xuICAgIH1cbiAgICBzcGVjaWZpY09mZnNldCA9IG1hdGNoZXMuWjtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5xKSkge1xuICAgIG1hdGNoZXMuTSA9IChtYXRjaGVzLnEgLSAxKSAqIDMgKyAxO1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLmgpKSB7XG4gICAgaWYgKG1hdGNoZXMuaCA8IDEyICYmIG1hdGNoZXMuYSA9PT0gMSkge1xuICAgICAgbWF0Y2hlcy5oICs9IDEyO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hlcy5oID09PSAxMiAmJiBtYXRjaGVzLmEgPT09IDApIHtcbiAgICAgIG1hdGNoZXMuaCA9IDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1hdGNoZXMuRyA9PT0gMCAmJiBtYXRjaGVzLnkpIHtcbiAgICBtYXRjaGVzLnkgPSAtbWF0Y2hlcy55O1xuICB9XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChtYXRjaGVzLnUpKSB7XG4gICAgbWF0Y2hlcy5TID0gcGFyc2VNaWxsaXMobWF0Y2hlcy51KTtcbiAgfVxuXG4gIGNvbnN0IHZhbHMgPSBPYmplY3Qua2V5cyhtYXRjaGVzKS5yZWR1Y2UoKHIsIGspID0+IHtcbiAgICBjb25zdCBmID0gdG9GaWVsZChrKTtcbiAgICBpZiAoZikge1xuICAgICAgcltmXSA9IG1hdGNoZXNba107XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gW3ZhbHMsIHpvbmUsIHNwZWNpZmljT2Zmc2V0XTtcbn1cblxubGV0IGR1bW15RGF0ZVRpbWVDYWNoZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldER1bW15RGF0ZVRpbWUoKSB7XG4gIGlmICghZHVtbXlEYXRlVGltZUNhY2hlKSB7XG4gICAgZHVtbXlEYXRlVGltZUNhY2hlID0gRGF0ZVRpbWUuZnJvbU1pbGxpcygxNTU1NTU1NTU1NTU1KTtcbiAgfVxuXG4gIHJldHVybiBkdW1teURhdGVUaW1lQ2FjaGU7XG59XG5cbmZ1bmN0aW9uIG1heWJlRXhwYW5kTWFjcm9Ub2tlbih0b2tlbiwgbG9jYWxlKSB7XG4gIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0T3B0cyA9IEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuLnZhbCk7XG5cbiAgaWYgKCFmb3JtYXRPcHRzKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0dGVyID0gRm9ybWF0dGVyLmNyZWF0ZShsb2NhbGUsIGZvcm1hdE9wdHMpO1xuICBjb25zdCBwYXJ0cyA9IGZvcm1hdHRlci5mb3JtYXREYXRlVGltZVBhcnRzKGdldER1bW15RGF0ZVRpbWUoKSk7XG5cbiAgY29uc3QgdG9rZW5zID0gcGFydHMubWFwKChwKSA9PiB0b2tlbkZvclBhcnQocCwgbG9jYWxlLCBmb3JtYXRPcHRzKSk7XG5cbiAgaWYgKHRva2Vucy5pbmNsdWRlcyh1bmRlZmluZWQpKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuZnVuY3Rpb24gZXhwYW5kTWFjcm9Ub2tlbnModG9rZW5zLCBsb2NhbGUpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQoLi4udG9rZW5zLm1hcCgodCkgPT4gbWF5YmVFeHBhbmRNYWNyb1Rva2VuKHQsIGxvY2FsZSkpKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleHBsYWluRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpIHtcbiAgY29uc3QgdG9rZW5zID0gZXhwYW5kTWFjcm9Ub2tlbnMoRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZvcm1hdCksIGxvY2FsZSksXG4gICAgdW5pdHMgPSB0b2tlbnMubWFwKCh0KSA9PiB1bml0Rm9yVG9rZW4odCwgbG9jYWxlKSksXG4gICAgZGlzcXVhbGlmeWluZ1VuaXQgPSB1bml0cy5maW5kKCh0KSA9PiB0LmludmFsaWRSZWFzb24pO1xuXG4gIGlmIChkaXNxdWFsaWZ5aW5nVW5pdCkge1xuICAgIHJldHVybiB7IGlucHV0LCB0b2tlbnMsIGludmFsaWRSZWFzb246IGRpc3F1YWxpZnlpbmdVbml0LmludmFsaWRSZWFzb24gfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbcmVnZXhTdHJpbmcsIGhhbmRsZXJzXSA9IGJ1aWxkUmVnZXgodW5pdHMpLFxuICAgICAgcmVnZXggPSBSZWdFeHAocmVnZXhTdHJpbmcsIFwiaVwiKSxcbiAgICAgIFtyYXdNYXRjaGVzLCBtYXRjaGVzXSA9IG1hdGNoKGlucHV0LCByZWdleCwgaGFuZGxlcnMpLFxuICAgICAgW3Jlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXRdID0gbWF0Y2hlc1xuICAgICAgICA/IGRhdGVUaW1lRnJvbU1hdGNoZXMobWF0Y2hlcylcbiAgICAgICAgOiBbbnVsbCwgbnVsbCwgdW5kZWZpbmVkXTtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkobWF0Y2hlcywgXCJhXCIpICYmIGhhc093blByb3BlcnR5KG1hdGNoZXMsIFwiSFwiKSkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFxuICAgICAgICBcIkNhbid0IGluY2x1ZGUgbWVyaWRpZW0gd2hlbiBzcGVjaWZ5aW5nIDI0LWhvdXIgZm9ybWF0XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7IGlucHV0LCB0b2tlbnMsIHJlZ2V4LCByYXdNYXRjaGVzLCBtYXRjaGVzLCByZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0IH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpIHtcbiAgY29uc3QgeyByZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0LCBpbnZhbGlkUmVhc29uIH0gPSBleHBsYWluRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpO1xuICByZXR1cm4gW3Jlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRSZWFzb25dO1xufVxuIiwgImltcG9ydCB7XG4gIGludGVnZXJCZXR3ZWVuLFxuICBpc0xlYXBZZWFyLFxuICB0aW1lT2JqZWN0LFxuICBkYXlzSW5ZZWFyLFxuICBkYXlzSW5Nb250aCxcbiAgd2Vla3NJbldlZWtZZWFyLFxuICBpc0ludGVnZXIsXG59IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ludmFsaWQuanNcIjtcblxuY29uc3Qgbm9uTGVhcExhZGRlciA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF0sXG4gIGxlYXBMYWRkZXIgPSBbMCwgMzEsIDYwLCA5MSwgMTIxLCAxNTIsIDE4MiwgMjEzLCAyNDQsIDI3NCwgMzA1LCAzMzVdO1xuXG5mdW5jdGlvbiB1bml0T3V0T2ZSYW5nZSh1bml0LCB2YWx1ZSkge1xuICByZXR1cm4gbmV3IEludmFsaWQoXG4gICAgXCJ1bml0IG91dCBvZiByYW5nZVwiLFxuICAgIGB5b3Ugc3BlY2lmaWVkICR7dmFsdWV9IChvZiB0eXBlICR7dHlwZW9mIHZhbHVlfSkgYXMgYSAke3VuaXR9LCB3aGljaCBpcyBpbnZhbGlkYFxuICApO1xufVxuXG5mdW5jdGlvbiBkYXlPZldlZWsoeWVhciwgbW9udGgsIGRheSkge1xuICBjb25zdCBqcyA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5KSkuZ2V0VVRDRGF5KCk7XG4gIHJldHVybiBqcyA9PT0gMCA/IDcgOiBqcztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSkge1xuICByZXR1cm4gZGF5ICsgKGlzTGVhcFllYXIoeWVhcikgPyBsZWFwTGFkZGVyIDogbm9uTGVhcExhZGRlcilbbW9udGggLSAxXTtcbn1cblxuZnVuY3Rpb24gdW5jb21wdXRlT3JkaW5hbCh5ZWFyLCBvcmRpbmFsKSB7XG4gIGNvbnN0IHRhYmxlID0gaXNMZWFwWWVhcih5ZWFyKSA/IGxlYXBMYWRkZXIgOiBub25MZWFwTGFkZGVyLFxuICAgIG1vbnRoMCA9IHRhYmxlLmZpbmRJbmRleCgoaSkgPT4gaSA8IG9yZGluYWwpLFxuICAgIGRheSA9IG9yZGluYWwgLSB0YWJsZVttb250aDBdO1xuICByZXR1cm4geyBtb250aDogbW9udGgwICsgMSwgZGF5IH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ3JlZ29yaWFuVG9XZWVrKGdyZWdPYmopIHtcbiAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSBncmVnT2JqLFxuICAgIG9yZGluYWwgPSBjb21wdXRlT3JkaW5hbCh5ZWFyLCBtb250aCwgZGF5KSxcbiAgICB3ZWVrZGF5ID0gZGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBkYXkpO1xuXG4gIGxldCB3ZWVrTnVtYmVyID0gTWF0aC5mbG9vcigob3JkaW5hbCAtIHdlZWtkYXkgKyAxMCkgLyA3KSxcbiAgICB3ZWVrWWVhcjtcblxuICBpZiAod2Vla051bWJlciA8IDEpIHtcbiAgICB3ZWVrWWVhciA9IHllYXIgLSAxO1xuICAgIHdlZWtOdW1iZXIgPSB3ZWVrc0luV2Vla1llYXIod2Vla1llYXIpO1xuICB9IGVsc2UgaWYgKHdlZWtOdW1iZXIgPiB3ZWVrc0luV2Vla1llYXIoeWVhcikpIHtcbiAgICB3ZWVrWWVhciA9IHllYXIgKyAxO1xuICAgIHdlZWtOdW1iZXIgPSAxO1xuICB9IGVsc2Uge1xuICAgIHdlZWtZZWFyID0geWVhcjtcbiAgfVxuXG4gIHJldHVybiB7IHdlZWtZZWFyLCB3ZWVrTnVtYmVyLCB3ZWVrZGF5LCAuLi50aW1lT2JqZWN0KGdyZWdPYmopIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrVG9HcmVnb3JpYW4od2Vla0RhdGEpIHtcbiAgY29uc3QgeyB3ZWVrWWVhciwgd2Vla051bWJlciwgd2Vla2RheSB9ID0gd2Vla0RhdGEsXG4gICAgd2Vla2RheU9mSmFuNCA9IGRheU9mV2Vlayh3ZWVrWWVhciwgMSwgNCksXG4gICAgeWVhckluRGF5cyA9IGRheXNJblllYXIod2Vla1llYXIpO1xuXG4gIGxldCBvcmRpbmFsID0gd2Vla051bWJlciAqIDcgKyB3ZWVrZGF5IC0gd2Vla2RheU9mSmFuNCAtIDMsXG4gICAgeWVhcjtcblxuICBpZiAob3JkaW5hbCA8IDEpIHtcbiAgICB5ZWFyID0gd2Vla1llYXIgLSAxO1xuICAgIG9yZGluYWwgKz0gZGF5c0luWWVhcih5ZWFyKTtcbiAgfSBlbHNlIGlmIChvcmRpbmFsID4geWVhckluRGF5cykge1xuICAgIHllYXIgPSB3ZWVrWWVhciArIDE7XG4gICAgb3JkaW5hbCAtPSBkYXlzSW5ZZWFyKHdlZWtZZWFyKTtcbiAgfSBlbHNlIHtcbiAgICB5ZWFyID0gd2Vla1llYXI7XG4gIH1cblxuICBjb25zdCB7IG1vbnRoLCBkYXkgfSA9IHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCk7XG4gIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIC4uLnRpbWVPYmplY3Qod2Vla0RhdGEpIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmVnb3JpYW5Ub09yZGluYWwoZ3JlZ0RhdGEpIHtcbiAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSBncmVnRGF0YTtcbiAgY29uc3Qgb3JkaW5hbCA9IGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpO1xuICByZXR1cm4geyB5ZWFyLCBvcmRpbmFsLCAuLi50aW1lT2JqZWN0KGdyZWdEYXRhKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3JkaW5hbFRvR3JlZ29yaWFuKG9yZGluYWxEYXRhKSB7XG4gIGNvbnN0IHsgeWVhciwgb3JkaW5hbCB9ID0gb3JkaW5hbERhdGE7XG4gIGNvbnN0IHsgbW9udGgsIGRheSB9ID0gdW5jb21wdXRlT3JkaW5hbCh5ZWFyLCBvcmRpbmFsKTtcbiAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSwgLi4udGltZU9iamVjdChvcmRpbmFsRGF0YSkgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRXZWVrRGF0YShvYmopIHtcbiAgY29uc3QgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai53ZWVrWWVhciksXG4gICAgdmFsaWRXZWVrID0gaW50ZWdlckJldHdlZW4ob2JqLndlZWtOdW1iZXIsIDEsIHdlZWtzSW5XZWVrWWVhcihvYmoud2Vla1llYXIpKSxcbiAgICB2YWxpZFdlZWtkYXkgPSBpbnRlZ2VyQmV0d2VlbihvYmoud2Vla2RheSwgMSwgNyk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ3ZWVrWWVhclwiLCBvYmoud2Vla1llYXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZFdlZWspIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ3ZWVrXCIsIG9iai53ZWVrKTtcbiAgfSBlbHNlIGlmICghdmFsaWRXZWVrZGF5KSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla2RheVwiLCBvYmoud2Vla2RheSk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkT3JkaW5hbERhdGEob2JqKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoueWVhciksXG4gICAgdmFsaWRPcmRpbmFsID0gaW50ZWdlckJldHdlZW4ob2JqLm9yZGluYWwsIDEsIGRheXNJblllYXIob2JqLnllYXIpKTtcblxuICBpZiAoIXZhbGlkWWVhcikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcInllYXJcIiwgb2JqLnllYXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE9yZGluYWwpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJvcmRpbmFsXCIsIG9iai5vcmRpbmFsKTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhKG9iaikge1xuICBjb25zdCB2YWxpZFllYXIgPSBpc0ludGVnZXIob2JqLnllYXIpLFxuICAgIHZhbGlkTW9udGggPSBpbnRlZ2VyQmV0d2VlbihvYmoubW9udGgsIDEsIDEyKSxcbiAgICB2YWxpZERheSA9IGludGVnZXJCZXR3ZWVuKG9iai5kYXksIDEsIGRheXNJbk1vbnRoKG9iai55ZWFyLCBvYmoubW9udGgpKTtcblxuICBpZiAoIXZhbGlkWWVhcikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcInllYXJcIiwgb2JqLnllYXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1vbnRoKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibW9udGhcIiwgb2JqLm1vbnRoKTtcbiAgfSBlbHNlIGlmICghdmFsaWREYXkpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJkYXlcIiwgb2JqLmRheSk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnZhbGlkVGltZURhdGEob2JqKSB7XG4gIGNvbnN0IHsgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kIH0gPSBvYmo7XG4gIGNvbnN0IHZhbGlkSG91ciA9XG4gICAgICBpbnRlZ2VyQmV0d2Vlbihob3VyLCAwLCAyMykgfHxcbiAgICAgIChob3VyID09PSAyNCAmJiBtaW51dGUgPT09IDAgJiYgc2Vjb25kID09PSAwICYmIG1pbGxpc2Vjb25kID09PSAwKSxcbiAgICB2YWxpZE1pbnV0ZSA9IGludGVnZXJCZXR3ZWVuKG1pbnV0ZSwgMCwgNTkpLFxuICAgIHZhbGlkU2Vjb25kID0gaW50ZWdlckJldHdlZW4oc2Vjb25kLCAwLCA1OSksXG4gICAgdmFsaWRNaWxsaXNlY29uZCA9IGludGVnZXJCZXR3ZWVuKG1pbGxpc2Vjb25kLCAwLCA5OTkpO1xuXG4gIGlmICghdmFsaWRIb3VyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwiaG91clwiLCBob3VyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRNaW51dGUpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtaW51dGVcIiwgbWludXRlKTtcbiAgfSBlbHNlIGlmICghdmFsaWRTZWNvbmQpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJzZWNvbmRcIiwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmICghdmFsaWRNaWxsaXNlY29uZCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm1pbGxpc2Vjb25kXCIsIG1pbGxpc2Vjb25kKTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cbiIsICJpbXBvcnQgRHVyYXRpb24gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcbmltcG9ydCBJbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgSW5mbyBmcm9tIFwiLi9pbmZvLmpzXCI7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gXCIuL2ltcGwvZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuaW1wb3J0IHtcbiAgaXNVbmRlZmluZWQsXG4gIG1heWJlQXJyYXksXG4gIGlzRGF0ZSxcbiAgaXNOdW1iZXIsXG4gIGJlc3RCeSxcbiAgZGF5c0luTW9udGgsXG4gIGRheXNJblllYXIsXG4gIGlzTGVhcFllYXIsXG4gIHdlZWtzSW5XZWVrWWVhcixcbiAgbm9ybWFsaXplT2JqZWN0LFxuICByb3VuZFRvLFxuICBvYmpUb0xvY2FsVFMsXG4gIHBhZFN0YXJ0LFxufSBmcm9tIFwiLi9pbXBsL3V0aWwuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5pbXBvcnQgZGlmZiBmcm9tIFwiLi9pbXBsL2RpZmYuanNcIjtcbmltcG9ydCB7IHBhcnNlUkZDMjgyMkRhdGUsIHBhcnNlSVNPRGF0ZSwgcGFyc2VIVFRQRGF0ZSwgcGFyc2VTUUwgfSBmcm9tIFwiLi9pbXBsL3JlZ2V4UGFyc2VyLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUZyb21Ub2tlbnMsIGV4cGxhaW5Gcm9tVG9rZW5zIH0gZnJvbSBcIi4vaW1wbC90b2tlblBhcnNlci5qc1wiO1xuaW1wb3J0IHtcbiAgZ3JlZ29yaWFuVG9XZWVrLFxuICB3ZWVrVG9HcmVnb3JpYW4sXG4gIGdyZWdvcmlhblRvT3JkaW5hbCxcbiAgb3JkaW5hbFRvR3JlZ29yaWFuLFxuICBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YSxcbiAgaGFzSW52YWxpZFdlZWtEYXRhLFxuICBoYXNJbnZhbGlkT3JkaW5hbERhdGEsXG4gIGhhc0ludmFsaWRUaW1lRGF0YSxcbn0gZnJvbSBcIi4vaW1wbC9jb252ZXJzaW9ucy5qc1wiO1xuaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9pbXBsL2Zvcm1hdHMuanNcIjtcbmltcG9ydCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcixcbiAgSW52YWxpZFVuaXRFcnJvcixcbiAgSW52YWxpZERhdGVUaW1lRXJyb3IsXG59IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5cbmNvbnN0IElOVkFMSUQgPSBcIkludmFsaWQgRGF0ZVRpbWVcIjtcbmNvbnN0IE1BWF9EQVRFID0gOC42NGUxNTtcblxuZnVuY3Rpb24gdW5zdXBwb3J0ZWRab25lKHpvbmUpIHtcbiAgcmV0dXJuIG5ldyBJbnZhbGlkKFwidW5zdXBwb3J0ZWQgem9uZVwiLCBgdGhlIHpvbmUgXCIke3pvbmUubmFtZX1cIiBpcyBub3Qgc3VwcG9ydGVkYCk7XG59XG5cbi8vIHdlIGNhY2hlIHdlZWsgZGF0YSBvbiB0aGUgRFQgb2JqZWN0IGFuZCB0aGlzIGludGVybWVkaWF0ZXMgdGhlIGNhY2hlXG5mdW5jdGlvbiBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKGR0KSB7XG4gIGlmIChkdC53ZWVrRGF0YSA9PT0gbnVsbCkge1xuICAgIGR0LndlZWtEYXRhID0gZ3JlZ29yaWFuVG9XZWVrKGR0LmMpO1xuICB9XG4gIHJldHVybiBkdC53ZWVrRGF0YTtcbn1cblxuLy8gY2xvbmUgcmVhbGx5IG1lYW5zLCBcIm1ha2UgYSBuZXcgb2JqZWN0IHdpdGggdGhlc2UgbW9kaWZpY2F0aW9uc1wiLiBhbGwgXCJzZXR0ZXJzXCIgcmVhbGx5IHVzZSB0aGlzXG4vLyB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IHdoaWxlIG9ubHkgY2hhbmdpbmcgc29tZSBvZiB0aGUgcHJvcGVydGllc1xuZnVuY3Rpb24gY2xvbmUoaW5zdCwgYWx0cykge1xuICBjb25zdCBjdXJyZW50ID0ge1xuICAgIHRzOiBpbnN0LnRzLFxuICAgIHpvbmU6IGluc3Quem9uZSxcbiAgICBjOiBpbnN0LmMsXG4gICAgbzogaW5zdC5vLFxuICAgIGxvYzogaW5zdC5sb2MsXG4gICAgaW52YWxpZDogaW5zdC5pbnZhbGlkLFxuICB9O1xuICByZXR1cm4gbmV3IERhdGVUaW1lKHsgLi4uY3VycmVudCwgLi4uYWx0cywgb2xkOiBjdXJyZW50IH0pO1xufVxuXG4vLyBmaW5kIHRoZSByaWdodCBvZmZzZXQgYSBnaXZlbiBsb2NhbCB0aW1lLiBUaGUgbyBpbnB1dCBpcyBvdXIgZ3Vlc3MsIHdoaWNoIGRldGVybWluZXMgd2hpY2hcbi8vIG9mZnNldCB3ZSdsbCBwaWNrIGluIGFtYmlndW91cyBjYXNlcyAoZS5nLiB0aGVyZSBhcmUgdHdvIDMgQU1zIGIvYyBGYWxsYmFjayBEU1QpXG5mdW5jdGlvbiBmaXhPZmZzZXQobG9jYWxUUywgbywgdHopIHtcbiAgLy8gT3VyIFVUQyB0aW1lIGlzIGp1c3QgYSBndWVzcyBiZWNhdXNlIG91ciBvZmZzZXQgaXMganVzdCBhIGd1ZXNzXG4gIGxldCB1dGNHdWVzcyA9IGxvY2FsVFMgLSBvICogNjAgKiAxMDAwO1xuXG4gIC8vIFRlc3Qgd2hldGhlciB0aGUgem9uZSBtYXRjaGVzIHRoZSBvZmZzZXQgZm9yIHRoaXMgdHNcbiAgY29uc3QgbzIgPSB0ei5vZmZzZXQodXRjR3Vlc3MpO1xuXG4gIC8vIElmIHNvLCBvZmZzZXQgZGlkbid0IGNoYW5nZSBhbmQgd2UncmUgZG9uZVxuICBpZiAobyA9PT0gbzIpIHtcbiAgICByZXR1cm4gW3V0Y0d1ZXNzLCBvXTtcbiAgfVxuXG4gIC8vIElmIG5vdCwgY2hhbmdlIHRoZSB0cyBieSB0aGUgZGlmZmVyZW5jZSBpbiB0aGUgb2Zmc2V0XG4gIHV0Y0d1ZXNzIC09IChvMiAtIG8pICogNjAgKiAxMDAwO1xuXG4gIC8vIElmIHRoYXQgZ2l2ZXMgdXMgdGhlIGxvY2FsIHRpbWUgd2Ugd2FudCwgd2UncmUgZG9uZVxuICBjb25zdCBvMyA9IHR6Lm9mZnNldCh1dGNHdWVzcyk7XG4gIGlmIChvMiA9PT0gbzMpIHtcbiAgICByZXR1cm4gW3V0Y0d1ZXNzLCBvMl07XG4gIH1cblxuICAvLyBJZiBpdCdzIGRpZmZlcmVudCwgd2UncmUgaW4gYSBob2xlIHRpbWUuIFRoZSBvZmZzZXQgaGFzIGNoYW5nZWQsIGJ1dCB0aGUgd2UgZG9uJ3QgYWRqdXN0IHRoZSB0aW1lXG4gIHJldHVybiBbbG9jYWxUUyAtIE1hdGgubWluKG8yLCBvMykgKiA2MCAqIDEwMDAsIE1hdGgubWF4KG8yLCBvMyldO1xufVxuXG4vLyBjb252ZXJ0IGFuIGVwb2NoIHRpbWVzdGFtcCBpbnRvIGEgY2FsZW5kYXIgb2JqZWN0IHdpdGggdGhlIGdpdmVuIG9mZnNldFxuZnVuY3Rpb24gdHNUb09iaih0cywgb2Zmc2V0KSB7XG4gIHRzICs9IG9mZnNldCAqIDYwICogMTAwMDtcblxuICBjb25zdCBkID0gbmV3IERhdGUodHMpO1xuXG4gIHJldHVybiB7XG4gICAgeWVhcjogZC5nZXRVVENGdWxsWWVhcigpLFxuICAgIG1vbnRoOiBkLmdldFVUQ01vbnRoKCkgKyAxLFxuICAgIGRheTogZC5nZXRVVENEYXRlKCksXG4gICAgaG91cjogZC5nZXRVVENIb3VycygpLFxuICAgIG1pbnV0ZTogZC5nZXRVVENNaW51dGVzKCksXG4gICAgc2Vjb25kOiBkLmdldFVUQ1NlY29uZHMoKSxcbiAgICBtaWxsaXNlY29uZDogZC5nZXRVVENNaWxsaXNlY29uZHMoKSxcbiAgfTtcbn1cblxuLy8gY29udmVydCBhIGNhbGVuZGFyIG9iamVjdCB0byBhIGVwb2NoIHRpbWVzdGFtcFxuZnVuY3Rpb24gb2JqVG9UUyhvYmosIG9mZnNldCwgem9uZSkge1xuICByZXR1cm4gZml4T2Zmc2V0KG9ialRvTG9jYWxUUyhvYmopLCBvZmZzZXQsIHpvbmUpO1xufVxuXG4vLyBjcmVhdGUgYSBuZXcgRFQgaW5zdGFuY2UgYnkgYWRkaW5nIGEgZHVyYXRpb24sIGFkanVzdGluZyBmb3IgRFNUc1xuZnVuY3Rpb24gYWRqdXN0VGltZShpbnN0LCBkdXIpIHtcbiAgY29uc3Qgb1ByZSA9IGluc3QubyxcbiAgICB5ZWFyID0gaW5zdC5jLnllYXIgKyBNYXRoLnRydW5jKGR1ci55ZWFycyksXG4gICAgbW9udGggPSBpbnN0LmMubW9udGggKyBNYXRoLnRydW5jKGR1ci5tb250aHMpICsgTWF0aC50cnVuYyhkdXIucXVhcnRlcnMpICogMyxcbiAgICBjID0ge1xuICAgICAgLi4uaW5zdC5jLFxuICAgICAgeWVhcixcbiAgICAgIG1vbnRoLFxuICAgICAgZGF5OlxuICAgICAgICBNYXRoLm1pbihpbnN0LmMuZGF5LCBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkpICtcbiAgICAgICAgTWF0aC50cnVuYyhkdXIuZGF5cykgK1xuICAgICAgICBNYXRoLnRydW5jKGR1ci53ZWVrcykgKiA3LFxuICAgIH0sXG4gICAgbWlsbGlzVG9BZGQgPSBEdXJhdGlvbi5mcm9tT2JqZWN0KHtcbiAgICAgIHllYXJzOiBkdXIueWVhcnMgLSBNYXRoLnRydW5jKGR1ci55ZWFycyksXG4gICAgICBxdWFydGVyczogZHVyLnF1YXJ0ZXJzIC0gTWF0aC50cnVuYyhkdXIucXVhcnRlcnMpLFxuICAgICAgbW9udGhzOiBkdXIubW9udGhzIC0gTWF0aC50cnVuYyhkdXIubW9udGhzKSxcbiAgICAgIHdlZWtzOiBkdXIud2Vla3MgLSBNYXRoLnRydW5jKGR1ci53ZWVrcyksXG4gICAgICBkYXlzOiBkdXIuZGF5cyAtIE1hdGgudHJ1bmMoZHVyLmRheXMpLFxuICAgICAgaG91cnM6IGR1ci5ob3VycyxcbiAgICAgIG1pbnV0ZXM6IGR1ci5taW51dGVzLFxuICAgICAgc2Vjb25kczogZHVyLnNlY29uZHMsXG4gICAgICBtaWxsaXNlY29uZHM6IGR1ci5taWxsaXNlY29uZHMsXG4gICAgfSkuYXMoXCJtaWxsaXNlY29uZHNcIiksXG4gICAgbG9jYWxUUyA9IG9ialRvTG9jYWxUUyhjKTtcblxuICBsZXQgW3RzLCBvXSA9IGZpeE9mZnNldChsb2NhbFRTLCBvUHJlLCBpbnN0LnpvbmUpO1xuXG4gIGlmIChtaWxsaXNUb0FkZCAhPT0gMCkge1xuICAgIHRzICs9IG1pbGxpc1RvQWRkO1xuICAgIC8vIHRoYXQgY291bGQgaGF2ZSBjaGFuZ2VkIHRoZSBvZmZzZXQgYnkgZ29pbmcgb3ZlciBhIERTVCwgYnV0IHdlIHdhbnQgdG8ga2VlcCB0aGUgdHMgdGhlIHNhbWVcbiAgICBvID0gaW5zdC56b25lLm9mZnNldCh0cyk7XG4gIH1cblxuICByZXR1cm4geyB0cywgbyB9O1xufVxuXG4vLyBoZWxwZXIgdXNlZnVsIGluIHR1cm5pbmcgdGhlIHJlc3VsdHMgb2YgcGFyc2luZyBpbnRvIHJlYWwgZGF0ZXNcbi8vIGJ5IGhhbmRsaW5nIHRoZSB6b25lIG9wdGlvbnNcbmZ1bmN0aW9uIHBhcnNlRGF0YVRvRGF0ZVRpbWUocGFyc2VkLCBwYXJzZWRab25lLCBvcHRzLCBmb3JtYXQsIHRleHQsIHNwZWNpZmljT2Zmc2V0KSB7XG4gIGNvbnN0IHsgc2V0Wm9uZSwgem9uZSB9ID0gb3B0cztcbiAgaWYgKHBhcnNlZCAmJiBPYmplY3Qua2V5cyhwYXJzZWQpLmxlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IGludGVycHJldGF0aW9uWm9uZSA9IHBhcnNlZFpvbmUgfHwgem9uZSxcbiAgICAgIGluc3QgPSBEYXRlVGltZS5mcm9tT2JqZWN0KHBhcnNlZCwge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICB6b25lOiBpbnRlcnByZXRhdGlvblpvbmUsXG4gICAgICAgIHNwZWNpZmljT2Zmc2V0LFxuICAgICAgfSk7XG4gICAgcmV0dXJuIHNldFpvbmUgPyBpbnN0IDogaW5zdC5zZXRab25lKHpvbmUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKFxuICAgICAgbmV3IEludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzICR7Zm9ybWF0fWApXG4gICAgKTtcbiAgfVxufVxuXG4vLyBpZiB5b3Ugd2FudCB0byBvdXRwdXQgYSB0ZWNobmljYWwgZm9ybWF0IChlLmcuIFJGQyAyODIyKSwgdGhpcyBoZWxwZXJcbi8vIGhlbHBzIGhhbmRsZSB0aGUgZGV0YWlsc1xuZnVuY3Rpb24gdG9UZWNoRm9ybWF0KGR0LCBmb3JtYXQsIGFsbG93WiA9IHRydWUpIHtcbiAgcmV0dXJuIGR0LmlzVmFsaWRcbiAgICA/IEZvcm1hdHRlci5jcmVhdGUoTG9jYWxlLmNyZWF0ZShcImVuLVVTXCIpLCB7XG4gICAgICAgIGFsbG93WixcbiAgICAgICAgZm9yY2VTaW1wbGU6IHRydWUsXG4gICAgICB9KS5mb3JtYXREYXRlVGltZUZyb21TdHJpbmcoZHQsIGZvcm1hdClcbiAgICA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHRvSVNPRGF0ZShvLCBleHRlbmRlZCkge1xuICBjb25zdCBsb25nRm9ybWF0ID0gby5jLnllYXIgPiA5OTk5IHx8IG8uYy55ZWFyIDwgMDtcbiAgbGV0IGMgPSBcIlwiO1xuICBpZiAobG9uZ0Zvcm1hdCAmJiBvLmMueWVhciA+PSAwKSBjICs9IFwiK1wiO1xuICBjICs9IHBhZFN0YXJ0KG8uYy55ZWFyLCBsb25nRm9ybWF0ID8gNiA6IDQpO1xuXG4gIGlmIChleHRlbmRlZCkge1xuICAgIGMgKz0gXCItXCI7XG4gICAgYyArPSBwYWRTdGFydChvLmMubW9udGgpO1xuICAgIGMgKz0gXCItXCI7XG4gICAgYyArPSBwYWRTdGFydChvLmMuZGF5KTtcbiAgfSBlbHNlIHtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5tb250aCk7XG4gICAgYyArPSBwYWRTdGFydChvLmMuZGF5KTtcbiAgfVxuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gdG9JU09UaW1lKG8sIGV4dGVuZGVkLCBzdXBwcmVzc1NlY29uZHMsIHN1cHByZXNzTWlsbGlzZWNvbmRzLCBpbmNsdWRlT2Zmc2V0KSB7XG4gIGxldCBjID0gcGFkU3RhcnQoby5jLmhvdXIpO1xuICBpZiAoZXh0ZW5kZWQpIHtcbiAgICBjICs9IFwiOlwiO1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLm1pbnV0ZSk7XG4gICAgaWYgKG8uYy5zZWNvbmQgIT09IDAgfHwgIXN1cHByZXNzU2Vjb25kcykge1xuICAgICAgYyArPSBcIjpcIjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYyArPSBwYWRTdGFydChvLmMubWludXRlKTtcbiAgfVxuXG4gIGlmIChvLmMuc2Vjb25kICE9PSAwIHx8ICFzdXBwcmVzc1NlY29uZHMpIHtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5zZWNvbmQpO1xuXG4gICAgaWYgKG8uYy5taWxsaXNlY29uZCAhPT0gMCB8fCAhc3VwcHJlc3NNaWxsaXNlY29uZHMpIHtcbiAgICAgIGMgKz0gXCIuXCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KG8uYy5taWxsaXNlY29uZCwgMyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGluY2x1ZGVPZmZzZXQpIHtcbiAgICBpZiAoby5pc09mZnNldEZpeGVkICYmIG8ub2Zmc2V0ID09PSAwKSB7XG4gICAgICBjICs9IFwiWlwiO1xuICAgIH0gZWxzZSBpZiAoby5vIDwgMCkge1xuICAgICAgYyArPSBcIi1cIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYygtby5vIC8gNjApKTtcbiAgICAgIGMgKz0gXCI6XCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoLW8ubyAlIDYwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgKz0gXCIrXCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoby5vIC8gNjApKTtcbiAgICAgIGMgKz0gXCI6XCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KE1hdGgudHJ1bmMoby5vICUgNjApKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbi8vIGRlZmF1bHRzIGZvciB1bnNwZWNpZmllZCB1bml0cyBpbiB0aGUgc3VwcG9ydGVkIGNhbGVuZGFyc1xuY29uc3QgZGVmYXVsdFVuaXRWYWx1ZXMgPSB7XG4gICAgbW9udGg6IDEsXG4gICAgZGF5OiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfSxcbiAgZGVmYXVsdFdlZWtVbml0VmFsdWVzID0ge1xuICAgIHdlZWtOdW1iZXI6IDEsXG4gICAgd2Vla2RheTogMSxcbiAgICBob3VyOiAwLFxuICAgIG1pbnV0ZTogMCxcbiAgICBzZWNvbmQ6IDAsXG4gICAgbWlsbGlzZWNvbmQ6IDAsXG4gIH0sXG4gIGRlZmF1bHRPcmRpbmFsVW5pdFZhbHVlcyA9IHtcbiAgICBvcmRpbmFsOiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfTtcblxuLy8gVW5pdHMgaW4gdGhlIHN1cHBvcnRlZCBjYWxlbmRhcnMsIHNvcnRlZCBieSBiaWduZXNzXG5jb25zdCBvcmRlcmVkVW5pdHMgPSBbXCJ5ZWFyXCIsIFwibW9udGhcIiwgXCJkYXlcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl0sXG4gIG9yZGVyZWRXZWVrVW5pdHMgPSBbXG4gICAgXCJ3ZWVrWWVhclwiLFxuICAgIFwid2Vla051bWJlclwiLFxuICAgIFwid2Vla2RheVwiLFxuICAgIFwiaG91clwiLFxuICAgIFwibWludXRlXCIsXG4gICAgXCJzZWNvbmRcIixcbiAgICBcIm1pbGxpc2Vjb25kXCIsXG4gIF0sXG4gIG9yZGVyZWRPcmRpbmFsVW5pdHMgPSBbXCJ5ZWFyXCIsIFwib3JkaW5hbFwiLCBcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXTtcblxuLy8gc3RhbmRhcmRpemUgY2FzZSBhbmQgcGx1cmFsaXR5IGluIHVuaXRzXG5mdW5jdGlvbiBub3JtYWxpemVVbml0KHVuaXQpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHtcbiAgICB5ZWFyOiBcInllYXJcIixcbiAgICB5ZWFyczogXCJ5ZWFyXCIsXG4gICAgbW9udGg6IFwibW9udGhcIixcbiAgICBtb250aHM6IFwibW9udGhcIixcbiAgICBkYXk6IFwiZGF5XCIsXG4gICAgZGF5czogXCJkYXlcIixcbiAgICBob3VyOiBcImhvdXJcIixcbiAgICBob3VyczogXCJob3VyXCIsXG4gICAgbWludXRlOiBcIm1pbnV0ZVwiLFxuICAgIG1pbnV0ZXM6IFwibWludXRlXCIsXG4gICAgcXVhcnRlcjogXCJxdWFydGVyXCIsXG4gICAgcXVhcnRlcnM6IFwicXVhcnRlclwiLFxuICAgIHNlY29uZDogXCJzZWNvbmRcIixcbiAgICBzZWNvbmRzOiBcInNlY29uZFwiLFxuICAgIG1pbGxpc2Vjb25kOiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgbWlsbGlzZWNvbmRzOiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgd2Vla2RheTogXCJ3ZWVrZGF5XCIsXG4gICAgd2Vla2RheXM6IFwid2Vla2RheVwiLFxuICAgIHdlZWtudW1iZXI6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWtzbnVtYmVyOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVrbnVtYmVyczogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla3llYXI6IFwid2Vla1llYXJcIixcbiAgICB3ZWVreWVhcnM6IFwid2Vla1llYXJcIixcbiAgICBvcmRpbmFsOiBcIm9yZGluYWxcIixcbiAgfVt1bml0LnRvTG93ZXJDYXNlKCldO1xuXG4gIGlmICghbm9ybWFsaXplZCkgdGhyb3cgbmV3IEludmFsaWRVbml0RXJyb3IodW5pdCk7XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbi8vIHRoaXMgaXMgYSBkdW1iZWQgZG93biB2ZXJzaW9uIG9mIGZyb21PYmplY3QoKSB0aGF0IHJ1bnMgYWJvdXQgNjAlIGZhc3RlclxuLy8gYnV0IGRvZXNuJ3QgZG8gYW55IHZhbGlkYXRpb24sIG1ha2VzIGEgYnVuY2ggb2YgYXNzdW1wdGlvbnMgYWJvdXQgd2hhdCB1bml0c1xuLy8gYXJlIHByZXNlbnQsIGFuZCBzbyBvbi5cblxuLy8gdGhpcyBpcyBhIGR1bWJlZCBkb3duIHZlcnNpb24gb2YgZnJvbU9iamVjdCgpIHRoYXQgcnVucyBhYm91dCA2MCUgZmFzdGVyXG4vLyBidXQgZG9lc24ndCBkbyBhbnkgdmFsaWRhdGlvbiwgbWFrZXMgYSBidW5jaCBvZiBhc3N1bXB0aW9ucyBhYm91dCB3aGF0IHVuaXRzXG4vLyBhcmUgcHJlc2VudCwgYW5kIHNvIG9uLlxuZnVuY3Rpb24gcXVpY2tEVChvYmosIG9wdHMpIHtcbiAgY29uc3Qgem9uZSA9IG5vcm1hbGl6ZVpvbmUob3B0cy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSksXG4gICAgbG9jID0gTG9jYWxlLmZyb21PYmplY3Qob3B0cyksXG4gICAgdHNOb3cgPSBTZXR0aW5ncy5ub3coKTtcblxuICBsZXQgdHMsIG87XG5cbiAgLy8gYXNzdW1lIHdlIGhhdmUgdGhlIGhpZ2hlci1vcmRlciB1bml0c1xuICBpZiAoIWlzVW5kZWZpbmVkKG9iai55ZWFyKSkge1xuICAgIGZvciAoY29uc3QgdSBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmIChpc1VuZGVmaW5lZChvYmpbdV0pKSB7XG4gICAgICAgIG9ialt1XSA9IGRlZmF1bHRVbml0VmFsdWVzW3VdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShvYmopIHx8IGhhc0ludmFsaWRUaW1lRGF0YShvYmopO1xuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9XG5cbiAgICBjb25zdCBvZmZzZXRQcm92aXMgPSB6b25lLm9mZnNldCh0c05vdyk7XG4gICAgW3RzLCBvXSA9IG9ialRvVFMob2JqLCBvZmZzZXRQcm92aXMsIHpvbmUpO1xuICB9IGVsc2Uge1xuICAgIHRzID0gdHNOb3c7XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGVUaW1lKHsgdHMsIHpvbmUsIGxvYywgbyB9KTtcbn1cblxuZnVuY3Rpb24gZGlmZlJlbGF0aXZlKHN0YXJ0LCBlbmQsIG9wdHMpIHtcbiAgY29uc3Qgcm91bmQgPSBpc1VuZGVmaW5lZChvcHRzLnJvdW5kKSA/IHRydWUgOiBvcHRzLnJvdW5kLFxuICAgIGZvcm1hdCA9IChjLCB1bml0KSA9PiB7XG4gICAgICBjID0gcm91bmRUbyhjLCByb3VuZCB8fCBvcHRzLmNhbGVuZGFyeSA/IDAgOiAyLCB0cnVlKTtcbiAgICAgIGNvbnN0IGZvcm1hdHRlciA9IGVuZC5sb2MuY2xvbmUob3B0cykucmVsRm9ybWF0dGVyKG9wdHMpO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoYywgdW5pdCk7XG4gICAgfSxcbiAgICBkaWZmZXIgPSAodW5pdCkgPT4ge1xuICAgICAgaWYgKG9wdHMuY2FsZW5kYXJ5KSB7XG4gICAgICAgIGlmICghZW5kLmhhc1NhbWUoc3RhcnQsIHVuaXQpKSB7XG4gICAgICAgICAgcmV0dXJuIGVuZC5zdGFydE9mKHVuaXQpLmRpZmYoc3RhcnQuc3RhcnRPZih1bml0KSwgdW5pdCkuZ2V0KHVuaXQpO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZW5kLmRpZmYoc3RhcnQsIHVuaXQpLmdldCh1bml0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIGlmIChvcHRzLnVuaXQpIHtcbiAgICByZXR1cm4gZm9ybWF0KGRpZmZlcihvcHRzLnVuaXQpLCBvcHRzLnVuaXQpO1xuICB9XG5cbiAgZm9yIChjb25zdCB1bml0IG9mIG9wdHMudW5pdHMpIHtcbiAgICBjb25zdCBjb3VudCA9IGRpZmZlcih1bml0KTtcbiAgICBpZiAoTWF0aC5hYnMoY291bnQpID49IDEpIHtcbiAgICAgIHJldHVybiBmb3JtYXQoY291bnQsIHVuaXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZm9ybWF0KHN0YXJ0ID4gZW5kID8gLTAgOiAwLCBvcHRzLnVuaXRzW29wdHMudW5pdHMubGVuZ3RoIC0gMV0pO1xufVxuXG5mdW5jdGlvbiBsYXN0T3B0cyhhcmdMaXN0KSB7XG4gIGxldCBvcHRzID0ge30sXG4gICAgYXJncztcbiAgaWYgKGFyZ0xpc3QubGVuZ3RoID4gMCAmJiB0eXBlb2YgYXJnTGlzdFthcmdMaXN0Lmxlbmd0aCAtIDFdID09PSBcIm9iamVjdFwiKSB7XG4gICAgb3B0cyA9IGFyZ0xpc3RbYXJnTGlzdC5sZW5ndGggLSAxXTtcbiAgICBhcmdzID0gQXJyYXkuZnJvbShhcmdMaXN0KS5zbGljZSgwLCBhcmdMaXN0Lmxlbmd0aCAtIDEpO1xuICB9IGVsc2Uge1xuICAgIGFyZ3MgPSBBcnJheS5mcm9tKGFyZ0xpc3QpO1xuICB9XG4gIHJldHVybiBbb3B0cywgYXJnc107XG59XG5cbi8qKlxuICogQSBEYXRlVGltZSBpcyBhbiBpbW11dGFibGUgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGEgc3BlY2lmaWMgZGF0ZSBhbmQgdGltZSBhbmQgYWNjb21wYW55aW5nIG1ldGhvZHMuIEl0IGNvbnRhaW5zIGNsYXNzIGFuZCBpbnN0YW5jZSBtZXRob2RzIGZvciBjcmVhdGluZywgcGFyc2luZywgaW50ZXJyb2dhdGluZywgdHJhbnNmb3JtaW5nLCBhbmQgZm9ybWF0dGluZyB0aGVtLlxuICpcbiAqIEEgRGF0ZVRpbWUgY29tcHJpc2VzIG9mOlxuICogKiBBIHRpbWVzdGFtcC4gRWFjaCBEYXRlVGltZSBpbnN0YW5jZSByZWZlcnMgdG8gYSBzcGVjaWZpYyBtaWxsaXNlY29uZCBvZiB0aGUgVW5peCBlcG9jaC5cbiAqICogQSB0aW1lIHpvbmUuIEVhY2ggaW5zdGFuY2UgaXMgY29uc2lkZXJlZCBpbiB0aGUgY29udGV4dCBvZiBhIHNwZWNpZmljIHpvbmUgKGJ5IGRlZmF1bHQgdGhlIGxvY2FsIHN5c3RlbSdzIHpvbmUpLlxuICogKiBDb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdGhhdCBlZmZlY3QgaG93IG91dHB1dCBzdHJpbmdzIGFyZSBmb3JtYXR0ZWQsIHN1Y2ggYXMgYGxvY2FsZWAsIGBudW1iZXJpbmdTeXN0ZW1gLCBhbmQgYG91dHB1dENhbGVuZGFyYC5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBmdW5jdGlvbmFsaXR5IGl0IHByb3ZpZGVzOlxuICpcbiAqICogKipDcmVhdGlvbioqOiBUbyBjcmVhdGUgYSBEYXRlVGltZSBmcm9tIGl0cyBjb21wb25lbnRzLCB1c2Ugb25lIG9mIGl0cyBmYWN0b3J5IGNsYXNzIG1ldGhvZHM6IHtAbGluayBEYXRlVGltZSNsb2NhbH0sIHtAbGluayBEYXRlVGltZSN1dGN9LCBhbmQgKG1vc3QgZmxleGlibHkpIHtAbGluayBEYXRlVGltZSNmcm9tT2JqZWN0fS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgc3RhbmRhcmQgc3RyaW5nIGZvcm1hdCwgdXNlIHtAbGluayBEYXRlVGltZSNmcm9tSVNPfSwge0BsaW5rIERhdGVUaW1lI2Zyb21IVFRQfSwgYW5kIHtAbGluayBEYXRlVGltZSNmcm9tUkZDMjgyMn0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIGN1c3RvbSBzdHJpbmcgZm9ybWF0LCB1c2Uge0BsaW5rIERhdGVUaW1lI2Zyb21Gb3JtYXR9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBuYXRpdmUgSlMgZGF0ZSwgdXNlIHtAbGluayBEYXRlVGltZSNmcm9tSlNEYXRlfS5cbiAqICogKipHcmVnb3JpYW4gY2FsZW5kYXIgYW5kIHRpbWUqKjogVG8gZXhhbWluZSB0aGUgR3JlZ29yaWFuIHByb3BlcnRpZXMgb2YgYSBEYXRlVGltZSBpbmRpdmlkdWFsbHkgKGkuZSBhcyBvcHBvc2VkIHRvIGNvbGxlY3RpdmVseSB0aHJvdWdoIHtAbGluayBEYXRlVGltZSN0b09iamVjdH0pLCB1c2UgdGhlIHtAbGluayBEYXRlVGltZSN5ZWFyfSwge0BsaW5rIERhdGVUaW1lI21vbnRofSxcbiAqIHtAbGluayBEYXRlVGltZSNkYXl9LCB7QGxpbmsgRGF0ZVRpbWUjaG91cn0sIHtAbGluayBEYXRlVGltZSNtaW51dGV9LCB7QGxpbmsgRGF0ZVRpbWUjc2Vjb25kfSwge0BsaW5rIERhdGVUaW1lI21pbGxpc2Vjb25kfSBhY2Nlc3NvcnMuXG4gKiAqICoqV2VlayBjYWxlbmRhcioqOiBGb3IgSVNPIHdlZWsgY2FsZW5kYXIgYXR0cmlidXRlcywgc2VlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjd2Vla1llYXJ9LCB7QGxpbmsgRGF0ZVRpbWUjd2Vla051bWJlcn0sIGFuZCB7QGxpbmsgRGF0ZVRpbWUjd2Vla2RheX0gYWNjZXNzb3JzLlxuICogKiAqKkNvbmZpZ3VyYXRpb24qKiBTZWUgdGhlIHtAbGluayBEYXRlVGltZSNsb2NhbGV9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjbnVtYmVyaW5nU3lzdGVtfSBhY2Nlc3NvcnMuXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKjogVG8gdHJhbnNmb3JtIHRoZSBEYXRlVGltZSBpbnRvIG90aGVyIERhdGVUaW1lcywgdXNlIHtAbGluayBEYXRlVGltZSNzZXR9LCB7QGxpbmsgRGF0ZVRpbWUjcmVjb25maWd1cmV9LCB7QGxpbmsgRGF0ZVRpbWUjc2V0Wm9uZX0sIHtAbGluayBEYXRlVGltZSNzZXRMb2NhbGV9LCB7QGxpbmsgRGF0ZVRpbWUucGx1c30sIHtAbGluayBEYXRlVGltZSNtaW51c30sIHtAbGluayBEYXRlVGltZSNlbmRPZn0sIHtAbGluayBEYXRlVGltZSNzdGFydE9mfSwge0BsaW5rIERhdGVUaW1lI3RvVVRDfSwgYW5kIHtAbGluayBEYXRlVGltZSN0b0xvY2FsfS5cbiAqICogKipPdXRwdXQqKjogVG8gY29udmVydCB0aGUgRGF0ZVRpbWUgdG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCB1c2UgdGhlIHtAbGluayBEYXRlVGltZSN0b1JlbGF0aXZlfSwge0BsaW5rIERhdGVUaW1lI3RvUmVsYXRpdmVDYWxlbmRhcn0sIHtAbGluayBEYXRlVGltZSN0b0pTT059LCB7QGxpbmsgRGF0ZVRpbWUjdG9JU099LCB7QGxpbmsgRGF0ZVRpbWUjdG9IVFRQfSwge0BsaW5rIERhdGVUaW1lI3RvT2JqZWN0fSwge0BsaW5rIERhdGVUaW1lI3RvUkZDMjgyMn0sIHtAbGluayBEYXRlVGltZSN0b1N0cmluZ30sIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30sIHtAbGluayBEYXRlVGltZSN0b0Zvcm1hdH0sIHtAbGluayBEYXRlVGltZSN0b01pbGxpc30gYW5kIHtAbGluayBEYXRlVGltZSN0b0pTRGF0ZX0uXG4gKlxuICogVGhlcmUncyBwbGVudHkgb3RoZXJzIGRvY3VtZW50ZWQgYmVsb3cuIEluIGFkZGl0aW9uLCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBzdWJ0bGVyIHRvcGljcyBsaWtlIGludGVybmF0aW9uYWxpemF0aW9uLCB0aW1lIHpvbmVzLCBhbHRlcm5hdGl2ZSBjYWxlbmRhcnMsIHZhbGlkaXR5LCBhbmQgc28gb24sIHNlZSB0aGUgZXh0ZXJuYWwgZG9jdW1lbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0ZVRpbWUge1xuICAvKipcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBjb25zdCB6b25lID0gY29uZmlnLnpvbmUgfHwgU2V0dGluZ3MuZGVmYXVsdFpvbmU7XG5cbiAgICBsZXQgaW52YWxpZCA9XG4gICAgICBjb25maWcuaW52YWxpZCB8fFxuICAgICAgKE51bWJlci5pc05hTihjb25maWcudHMpID8gbmV3IEludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpIDogbnVsbCkgfHxcbiAgICAgICghem9uZS5pc1ZhbGlkID8gdW5zdXBwb3J0ZWRab25lKHpvbmUpIDogbnVsbCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50cyA9IGlzVW5kZWZpbmVkKGNvbmZpZy50cykgPyBTZXR0aW5ncy5ub3coKSA6IGNvbmZpZy50cztcblxuICAgIGxldCBjID0gbnVsbCxcbiAgICAgIG8gPSBudWxsO1xuICAgIGlmICghaW52YWxpZCkge1xuICAgICAgY29uc3QgdW5jaGFuZ2VkID0gY29uZmlnLm9sZCAmJiBjb25maWcub2xkLnRzID09PSB0aGlzLnRzICYmIGNvbmZpZy5vbGQuem9uZS5lcXVhbHMoem9uZSk7XG5cbiAgICAgIGlmICh1bmNoYW5nZWQpIHtcbiAgICAgICAgW2MsIG9dID0gW2NvbmZpZy5vbGQuYywgY29uZmlnLm9sZC5vXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG90ID0gem9uZS5vZmZzZXQodGhpcy50cyk7XG4gICAgICAgIGMgPSB0c1RvT2JqKHRoaXMudHMsIG90KTtcbiAgICAgICAgaW52YWxpZCA9IE51bWJlci5pc05hTihjLnllYXIpID8gbmV3IEludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpIDogbnVsbDtcbiAgICAgICAgYyA9IGludmFsaWQgPyBudWxsIDogYztcbiAgICAgICAgbyA9IGludmFsaWQgPyBudWxsIDogb3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fem9uZSA9IHpvbmU7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2MgPSBjb25maWcubG9jIHx8IExvY2FsZS5jcmVhdGUoKTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBpbnZhbGlkO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMud2Vla0RhdGEgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYyA9IGM7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vID0gbztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlzTHV4b25EYXRlVGltZSA9IHRydWU7XG4gIH1cblxuICAvLyBDT05TVFJVQ1RcblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZm9yIHRoZSBjdXJyZW50IGluc3RhbnQsIGluIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUuXG4gICAqXG4gICAqIFVzZSBTZXR0aW5ncyB0byBvdmVycmlkZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpZiBuZWVkZWQuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKCkgLy9+PiBub3cgaW4gdGhlIElTTyBmb3JtYXRcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgbm93KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe30pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxvY2FsIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYGxvY2FsKClgIHdpdGggbm8gYXJndW1lbnRzKSwgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttb250aD0xXSAtIFRoZSBtb250aCwgMS1pbmRleGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF5PTFdIC0gVGhlIGRheSBvZiB0aGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hvdXI9MF0gLSBUaGUgaG91ciBvZiB0aGUgZGF5LCBpbiAyNC1ob3VyIHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW51dGU9MF0gLSBUaGUgbWludXRlIG9mIHRoZSBob3VyLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmQ9MF0gLSBUaGUgc2Vjb25kIG9mIHRoZSBtaW51dGUsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbGxpc2Vjb25kPTBdIC0gVGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA5OTlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IG5vd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCh7IHpvbmU6IFwiQW1lcmljYS9OZXdfWW9ya1wiIH0pICAgICAgLy9+PiBub3csIGluIFVTIGVhc3QgY29hc3QgdGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMS0wMVQwMDowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0wMVQwMDowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgeyBsb2NhbGU6IFwiZnJcIiB9KSAgICAgLy9+PiAyMDE3LTAzLTEyVDAwOjAwOjAwLCB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSkgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAzLCAxMiwgNSwgeyB6b25lOiBcInV0Y1wiIH0pICAgLy9+PiAyMDE3LTAzLTEyVDA1OjAwOjAwLCBpbiBVVENcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1KSAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCkgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCwgNzY1KSAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTAuNzY1XG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGxvY2FsKCkge1xuICAgIGNvbnN0IFtvcHRzLCBhcmdzXSA9IGxhc3RPcHRzKGFyZ3VtZW50cyksXG4gICAgICBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXSA9IGFyZ3M7XG4gICAgcmV0dXJuIHF1aWNrRFQoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgaW4gVVRDXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYHV0YygpYCB3aXRoIG5vIGFyZ3VtZW50cyksIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbW9udGg9MV0gLSBUaGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RheT0xXSAtIFRoZSBkYXkgb2YgdGhlIG1vbnRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaG91cj0wXSAtIFRoZSBob3VyIG9mIHRoZSBkYXksIGluIDI0LWhvdXIgdGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbnV0ZT0wXSAtIFRoZSBtaW51dGUgb2YgdGhlIGhvdXIsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZD0wXSAtIFRoZSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWlsbGlzZWNvbmQ9MF0gLSBUaGUgbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDk5OVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm91dHB1dENhbGVuZGFyXSAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm51bWJlcmluZ1N5c3RlbV0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IG5vd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDEtMDFUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0wMVQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUpICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NTowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgeyBsb2NhbGU6IFwiZnJcIiB9KSAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBaIHdpdGggYSBGcmVuY2ggbG9jYWxlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUsIDEwKSAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NToxMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTAsIDc2NSwgeyBsb2NhbGU6IFwiZnJcIiB9KSAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTAuNzY1WiB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyB1dGMoKSB7XG4gICAgY29uc3QgW29wdHMsIGFyZ3NdID0gbGFzdE9wdHMoYXJndW1lbnRzKSxcbiAgICAgIFt5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdID0gYXJncztcblxuICAgIG9wdHMuem9uZSA9IEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZTtcbiAgICByZXR1cm4gcXVpY2tEVCh7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCB9LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgSmF2YVNjcmlwdCBEYXRlIG9iamVjdC4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge0RhdGV9IGRhdGUgLSBhIEphdmFTY3JpcHQgRGF0ZSBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUpTRGF0ZShkYXRlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB0cyA9IGlzRGF0ZShkYXRlKSA/IGRhdGUudmFsdWVPZigpIDogTmFOO1xuICAgIGlmIChOdW1iZXIuaXNOYU4odHMpKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcImludmFsaWQgaW5wdXRcIik7XG4gICAgfVxuXG4gICAgY29uc3Qgem9uZVRvVXNlID0gbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgICBpZiAoIXpvbmVUb1VzZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZVRvVXNlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgICB0czogdHMsXG4gICAgICB6b25lOiB6b25lVG9Vc2UsXG4gICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaCAobWVhbmluZyBzaW5jZSAxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLiBVc2VzIHRoZSBkZWZhdWx0IHpvbmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaWxsaXNlY29uZHMgLSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgMTk3MCBVVENcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsZV0gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbU1pbGxpcyhtaWxsaXNlY29uZHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNOdW1iZXIobWlsbGlzZWNvbmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgZnJvbU1pbGxpcyByZXF1aXJlcyBhIG51bWVyaWNhbCBpbnB1dCwgYnV0IHJlY2VpdmVkIGEgJHt0eXBlb2YgbWlsbGlzZWNvbmRzfSB3aXRoIHZhbHVlICR7bWlsbGlzZWNvbmRzfWBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChtaWxsaXNlY29uZHMgPCAtTUFYX0RBVEUgfHwgbWlsbGlzZWNvbmRzID4gTUFYX0RBVEUpIHtcbiAgICAgIC8vIHRoaXMgaXNuJ3QgcGVyZmVjdCBiZWNhdXNlIGJlY2F1c2Ugd2UgY2FuIHN0aWxsIGVuZCB1cCBvdXQgb2YgcmFuZ2UgYmVjYXVzZSBvZiBhZGRpdGlvbmFsIHNoaWZ0aW5nLCBidXQgaXQncyBhIHN0YXJ0XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcIlRpbWVzdGFtcCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogbWlsbGlzZWNvbmRzLFxuICAgICAgICB6b25lOiBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpLFxuICAgICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggKG1lYW5pbmcgc2luY2UgMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Vjb25kcyAtIGEgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgMTk3MCBVVENcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0aW9ucy56b25lPSdsb2NhbCddIC0gdGhlIHpvbmUgdG8gcGxhY2UgdGhlIERhdGVUaW1lIGludG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsZV0gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVNlY29uZHMoc2Vjb25kcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc051bWJlcihzZWNvbmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiZnJvbVNlY29uZHMgcmVxdWlyZXMgYSBudW1lcmljYWwgaW5wdXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgICB0czogc2Vjb25kcyAqIDEwMDAsXG4gICAgICAgIHpvbmU6IG5vcm1hbGl6ZVpvbmUob3B0aW9ucy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSksXG4gICAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob3B0aW9ucyksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFyJyBhbmQgJ2hvdXInIHdpdGggcmVhc29uYWJsZSBkZWZhdWx0cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gY3JlYXRlIHRoZSBEYXRlVGltZSBmcm9tXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoueWVhciAtIGEgeWVhciwgc3VjaCBhcyAxOTg3XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubW9udGggLSBhIG1vbnRoLCAxLTEyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouZGF5IC0gYSBkYXkgb2YgdGhlIG1vbnRoLCAxLTMxLCBkZXBlbmRpbmcgb24gdGhlIG1vbnRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoub3JkaW5hbCAtIGRheSBvZiB0aGUgeWVhciwgMS0zNjUgb3IgMzY2XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla1llYXIgLSBhbiBJU08gd2VlayB5ZWFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla051bWJlciAtIGFuIElTTyB3ZWVrIG51bWJlciwgYmV0d2VlbiAxIGFuZCA1MiBvciA1MywgZGVwZW5kaW5nIG9uIHRoZSB5ZWFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla2RheSAtIGFuIElTTyB3ZWVrZGF5LCAxLTcsIHdoZXJlIDEgaXMgTW9uZGF5IGFuZCA3IGlzIFN1bmRheVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmhvdXIgLSBob3VyIG9mIHRoZSBkYXksIDAtMjNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taW51dGUgLSBtaW51dGUgb2YgdGhlIGhvdXIsIDAtNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5zZWNvbmQgLSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSwgMC01OVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbGxpc2Vjb25kIC0gbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCwgMC05OTlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSBpbnRlcnByZXQgdGhlIG51bWJlcnMgaW4gdGhlIGNvbnRleHQgb2YgYSBwYXJ0aWN1bGFyIHpvbmUuIENhbiB0YWtlIGFueSB2YWx1ZSB0YWtlbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gc2V0Wm9uZSgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyLCBtb250aDogNSwgZGF5OiAyNX0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDUtMjUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyIH0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDEtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0pIC8vfj4gdG9kYXkgYXQgMTA6MjY6MDZcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSwgeyB6b25lOiAndXRjJyB9KSxcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYgfSwgeyB6b25lOiAnbG9jYWwnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0sIHsgem9uZTogJ0FtZXJpY2EvTmV3X1lvcmsnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB3ZWVrWWVhcjogMjAxNiwgd2Vla051bWJlcjogMiwgd2Vla2RheTogMyB9KS50b0lTT0RhdGUoKSAvLz0+ICcyMDE2LTAxLTEzJ1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tT2JqZWN0KG9iaiwgb3B0cyA9IHt9KSB7XG4gICAgb2JqID0gb2JqIHx8IHt9O1xuICAgIGNvbnN0IHpvbmVUb1VzZSA9IG5vcm1hbGl6ZVpvbmUob3B0cy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gICAgaWYgKCF6b25lVG9Vc2UuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmVUb1VzZSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHRzTm93ID0gU2V0dGluZ3Mubm93KCksXG4gICAgICBvZmZzZXRQcm92aXMgPSAhaXNVbmRlZmluZWQob3B0cy5zcGVjaWZpY09mZnNldClcbiAgICAgICAgPyBvcHRzLnNwZWNpZmljT2Zmc2V0XG4gICAgICAgIDogem9uZVRvVXNlLm9mZnNldCh0c05vdyksXG4gICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplT2JqZWN0KG9iaiwgbm9ybWFsaXplVW5pdCksXG4gICAgICBjb250YWluc09yZGluYWwgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yWWVhciA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLnllYXIpLFxuICAgICAgY29udGFpbnNHcmVnb3JNRCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm1vbnRoKSB8fCAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpLFxuICAgICAgY29udGFpbnNHcmVnb3IgPSBjb250YWluc0dyZWdvclllYXIgfHwgY29udGFpbnNHcmVnb3JNRCxcbiAgICAgIGRlZmluaXRlV2Vla0RlZiA9IG5vcm1hbGl6ZWQud2Vla1llYXIgfHwgbm9ybWFsaXplZC53ZWVrTnVtYmVyLFxuICAgICAgbG9jID0gTG9jYWxlLmZyb21PYmplY3Qob3B0cyk7XG5cbiAgICAvLyBjYXNlczpcbiAgICAvLyBqdXN0IGEgd2Vla2RheSAtPiB0aGlzIHdlZWsncyBpbnN0YW5jZSBvZiB0aGF0IHdlZWtkYXksIG5vIHdvcnJpZXNcbiAgICAvLyAoZ3JlZ29yaWFuIGRhdGEgb3Igb3JkaW5hbCkgKyAod2Vla1llYXIgb3Igd2Vla051bWJlcikgLT4gZXJyb3JcbiAgICAvLyAoZ3JlZ29yaWFuIG1vbnRoIG9yIGRheSkgKyBvcmRpbmFsIC0+IGVycm9yXG4gICAgLy8gb3RoZXJ3aXNlIGp1c3QgdXNlIHdlZWtzIG9yIG9yZGluYWxzIG9yIGdyZWdvcmlhbiwgZGVwZW5kaW5nIG9uIHdoYXQncyBzcGVjaWZpZWRcblxuICAgIGlmICgoY29udGFpbnNHcmVnb3IgfHwgY29udGFpbnNPcmRpbmFsKSAmJiBkZWZpbml0ZVdlZWtEZWYpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW4ndCBtaXggd2Vla1llYXIvd2Vla051bWJlciB1bml0cyB3aXRoIHllYXIvbW9udGgvZGF5IG9yIG9yZGluYWxzXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5zR3JlZ29yTUQgJiYgY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXCJDYW4ndCBtaXggb3JkaW5hbCBkYXRlcyB3aXRoIG1vbnRoL2RheVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VXZWVrRGF0YSA9IGRlZmluaXRlV2Vla0RlZiB8fCAobm9ybWFsaXplZC53ZWVrZGF5ICYmICFjb250YWluc0dyZWdvcik7XG5cbiAgICAvLyBjb25maWd1cmUgb3Vyc2VsdmVzIHRvIGRlYWwgd2l0aCBncmVnb3JpYW4gZGF0ZXMgb3Igd2VlayBzdHVmZlxuICAgIGxldCB1bml0cyxcbiAgICAgIGRlZmF1bHRWYWx1ZXMsXG4gICAgICBvYmpOb3cgPSB0c1RvT2JqKHRzTm93LCBvZmZzZXRQcm92aXMpO1xuICAgIGlmICh1c2VXZWVrRGF0YSkge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkV2Vla1VuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRXZWVrVW5pdFZhbHVlcztcbiAgICAgIG9iak5vdyA9IGdyZWdvcmlhblRvV2VlayhvYmpOb3cpO1xuICAgIH0gZWxzZSBpZiAoY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRPcmRpbmFsVW5pdHM7XG4gICAgICBkZWZhdWx0VmFsdWVzID0gZGVmYXVsdE9yZGluYWxVbml0VmFsdWVzO1xuICAgICAgb2JqTm93ID0gZ3JlZ29yaWFuVG9PcmRpbmFsKG9iak5vdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZFVuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRVbml0VmFsdWVzO1xuICAgIH1cblxuICAgIC8vIHNldCBkZWZhdWx0IHZhbHVlcyBmb3IgbWlzc2luZyBzdHVmZlxuICAgIGxldCBmb3VuZEZpcnN0ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB1IG9mIHVuaXRzKSB7XG4gICAgICBjb25zdCB2ID0gbm9ybWFsaXplZFt1XTtcbiAgICAgIGlmICghaXNVbmRlZmluZWQodikpIHtcbiAgICAgICAgZm91bmRGaXJzdCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGZvdW5kRmlyc3QpIHtcbiAgICAgICAgbm9ybWFsaXplZFt1XSA9IGRlZmF1bHRWYWx1ZXNbdV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkW3VdID0gb2JqTm93W3VdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGUgdmFsdWVzIHdlIGhhdmUgYXJlIGluIHJhbmdlXG4gICAgY29uc3QgaGlnaGVyT3JkZXJJbnZhbGlkID0gdXNlV2Vla0RhdGFcbiAgICAgICAgPyBoYXNJbnZhbGlkV2Vla0RhdGEobm9ybWFsaXplZClcbiAgICAgICAgOiBjb250YWluc09yZGluYWxcbiAgICAgICAgPyBoYXNJbnZhbGlkT3JkaW5hbERhdGEobm9ybWFsaXplZClcbiAgICAgICAgOiBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShub3JtYWxpemVkKSxcbiAgICAgIGludmFsaWQgPSBoaWdoZXJPcmRlckludmFsaWQgfHwgaGFzSW52YWxpZFRpbWVEYXRhKG5vcm1hbGl6ZWQpO1xuXG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgdGhlIGFjdHVhbCB0aW1lXG4gICAgY29uc3QgZ3JlZ29yaWFuID0gdXNlV2Vla0RhdGFcbiAgICAgICAgPyB3ZWVrVG9HcmVnb3JpYW4obm9ybWFsaXplZClcbiAgICAgICAgOiBjb250YWluc09yZGluYWxcbiAgICAgICAgPyBvcmRpbmFsVG9HcmVnb3JpYW4obm9ybWFsaXplZClcbiAgICAgICAgOiBub3JtYWxpemVkLFxuICAgICAgW3RzRmluYWwsIG9mZnNldEZpbmFsXSA9IG9ialRvVFMoZ3JlZ29yaWFuLCBvZmZzZXRQcm92aXMsIHpvbmVUb1VzZSksXG4gICAgICBpbnN0ID0gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IHRzRmluYWwsXG4gICAgICAgIHpvbmU6IHpvbmVUb1VzZSxcbiAgICAgICAgbzogb2Zmc2V0RmluYWwsXG4gICAgICAgIGxvYyxcbiAgICAgIH0pO1xuXG4gICAgLy8gZ3JlZ29yaWFuIGRhdGEgKyB3ZWVrZGF5IHNlcnZlcyBvbmx5IHRvIHZhbGlkYXRlXG4gICAgaWYgKG5vcm1hbGl6ZWQud2Vla2RheSAmJiBjb250YWluc0dyZWdvciAmJiBvYmoud2Vla2RheSAhPT0gaW5zdC53ZWVrZGF5KSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChcbiAgICAgICAgXCJtaXNtYXRjaGVkIHdlZWtkYXlcIixcbiAgICAgICAgYHlvdSBjYW4ndCBzcGVjaWZ5IGJvdGggYSB3ZWVrZGF5IG9mICR7bm9ybWFsaXplZC53ZWVrZGF5fSBhbmQgYSBkYXRlIG9mICR7aW5zdC50b0lTTygpfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBJU08gODYwMSBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSVNPIHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXJdIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMrMDY6MDAnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMyswNjowMCcsIHtzZXRab25lOiB0cnVlfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMnLCB7em9uZTogJ3V0Yyd9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LVcwNS00JylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBbdmFscywgcGFyc2VkWm9uZV0gPSBwYXJzZUlTT0RhdGUodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJJU08gODYwMVwiLCB0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIFJGQyAyODIyIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBSRkMgMjgyMiBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIGNvbnZlcnQgdGhlIHRpbWUgdG8gdGhpcyB6b25lLiBTaW5jZSB0aGUgb2Zmc2V0IGlzIGFsd2F5cyBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIHRoaXMgaGFzIG5vIGVmZmVjdCBvbiB0aGUgaW50ZXJwcmV0YXRpb24gb2Ygc3RyaW5nLCBtZXJlbHkgdGhlIHpvbmUgdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpcyBleHByZXNzZWQgaW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgZml4ZWQtb2Zmc2V0IHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCcyNSBOb3YgMjAxNiAxMzoyMzoxMiBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tUkZDMjgyMignRnJpLCAyNSBOb3YgMjAxNiAxMzoyMzoxMiArMDYwMCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCcyNSBOb3YgMjAxNiAxMzoyMyBaJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbVJGQzI4MjIodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VSRkMyODIyRGF0ZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIlJGQyAyODIyXCIsIHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gSFRUUCBoZWFkZXIgZGF0ZVxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9Qcm90b2NvbHMvcmZjMjYxNi9yZmMyNjE2LXNlYzMuaHRtbCNzZWMzLjMuMVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBIVFRQIGhlYWRlciBkYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSBjb252ZXJ0IHRoZSB0aW1lIHRvIHRoaXMgem9uZS4gU2luY2UgSFRUUCBkYXRlcyBhcmUgYWx3YXlzIGluIFVUQywgdGhpcyBoYXMgbm8gZWZmZWN0IG9uIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBzdHJpbmcsIG1lcmVseSB0aGUgem9uZSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGlzIGV4cHJlc3NlZCBpbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggdGhlIGZpeGVkLW9mZnNldCB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nLiBGb3IgSFRUUCBkYXRlcywgdGhpcyBpcyBhbHdheXMgVVRDLCBzbyB0aGlzIG9wdGlvbiBpcyBlcXVpdmFsZW50IHRvIHNldHRpbmcgdGhlIGB6b25lYCBvcHRpb24gdG8gJ3V0YycsIGJ1dCB0aGlzIG9wdGlvbiBpcyBpbmNsdWRlZCBmb3IgY29uc2lzdGVuY3kgd2l0aCBzaW1pbGFyIG1ldGhvZHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21IVFRQKCdTdW4sIDA2IE5vdiAxOTk0IDA4OjQ5OjM3IEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21IVFRQKCdTdW5kYXksIDA2LU5vdi05NCAwODo0OTozNyBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuIE5vdiAgNiAwODo0OTozNyAxOTk0JylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUhUVFAodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VIVFRQRGF0ZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIkhUVFBcIiwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBpbnB1dCBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmcuXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZS4gRm9yIGEgdGFibGUgb2YgdG9rZW5zIGFuZCB0aGVpciBpbnRlcnByZXRhdGlvbnMsIHNlZSBbaGVyZV0oaHR0cHM6Ly9tb21lbnQuZ2l0aHViLmlvL2x1eG9uLyMvcGFyc2luZz9pZD10YWJsZS1vZi10b2tlbnMpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgdGhlIHN0cmluZyBpcyBleHBlY3RlZCB0byBiZSBpbiAoc2VlIHRoZSBsaW5rIGJlbG93IGZvciB0aGUgZm9ybWF0cylcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSBhIGxvY2FsZSBzdHJpbmcgdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIHRvIHRoaXMgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbUZvcm1hdCh0ZXh0LCBmbXQsIG9wdHMgPSB7fSkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh0ZXh0KSB8fCBpc1VuZGVmaW5lZChmbXQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJmcm9tRm9ybWF0IHJlcXVpcmVzIGFuIGlucHV0IHN0cmluZyBhbmQgYSBmb3JtYXRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsIH0gPSBvcHRzLFxuICAgICAgbG9jYWxlVG9Vc2UgPSBMb2NhbGUuZnJvbU9wdHMoe1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgZGVmYXVsdFRvRU46IHRydWUsXG4gICAgICB9KSxcbiAgICAgIFt2YWxzLCBwYXJzZWRab25lLCBzcGVjaWZpY09mZnNldCwgaW52YWxpZF0gPSBwYXJzZUZyb21Ub2tlbnMobG9jYWxlVG9Vc2UsIHRleHQsIGZtdCk7XG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBgZm9ybWF0ICR7Zm10fWAsIHRleHQsIHNwZWNpZmljT2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXQgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcodGV4dCwgZm10LCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUZvcm1hdCh0ZXh0LCBmbXQsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBTUUwgZGF0ZSwgdGltZSwgb3IgZGF0ZXRpbWVcbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gdXNlIHRoaXMgem9uZSBpZiBubyBvZmZzZXQgaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBzdHJpbmcgaXRzZWxmLiBXaWxsIGFsc28gY29udmVydCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyB6b25lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIGEgbG9jYWxlIHN0cmluZyB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSBEYXRlVGltZSB0byB0aGlzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2Ugd2hlbiBwYXJzaW5nLiBXaWxsIGFsc28gc2V0IHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgdG8gdGhpcyBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1JylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIrMDY6MDAnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MiBBbWVyaWNhL0xvc19BbmdlbGVzJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIgQW1lcmljYS9Mb3NfQW5nZWxlcycsIHsgc2V0Wm9uZTogdHJ1ZSB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MicsIHsgem9uZTogJ0FtZXJpY2EvTG9zX0FuZ2VsZXMnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzA5OjEyOjM0LjM0MicpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21TUUwodGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VTUUwodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJTUUxcIiwgdGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIERhdGVUaW1lIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24gPSBudWxsKSB7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm5lZWQgdG8gc3BlY2lmeSBhIHJlYXNvbiB0aGUgRGF0ZVRpbWUgaXMgaW52YWxpZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGVUaW1lRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoeyBpbnZhbGlkIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYSBEYXRlVGltZS4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRGF0ZVRpbWUobykge1xuICAgIHJldHVybiAobyAmJiBvLmlzTHV4b25EYXRlVGltZSkgfHwgZmFsc2U7XG4gIH1cblxuICAvLyBJTkZPXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlJyBvciAnZGF5J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA3LCA0KS5nZXQoJ21vbnRoJyk7IC8vPT4gN1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA3LCA0KS5nZXQoJ2RheScpOyAvLz0+IDRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0KHVuaXQpIHtcbiAgICByZXR1cm4gdGhpc1t1bml0XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIERhdGVUaW1lIGlzIHZhbGlkLiBJbnZhbGlkIERhdGVUaW1lcyBvY2N1ciB3aGVuOlxuICAgKiAqIFRoZSBEYXRlVGltZSB3YXMgY3JlYXRlZCBmcm9tIGludmFsaWQgY2FsZW5kYXIgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIDEzdGggbW9udGggb3IgRmVicnVhcnkgMzBcbiAgICogKiBUaGUgRGF0ZVRpbWUgd2FzIGNyZWF0ZWQgYnkgYW4gb3BlcmF0aW9uIG9uIGFub3RoZXIgaW52YWxpZCBkYXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGNvZGUgaWYgdGhpcyBEYXRlVGltZSBpcyBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEYXRlVGltZSBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgRGF0ZVRpbWUgYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIERhdGVUaW1lIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZEV4cGxhbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbG9jYWxlIG9mIGEgRGF0ZVRpbWUsIHN1Y2ggJ2VuLUdCJy4gVGhlIGxvY2FsZSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRGF0ZVRpbWVcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBsb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLmxvY2FsZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXJpbmcgc3lzdGVtIG9mIGEgRGF0ZVRpbWUsIHN1Y2ggJ2JlbmcnLiBUaGUgbnVtYmVyaW5nIHN5c3RlbSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRGF0ZVRpbWVcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBudW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvdXRwdXQgY2FsZW5kYXIgb2YgYSBEYXRlVGltZSwgc3VjaCAnaXNsYW1pYycuIFRoZSBvdXRwdXQgY2FsZW5kYXIgaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgb3V0cHV0Q2FsZW5kYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm91dHB1dENhbGVuZGFyIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRpbWUgem9uZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBEYXRlVGltZS5cbiAgICogQHR5cGUge1pvbmV9XG4gICAqL1xuICBnZXQgem9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fem9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWUgb2YgdGhlIHRpbWUgem9uZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB6b25lTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy56b25lLm5hbWUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgeWVhclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkueWVhciAvLz0+IDIwMTdcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB5ZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMueWVhciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHF1YXJ0ZXJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnF1YXJ0ZXIgLy89PiAyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgcXVhcnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gTWF0aC5jZWlsKHRoaXMuYy5tb250aCAvIDMpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9udGggKDEtMTIpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkubW9udGggLy89PiA1XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbW9udGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5tb250aCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBvZiB0aGUgbW9udGggKDEtMzBpc2gpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkuZGF5IC8vPT4gMjVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5kYXkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBob3VyIG9mIHRoZSBkYXkgKDAtMjMpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSkuaG91ciAvLz0+IDlcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBob3VyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMuaG91ciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbnV0ZSBvZiB0aGUgaG91ciAoMC01OSkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5LCAzMCkubWludXRlIC8vPT4gMzBcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaW51dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5taW51dGUgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSAoMC01OSkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5LCAzMCwgNTIpLnNlY29uZCAvLz0+IDUyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMuc2Vjb25kIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCAoMC05OTkpLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzAsIDUyLCA2NTQpLm1pbGxpc2Vjb25kIC8vPT4gNjU0XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWlsbGlzZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5taWxsaXNlY29uZCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWsgeWVhclxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMTIsIDMxKS53ZWVrWWVhciAvLz0+IDIwMTVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrWWVhciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdlZWsgbnVtYmVyIG9mIHRoZSB3ZWVrIHllYXIgKDEtNTJpc2gpLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLndlZWtOdW1iZXIgLy89PiAyMVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEodGhpcykud2Vla051bWJlciA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRheSBvZiB0aGUgd2Vlay5cbiAgICogMSBpcyBNb25kYXkgYW5kIDcgaXMgU3VuZGF5XG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAxMSwgMzEpLndlZWtkYXkgLy89PiA0XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla2RheSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrZGF5IDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3JkaW5hbCAobWVhbmluZyB0aGUgZGF5IG9mIHRoZSB5ZWFyKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkub3JkaW5hbCAvLz0+IDE0NVxuICAgKiBAdHlwZSB7bnVtYmVyfERhdGVUaW1lfVxuICAgKi9cbiAgZ2V0IG9yZGluYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IGdyZWdvcmlhblRvT3JkaW5hbCh0aGlzLmMpLm9yZGluYWwgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBzaG9ydCBtb250aCBuYW1lLCBzdWNoIGFzICdPY3QnLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS5tb250aFNob3J0IC8vPT4gT2N0XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbW9udGhTaG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby5tb250aHMoXCJzaG9ydFwiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy5tb250aCAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIGxvbmcgbW9udGggbmFtZSwgc3VjaCBhcyAnT2N0b2JlcicuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLm1vbnRoTG9uZyAvLz0+IE9jdG9iZXJcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBtb250aExvbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ubW9udGhzKFwibG9uZ1wiLCB7IGxvY09iajogdGhpcy5sb2MgfSlbdGhpcy5tb250aCAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIHNob3J0IHdlZWtkYXksIHN1Y2ggYXMgJ01vbicuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLndlZWtkYXlTaG9ydCAvLz0+IE1vblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHdlZWtkYXlTaG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby53ZWVrZGF5cyhcInNob3J0XCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLndlZWtkYXkgLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBodW1hbiByZWFkYWJsZSBsb25nIHdlZWtkYXksIHN1Y2ggYXMgJ01vbmRheScuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLndlZWtkYXlMb25nIC8vPT4gTW9uZGF5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgd2Vla2RheUxvbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ud2Vla2RheXMoXCJsb25nXCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLndlZWtkYXkgLSAxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBVVEMgb2Zmc2V0IG9mIHRoaXMgRGF0ZVRpbWUgaW4gbWludXRlc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5vZmZzZXQgLy89PiAtMjQwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLm9mZnNldCAvLz0+IDBcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/ICt0aGlzLm8gOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaG9ydCBodW1hbiBuYW1lIGZvciB0aGUgem9uZSdzIGN1cnJlbnQgb2Zmc2V0LCBmb3IgZXhhbXBsZSBcIkVTVFwiIG9yIFwiRURUXCIuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG9mZnNldE5hbWVTaG9ydCgpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy56b25lLm9mZnNldE5hbWUodGhpcy50cywge1xuICAgICAgICBmb3JtYXQ6IFwic2hvcnRcIixcbiAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsb25nIGh1bWFuIG5hbWUgZm9yIHRoZSB6b25lJ3MgY3VycmVudCBvZmZzZXQsIGZvciBleGFtcGxlIFwiRWFzdGVybiBTdGFuZGFyZCBUaW1lXCIgb3IgXCJFYXN0ZXJuIERheWxpZ2h0IFRpbWVcIi5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgb2Zmc2V0TmFtZUxvbmcoKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuem9uZS5vZmZzZXROYW1lKHRoaXMudHMsIHtcbiAgICAgICAgZm9ybWF0OiBcImxvbmdcIixcbiAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgdGhpcyB6b25lJ3Mgb2Zmc2V0IGV2ZXIgY2hhbmdlcywgYXMgaW4gYSBEU1QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzT2Zmc2V0Rml4ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuem9uZS5pc1VuaXZlcnNhbCA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgdGhlIERhdGVUaW1lIGlzIGluIGEgRFNULlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc0luRFNUKCkge1xuICAgIGlmICh0aGlzLmlzT2Zmc2V0Rml4ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5vZmZzZXQgPiB0aGlzLnNldCh7IG1vbnRoOiAxIH0pLm9mZnNldCB8fCB0aGlzLm9mZnNldCA+IHRoaXMuc2V0KHsgbW9udGg6IDUgfSkub2Zmc2V0XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBEYXRlVGltZSBpcyBpbiBhIGxlYXAgeWVhciwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYpLmlzSW5MZWFwWWVhciAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykuaXNJbkxlYXBZZWFyIC8vPT4gZmFsc2VcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNJbkxlYXBZZWFyKCkge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhpcyBEYXRlVGltZSdzIG1vbnRoXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYsIDIpLmRheXNJbk1vbnRoIC8vPT4gMjlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNiwgMykuZGF5c0luTW9udGggLy89PiAzMVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXNJbk1vbnRoKCkge1xuICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIsIHRoaXMubW9udGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoaXMgRGF0ZVRpbWUncyB5ZWFyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYpLmRheXNJblllYXIgLy89PiAzNjZcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykuZGF5c0luWWVhciAvLz0+IDM2NVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheXNJblllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IGRheXNJblllYXIodGhpcy55ZWFyKSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygd2Vla3MgaW4gdGhpcyBEYXRlVGltZSdzIHllYXJcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMDQpLndlZWtzSW5XZWVrWWVhciAvLz0+IDUzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLndlZWtzSW5XZWVrWWVhciAvLz0+IDUyXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla3NJbldlZWtZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB3ZWVrc0luV2Vla1llYXIodGhpcy53ZWVrWWVhcikgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVzb2x2ZWQgSW50bCBvcHRpb25zIGZvciB0aGlzIERhdGVUaW1lLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBpbiB1bmRlcnN0YW5kaW5nIHRoZSBiZWhhdmlvciBvZiBmb3JtYXR0aW5nIG1ldGhvZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSB0aGUgc2FtZSBvcHRpb25zIGFzIHRvTG9jYWxlU3RyaW5nXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHJlc29sdmVkTG9jYWxlT3B0aW9ucyhvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBjYWxlbmRhciB9ID0gRm9ybWF0dGVyLmNyZWF0ZShcbiAgICAgIHRoaXMubG9jLmNsb25lKG9wdHMpLFxuICAgICAgb3B0c1xuICAgICkucmVzb2x2ZWRPcHRpb25zKHRoaXMpO1xuICAgIHJldHVybiB7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcjogY2FsZW5kYXIgfTtcbiAgfVxuXG4gIC8vIFRSQU5TRk9STVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gVVRDLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8ge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9KCd1dGMnKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIG9wdGlvbmFsbHksIGFuIG9mZnNldCBmcm9tIFVUQyBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV0gLSBvcHRpb25zIHRvIHBhc3MgdG8gYHNldFpvbmUoKWBcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICB0b1VUQyhvZmZzZXQgPSAwLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5zZXRab25lKEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShvZmZzZXQpLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gdGhlIGhvc3QncyBsb2NhbCB6b25lLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8gYHNldFpvbmUoJ2xvY2FsJylgXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgdG9Mb2NhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRab25lKFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gc3BlY2lmaWVkIHpvbmUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHNldHRlciBrZWVwcyB0aGUgdW5kZXJseWluZyB0aW1lIHRoZSBzYW1lIChhcyBpbiwgdGhlIHNhbWUgdGltZXN0YW1wKSwgYnV0IHRoZSBuZXcgaW5zdGFuY2Ugd2lsbCByZXBvcnQgZGlmZmVyZW50IGxvY2FsIHRpbWVzIGFuZCBjb25zaWRlciBEU1RzIHdoZW4gbWFraW5nIGNvbXB1dGF0aW9ucywgYXMgd2l0aCB7QGxpbmsgRGF0ZVRpbWUjcGx1c30uIFlvdSBtYXkgd2lzaCB0byB1c2Uge0BsaW5rIERhdGVUaW1lI3RvTG9jYWx9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9VVEN9IHdoaWNoIHByb3ZpZGUgc2ltcGxlIGNvbnZlbmllbmNlIHdyYXBwZXJzIGZvciBjb21tb25seSB1c2VkIHpvbmVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbem9uZT0nbG9jYWwnXSAtIGEgem9uZSBpZGVudGlmaWVyLiBBcyBhIHN0cmluZywgdGhhdCBjYW4gYmUgYW55IElBTkEgem9uZSBzdXBwb3J0ZWQgYnkgdGhlIGhvc3QgZW52aXJvbm1lbnQsIG9yIGEgZml4ZWQtb2Zmc2V0IG5hbWUgb2YgdGhlIGZvcm0gJ1VUQyszJywgb3IgdGhlIHN0cmluZ3MgJ2xvY2FsJyBvciAndXRjJy4gWW91IG1heSBhbHNvIHN1cHBseSBhbiBpbnN0YW5jZSBvZiBhIHtAbGluayBEYXRlVGltZSNab25lfSBjbGFzcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMua2VlcExvY2FsVGltZT1mYWxzZV0gLSBJZiB0cnVlLCBhZGp1c3QgdGhlIHVuZGVybHlpbmcgdGltZSBzbyB0aGF0IHRoZSBsb2NhbCB0aW1lIHN0YXlzIHRoZSBzYW1lLCBidXQgaW4gdGhlIHRhcmdldCB6b25lLiBZb3Ugc2hvdWxkIHJhcmVseSBuZWVkIHRoaXMuXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc2V0Wm9uZSh6b25lLCB7IGtlZXBMb2NhbFRpbWUgPSBmYWxzZSwga2VlcENhbGVuZGFyVGltZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIHpvbmUgPSBub3JtYWxpemVab25lKHpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgICBpZiAoem9uZS5lcXVhbHModGhpcy56b25lKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICghem9uZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZCh1bnN1cHBvcnRlZFpvbmUoem9uZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmV3VFMgPSB0aGlzLnRzO1xuICAgICAgaWYgKGtlZXBMb2NhbFRpbWUgfHwga2VlcENhbGVuZGFyVGltZSkge1xuICAgICAgICBjb25zdCBvZmZzZXRHdWVzcyA9IHpvbmUub2Zmc2V0KHRoaXMudHMpO1xuICAgICAgICBjb25zdCBhc09iaiA9IHRoaXMudG9PYmplY3QoKTtcbiAgICAgICAgW25ld1RTXSA9IG9ialRvVFMoYXNPYmosIG9mZnNldEd1ZXNzLCB6b25lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHRzOiBuZXdUUywgem9uZSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG9yIG91dHB1dENhbGVuZGFyLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gdGhlIHByb3BlcnRpZXMgdG8gc2V0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5yZWNvbmZpZ3VyZSh7IGxvY2FsZTogJ2VuLUdCJyB9KVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHJlY29uZmlndXJlKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0gPSB7fSkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMubG9jLmNsb25lKHsgbG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyIH0pO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IGxvYyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogSnVzdCBhIGNvbnZlbmllbnQgYWxpYXMgZm9yIHJlY29uZmlndXJlKHsgbG9jYWxlIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5zZXRMb2NhbGUoJ2VuLUdCJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzZXRMb2NhbGUobG9jYWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb25maWd1cmUoeyBsb2NhbGUgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgdmFsdWVzIG9mIHNwZWNpZmllZCB1bml0cy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKiBZb3UgY2FuIG9ubHkgc2V0IHVuaXRzIHdpdGggdGhpcyBtZXRob2Q7IGZvciBcInNldHRpbmdcIiBtZXRhZGF0YSwgc2VlIHtAbGluayBEYXRlVGltZSNyZWNvbmZpZ3VyZX0gYW5kIHtAbGluayBEYXRlVGltZSNzZXRab25lfS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIGEgbWFwcGluZyBvZiB1bml0cyB0byBudW1iZXJzXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHllYXI6IDIwMTcgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgaG91cjogOCwgbWludXRlOiAzMCB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyB3ZWVrZGF5OiA1IH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHllYXI6IDIwMDUsIG9yZGluYWw6IDIzNCB9KVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHNldCh2YWx1ZXMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplT2JqZWN0KHZhbHVlcywgbm9ybWFsaXplVW5pdCksXG4gICAgICBzZXR0aW5nV2Vla1N0dWZmID1cbiAgICAgICAgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla1llYXIpIHx8XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtOdW1iZXIpIHx8XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtkYXkpLFxuICAgICAgY29udGFpbnNPcmRpbmFsID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQub3JkaW5hbCksXG4gICAgICBjb250YWluc0dyZWdvclllYXIgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC55ZWFyKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yTUQgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5tb250aCkgfHwgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yID0gY29udGFpbnNHcmVnb3JZZWFyIHx8IGNvbnRhaW5zR3JlZ29yTUQsXG4gICAgICBkZWZpbml0ZVdlZWtEZWYgPSBub3JtYWxpemVkLndlZWtZZWFyIHx8IG5vcm1hbGl6ZWQud2Vla051bWJlcjtcblxuICAgIGlmICgoY29udGFpbnNHcmVnb3IgfHwgY29udGFpbnNPcmRpbmFsKSAmJiBkZWZpbml0ZVdlZWtEZWYpIHtcbiAgICAgIHRocm93IG5ldyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcihcbiAgICAgICAgXCJDYW4ndCBtaXggd2Vla1llYXIvd2Vla051bWJlciB1bml0cyB3aXRoIHllYXIvbW9udGgvZGF5IG9yIG9yZGluYWxzXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5zR3JlZ29yTUQgJiYgY29udGFpbnNPcmRpbmFsKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXCJDYW4ndCBtaXggb3JkaW5hbCBkYXRlcyB3aXRoIG1vbnRoL2RheVwiKTtcbiAgICB9XG5cbiAgICBsZXQgbWl4ZWQ7XG4gICAgaWYgKHNldHRpbmdXZWVrU3R1ZmYpIHtcbiAgICAgIG1peGVkID0gd2Vla1RvR3JlZ29yaWFuKHsgLi4uZ3JlZ29yaWFuVG9XZWVrKHRoaXMuYyksIC4uLm5vcm1hbGl6ZWQgfSk7XG4gICAgfSBlbHNlIGlmICghaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSkge1xuICAgICAgbWl4ZWQgPSBvcmRpbmFsVG9HcmVnb3JpYW4oeyAuLi5ncmVnb3JpYW5Ub09yZGluYWwodGhpcy5jKSwgLi4ubm9ybWFsaXplZCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWl4ZWQgPSB7IC4uLnRoaXMudG9PYmplY3QoKSwgLi4ubm9ybWFsaXplZCB9O1xuXG4gICAgICAvLyBpZiB3ZSBkaWRuJ3Qgc2V0IHRoZSBkYXkgYnV0IHdlIGVuZGVkIHVwIG9uIGFuIG92ZXJmbG93IGRhdGUsXG4gICAgICAvLyB1c2UgdGhlIGxhc3QgZGF5IG9mIHRoZSByaWdodCBtb250aFxuICAgICAgaWYgKGlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSkge1xuICAgICAgICBtaXhlZC5kYXkgPSBNYXRoLm1pbihkYXlzSW5Nb250aChtaXhlZC55ZWFyLCBtaXhlZC5tb250aCksIG1peGVkLmRheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgW3RzLCBvXSA9IG9ialRvVFMobWl4ZWQsIHRoaXMubywgdGhpcy56b25lKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB0cywgbyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBwZXJpb2Qgb2YgdGltZSB0byB0aGlzIERhdGVUaW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBEYXRlVGltZVxuICAgKlxuICAgKiBBZGRpbmcgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG9yIG1pbGxpc2Vjb25kcyBpbmNyZWFzZXMgdGhlIHRpbWVzdGFtcCBieSB0aGUgcmlnaHQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy4gQWRkaW5nIGRheXMsIG1vbnRocywgb3IgeWVhcnMgc2hpZnRzIHRoZSBjYWxlbmRhciwgYWNjb3VudGluZyBmb3IgRFNUcyBhbmQgbGVhcCB5ZWFycyBhbG9uZyB0aGUgd2F5LiBUaHVzLCBgZHQucGx1cyh7IGhvdXJzOiAyNCB9KWAgbWF5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0aW1lIHRoYW4gYGR0LnBsdXMoeyBkYXlzOiAxIH0pYCBpZiB0aGVyZSdzIGEgRFNUIHNoaWZ0IGluIGJldHdlZW4uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIGFkZC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cygxMjMpIC8vfj4gaW4gMTIzIG1pbGxpc2Vjb25kc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgbWludXRlczogMTUgfSkgLy9+PiBpbiAxNSBtaW51dGVzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pIC8vfj4gdGhpcyB0aW1lIHRvbW9ycm93XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAtMSB9KSAvL34+IHRoaXMgdGltZSB5ZXN0ZXJkYXlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGhvdXJzOiAzLCBtaW51dGVzOiAxMyB9KSAvL34+IGluIDMgaHIsIDEzIG1pblxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMywgbWludXRlczogMTMgfSkpIC8vfj4gaW4gMyBociwgMTMgbWluXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgcGx1cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgYWRqdXN0VGltZSh0aGlzLCBkdXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdCBhIHBlcmlvZCBvZiB0aW1lIHRvIHRoaXMgRGF0ZVRpbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lXG4gICAqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjcGx1c31cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIG1pbnVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGR1ciA9IER1cmF0aW9uLmZyb21EdXJhdGlvbkxpa2UoZHVyYXRpb24pLm5lZ2F0ZSgpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCBhZGp1c3RUaW1lKHRoaXMsIGR1cikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhpcyBEYXRlVGltZSB0byB0aGUgYmVnaW5uaW5nIG9mIGEgdW5pdCBvZiB0aW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIFRoZSB1bml0IHRvIGdvIHRvIHRoZSBiZWdpbm5pbmcgb2YuIENhbiBiZSAneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsIG9yICdtaWxsaXNlY29uZCcuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ21vbnRoJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDMtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ3llYXInKS50b0lTT0RhdGUoKTsgLy89PiAnMjAxNC0wMS0wMSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuc3RhcnRPZignd2VlaycpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAzLTAzJywgd2Vla3MgYWx3YXlzIHN0YXJ0IG9uIE1vbmRheXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLnN0YXJ0T2YoJ2RheScpLnRvSVNPVGltZSgpOyAvLz0+ICcwMDowMC4wMDAtMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5zdGFydE9mKCdob3VyJykudG9JU09UaW1lKCk7IC8vPT4gJzA1OjAwOjAwLjAwMC0wNTowMCdcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGFydE9mKHVuaXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgbyA9IHt9LFxuICAgICAgbm9ybWFsaXplZFVuaXQgPSBEdXJhdGlvbi5ub3JtYWxpemVVbml0KHVuaXQpO1xuICAgIHN3aXRjaCAobm9ybWFsaXplZFVuaXQpIHtcbiAgICAgIGNhc2UgXCJ5ZWFyc1wiOlxuICAgICAgICBvLm1vbnRoID0gMTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJxdWFydGVyc1wiOlxuICAgICAgY2FzZSBcIm1vbnRoc1wiOlxuICAgICAgICBvLmRheSA9IDE7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwid2Vla3NcIjpcbiAgICAgIGNhc2UgXCJkYXlzXCI6XG4gICAgICAgIG8uaG91ciA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwiaG91cnNcIjpcbiAgICAgICAgby5taW51dGUgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcIm1pbnV0ZXNcIjpcbiAgICAgICAgby5zZWNvbmQgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcInNlY29uZHNcIjpcbiAgICAgICAgby5taWxsaXNlY29uZCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pbGxpc2Vjb25kc1wiOlxuICAgICAgICBicmVhaztcbiAgICAgIC8vIG5vIGRlZmF1bHQsIGludmFsaWQgdW5pdHMgdGhyb3cgaW4gbm9ybWFsaXplVW5pdCgpXG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcIndlZWtzXCIpIHtcbiAgICAgIG8ud2Vla2RheSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcInF1YXJ0ZXJzXCIpIHtcbiAgICAgIGNvbnN0IHEgPSBNYXRoLmNlaWwodGhpcy5tb250aCAvIDMpO1xuICAgICAgby5tb250aCA9IChxIC0gMSkgKiAzICsgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQobyk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGlzIERhdGVUaW1lIHRvIHRoZSBlbmQgKG1lYW5pbmcgdGhlIGxhc3QgbWlsbGlzZWNvbmQpIG9mIGEgdW5pdCBvZiB0aW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gVGhlIHVuaXQgdG8gZ28gdG8gdGhlIGVuZCBvZi4gQ2FuIGJlICd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgb3IgJ21pbGxpc2Vjb25kJy5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ21vbnRoJykudG9JU08oKTsgLy89PiAnMjAxNC0wMy0zMVQyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCd5ZWFyJykudG9JU08oKTsgLy89PiAnMjAxNC0xMi0zMVQyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCd3ZWVrJykudG9JU08oKTsgLy8gPT4gJzIwMTQtMDMtMDlUMjM6NTk6NTkuOTk5LTA1OjAwJywgd2Vla3Mgc3RhcnQgb24gTW9uZGF5c1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuZW5kT2YoJ2RheScpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMDNUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuZW5kT2YoJ2hvdXInKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTAzVDA1OjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBlbmRPZih1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFxuICAgICAgPyB0aGlzLnBsdXMoeyBbdW5pdF06IDEgfSlcbiAgICAgICAgICAuc3RhcnRPZih1bml0KVxuICAgICAgICAgIC5taW51cygxKVxuICAgICAgOiB0aGlzO1xuICB9XG5cbiAgLy8gT1VUUFVUXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgZm9ybWF0IHN0cmluZy5cbiAgICogKipZb3UgbWF5IG5vdCB3YW50IHRoaXMuKiogU2VlIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9yIGEgbW9yZSBmbGV4aWJsZSBmb3JtYXR0aW5nIHRvb2wuIEZvciBhIHRhYmxlIG9mIHRva2VucyBhbmQgdGhlaXIgaW50ZXJwcmV0YXRpb25zLCBzZWUgW2hlcmVdKGh0dHBzOi8vbW9tZW50LmdpdGh1Yi5pby9sdXhvbi8jL2Zvcm1hdHRpbmc/aWQ9dGFibGUtb2YtdG9rZW5zKS5cbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRzIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb24gdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnKSAvLz0+ICcyMDE3IEFwciAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKCdmcicpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcpIC8vPT4gJzIwMTcgYXZyLiAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJywgeyBsb2NhbGU6IFwiZnJcIiB9KSAvLz0+ICcyMDE3IGF2ci4gMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KFwiSEggJ2hvdXJzIGFuZCcgbW0gJ21pbnV0ZXMnXCIpIC8vPT4gJzIwIGhvdXJzIGFuZCA1NSBtaW51dGVzJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdChmbXQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5yZWRlZmF1bHRUb0VOKG9wdHMpKS5mb3JtYXREYXRlVGltZUZyb21TdHJpbmcodGhpcywgZm10KVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIGRhdGUuIEFjY2VwdHMgdGhlIHNhbWUgb3B0aW9ucyBhcyB0aGUgSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBhbmQgYW55IHByZXNldHMgZGVmaW5lZCBieSBMdXhvbiwgc3VjaCBhcyBgRGF0ZVRpbWUuREFURV9GVUxMYCBvciBgRGF0ZVRpbWUuVElNRV9TSU1QTEVgLlxuICAgKiBUaGUgZXhhY3QgYmVoYXZpb3Igb2YgdGhpcyBtZXRob2QgaXMgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGluIGdlbmVyYWwgaXQgd2lsbCByZXR1cm4gYW4gYXBwcm9wcmlhdGUgcmVwcmVzZW50YXRpb25cbiAgICogb2YgdGhlIERhdGVUaW1lIGluIHRoZSBhc3NpZ25lZCBsb2NhbGUuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSBmb3JtYXRPcHRzIHtPYmplY3R9IC0gSW50bC5EYXRlVGltZUZvcm1hdCBjb25zdHJ1Y3RvciBvcHRpb25zIGFuZCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRzIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb24gdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZygpOyAvLz0+IDQvMjAvMjAxN1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5zZXRMb2NhbGUoJ2VuLWdiJykudG9Mb2NhbGVTdHJpbmcoKTsgLy89PiAnMjAvMDQvMjAxNydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyBsb2NhbGU6ICdlbi1nYicgfSk7IC8vPT4gJzIwLzA0LzIwMTcnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCk7IC8vPT4gJ0FwcmlsIDIwLCAyMDE3J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5USU1FX1NJTVBMRSk7IC8vPT4gJzExOjMyIEFNJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFVElNRV9TSE9SVCk7IC8vPT4gJzQvMjAvMjAxNywgMTE6MzIgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgd2Vla2RheTogJ2xvbmcnLCBtb250aDogJ2xvbmcnLCBkYXk6ICcyLWRpZ2l0JyB9KTsgLy89PiAnVGh1cnNkYXksIEFwcmlsIDIwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyh7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICcyLWRpZ2l0JywgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JyB9KTsgLy89PiAnVGh1LCBBcHIgMjAsIDExOjI3IEFNJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyh7IGhvdXI6ICcyLWRpZ2l0JywgbWludXRlOiAnMi1kaWdpdCcsIGhvdXJDeWNsZTogJ2gyMycgfSk7IC8vPT4gJzExOjMyJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0xvY2FsZVN0cmluZyhmb3JtYXRPcHRzID0gRm9ybWF0cy5EQVRFX1NIT1JULCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MuY2xvbmUob3B0cyksIGZvcm1hdE9wdHMpLmZvcm1hdERhdGVUaW1lKHRoaXMpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBmb3JtYXQgXCJwYXJ0c1wiLCBtZWFuaW5nIGluZGl2aWR1YWwgdG9rZW5zIGFsb25nIHdpdGggbWV0YWRhdGEuIFRoaXMgaXMgYWxsb3dzIGNhbGxlcnMgdG8gcG9zdC1wcm9jZXNzIGluZGl2aWR1YWwgc2VjdGlvbnMgb2YgdGhlIGZvcm1hdHRlZCBvdXRwdXQuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0L2Zvcm1hdFRvUGFydHNcbiAgICogQHBhcmFtIG9wdHMge09iamVjdH0gLSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIG9wdGlvbnMsIHNhbWUgYXMgYHRvTG9jYWxlU3RyaW5nYC5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVQYXJ0cygpOyAvLz0+IFtcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdkYXknLCB2YWx1ZTogJzI1JyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogJy8nIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbW9udGgnLCB2YWx1ZTogJzA1JyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogJy8nIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAneWVhcicsIHZhbHVlOiAnMTk4MicgfVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiBdXG4gICAqL1xuICB0b0xvY2FsZVBhcnRzKG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5jbG9uZShvcHRzKSwgb3B0cykuZm9ybWF0RGF0ZVRpbWVQYXJ0cyh0aGlzKVxuICAgICAgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgzLCA1LCAyNSkudG9JU08oKSAvLz0+ICcxOTgyLTA1LTI1VDAwOjAwOjAwLjAwMFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKCkgLy89PiAnMjAxNy0wNC0yMlQyMDo0NzowNS4zMzUtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNy0wNC0yMlQyMDo0NzowNS4zMzUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzIwMTcwNDIyVDIwNDcwNS4zMzUtMDQwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU08oe1xuICAgIGZvcm1hdCA9IFwiZXh0ZW5kZWRcIixcbiAgICBzdXBwcmVzc1NlY29uZHMgPSBmYWxzZSxcbiAgICBzdXBwcmVzc01pbGxpc2Vjb25kcyA9IGZhbHNlLFxuICAgIGluY2x1ZGVPZmZzZXQgPSB0cnVlLFxuICB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZXh0ID0gZm9ybWF0ID09PSBcImV4dGVuZGVkXCI7XG5cbiAgICBsZXQgYyA9IHRvSVNPRGF0ZSh0aGlzLCBleHQpO1xuICAgIGMgKz0gXCJUXCI7XG4gICAgYyArPSB0b0lTT1RpbWUodGhpcywgZXh0LCBzdXBwcmVzc1NlY29uZHMsIHN1cHByZXNzTWlsbGlzZWNvbmRzLCBpbmNsdWRlT2Zmc2V0KTtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIGRhdGUgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODIsIDUsIDI1KS50b0lTT0RhdGUoKSAvLz0+ICcxOTgyLTA1LTI1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPRGF0ZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcxOTgyMDUyNSdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09EYXRlKHsgZm9ybWF0ID0gXCJleHRlbmRlZFwiIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9JU09EYXRlKHRoaXMsIGZvcm1hdCA9PT0gXCJleHRlbmRlZFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIHdlZWsgZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPV2Vla0RhdGUoKSAvLz0+ICcxOTgyLVcyMS0yJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1dlZWtEYXRlKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgXCJra2trLSdXJ1dXLWNcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUncyB0aW1lIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlUHJlZml4PWZhbHNlXSAtIGluY2x1ZGUgdGhlIGBUYCBwcmVmaXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKCkgLy89PiAnMDc6MzQ6MTkuMzYxWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCwgc2Vjb25kczogMCwgbWlsbGlzZWNvbmRzOiAwIH0pLnRvSVNPVGltZSh7IHN1cHByZXNzU2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcwNzozNFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzA3MzQxOS4zNjFaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSh7IGluY2x1ZGVQcmVmaXg6IHRydWUgfSkgLy89PiAnVDA3OjM0OjE5LjM2MVonXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZSh7XG4gICAgc3VwcHJlc3NNaWxsaXNlY29uZHMgPSBmYWxzZSxcbiAgICBzdXBwcmVzc1NlY29uZHMgPSBmYWxzZSxcbiAgICBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSxcbiAgICBpbmNsdWRlUHJlZml4ID0gZmFsc2UsXG4gICAgZm9ybWF0ID0gXCJleHRlbmRlZFwiLFxuICB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGMgPSBpbmNsdWRlUHJlZml4ID8gXCJUXCIgOiBcIlwiO1xuICAgIHJldHVybiAoXG4gICAgICBjICtcbiAgICAgIHRvSVNPVGltZSh0aGlzLCBmb3JtYXQgPT09IFwiZXh0ZW5kZWRcIiwgc3VwcHJlc3NTZWNvbmRzLCBzdXBwcmVzc01pbGxpc2Vjb25kcywgaW5jbHVkZU9mZnNldClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gUkZDIDI4MjItY29tcGF0aWJsZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvUkZDMjgyMigpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMDA6MDA6MDAgKzAwMDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1JGQzI4MjIoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwIC0wNDAwJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1JGQzI4MjIoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBcIkVFRSwgZGQgTExMIHl5eXkgSEg6bW06c3MgWlpaXCIsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBIVFRQIGhlYWRlcnMuIFRoZSBvdXRwdXQgaXMgYWx3YXlzIGV4cHJlc3NlZCBpbiBHTVQuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHN0cmluZyBjb25mb3JtcyB0byBSRkMgMTEyMy5cbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWMzLmh0bWwjc2VjMy4zLjFcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b0hUVFAoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwIEdNVCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzLCAxOSkudG9IVFRQKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAxOTowMDowMCBHTVQnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSFRUUCgpIHtcbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMudG9VVEMoKSwgXCJFRUUsIGRkIExMTCB5eXl5IEhIOm1tOnNzICdHTVQnXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBEYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9TUUxEYXRlKCkgLy89PiAnMjAxNC0wNy0xMydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TUUxEYXRlKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRvSVNPRGF0ZSh0aGlzLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlWm9uZT1mYWxzZV0gLSBpbmNsdWRlIHRoZSB6b25lLCBzdWNoIGFzICdBbWVyaWNhL05ld19Zb3JrJy4gT3ZlcnJpZGVzIGluY2x1ZGVPZmZzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkudG9TUUwoKSAvLz0+ICcwNToxNToxNi4zNDUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvU1FMKCkgLy89PiAnMDU6MTU6MTYuMzQ1IC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoeyBpbmNsdWRlT2Zmc2V0OiBmYWxzZSB9KSAvLz0+ICcwNToxNToxNi4zNDUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvU1FMKHsgaW5jbHVkZVpvbmU6IGZhbHNlIH0pIC8vPT4gJzA1OjE1OjE2LjM0NSBBbWVyaWNhL05ld19Zb3JrJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1NRTFRpbWUoeyBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSwgaW5jbHVkZVpvbmUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBsZXQgZm10ID0gXCJISDptbTpzcy5TU1NcIjtcblxuICAgIGlmIChpbmNsdWRlWm9uZSB8fCBpbmNsdWRlT2Zmc2V0KSB7XG4gICAgICBmbXQgKz0gXCIgXCI7XG4gICAgICBpZiAoaW5jbHVkZVpvbmUpIHtcbiAgICAgICAgZm10ICs9IFwielwiO1xuICAgICAgfSBlbHNlIGlmIChpbmNsdWRlT2Zmc2V0KSB7XG4gICAgICAgIGZtdCArPSBcIlpaXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBmbXQsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBEYXRlVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlWm9uZT1mYWxzZV0gLSBpbmNsdWRlIHRoZSB6b25lLCBzdWNoIGFzICdBbWVyaWNhL05ld19Zb3JrJy4gT3ZlcnJpZGVzIGluY2x1ZGVPZmZzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvU1FMKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCh7IGluY2x1ZGVab25lOiB0cnVlIH0pIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIEFtZXJpY2EvTmV3X1lvcmsnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU1FMKG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7dGhpcy50b1NRTERhdGUoKX0gJHt0aGlzLnRvU1FMVGltZShvcHRzKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgZGVidWdnaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRvSVNPKCkgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIG1pbGxpc2Vjb25kcyBvZiB0aGlzIERhdGVUaW1lLiBBbGlhcyBvZiB7QGxpbmsgRGF0ZVRpbWUjdG9NaWxsaXN9XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9NaWxsaXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBtaWxsaXNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9NaWxsaXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggc2Vjb25kcyBvZiB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b1NlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgLyAxMDAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIEpTT04uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0lTTygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBCU09OIHNlcmlhbGl6YWJsZSBlcXVpdmFsZW50IHRvIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge0RhdGV9XG4gICAqL1xuICB0b0JTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9KU0RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCB0aGlzIERhdGVUaW1lJ3MgeWVhciwgbW9udGgsIGRheSwgYW5kIHNvIG9uLlxuICAgKiBAcGFyYW0gb3B0cyAtIG9wdGlvbnMgZm9yIGdlbmVyYXRpbmcgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVDb25maWc9ZmFsc2VdIC0gaW5jbHVkZSBjb25maWd1cmF0aW9uIGF0dHJpYnV0ZXMgaW4gdGhlIG91dHB1dFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b09iamVjdCgpIC8vPT4geyB5ZWFyOiAyMDE3LCBtb250aDogNCwgZGF5OiAyMiwgaG91cjogMjAsIG1pbnV0ZTogNDksIHNlY29uZDogNDIsIG1pbGxpc2Vjb25kOiAyNjggfVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b09iamVjdChvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHt9O1xuXG4gICAgY29uc3QgYmFzZSA9IHsgLi4udGhpcy5jIH07XG5cbiAgICBpZiAob3B0cy5pbmNsdWRlQ29uZmlnKSB7XG4gICAgICBiYXNlLm91dHB1dENhbGVuZGFyID0gdGhpcy5vdXRwdXRDYWxlbmRhcjtcbiAgICAgIGJhc2UubnVtYmVyaW5nU3lzdGVtID0gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtO1xuICAgICAgYmFzZS5sb2NhbGUgPSB0aGlzLmxvYy5sb2NhbGU7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhU2NyaXB0IERhdGUgZXF1aXZhbGVudCB0byB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfVxuICAgKi9cbiAgdG9KU0RhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgOiBOYU4pO1xuICB9XG5cbiAgLy8gQ09NUEFSRVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gRGF0ZVRpbWVzIGFzIGEgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgRGF0ZVRpbWUgdG8gY29tcGFyZSB0aGlzIG9uZSB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3VuaXQ9WydtaWxsaXNlY29uZHMnXV0gLSB0aGUgdW5pdCBvciBhcnJheSBvZiB1bml0cyAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gaW5jbHVkZSBpbiB0aGUgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgaTEgPSBEYXRlVGltZS5mcm9tSVNPKCcxOTgyLTA1LTI1VDA5OjQ1JyksXG4gICAqICAgICBpMiA9IERhdGVUaW1lLmZyb21JU08oJzE5ODMtMTAtMTRUMTA6MzAnKTtcbiAgICogaTIuZGlmZihpMSkudG9PYmplY3QoKSAvLz0+IHsgbWlsbGlzZWNvbmRzOiA0MzgwNzUwMDAwMCB9XG4gICAqIGkyLmRpZmYoaTEsICdob3VycycpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMjE2OC43NSB9XG4gICAqIGkyLmRpZmYoaTEsIFsnbW9udGhzJywgJ2RheXMnXSkudG9PYmplY3QoKSAvLz0+IHsgbW9udGhzOiAxNiwgZGF5czogMTkuMDMxMjUgfVxuICAgKiBpMi5kaWZmKGkxLCBbJ21vbnRocycsICdkYXlzJywgJ2hvdXJzJ10pLnRvT2JqZWN0KCkgLy89PiB7IG1vbnRoczogMTYsIGRheXM6IDE5LCBob3VyczogMC43NSB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgZGlmZihvdGhlckRhdGVUaW1lLCB1bml0ID0gXCJtaWxsaXNlY29uZHNcIiwgb3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyRGF0ZVRpbWUuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJjcmVhdGVkIGJ5IGRpZmZpbmcgYW4gaW52YWxpZCBEYXRlVGltZVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBkdXJPcHRzID0geyBsb2NhbGU6IHRoaXMubG9jYWxlLCBudW1iZXJpbmdTeXN0ZW06IHRoaXMubnVtYmVyaW5nU3lzdGVtLCAuLi5vcHRzIH07XG5cbiAgICBjb25zdCB1bml0cyA9IG1heWJlQXJyYXkodW5pdCkubWFwKER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQpLFxuICAgICAgb3RoZXJJc0xhdGVyID0gb3RoZXJEYXRlVGltZS52YWx1ZU9mKCkgPiB0aGlzLnZhbHVlT2YoKSxcbiAgICAgIGVhcmxpZXIgPSBvdGhlcklzTGF0ZXIgPyB0aGlzIDogb3RoZXJEYXRlVGltZSxcbiAgICAgIGxhdGVyID0gb3RoZXJJc0xhdGVyID8gb3RoZXJEYXRlVGltZSA6IHRoaXMsXG4gICAgICBkaWZmZWQgPSBkaWZmKGVhcmxpZXIsIGxhdGVyLCB1bml0cywgZHVyT3B0cyk7XG5cbiAgICByZXR1cm4gb3RoZXJJc0xhdGVyID8gZGlmZmVkLm5lZ2F0ZSgpIDogZGlmZmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgRGF0ZVRpbWUgYW5kIHJpZ2h0IG5vdy5cbiAgICogU2VlIHtAbGluayBEYXRlVGltZSNkaWZmfVxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3VuaXQ9WydtaWxsaXNlY29uZHMnXV0gLSB0aGUgdW5pdCBvciB1bml0cyB1bml0cyAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gaW5jbHVkZSBpbiB0aGUgZHVyYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgZGlmZk5vdyh1bml0ID0gXCJtaWxsaXNlY29uZHNcIiwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlmZihEYXRlVGltZS5ub3coKSwgdW5pdCwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHNwYW5uaW5nIGJldHdlZW4gdGhpcyBEYXRlVGltZSBhbmQgYW5vdGhlciBEYXRlVGltZVxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlckRhdGVUaW1lIC0gdGhlIG90aGVyIGVuZCBwb2ludCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICB1bnRpbChvdGhlckRhdGVUaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEludGVydmFsLmZyb21EYXRlVGltZXModGhpcywgb3RoZXJEYXRlVGltZSkgOiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgRGF0ZVRpbWUgaXMgaW4gdGhlIHNhbWUgdW5pdCBvZiB0aW1lIGFzIGFub3RoZXIgRGF0ZVRpbWUuXG4gICAqIEhpZ2hlci1vcmRlciB1bml0cyBtdXN0IGFsc28gYmUgaWRlbnRpY2FsIGZvciB0aGlzIGZ1bmN0aW9uIHRvIHJldHVybiBgdHJ1ZWAuXG4gICAqIE5vdGUgdGhhdCB0aW1lIHpvbmVzIGFyZSAqKmlnbm9yZWQqKiBpbiB0aGlzIGNvbXBhcmlzb24sIHdoaWNoIGNvbXBhcmVzIHRoZSAqKmxvY2FsKiogY2FsZW5kYXIgdGltZS4gVXNlIHtAbGluayBEYXRlVGltZSNzZXRab25lfSB0byBjb252ZXJ0IG9uZSBvZiB0aGUgZGF0ZXMgaWYgbmVlZGVkLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlckRhdGVUaW1lIC0gdGhlIG90aGVyIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gdGhlIHVuaXQgb2YgdGltZSB0byBjaGVjayBzYW1lbmVzcyBvblxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5oYXNTYW1lKG90aGVyRFQsICdkYXknKTsgLy9+PiB0cnVlIGlmIG90aGVyRFQgaXMgaW4gdGhlIHNhbWUgY3VycmVudCBjYWxlbmRhciBkYXlcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1NhbWUob3RoZXJEYXRlVGltZSwgdW5pdCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBpbnB1dE1zID0gb3RoZXJEYXRlVGltZS52YWx1ZU9mKCk7XG4gICAgY29uc3QgYWRqdXN0ZWRUb1pvbmUgPSB0aGlzLnNldFpvbmUob3RoZXJEYXRlVGltZS56b25lLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSk7XG4gICAgcmV0dXJuIGFkanVzdGVkVG9ab25lLnN0YXJ0T2YodW5pdCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IGFkanVzdGVkVG9ab25lLmVuZE9mKHVuaXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVxdWFsaXR5IGNoZWNrXG4gICAqIFR3byBEYXRlVGltZXMgYXJlIGVxdWFsIGlmZiB0aGV5IHJlcHJlc2VudCB0aGUgc2FtZSBtaWxsaXNlY29uZCwgaGF2ZSB0aGUgc2FtZSB6b25lIGFuZCBsb2NhdGlvbiwgYW5kIGFyZSBib3RoIHZhbGlkLlxuICAgKiBUbyBjb21wYXJlIGp1c3QgdGhlIG1pbGxpc2Vjb25kIHZhbHVlcywgdXNlIGArZHQxID09PSArZHQyYC5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXIgLSB0aGUgb3RoZXIgRGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmlzVmFsaWQgJiZcbiAgICAgIG90aGVyLmlzVmFsaWQgJiZcbiAgICAgIHRoaXMudmFsdWVPZigpID09PSBvdGhlci52YWx1ZU9mKCkgJiZcbiAgICAgIHRoaXMuem9uZS5lcXVhbHMob3RoZXIuem9uZSkgJiZcbiAgICAgIHRoaXMubG9jLmVxdWFscyhvdGhlci5sb2MpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdGhpcyB0aW1lIHJlbGF0aXZlIHRvIG5vdywgc3VjaCBhcyBcImluIHR3byBkYXlzXCIuIENhbiBvbmx5IGludGVybmF0aW9uYWxpemUgaWYgeW91clxuICAgKiBwbGF0Zm9ybSBzdXBwb3J0cyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC4gUm91bmRzIGRvd24gYnkgZGVmYXVsdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBvdXRwdXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gW29wdGlvbnMuYmFzZT1EYXRlVGltZS5ub3coKV0gLSB0aGUgRGF0ZVRpbWUgdG8gdXNlIGFzIHRoZSBiYXNpcyB0byB3aGljaCB0aGlzIHRpbWUgaXMgY29tcGFyZWQuIERlZmF1bHRzIHRvIG5vdy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN0eWxlPVwibG9uZ1wiXSAtIHRoZSBzdHlsZSBvZiB1bml0cywgbXVzdCBiZSBcImxvbmdcIiwgXCJzaG9ydFwiLCBvciBcIm5hcnJvd1wiXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBvcHRpb25zLnVuaXQgLSB1c2UgYSBzcGVjaWZpYyB1bml0IG9yIGFycmF5IG9mIHVuaXRzOyBpZiBvbWl0dGVkLCBvciBhbiBhcnJheSwgdGhlIG1ldGhvZCB3aWxsIHBpY2sgdGhlIGJlc3QgdW5pdC4gVXNlIGFuIGFycmF5IG9yIG9uZSBvZiBcInllYXJzXCIsIFwicXVhcnRlcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgb3IgXCJzZWNvbmRzXCJcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yb3VuZD10cnVlXSAtIHdoZXRoZXIgdG8gcm91bmQgdGhlIG51bWJlcnMgaW4gdGhlIG91dHB1dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnBhZGRpbmc9MF0gLSBwYWRkaW5nIGluIG1pbGxpc2Vjb25kcy4gVGhpcyBhbGxvd3MgeW91IHRvIHJvdW5kIHVwIHRoZSByZXN1bHQgaWYgaXQgZml0cyBpbnNpZGUgdGhlIHRocmVzaG9sZC4gRG9uJ3QgdXNlIGluIGNvbWJpbmF0aW9uIHdpdGgge3JvdW5kOiBmYWxzZX0gYmVjYXVzZSB0aGUgZGVjaW1hbCBvdXRwdXQgd2lsbCBpbmNsdWRlIHRoZSBwYWRkaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2NhbGUgLSBvdmVycmlkZSB0aGUgbG9jYWxlIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtIC0gb3ZlcnJpZGUgdGhlIG51bWJlcmluZ1N5c3RlbSBvZiB0aGlzIERhdGVUaW1lLiBUaGUgSW50bCBzeXN0ZW0gbWF5IGNob29zZSBub3QgdG8gaG9ub3IgdGhpc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlKCkgLy89PiBcImluIDEgZGF5XCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKFwiZXNcIikudG9SZWxhdGl2ZSh7IGRheXM6IDEgfSkgLy89PiBcImRlbnRybyBkZSAxIGRcdTAwRURhXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSh7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gXCJkYW5zIDIzIGhldXJlc1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlKCkgLy89PiBcIjIgZGF5cyBhZ29cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZSh7IHVuaXQ6IFwiaG91cnNcIiB9KSAvLz0+IFwiNDggaG91cnMgYWdvXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBob3VyczogMzYgfSkudG9SZWxhdGl2ZSh7IHJvdW5kOiBmYWxzZSB9KSAvLz0+IFwiMS41IGRheXMgYWdvXCJcbiAgICovXG4gIHRvUmVsYXRpdmUob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGJhc2UgPSBvcHRpb25zLmJhc2UgfHwgRGF0ZVRpbWUuZnJvbU9iamVjdCh7fSwgeyB6b25lOiB0aGlzLnpvbmUgfSksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nID8gKHRoaXMgPCBiYXNlID8gLW9wdGlvbnMucGFkZGluZyA6IG9wdGlvbnMucGFkZGluZykgOiAwO1xuICAgIGxldCB1bml0cyA9IFtcInllYXJzXCIsIFwibW9udGhzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIl07XG4gICAgbGV0IHVuaXQgPSBvcHRpb25zLnVuaXQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy51bml0KSkge1xuICAgICAgdW5pdHMgPSBvcHRpb25zLnVuaXQ7XG4gICAgICB1bml0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZGlmZlJlbGF0aXZlKGJhc2UsIHRoaXMucGx1cyhwYWRkaW5nKSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIG51bWVyaWM6IFwiYWx3YXlzXCIsXG4gICAgICB1bml0cyxcbiAgICAgIHVuaXQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGRhdGUgcmVsYXRpdmUgdG8gdG9kYXksIHN1Y2ggYXMgXCJ5ZXN0ZXJkYXlcIiBvciBcIm5leHQgbW9udGhcIi5cbiAgICogT25seSBpbnRlcm5hdGlvbmFsaXplcyBvbiBwbGF0Zm9ybXMgdGhhdCBzdXBwb3J0cyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBvdXRwdXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gW29wdGlvbnMuYmFzZT1EYXRlVGltZS5ub3coKV0gLSB0aGUgRGF0ZVRpbWUgdG8gdXNlIGFzIHRoZSBiYXNpcyB0byB3aGljaCB0aGlzIHRpbWUgaXMgY29tcGFyZWQuIERlZmF1bHRzIHRvIG5vdy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9jYWxlIC0gb3ZlcnJpZGUgdGhlIGxvY2FsZSBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVuaXQgLSB1c2UgYSBzcGVjaWZpYyB1bml0OyBpZiBvbWl0dGVkLCB0aGUgbWV0aG9kIHdpbGwgcGljayB0aGUgdW5pdC4gVXNlIG9uZSBvZiBcInllYXJzXCIsIFwicXVhcnRlcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBvciBcImRheXNcIlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSBvdmVycmlkZSB0aGUgbnVtYmVyaW5nU3lzdGVtIG9mIHRoaXMgRGF0ZVRpbWUuIFRoZSBJbnRsIHN5c3RlbSBtYXkgY2hvb3NlIG5vdCB0byBob25vciB0aGlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmVDYWxlbmRhcigpIC8vPT4gXCJ0b21vcnJvd1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZShcImVzXCIpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiXCJtYVx1MDBGMWFuYVwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmVDYWxlbmRhcih7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gXCJkZW1haW5cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKCkgLy89PiBcIjIgZGF5cyBhZ29cIlxuICAgKi9cbiAgdG9SZWxhdGl2ZUNhbGVuZGFyKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiBkaWZmUmVsYXRpdmUob3B0aW9ucy5iYXNlIHx8IERhdGVUaW1lLmZyb21PYmplY3Qoe30sIHsgem9uZTogdGhpcy56b25lIH0pLCB0aGlzLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgbnVtZXJpYzogXCJhdXRvXCIsXG4gICAgICB1bml0czogW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCJdLFxuICAgICAgY2FsZW5kYXJ5OiB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWluIG9mIHNldmVyYWwgZGF0ZSB0aW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgRGF0ZVRpbWVzIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtaW5pbXVtXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgbWluIERhdGVUaW1lLCBvciB1bmRlZmluZWQgaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRcbiAgICovXG4gIHN0YXRpYyBtaW4oLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCFkYXRlVGltZXMuZXZlcnkoRGF0ZVRpbWUuaXNEYXRlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1pbiByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGJlIERhdGVUaW1lc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlc3RCeShkYXRlVGltZXMsIChpKSA9PiBpLnZhbHVlT2YoKSwgTWF0aC5taW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWF4IG9mIHNldmVyYWwgZGF0ZSB0aW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgRGF0ZVRpbWVzIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtYXhpbXVtXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgbWF4IERhdGVUaW1lLCBvciB1bmRlZmluZWQgaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRcbiAgICovXG4gIHN0YXRpYyBtYXgoLi4uZGF0ZVRpbWVzKSB7XG4gICAgaWYgKCFkYXRlVGltZXMuZXZlcnkoRGF0ZVRpbWUuaXNEYXRlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1heCByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGJlIERhdGVUaW1lc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlc3RCeShkYXRlVGltZXMsIChpKSA9PiBpLnZhbHVlT2YoKSwgTWF0aC5tYXgpO1xuICB9XG5cbiAgLy8gTUlTQ1xuXG4gIC8qKlxuICAgKiBFeHBsYWluIGhvdyBhIHN0cmluZyB3b3VsZCBiZSBwYXJzZWQgYnkgZnJvbUZvcm1hdCgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm10IC0gdGhlIGZvcm1hdCB0aGUgc3RyaW5nIGlzIGV4cGVjdGVkIHRvIGJlIGluIChzZWUgZGVzY3JpcHRpb24pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0YWtlbiBieSBmcm9tRm9ybWF0KClcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGZyb21Gb3JtYXRFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsIH0gPSBvcHRpb25zLFxuICAgICAgbG9jYWxlVG9Vc2UgPSBMb2NhbGUuZnJvbU9wdHMoe1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgZGVmYXVsdFRvRU46IHRydWUsXG4gICAgICB9KTtcbiAgICByZXR1cm4gZXhwbGFpbkZyb21Ub2tlbnMobG9jYWxlVG9Vc2UsIHRleHQsIGZtdCk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXRFeHBsYWluIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nRXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tRm9ybWF0RXhwbGFpbih0ZXh0LCBmbXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gRk9STUFUIFBSRVNFVFNcblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAxMC8xNC8xOTgzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfU0hPUlQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9TSE9SVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3QgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfTUVEKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfTUVEO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaSwgT2N0IDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX01FRF9XSVRIX1dFRUtEQVkoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9NRURfV0lUSF9XRUVLREFZO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfRlVMTCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX0ZVTEw7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnVHVlc2RheSwgT2N0b2JlciAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9IVUdFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfSFVHRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1NJTVBMRSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1NJTVBMRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV9XSVRIX1NIT1JUX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfTE9OR19PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfU0lNUExFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfU0lNUExFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEVEVCcsIGFsd2F5cyAyNC1ob3VyLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgRWFzdGVybiBEYXlsaWdodCBUaW1lJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMTAvMTQvMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9TSE9SVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9TSE9SVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcxMC8xNC8xOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9NRUQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzLCA5OjMwOjMzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmksIDE0IE9jdCAxOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVkoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVEVCcuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9GVUxMKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0ZVTEw7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MywgOTozMDozMyBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9IVUdFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0hVR0U7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpZGF5LCBPY3RvYmVyIDE0LCAxOTgzLCA5OjMwOjMzIEFNIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUztcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcmllbmRseURhdGVUaW1lKGRhdGVUaW1laXNoKSB7XG4gIGlmIChEYXRlVGltZS5pc0RhdGVUaW1lKGRhdGVUaW1laXNoKSkge1xuICAgIHJldHVybiBkYXRlVGltZWlzaDtcbiAgfSBlbHNlIGlmIChkYXRlVGltZWlzaCAmJiBkYXRlVGltZWlzaC52YWx1ZU9mICYmIGlzTnVtYmVyKGRhdGVUaW1laXNoLnZhbHVlT2YoKSkpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUpTRGF0ZShkYXRlVGltZWlzaCk7XG4gIH0gZWxzZSBpZiAoZGF0ZVRpbWVpc2ggJiYgdHlwZW9mIGRhdGVUaW1laXNoID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21PYmplY3QoZGF0ZVRpbWVpc2gpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgIGBVbmtub3duIGRhdGV0aW1lIGFyZ3VtZW50OiAke2RhdGVUaW1laXNofSwgb2YgdHlwZSAke3R5cGVvZiBkYXRlVGltZWlzaH1gXG4gICAgKTtcbiAgfVxufVxuIiwgImltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IER1cmF0aW9uIGZyb20gXCIuL2R1cmF0aW9uLmpzXCI7XG5pbXBvcnQgSW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCBJbmZvIGZyb20gXCIuL2luZm8uanNcIjtcbmltcG9ydCBab25lIGZyb20gXCIuL3pvbmUuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBJbnZhbGlkWm9uZSBmcm9tIFwiLi96b25lcy9pbnZhbGlkWm9uZS5qc1wiO1xuaW1wb3J0IFN5c3RlbVpvbmUgZnJvbSBcIi4vem9uZXMvc3lzdGVtWm9uZS5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5cbmNvbnN0IFZFUlNJT04gPSBcIjIuMy4wXCI7XG5cbmV4cG9ydCB7XG4gIFZFUlNJT04sXG4gIERhdGVUaW1lLFxuICBEdXJhdGlvbixcbiAgSW50ZXJ2YWwsXG4gIEluZm8sXG4gIFpvbmUsXG4gIEZpeGVkT2Zmc2V0Wm9uZSxcbiAgSUFOQVpvbmUsXG4gIEludmFsaWRab25lLFxuICBTeXN0ZW1ab25lLFxuICBTZXR0aW5ncyxcbn07XG4iLCAiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmpzb24yY3N2ID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBkb21haW47XG5cbiAgLy8gVGhpcyBjb25zdHJ1Y3RvciBpcyB1c2VkIHRvIHN0b3JlIGV2ZW50IGhhbmRsZXJzLiBJbnN0YW50aWF0aW5nIHRoaXMgaXNcbiAgLy8gZmFzdGVyIHRoYW4gZXhwbGljaXRseSBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCB0byBnZXQgYSBcImNsZWFuXCIgZW1wdHlcbiAgLy8gb2JqZWN0ICh0ZXN0ZWQgd2l0aCB2OCB2NC45KS5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVycygpIHt9XG4gIEV2ZW50SGFuZGxlcnMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8vIG5vZGVqcyBvZGRpdHlcbiAgLy8gcmVxdWlyZSgnZXZlbnRzJykgPT09IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICBFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4gIEV2ZW50RW1pdHRlci51c2luZ0RvbWFpbnMgPSBmYWxzZTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmRvbWFpbiA9IHVuZGVmaW5lZDtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbiAgLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4gIC8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG4gIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbiAgRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRvbWFpbiA9IG51bGw7XG4gICAgaWYgKEV2ZW50RW1pdHRlci51c2luZ0RvbWFpbnMpIHtcbiAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSBkb21haW4sIHRoZW4gYXR0YWNoIHRvIGl0LlxuICAgICAgaWYgKGRvbWFpbi5hY3RpdmUgJiYgISh0aGlzIGluc3RhbmNlb2YgZG9tYWluLkRvbWFpbikpIDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2V2ZW50cyB8fCB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgIH1cblxuICAgIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4gIC8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gICAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiblwiIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICAgIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xuICB9XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gICAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG4gIH07XG5cbiAgLy8gVGhlc2Ugc3RhbmRhbG9uZSBlbWl0KiBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gb3B0aW1pemUgY2FsbGluZyBvZiBldmVudFxuICAvLyBoYW5kbGVycyBmb3IgZmFzdCBjYXNlcyBiZWNhdXNlIGVtaXQoKSBpdHNlbGYgb2Z0ZW4gaGFzIGEgdmFyaWFibGUgbnVtYmVyIG9mXG4gIC8vIGFyZ3VtZW50cyBhbmQgY2FuIGJlIGRlb3B0aW1pemVkIGJlY2F1c2Ugb2YgdGhhdC4gVGhlc2UgZnVuY3Rpb25zIGFsd2F5cyBoYXZlXG4gIC8vIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHRodXMgZG8gbm90IGdldCBkZW9wdGltaXplZCwgc28gdGhlIGNvZGVcbiAgLy8gaW5zaWRlIHRoZW0gY2FuIGV4ZWN1dGUgZmFzdGVyLlxuICBmdW5jdGlvbiBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmKSB7XG4gICAgaWYgKGlzRm4pXG4gICAgICBoYW5kbGVyLmNhbGwoc2VsZik7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSkge1xuICAgIGlmIChpc0ZuKVxuICAgICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIpIHtcbiAgICBpZiAoaXNGbilcbiAgICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAoaXNGbilcbiAgICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmdzKSB7XG4gICAgaWYgKGlzRm4pXG4gICAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICAgIGxpc3RlbmVyc1tpXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgZXZlbnRzLCBkb21haW47XG4gICAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgaWYgKGV2ZW50cylcbiAgICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT0gbnVsbCk7XG4gICAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBkb21haW4gPSB0aGlzLmRvbWFpbjtcblxuICAgIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgICBpZiAoZG9FcnJvcikge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgIGlmICghZXIpXG4gICAgICAgICAgZXIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQnKTtcbiAgICAgICAgZXIuZG9tYWluRW1pdHRlciA9IHRoaXM7XG4gICAgICAgIGVyLmRvbWFpbiA9IGRvbWFpbjtcbiAgICAgICAgZXIuZG9tYWluVGhyb3duID0gZmFsc2U7XG4gICAgICAgIGRvbWFpbi5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgIH0gZWxzZSBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKCFoYW5kbGVyKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGlzRm4gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJztcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gICAgdmFyIG07XG4gICAgdmFyIGV2ZW50cztcbiAgICB2YXIgZXhpc3Rpbmc7XG5cbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgaWYgKCFldmVudHMpIHtcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lcikge1xuICAgICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICAgIH1cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICAgIH1cblxuICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgICAgaWYgKCFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSkge1xuICAgICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyB0eXBlICsgJyBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0Jyk7XG4gICAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgICAgICBlbWl0V2FybmluZyh3KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgZnVuY3Rpb24gZW1pdFdhcm5pbmcoZSkge1xuICAgIHR5cGVvZiBjb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicgPyBjb25zb2xlLndhcm4oZSkgOiBjb25zb2xlLmxvZyhlKTtcbiAgfVxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgICAgfTtcblxuICBmdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICAgIHZhciBmaXJlZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICB0YXJnZXQucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG4gICAgICBpZiAoIWZpcmVkKSB7XG4gICAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkodGFyZ2V0LCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgcmV0dXJuIGc7XG4gIH1cblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gIC8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgICBpZiAoIWxpc3QpXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IChsaXN0Lmxpc3RlbmVyICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbGlzdFswXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cztcblxuICAgICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgICAgaWYgKCFldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSkge1xuICAgICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBrZXk7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICB9IHdoaWxlIChsaXN0ZW5lcnNbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgICB2YXIgZXZsaXN0ZW5lcjtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgICBpZiAoIWV2ZW50cylcbiAgICAgIHJldCA9IFtdO1xuICAgIGVsc2Uge1xuICAgICAgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmICghZXZsaXN0ZW5lcilcbiAgICAgICAgcmV0ID0gW107XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0ID0gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl07XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICAgIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICAgIH1cbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuICBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0Lm93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xuICB9O1xuXG4gIC8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKS5cbiAgZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gICAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKVxuICAgICAgbGlzdFtpXSA9IGxpc3Rba107XG4gICAgbGlzdC5wb3AoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBpKSB7XG4gICAgdmFyIGNvcHkgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSlcbiAgICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gICAgcmV0dXJuIGNvcHk7XG4gIH1cblxuICBmdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHZhciBnbG9iYWwkMSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDpcbiAgICAgICAgICAgICAgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDpcbiAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KTtcblxuICB2YXIgbG9va3VwID0gW107XG4gIHZhciByZXZMb29rdXAgPSBbXTtcbiAgdmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheTtcbiAgdmFyIGluaXRlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBpbml0ICgpIHtcbiAgICBpbml0ZWQgPSB0cnVlO1xuICAgIHZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBsb29rdXBbaV0gPSBjb2RlW2ldO1xuICAgICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpO1xuICAgIH1cblxuICAgIHJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MjtcbiAgICByZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjM7XG4gIH1cblxuICBmdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gICAgaWYgKCFpbml0ZWQpIHtcbiAgICAgIGluaXQoKTtcbiAgICB9XG4gICAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnI7XG4gICAgdmFyIGxlbiA9IGI2NC5sZW5ndGg7XG5cbiAgICBpZiAobGVuICUgNCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gICAgfVxuXG4gICAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gICAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gICAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gICAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICAgIHBsYWNlSG9sZGVycyA9IGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDA7XG5cbiAgICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKTtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW47XG5cbiAgICB2YXIgTCA9IDA7XG5cbiAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG4gICAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRjtcbiAgICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7XG4gICAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gICAgfVxuXG4gICAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNCk7XG4gICAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gICAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKTtcbiAgICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7XG4gICAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyclxuICB9XG5cbiAgZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICAgIHZhciB0bXA7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pO1xuICAgICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG4gIH1cblxuICBmdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICAgIGlmICghaW5pdGVkKSB7XG4gICAgICBpbml0KCk7XG4gICAgfVxuICAgIHZhciB0bXA7XG4gICAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aDtcbiAgICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDM7IC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gICAgdmFyIG91dHB1dCA9ICcnO1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzOyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAgIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKTtcbiAgICB9XG5cbiAgICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gICAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdO1xuICAgICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl07XG4gICAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXTtcbiAgICAgIG91dHB1dCArPSAnPT0nO1xuICAgIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKTtcbiAgICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXTtcbiAgICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdO1xuICAgICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl07XG4gICAgICBvdXRwdXQgKz0gJz0nO1xuICAgIH1cblxuICAgIHBhcnRzLnB1c2gob3V0cHV0KTtcblxuICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICAgIHZhciBlLCBtO1xuICAgIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICAgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICAgIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgICB2YXIgbkJpdHMgPSAtNztcbiAgICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwO1xuICAgIHZhciBkID0gaXNMRSA/IC0xIDogMTtcbiAgICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICAgIGkgKz0gZDtcblxuICAgIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICAgIHMgPj49ICgtbkJpdHMpO1xuICAgIG5CaXRzICs9IGVMZW47XG4gICAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICAgIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICAgIGUgPj49ICgtbkJpdHMpO1xuICAgIG5CaXRzICs9IG1MZW47XG4gICAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICAgIGlmIChlID09PSAwKSB7XG4gICAgICBlID0gMSAtIGVCaWFzO1xuICAgIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSAtIGVCaWFzO1xuICAgIH1cbiAgICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGUgKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gICAgdmFyIGUsIG0sIGM7XG4gICAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gICAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gICAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICAgIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCk7XG4gICAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKTtcbiAgICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7XG4gICAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICAgIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgICBlLS07XG4gICAgICAgIGMgKj0gMjtcbiAgICAgIH1cbiAgICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgICAgZSsrO1xuICAgICAgICBjIC89IDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgICBtID0gMDtcbiAgICAgICAgZSA9IGVNYXg7XG4gICAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgICAgZSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICAgIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gICAgZUxlbiArPSBtTGVuO1xuICAgIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICAgIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbiAgfVxuXG4gIHZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIHZhciBJTlNQRUNUX01BWF9CWVRFUyA9IDUwO1xuXG4gIC8qKlxuICAgKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICAgKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICAgKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gICAqXG4gICAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAgICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICAgKlxuICAgKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gICAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICAgKlxuICAgKiBOb3RlOlxuICAgKlxuICAgKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICAgKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gICAqXG4gICAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICAgKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAgICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAgICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gICAqL1xuICBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbCQxLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICAgID8gZ2xvYmFsJDEuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgIDogdHJ1ZTtcblxuICBmdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICAgID8gMHg3ZmZmZmZmZlxuICAgICAgOiAweDNmZmZmZmZmXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICAgIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gICAgfVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICAvKipcbiAgICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gICAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAgICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICAgKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICAgKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICAgKlxuICAgKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICAgIH1cblxuICAgIC8vIENvbW1vbiBjYXNlLlxuICAgIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIEJ1ZmZlci5wb29sU2l6ZSA9IDgxOTI7IC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuICAvLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICAgIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICAgIHJldHVybiBhcnJcbiAgfTtcblxuICBmdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICAgKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAgICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICAgKiBCdWZmZXIuZnJvbShhcnJheSlcbiAgICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICAgKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAgICoqL1xuICBCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfTtcblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlO1xuICAgIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5O1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gICAgYXNzZXJ0U2l6ZShzaXplKTtcbiAgICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gICAgfVxuICAgIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gICAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAgICoqL1xuICBCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG4gIH07XG5cbiAgZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgICBhc3NlcnRTaXplKHNpemUpO1xuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApO1xuICAgIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICAgIHRoYXRbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgLyoqXG4gICAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gICAqICovXG4gIEJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG4gIH07XG4gIC8qKlxuICAgKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAgICovXG4gIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxuICB9O1xuXG4gIGZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIH1cblxuICAgIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwO1xuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKTtcblxuICAgIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpO1xuXG4gICAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDtcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1O1xuICAgIH1cbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgYXJyYXkuYnl0ZUxlbmd0aDsgLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gICAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICAgIH1cblxuICAgIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gICAgfVxuXG4gICAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSk7XG4gICAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICAgIHRoYXQgPSBhcnJheTtcbiAgICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gICAgaWYgKGludGVybmFsSXNCdWZmZXIob2JqKSkge1xuICAgICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwO1xuICAgICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pO1xuXG4gICAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoYXRcbiAgICAgIH1cblxuICAgICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKTtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgaWYgKG9iaikge1xuICAgICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgICB9XG5cbiAgICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG4gIH1cblxuICBmdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoIHwgMFxuICB9XG4gIEJ1ZmZlci5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuICBmdW5jdGlvbiBpbnRlcm5hbElzQnVmZmVyIChiKSB7XG4gICAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbiAgfVxuXG4gIEJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihhKSB8fCAhaW50ZXJuYWxJc0J1ZmZlcihiKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gICAgfVxuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgICB2YXIgeCA9IGEubGVuZ3RoO1xuICAgIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgeCA9IGFbaV07XG4gICAgICAgIHkgPSBiW2ldO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gICAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICAgIHJldHVybiAwXG4gIH07XG5cbiAgQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICAgIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIEJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICAgIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpO1xuICAgIHZhciBwb3MgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgICB9XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcyk7XG4gICAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9O1xuXG4gIGZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHN0cmluZyA9ICcnICsgc3RyaW5nO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoO1xuICAgIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgICByZXR1cm4gbGVuXG4gICAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgICBjYXNlICd1Y3MyJzpcbiAgICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcblxuICAgIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAgIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICAgIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChlbmQgPD0gMCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgICBlbmQgPj4+PSAwO1xuICAgIHN0YXJ0ID4+Pj0gMDtcblxuICAgIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgICBjYXNlICd1dGY4JzpcbiAgICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgICAgY2FzZSAndWNzMic6XG4gICAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuICAvLyBCdWZmZXIgaW5zdGFuY2VzLlxuICBCdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWU7XG5cbiAgZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICAgIHZhciBpID0gYltuXTtcbiAgICBiW25dID0gYlttXTtcbiAgICBiW21dID0gaTtcbiAgfVxuXG4gIEJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgIHN3YXAodGhpcywgaSwgaSArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgIHN3YXAodGhpcywgaSwgaSArIDMpO1xuICAgICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICAgIHN3YXAodGhpcywgaSwgaSArIDcpO1xuICAgICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpO1xuICAgICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpO1xuICAgICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMDtcbiAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gICAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgICBpZiAoIWludGVybmFsSXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICAgIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICB2YXIgbWF4ID0gSU5TUEVDVF9NQVhfQllURVM7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJyk7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnO1xuICAgIH1cbiAgICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gICAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKHRhcmdldCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICAgIH1cblxuICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpc1N0YXJ0ID0gMDtcbiAgICB9XG4gICAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gICAgfVxuXG4gICAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBzdGFydCA+Pj49IDA7XG4gICAgZW5kID4+Pj0gMDtcbiAgICB0aGlzU3RhcnQgPj4+PSAwO1xuICAgIHRoaXNFbmQgPj4+PSAwO1xuXG4gICAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICAgIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydDtcbiAgICB2YXIgeSA9IGVuZCAtIHN0YXJ0O1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KTtcblxuICAgIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKTtcbiAgICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgICB4ID0gdGhpc0NvcHlbaV07XG4gICAgICAgIHkgPSB0YXJnZXRDb3B5W2ldO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gICAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICAgIHJldHVybiAwXG4gIH07XG5cbiAgLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuICAvLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuICAvL1xuICAvLyBBcmd1bWVudHM6XG4gIC8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4gIC8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4gIC8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuICAvLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuICAvLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuICBmdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICAgIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldDtcbiAgICAgIGJ5dGVPZmZzZXQgPSAwO1xuICAgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmO1xuICAgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDA7XG4gICAgfVxuICAgIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDsgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gICAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICAgIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0O1xuICAgIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDA7XG4gICAgICBlbHNlIHJldHVybiAtMVxuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSB2YWxcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpO1xuICAgIH1cblxuICAgIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gICAgaWYgKGludGVybmFsSXNCdWZmZXIodmFsKSkge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhbCA9IHZhbCAmIDB4RkY7IC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAgIHZhciBpbmRleFNpemUgPSAxO1xuICAgIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoO1xuXG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGluZGV4U2l6ZSA9IDI7XG4gICAgICAgIGFyckxlbmd0aCAvPSAyO1xuICAgICAgICB2YWxMZW5ndGggLz0gMjtcbiAgICAgICAgYnl0ZU9mZnNldCAvPSAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYnVmW2ldXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIGlmIChkaXIpIHtcbiAgICAgIHZhciBmb3VuZEluZGV4ID0gLTE7XG4gICAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGk7XG4gICAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleDtcbiAgICAgICAgICBmb3VuZEluZGV4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGg7XG4gICAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgZm91bmQgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIEJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICAgIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICAgIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICAgIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbiAgfTtcblxuICBmdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMDtcbiAgICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTtcbiAgICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gICAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gICAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZDtcbiAgICB9XG4gICAgcmV0dXJuIGlcbiAgfVxuXG4gIGZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBmdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gICAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gICAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMDtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgICAgKVxuICAgIH1cblxuICAgIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmc7XG5cbiAgICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgICB9XG5cbiAgICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4JztcblxuICAgIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICAgIGZvciAoOzspIHtcbiAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgICBjYXNlICd1dGY4JzpcbiAgICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgICBjYXNlICd1Y3MyJzpcbiAgICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdCdWZmZXInLFxuICAgICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICAgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG4gICAgdmFyIHJlcyA9IFtdO1xuXG4gICAgdmFyIGkgPSBzdGFydDtcbiAgICB3aGlsZSAoaSA8IGVuZCkge1xuICAgICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXTtcbiAgICAgIHZhciBjb2RlUG9pbnQgPSBudWxsO1xuICAgICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgOiAxO1xuXG4gICAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnQ7XG5cbiAgICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG4gICAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG4gICAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXTtcbiAgICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKTtcbiAgICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICAgIGNvZGVQb2ludCA9IDB4RkZGRDtcbiAgICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcbiAgICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkY7XG4gICAgICB9XG5cbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG4gIH1cblxuICAvLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbiAgLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuICAvLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG4gIHZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMDtcblxuICBmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGg7XG4gICAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gICAgfVxuXG4gICAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICAgIHZhciByZXMgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgICBTdHJpbmcsXG4gICAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICAgIHZhciByZXQgPSAnJztcbiAgICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBmdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHJldCA9ICcnO1xuICAgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuXG4gICAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMDtcbiAgICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuXG4gICAgdmFyIG91dCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgIHN0YXJ0ID0gfn5zdGFydDtcbiAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kO1xuXG4gICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgc3RhcnQgKz0gbGVuO1xuICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICAgIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICAgIHN0YXJ0ID0gbGVuO1xuICAgIH1cblxuICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICBlbmQgKz0gbGVuO1xuICAgICAgaWYgKGVuZCA8IDApIGVuZCA9IDA7XG4gICAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICAgIGVuZCA9IGxlbjtcbiAgICB9XG5cbiAgICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG4gICAgdmFyIG5ld0J1ZjtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCk7XG4gICAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3QnVmXG4gIH07XG5cbiAgLypcbiAgICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gICAqL1xuICBmdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICAgIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gICAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gICAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgICB2YXIgbXVsID0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXTtcbiAgICB2YXIgbXVsID0gMTtcbiAgICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbFxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gICAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgICB0aGlzW29mZnNldCArIDNdKVxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdO1xuICAgIHZhciBtdWwgPSAxO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gICAgfVxuICAgIG11bCAqPSAweDgwO1xuXG4gICAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG5cbiAgICByZXR1cm4gdmFsXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuICAgIHZhciBpID0gYnl0ZUxlbmd0aDtcbiAgICB2YXIgbXVsID0gMTtcbiAgICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldO1xuICAgIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bDtcbiAgICB9XG4gICAgbXVsICo9IDB4ODA7XG5cbiAgICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcblxuICAgIHJldHVybiB2YWxcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTtcbiAgICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gICAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpO1xuICAgIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOCk7XG4gICAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gICAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICAgIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10pXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcbiAgICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICAgIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTtcbiAgICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gICAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gICAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICAgIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgfVxuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICAgIH1cblxuICAgIHZhciBtdWwgPSAxO1xuICAgIHZhciBpID0gMDtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG4gICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICAgIH1cblxuICAgIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gICAgdmFyIG11bCA9IDE7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRjtcbiAgICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgdmFsdWUgPSArdmFsdWU7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKTtcbiAgICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIHJldHVybiBvZmZzZXQgKyAxXG4gIH07XG5cbiAgZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDE7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4O1xuICAgIH1cbiAgfVxuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgdmFsdWUgPSArdmFsdWU7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApO1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgKyAyXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpO1xuICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgKyAyXG4gIH07XG5cbiAgZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmY7XG4gICAgfVxuICB9XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgKyA0XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNik7XG4gICAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KTtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0ICsgNFxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gICAgdmFsdWUgPSArdmFsdWU7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuXG4gICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCk7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBtdWwgPSAxO1xuICAgIHZhciBzdWIgPSAwO1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRjtcbiAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgICAgc3ViID0gMTtcbiAgICAgIH1cbiAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcblxuICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuICAgIH1cblxuICAgIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gICAgdmFyIG11bCA9IDE7XG4gICAgdmFyIHN1YiA9IDA7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRjtcbiAgICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICAgIHN1YiA9IDE7XG4gICAgICB9XG4gICAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGO1xuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgdmFsdWUgPSArdmFsdWU7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MCk7XG4gICAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDE7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgcmV0dXJuIG9mZnNldCArIDFcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMCk7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldCArIDJcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMCk7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpO1xuICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgKyAyXG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgdmFsdWUgPSArdmFsdWU7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldCArIDRcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDE7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KTtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KTtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgKyA0XG4gIH07XG5cbiAgZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gICAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCk7XG4gICAgfVxuICAgIHdyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCk7XG4gICAgcmV0dXJuIG9mZnNldCArIDRcbiAgfVxuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbiAgfTtcblxuICBmdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCk7XG4gICAgfVxuICAgIHdyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOCk7XG4gICAgcmV0dXJuIG9mZnNldCArIDhcbiAgfVxuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbiAgfTtcblxuICAvLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG4gIEJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoIXN0YXJ0KSBzdGFydCA9IDA7XG4gICAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoO1xuICAgIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMDtcbiAgICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7XG5cbiAgICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAgIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gICAgfVxuICAgIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAgIC8vIEFyZSB3ZSBvb2I/XG4gICAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0O1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcbiAgICB2YXIgaTtcblxuICAgIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgICAgdGFyZ2V0U3RhcnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlblxuICB9O1xuXG4gIC8vIFVzYWdlOlxuICAvLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbiAgLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4gIC8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuICBCdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gICAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVuY29kaW5nID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVuY29kaW5nID0gZW5kO1xuICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgICAgdmFsID0gY29kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhbCA9IHZhbCAmIDI1NTtcbiAgICB9XG5cbiAgICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICAgIH1cblxuICAgIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgc3RhcnQgPSBzdGFydCA+Pj4gMDtcbiAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwO1xuXG4gICAgaWYgKCF2YWwpIHZhbCA9IDA7XG5cbiAgICB2YXIgaTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgdGhpc1tpXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ5dGVzID0gaW50ZXJuYWxJc0J1ZmZlcih2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKTtcbiAgICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9O1xuXG4gIC8vIEhFTFBFUiBGVU5DVElPTlNcbiAgLy8gPT09PT09PT09PT09PT09PVxuXG4gIHZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZztcblxuICBmdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gICAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gICAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKTtcbiAgICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gICAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgIHN0ciA9IHN0ciArICc9JztcbiAgICB9XG4gICAgcmV0dXJuIHN0clxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gICAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG4gIH1cblxuICBmdW5jdGlvbiB0b0hleCAobikge1xuICAgIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICAgIHJldHVybiBuLnRvU3RyaW5nKDE2KVxuICB9XG5cbiAgZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5O1xuICAgIHZhciBjb2RlUG9pbnQ7XG4gICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuICAgIHZhciBieXRlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICB9XG5cbiAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgICAvLyBlbmNvZGUgdXRmOFxuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gICAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG4gICAgfVxuICAgIHJldHVybiBieXRlQXJyYXlcbiAgfVxuXG4gIGZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gICAgdmFyIGMsIGhpLCBsbztcbiAgICB2YXIgYnl0ZUFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBoaSA9IGMgPj4gODtcbiAgICAgIGxvID0gYyAlIDI1NjtcbiAgICAgIGJ5dGVBcnJheS5wdXNoKGxvKTtcbiAgICAgIGJ5dGVBcnJheS5wdXNoKGhpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZUFycmF5XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICAgIHJldHVybiB0b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxuICB9XG5cbiAgZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldO1xuICAgIH1cbiAgICByZXR1cm4gaVxuICB9XG5cbiAgZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICAgIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICB9XG5cblxuICAvLyB0aGUgZm9sbG93aW5nIGlzIGZyb20gaXMtYnVmZmVyLCBhbHNvIGJ5IEZlcm9zcyBBYm91a2hhZGlqZWggYW5kIHdpdGggc2FtZSBsaXNlbmNlXG4gIC8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3NpbmdcbiAgLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxuICBmdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgKCEhb2JqLl9pc0J1ZmZlciB8fCBpc0Zhc3RCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRmFzdEJ1ZmZlciAob2JqKSB7XG4gICAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbiAgfVxuXG4gIC8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG4gIGZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0Zhc3RCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxuICB9XG5cbiAgLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG4gIC8vIGJhc2VkIG9mZiBodHRwczovL2dpdGh1Yi5jb20vZGVmdW5jdHpvbWJpZS9ub2RlLXByb2Nlc3MvYmxvYi9tYXN0ZXIvYnJvd3Nlci5qc1xuXG4gIGZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbiAgfVxuICBmdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG4gIH1cbiAgdmFyIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICB2YXIgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgaWYgKHR5cGVvZiBnbG9iYWwkMS5zZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbCQxLmNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICB9XG5cbiAgZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgfVxuICBmdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgICB9XG4gICAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG5cblxuICB9XG4gIHZhciBxdWV1ZSA9IFtdO1xuICB2YXIgZHJhaW5pbmcgPSBmYWxzZTtcbiAgdmFyIGN1cnJlbnRRdWV1ZTtcbiAgdmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuICBmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICB9XG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgICAgd2hpbGUobGVuKSB7XG4gICAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG4gIH1cbiAgZnVuY3Rpb24gbmV4dFRpY2soZnVuKSB7XG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgICAgfVxuICB9XG4gIC8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbiAgZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgfVxuICBJdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbiAgfTtcblxuICAvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rdW1hdmlzL2Jyb3dzZXItcHJvY2Vzcy1ocnRpbWUvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAgdmFyIHBlcmZvcm1hbmNlID0gZ2xvYmFsJDEucGVyZm9ybWFuY2UgfHwge307XG4gIHZhciBwZXJmb3JtYW5jZU5vdyA9XG4gICAgcGVyZm9ybWFuY2Uubm93ICAgICAgICB8fFxuICAgIHBlcmZvcm1hbmNlLm1vek5vdyAgICAgfHxcbiAgICBwZXJmb3JtYW5jZS5tc05vdyAgICAgIHx8XG4gICAgcGVyZm9ybWFuY2Uub05vdyAgICAgICB8fFxuICAgIHBlcmZvcm1hbmNlLndlYmtpdE5vdyAgfHxcbiAgICBmdW5jdGlvbigpeyByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSB9O1xuXG4gIHZhciBpbmhlcml0cztcbiAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKXtcbiAgICBpbmhlcml0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgICAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpbmhlcml0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICAgIH07XG4gIH1cbiAgdmFyIGluaGVyaXRzJDEgPSBpbmhlcml0cztcblxuICB2YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbiAgZnVuY3Rpb24gZm9ybWF0KGYpIHtcbiAgICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgICBzd2l0Y2ggKHgpIHtcbiAgICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgICBjYXNlICclaic6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAgLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAgZnVuY3Rpb24gZGVwcmVjYXRlKGZuLCBtc2cpIHtcbiAgICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICAgIGlmIChpc1VuZGVmaW5lZChnbG9iYWwkMS5wcm9jZXNzKSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG4gIH1cblxuICB2YXIgZGVidWdzID0ge307XG4gIHZhciBkZWJ1Z0Vudmlyb247XG4gIGZ1bmN0aW9uIGRlYnVnbG9nKHNldCkge1xuICAgIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgICAgZGVidWdFbnZpcm9uID0gICcnO1xuICAgIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICAgIGlmICghZGVidWdzW3NldF0pIHtcbiAgICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgICB2YXIgcGlkID0gMDtcbiAgICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgbXNnID0gZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gICAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICAgKi9cbiAgLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuICBmdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgIHZhciBjdHggPSB7XG4gICAgICBzZWVuOiBbXSxcbiAgICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gICAgfTtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgICAvLyBsZWdhY3kuLi5cbiAgICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICAgIF9leHRlbmQoY3R4LCBvcHRzKTtcbiAgICB9XG4gICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICAgIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gICAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xuICB9XG5cbiAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG4gIGluc3BlY3QuY29sb3JzID0ge1xuICAgICdib2xkJyA6IFsxLCAyMl0sXG4gICAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAgICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAgICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAgICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAgICdyZWQnIDogWzMxLCAzOV0sXG4gICAgJ3llbGxvdycgOiBbMzMsIDM5XVxuICB9O1xuXG4gIC8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuICBpbnNwZWN0LnN0eWxlcyA9IHtcbiAgICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAgICdudWxsJzogJ2JvbGQnLFxuICAgICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAgICdkYXRlJzogJ21hZ2VudGEnLFxuICAgIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICAgJ3JlZ2V4cCc6ICdyZWQnXG4gIH07XG5cblxuICBmdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gICAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gICAgdmFyIGhhc2ggPSB7fTtcblxuICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gICAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAgIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICAgIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgICB2YWx1ZSAmJlxuICAgICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBpbnNwZWN0ICYmXG4gICAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gICAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgICBpZiAocHJpbWl0aXZlKSB7XG4gICAgICByZXR1cm4gcHJpbWl0aXZlO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICAgIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAgIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgICBpZiAoaXNBcnJheSQxKHZhbHVlKSkge1xuICAgICAgYXJyYXkgPSB0cnVlO1xuICAgICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgICB9XG5cbiAgICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgIH1cblxuICAgIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICAgIH1cblxuICAgIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICAgIHZhciBvdXRwdXQ7XG4gICAgaWYgKGFycmF5KSB7XG4gICAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGN0eC5zZWVuLnBvcCgpO1xuXG4gICAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAgIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gICAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbiAgfVxuXG5cbiAgZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cblxuICBmdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gICAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgICB9XG4gICAgaWYgKCFzdHIpIHtcbiAgICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xuICB9XG5cblxuICBmdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICAgIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSA7XG4gICAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gICAgfSwgMCk7XG5cbiAgICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgIGJyYWNlc1sxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xuICB9XG5cblxuICAvLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbiAgLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG4gIGZ1bmN0aW9uIGlzQXJyYXkkMShhcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG4gIH1cblxuICBmdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG4gIH1cblxuICBmdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG4gIH1cblxuICBmdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICAgIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBpc0RhdGUoZCkge1xuICAgIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xuICB9XG5cbiAgZnVuY3Rpb24gX2V4dGVuZChvcmlnaW4sIGFkZCkge1xuICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdpbjtcbiAgfVxuICBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG4gIH1cblxuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIHAuZGF0YS5jb3B5KHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIC8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuICB2YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gICAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgICB9XG4gICAgICAgfTtcblxuXG4gIGZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gICAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2ZcbiAgLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4gIC8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuICAvL1xuICAvLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbiAgLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4gIC8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbiAgLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxuICBmdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gICAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gICAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICAgIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gICAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gICAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbiAgfVxuXG4gIC8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuICAvLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbiAgLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbiAgLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbiAgLy9cbiAgLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbiAgLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3JcbiAgLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbiAgLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cbiAgU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICB2YXIgY2hhclN0ciA9ICcnO1xuICAgIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gICAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgICBjaGFyU3RyID0gJyc7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY2hhclN0cjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgfVxuXG4gICAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICAgIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gICAgfVxuXG4gICAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gICAgcmV0dXJuIGNoYXJTdHI7XG4gIH07XG5cbiAgLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuICAvLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuICAvLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbiAgLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cbiAgU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gICAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAgIC8vIGluY29tcGxldGUgY2hhci5cbiAgICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgICAvLyAxMTBYWFhYWFxuICAgICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gMTExMFhYWFhcbiAgICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIDExMTEwWFhYXG4gICAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG4gIH07XG5cbiAgU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICAgIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG4gIH1cblxuICBmdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICAgIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG4gIH1cblxuICBSZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuICB2YXIgZGVidWcgPSBkZWJ1Z2xvZygnc3RyZWFtJyk7XG4gIGluaGVyaXRzJDEoUmVhZGFibGUsIEV2ZW50RW1pdHRlcik7XG5cbiAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAgIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gICAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gICAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgICAgIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAgICAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAgICAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICAgICAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pXG4gICAgICAgIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtcbiAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpXG4gICAgICAgIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7XG4gICAgICBlbHNlXG4gICAgICAgIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBsaXN0ZW5lckNvdW50JDEgKGVtaXR0ZXIsIHR5cGUpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xuICB9XG4gIGZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gICAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICAgIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gICAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gICAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICAgIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gICAgLy8gY2FzdCB0byBpbnRzLlxuICAgIHRoaXMuaGlnaFdhdGVyTWFyayA9IH4gfnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICAgIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gICAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgICAvLyBhcnJheS5zaGlmdCgpXG4gICAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICAgIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gICAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gICAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gICAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gICAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAgIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gICAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gICAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gICAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAgIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gICAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gICAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gICAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICAgIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICAgIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gICAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgICAvLyBsZWdhY3lcbiAgICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuICAvLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbiAgLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuICAvLyB3cml0ZSgpIHNvbWUgbW9yZS5cbiAgUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAgIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbiAgfTtcblxuICAvLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuICBSZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG4gIH07XG5cbiAgUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gICAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICAgIHZhciBfZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgX2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNraXBBZGQ7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgc2tpcEFkZCA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIGNodW5rLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWRkVG9Gcm9udCkgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIERvbid0IGFkZCB0byB0aGUgYnVmZmVyIGlmIHdlJ3ZlIGRlY29kZWQgdG8gYW4gZW1wdHkgc3RyaW5nIGNodW5rIGFuZFxuICAgICAgICAvLyB3ZSdyZSBub3QgaW4gb2JqZWN0IG1vZGVcbiAgICAgICAgaWYgKCFza2lwQWRkKSB7XG4gICAgICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC5cbiAgICAgICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbiAgfVxuXG4gIC8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4gIC8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4gIC8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuICAvLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuICAvLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbiAgLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbiAgLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbiAgZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gICAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbiAgfVxuXG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBSZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbiAgdmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbiAgZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICAgIGlmIChuID49IE1BWF9IV00pIHtcbiAgICAgIG4gPSBNQVhfSFdNO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAgIC8vIHRpbnkgYW1vdW50c1xuICAgICAgbi0tO1xuICAgICAgbiB8PSBuID4+PiAxO1xuICAgICAgbiB8PSBuID4+PiAyO1xuICAgICAgbiB8PSBuID4+PiA0O1xuICAgICAgbiB8PSBuID4+PiA4O1xuICAgICAgbiB8PSBuID4+PiAxNjtcbiAgICAgIG4rKztcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuICAvLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuICBmdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gICAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgICBpZiAobiAhPT0gbikge1xuICAgICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gICAgfVxuICAgIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICAgIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICAgIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gICAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICAvLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuICBSZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgICBuID0gcGFyc2VJbnQobiwgMTApO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgdmFyIG5PcmlnID0gbjtcblxuICAgIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAgIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gICAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gICAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gICAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICAgIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gICAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAgIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gICAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gICAgLy9cbiAgICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gICAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgICAvL1xuICAgIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gICAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gICAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gICAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAgIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gICAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gICAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAgIC8vICdyZWFkYWJsZScgZXRjLlxuICAgIC8vXG4gICAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gICAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICAgIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gICAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gICAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgICAgZG9SZWFkID0gdHJ1ZTtcbiAgICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gICAgfVxuXG4gICAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gICAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICAgIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgdmFyIHJldDtcbiAgICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgbiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBmdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gICAgdmFyIGVyID0gbnVsbDtcbiAgICBpZiAoIWlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICAgIH1cbiAgICByZXR1cm4gZXI7XG4gIH1cblxuICBmdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAgIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG5cbiAgLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4gIC8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuICAvLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG4gIGZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoc3RhdGUuc3luYykgbmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICAgIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgZmxvdyhzdHJlYW0pO1xuICB9XG5cbiAgLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbiAgLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuICAvLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuICAvLyBpdCdzIGluIHByb2dyZXNzLlxuICAvLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuICAvLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuICBmdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgICBuZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gICAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgICB9XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbiAgLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbiAgLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbiAgLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuICBSZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbiAgfTtcblxuICBSZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICAgIHZhciBzcmMgPSB0aGlzO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gICAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICAgIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSk7XG5cbiAgICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgbmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICAgIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICAgIGRlc3QuZW5kKCk7XG4gICAgfVxuXG4gICAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAgIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAgIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gICAgLy8gdG9vIHNsb3cuXG4gICAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICAgIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAgIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gICAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICAgIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzcmMucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gICAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgICB1bnBpcGUoKTtcbiAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgICBpZiAobGlzdGVuZXJDb3VudCQxKGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICAgIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgICB1bnBpcGUoKTtcbiAgICB9XG4gICAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgICAgdW5waXBlKCk7XG4gICAgfVxuICAgIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gICAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgICAgZGVidWcoJ3VucGlwZScpO1xuICAgICAgc3JjLnVucGlwZShkZXN0KTtcbiAgICB9XG5cbiAgICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICAgIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gICAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICAgIHNyYy5yZXN1bWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzdDtcbiAgfTtcblxuICBmdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgc3JjLmxpc3RlbmVycygnZGF0YScpLmxlbmd0aCkge1xuICAgICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgICAgZmxvdyhzcmMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBSZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gICAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICAgIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAgIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gICAgaWYgKCFkZXN0KSB7XG4gICAgICAvLyByZW1vdmUgYWxsLlxuICAgICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuOyBfaSsrKSB7XG4gICAgICAgIGRlc3RzW19pXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICAgIH1yZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICAgIHZhciBpID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gICAgaWYgKGkgPT09IC0xKSByZXR1cm4gdGhpcztcblxuICAgIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gICAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuICAvLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuICBSZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gICAgdmFyIHJlcyA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gICAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgICAgbmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG4gIGZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICAgIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgICBzZWxmLnJlYWQoMCk7XG4gIH1cblxuICAvLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4gIC8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cbiAgUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBmdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgbmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgfVxuXG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gICAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICAgIGZsb3coc3RyZWFtKTtcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBSZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gICAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICAgIGRlYnVnKCdwYXVzZScpO1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gICAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gICAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbiAgfVxuXG4gIC8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4gIC8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbiAgLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG4gIFJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgc2VsZi5wdXNoKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5wdXNoKG51bGwpO1xuICAgIH0pO1xuXG4gICAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgICAgaWYgKCFyZXQpIHtcbiAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gICAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gICAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0oaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICAgIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gICAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uIChldikge1xuICAgICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICAgIH0pO1xuXG4gICAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAgIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICAgIHNlbGYuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICAgIGlmIChwYXVzZWQpIHtcbiAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuICBSZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuICAvLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4gIC8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4gIC8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG4gIGZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gICAgLy8gbm90aGluZyBidWZmZXJlZFxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgdmFyIHJldDtcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuICAvLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuICBmdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICAgIHZhciByZXQ7XG4gICAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gICAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuICAvLyBjaHVua3MuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4gIC8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG4gIGZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgICB2YXIgYyA9IDE7XG4gICAgdmFyIHJldCA9IHAuZGF0YTtcbiAgICBuIC09IHJldC5sZW5ndGg7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICAgIG4gLT0gbmI7XG4gICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICArK2M7XG4gICAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICArK2M7XG4gICAgfVxuICAgIGxpc3QubGVuZ3RoIC09IGM7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbiAgLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbiAgZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gICAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gICAgdmFyIGMgPSAxO1xuICAgIHAuZGF0YS5jb3B5KHJldCk7XG4gICAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICAgIG4gLT0gbmI7XG4gICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICArK2M7XG4gICAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICArK2M7XG4gICAgfVxuICAgIGxpc3QubGVuZ3RoIC09IGM7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICAgIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAgIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gICAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGYoeHNbaV0sIGkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4gIFdyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuICBpbmhlcml0cyQxKFdyaXRhYmxlLCBFdmVudEVtaXR0ZXIpO1xuXG4gIGZ1bmN0aW9uIG5vcCgpIHt9XG5cbiAgZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBkZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJylcbiAgICB9KTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAgIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICAgIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gICAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAgIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gICAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICAgIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gICAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAgIC8vIGNhc3QgdG8gaW50cy5cbiAgICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+IH50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gICAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gICAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAgIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAgIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAgIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAgIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gICAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gICAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAgIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gICAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAgIC8vIHNvY2tldCBvciBmaWxlLlxuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gICAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gICAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gICAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gICAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gICAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gICAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAgIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAgIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICAgIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gICAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICAgIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgICB9O1xuXG4gICAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gICAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAgIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgICB0aGlzLndyaXRlbGVuID0gMDtcblxuICAgIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gICAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gICAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICAgIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICAgIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gICAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAgIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xuICB9XG5cbiAgV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gd3JpdGFibGVTdGF0ZUdldEJ1ZmZlcigpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuICBmdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG5cbiAgICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAgIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgICAvLyBsZWdhY3kuXG4gICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICAgIH1cblxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuICBXcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICAgIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gICAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgbmV4dFRpY2soY2IsIGVyKTtcbiAgfVxuXG4gIC8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuICAvLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuICAvLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbiAgLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4gIC8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG4gIGZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gICAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgICB2YXIgZXIgPSBmYWxzZTtcbiAgICAvLyBBbHdheXMgdGhyb3cgZXJyb3IgaWYgYSBudWxsIGlzIHdyaXR0ZW5cbiAgICAvLyBpZiB3ZSBhcmUgbm90IGluIG9iamVjdCBtb2RlIHRoZW4gdGhyb3dcbiAgICAvLyBpZiBpdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgb3IgdW5kZWZpbmVkLlxuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICB9XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgICBuZXh0VGljayhjYiwgZXIpO1xuICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkO1xuICB9XG5cbiAgV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICAgIHZhciByZXQgPSBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgICBlbmNvZGluZyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gICAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICAgIHN0YXRlLmNvcmtlZCsrO1xuICB9O1xuXG4gIFdyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICAgIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIFdyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBmdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gICAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rO1xuICB9XG5cbiAgLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4gIC8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4gIC8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG4gIGZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gICAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gICAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gICAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBpZiAobGFzdCkge1xuICAgICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gICAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgICAtLXN0YXRlLnBlbmRpbmdjYjtcbiAgICBpZiAoc3luYykgbmV4dFRpY2soY2IsIGVyKTtlbHNlIGNiKGVyKTtcblxuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gICAgc3RhdGUud3JpdGVsZW4gPSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gICAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICAgIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gICAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICAgIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICAgICAgbmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gICAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKCk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICAvLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4gIC8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG4gIGZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbiAgZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICAgIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICAgIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgICAgY291bnQgKz0gMTtcbiAgICAgIH1cblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICAgIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xuICB9O1xuXG4gIFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuICBXcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBjaHVuaztcbiAgICAgIGNodW5rID0gbnVsbDtcbiAgICAgIGVuY29kaW5nID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBlbmNvZGluZztcbiAgICAgIGVuY29kaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gICAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgICAgdGhpcy51bmNvcmsoKTtcbiAgICB9XG5cbiAgICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gICAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gICAgaWYgKG5lZWQpIHtcbiAgICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5lZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICAgIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKGNiKSB7XG4gICAgICBpZiAoc3RhdGUuZmluaXNoZWQpIG5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gICAgfVxuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuICAvLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbiAgZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIHRoaXMuZW50cnkgPSBudWxsO1xuXG4gICAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICB2YXIgZW50cnkgPSBfdGhpcy5lbnRyeTtcbiAgICAgIF90aGlzLmVudHJ5ID0gbnVsbDtcbiAgICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICAgIGNiKGVycik7XG4gICAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBfdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IF90aGlzO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpbmhlcml0cyQxKER1cGxleCwgUmVhZGFibGUpO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG4gIGZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gICAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG4gIH1cblxuICAvLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gICAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAgIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgICBuZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICAgIHNlbGYuZW5kKCk7XG4gIH1cblxuICAvLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4gIGluaGVyaXRzJDEoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG4gIGZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKHN0cmVhbSkge1xuICAgIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgICB9O1xuXG4gICAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gICAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICAgIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG4gICAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gICAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICAgIGlmICghY2IpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gICAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gICAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gICAgY2IoZXIpO1xuXG4gICAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICAgIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKHRoaXMpO1xuXG4gICAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICAgIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gICAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gICAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAgIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gICAgfVxuXG4gICAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgZG9uZShzdHJlYW0sIGVyKTtcbiAgICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pO1xuICAgIH0pO1xuICB9XG5cbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICAgIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbiAgLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuICAvLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuICAvL1xuICAvLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbiAgLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbiAgLy9cbiAgLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3NcbiAgLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuICAvLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuICBUcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gIH07XG5cbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICAgIHRzLndyaXRlY2IgPSBjYjtcbiAgICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gICAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICAgIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gICAgfVxuICB9O1xuXG4gIC8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4gIC8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4gIC8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gICAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XG4gICAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gICAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAgIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICAgIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gICAgaWYgKHdzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICAgIGlmICh0cy50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gICAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xuICB9XG5cbiAgaW5oZXJpdHMkMShQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcbiAgZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIFBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBjYihudWxsLCBjaHVuayk7XG4gIH07XG5cbiAgaW5oZXJpdHMkMShTdHJlYW0sIEV2ZW50RW1pdHRlcik7XG4gIFN0cmVhbS5SZWFkYWJsZSA9IFJlYWRhYmxlO1xuICBTdHJlYW0uV3JpdGFibGUgPSBXcml0YWJsZTtcbiAgU3RyZWFtLkR1cGxleCA9IER1cGxleDtcbiAgU3RyZWFtLlRyYW5zZm9ybSA9IFRyYW5zZm9ybTtcbiAgU3RyZWFtLlBhc3NUaHJvdWdoID0gUGFzc1Rocm91Z2g7XG5cbiAgLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcbiAgU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuICAvLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4gIC8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbiAgZnVuY3Rpb24gU3RyZWFtKCkge1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB9XG5cbiAgU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gICAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gICAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB9XG5cbiAgICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgICBkZXN0LmVuZCgpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICAgIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICAgIGlmIChFdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgICAgfVxuICAgIH1cblxuICAgIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICAgIH1cblxuICAgIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICAgIHJldHVybiBkZXN0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH1cblxuICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgcmV0dXJuIG87XG4gICAgfTtcblxuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b0FycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICAgIHJldHVybiBhcnIyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gICAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gIH1cblxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICB9XG5cbiAgLypcbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDE2IENvZGVyUHVwcHlcblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuXG4gICovXG4gIHZhciBfZW5kaWFubmVzcztcbiAgZnVuY3Rpb24gZW5kaWFubmVzcygpIHtcbiAgICBpZiAodHlwZW9mIF9lbmRpYW5uZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIGEgPSBuZXcgQXJyYXlCdWZmZXIoMik7XG4gICAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KGEpO1xuICAgICAgdmFyIGMgPSBuZXcgVWludDE2QXJyYXkoYSk7XG4gICAgICBiWzBdID0gMTtcbiAgICAgIGJbMV0gPSAyO1xuICAgICAgaWYgKGNbMF0gPT09IDI1OCkge1xuICAgICAgICBfZW5kaWFubmVzcyA9ICdCRSc7XG4gICAgICB9IGVsc2UgaWYgKGNbMF0gPT09IDUxMyl7XG4gICAgICAgIF9lbmRpYW5uZXNzID0gJ0xFJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGZpZ3VyZSBvdXQgZW5kaWFuZXNzJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfZW5kaWFubmVzcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhvc3RuYW1lKCkge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsJDEubG9jYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsJDEubG9jYXRpb24uaG9zdG5hbWVcbiAgICB9IGVsc2UgcmV0dXJuICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9hZGF2ZygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBmdW5jdGlvbiB1cHRpbWUoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlbWVtKCkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xuICB9XG5cbiAgZnVuY3Rpb24gdG90YWxtZW0oKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG4gIH1cblxuICBmdW5jdGlvbiBjcHVzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHR5cGUoKSB7XG4gICAgcmV0dXJuICdCcm93c2VyJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbGVhc2UgKCkge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsJDEubmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGdsb2JhbCQxLm5hdmlnYXRvci5hcHBWZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBmdW5jdGlvbiBuZXR3b3JrSW50ZXJmYWNlcygpe31cbiAgZnVuY3Rpb24gZ2V0TmV0d29ya0ludGVyZmFjZXMoKXt9XG5cbiAgZnVuY3Rpb24gdG1wRGlyKCkge1xuICAgIHJldHVybiAnL3RtcCc7XG4gIH1cbiAgdmFyIHRtcGRpciA9IHRtcERpcjtcblxuICB2YXIgRU9MID0gJ1xcbic7XG4gIHZhciBvcyA9IHtcbiAgICBFT0w6IEVPTCxcbiAgICB0bXBkaXI6IHRtcGRpcixcbiAgICB0bXBEaXI6IHRtcERpcixcbiAgICBuZXR3b3JrSW50ZXJmYWNlczpuZXR3b3JrSW50ZXJmYWNlcyxcbiAgICBnZXROZXR3b3JrSW50ZXJmYWNlczogZ2V0TmV0d29ya0ludGVyZmFjZXMsXG4gICAgcmVsZWFzZTogcmVsZWFzZSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNwdXM6IGNwdXMsXG4gICAgdG90YWxtZW06IHRvdGFsbWVtLFxuICAgIGZyZWVtZW06IGZyZWVtZW0sXG4gICAgdXB0aW1lOiB1cHRpbWUsXG4gICAgbG9hZGF2ZzogbG9hZGF2ZyxcbiAgICBob3N0bmFtZTogaG9zdG5hbWUsXG4gICAgZW5kaWFubmVzczogZW5kaWFubmVzcyxcbiAgfTtcblxuICB2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuICAvKipcbiAgICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICAgKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAgICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gICAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAgICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAgICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gICAqL1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG4gIHZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbiAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuICB2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG4gIHZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgICByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gICAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICAgKi9cbiAgdmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbiAgdmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgY29tbW9uanNHbG9iYWw7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gICAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgICAvLyBkZXNwaXRlIGhhdmluZyBpbXByb3Blcmx5IGRlZmluZWQgYHRvU3RyaW5nYCBtZXRob2RzLlxuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG4gIHZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbiAgdmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG4gIH0oKSk7XG5cbiAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4gIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgaGFzT3duUHJvcGVydHkkMSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gICAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICAgKiBvZiB2YWx1ZXMuXG4gICAqL1xuICB2YXIgb2JqZWN0VG9TdHJpbmckMSA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG4gIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkkMSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuICApO1xuXG4gIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuICB2YXIgU3ltYm9sJDEgPSByb290LlN5bWJvbCxcbiAgICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4gIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbiAgdmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbiAgLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG4gIHZhciBzeW1ib2xQcm90byA9IFN5bWJvbCQxID8gU3ltYm9sJDEucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICovXG4gIGZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGNsZWFyXG4gICAqIEBtZW1iZXJPZiBIYXNoXG4gICAqL1xuICBmdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gICAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBkZWxldGVcbiAgICogQG1lbWJlck9mIEhhc2hcbiAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBnZXRcbiAgICogQG1lbWJlck9mIEhhc2hcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5JDEuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgaGFzXG4gICAqIEBtZW1iZXJPZiBIYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eSQxLmNhbGwoZGF0YSwga2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIHNldFxuICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuICBIYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbiAgSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbiAgSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbiAgSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbiAgSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgKi9cbiAgZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBjbGVhclxuICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAqL1xuICBmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgICB0aGlzLl9fZGF0YV9fID0gW107XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGRlbGV0ZVxuICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICAgIGRhdGEucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGdldFxuICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgaGFzXG4gICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIHNldFxuICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuICBMaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG4gIExpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG4gIExpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICovXG4gIGZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGNsZWFyXG4gICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgKi9cbiAgZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBkZWxldGVcbiAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGdldFxuICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGhhc1xuICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIHNldFxuICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgIGdldE1hcERhdGEodGhpcywga2V5KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuICBNYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuICBNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG4gIE1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbiAgTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuICBNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgICBwYXRoID0gaXNLZXkocGF0aCwgb2JqZWN0KSA/IFtwYXRoXSA6IGNhc3RQYXRoKHBhdGgpO1xuXG4gICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gICAgfVxuICAgIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QkMSh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBwYXR0ZXJuID0gKGlzRnVuY3Rpb24kMSh2YWx1ZSkgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAgICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAgIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUpIHtcbiAgICByZXR1cm4gaXNBcnJheSQyKHZhbHVlKSA/IHZhbHVlIDogc3RyaW5nVG9QYXRoKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gICAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gICAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgICAgOiBkYXRhLm1hcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgICBpZiAoaXNBcnJheSQyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICAgIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgKi9cbiAgdmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemUoZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgc3RyaW5nID0gdG9TdHJpbmckMShzdHJpbmcpO1xuXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGlmIChyZUxlYWRpbmdEb3QudGVzdChzdHJpbmcpKSB7XG4gICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgfVxuICAgIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdHJpbmcpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcblxuICAvKipcbiAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICAgKi9cbiAgZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwcm9jZXNzLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAgICovXG4gIGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gICAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gICAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICAgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICAgKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICAgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICAgKlxuICAgKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAgICogdmFsdWVzKG9iamVjdCk7XG4gICAqIC8vID0+IFsxLCAyXVxuICAgKlxuICAgKiB2YWx1ZXMob3RoZXIpO1xuICAgKiAvLyA9PiBbMywgNF1cbiAgICpcbiAgICogb2JqZWN0LmEgPSAyO1xuICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICogLy8gPT4gWzEsIDJdXG4gICAqXG4gICAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICAgKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAqIHZhbHVlcyhvYmplY3QpO1xuICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAqXG4gICAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gICAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gICAqL1xuICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgIH1cbiAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gICAgcmV0dXJuIG1lbW9pemVkO1xuICB9XG5cbiAgLy8gQXNzaWduIGNhY2hlIHRvIGBfLm1lbW9pemVgLlxuICBtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGFcbiAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgKlxuICAgKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmVxKCdhJywgJ2EnKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmVxKE5hTiwgTmFOKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc0FycmF5KCdhYmMnKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc0FycmF5KF8ubm9vcCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICB2YXIgaXNBcnJheSQyID0gQXJyYXkuaXNBcnJheTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24kMSh2YWx1ZSkge1xuICAgIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAgIC8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgICB2YXIgdGFnID0gaXNPYmplY3QkMSh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZyQxLmNhbGwodmFsdWUpIDogJyc7XG4gICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gICAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAgICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNPYmplY3Qoe30pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdChudWxsKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzT2JqZWN0JDEodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICAgKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmckMS5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gICAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8udG9TdHJpbmcobnVsbCk7XG4gICAqIC8vID0+ICcnXG4gICAqXG4gICAqIF8udG9TdHJpbmcoLTApO1xuICAgKiAvLyA9PiAnLTAnXG4gICAqXG4gICAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAgICogLy8gPT4gJzEsMiwzJ1xuICAgKi9cbiAgZnVuY3Rpb24gdG9TdHJpbmckMSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gICAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAzLjcuMFxuICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgKlxuICAgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgKiAvLyA9PiAzXG4gICAqXG4gICAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgKiAvLyA9PiAzXG4gICAqXG4gICAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAqL1xuICBmdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xuICB9XG5cbiAgdmFyIGxvZGFzaF9nZXQgPSBnZXQ7XG5cbiAgZnVuY3Rpb24gZ2V0UHJvcChvYmosIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiBvYmpbcGF0aF0gPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IG9ialtwYXRoXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFByb3Aob2JqLCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBwYXRoQXJyYXkgPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoJy4nKTtcblxuICAgIHZhciBfcGF0aEFycmF5ID0gX3RvQXJyYXkocGF0aEFycmF5KSxcbiAgICAgICAga2V5ID0gX3BhdGhBcnJheVswXSxcbiAgICAgICAgcmVzdFBhdGggPSBfcGF0aEFycmF5LnNsaWNlKDEpO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gcGF0aEFycmF5Lmxlbmd0aCA+IDEgPyBzZXRQcm9wKG9ialtrZXldIHx8IHt9LCByZXN0UGF0aCwgdmFsdWUpIDogdmFsdWU7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9iaiwgX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIG5ld1ZhbHVlKSk7XG4gIH1cblxuICBmdW5jdGlvbiB1bnNldFByb3Aob2JqLCBwYXRoKSB7XG4gICAgdmFyIHBhdGhBcnJheSA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuXG4gICAgdmFyIF9wYXRoQXJyYXkyID0gX3RvQXJyYXkocGF0aEFycmF5KSxcbiAgICAgICAga2V5ID0gX3BhdGhBcnJheTJbMF0sXG4gICAgICAgIHJlc3RQYXRoID0gX3BhdGhBcnJheTIuc2xpY2UoMSk7XG5cbiAgICBpZiAoX3R5cGVvZihvYmpba2V5XSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgbmV2ZXIgYmUgaGl0IGluIHRoZSBjdXJyZW50IGNvZGUgYmVjYXVzZSB1bndpbmQgZG9lcyB0aGUgY2hlY2sgYmVmb3JlIGNhbGxpbmcgdW5zZXRQcm9wXG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGlmIChwYXRoQXJyYXkubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5maWx0ZXIoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIHByb3AgIT09IGtleTtcbiAgICAgIH0pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjYywgX2RlZmluZVByb3BlcnR5KHt9LCBwcm9wLCBvYmpbcHJvcF0pKTtcbiAgICAgIH0sIHt9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5zZXRQcm9wKG9ialtrZXldLCByZXN0UGF0aCk7XG4gIH1cblxuICBmdW5jdGlvbiBmbGF0dGVuUmVkdWNlcihhY2MsIGFycikge1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGlzIGlzIGZhc3RlciBidXQgc3VzY2VwdGlibGUgdG8gYFJhbmdlRXJyb3I6IE1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkYFxuICAgICAgYWNjLnB1c2guYXBwbHkoYWNjLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gYSBzbG93ZXIgYnV0IHNhZmVyIG9wdGlvblxuICAgICAgcmV0dXJuIGFjYy5jb25jYXQoYXJyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmYXN0Sm9pbihhcnIsIHNlcGFyYXRvcikge1xuICAgIHZhciBpc0ZpcnN0ID0gdHJ1ZTtcbiAgICByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBlbGVtKSB7XG4gICAgICBpZiAoZWxlbSA9PT0gbnVsbCB8fCBlbGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWxlbSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICBpc0ZpcnN0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChlbGVtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGFjYykuY29uY2F0KHNlcGFyYXRvcikuY29uY2F0KGVsZW0pO1xuICAgIH0sICcnKTtcbiAgfVxuXG4gIHZhciB1dGlscyA9IHtcbiAgICBnZXRQcm9wOiBnZXRQcm9wLFxuICAgIHNldFByb3A6IHNldFByb3AsXG4gICAgdW5zZXRQcm9wOiB1bnNldFByb3AsXG4gICAgZmFzdEpvaW46IGZhc3RKb2luLFxuICAgIGZsYXR0ZW5SZWR1Y2VyOiBmbGF0dGVuUmVkdWNlclxuICB9O1xuXG4gIHZhciBnZXRQcm9wJDEgPSB1dGlscy5nZXRQcm9wLFxuICAgICAgZmFzdEpvaW4kMSA9IHV0aWxzLmZhc3RKb2luLFxuICAgICAgZmxhdHRlblJlZHVjZXIkMSA9IHV0aWxzLmZsYXR0ZW5SZWR1Y2VyO1xuXG4gIHZhciBKU09OMkNTVkJhc2UgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKU09OMkNTVkJhc2Uob3B0cykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEpTT04yQ1NWQmFzZSk7XG5cbiAgICAgIHRoaXMub3B0cyA9IHRoaXMucHJlcHJvY2Vzc09wdHMob3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHBhc3Npbmcgb3B0cyBhbmQgc2V0IGRlZmF1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKc29uMkNzdk9wdGlvbnN9IG9wdHMgT3B0aW9ucyBvYmplY3QgY29udGFpbmluZyBmaWVsZHMsXG4gICAgICogZGVsaW1pdGVyLCBkZWZhdWx0IHZhbHVlLCBxdW90ZSBtYXJrLCBoZWFkZXIsIGV0Yy5cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEpTT04yQ1NWQmFzZSwgW3tcbiAgICAgIGtleTogXCJwcmVwcm9jZXNzT3B0c1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByZXByb2Nlc3NPcHRzKG9wdHMpIHtcbiAgICAgICAgdmFyIHByb2Nlc3NlZE9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKTtcbiAgICAgICAgcHJvY2Vzc2VkT3B0cy50cmFuc2Zvcm1zID0gIUFycmF5LmlzQXJyYXkocHJvY2Vzc2VkT3B0cy50cmFuc2Zvcm1zKSA/IHByb2Nlc3NlZE9wdHMudHJhbnNmb3JtcyA/IFtwcm9jZXNzZWRPcHRzLnRyYW5zZm9ybXNdIDogW10gOiBwcm9jZXNzZWRPcHRzLnRyYW5zZm9ybXM7XG4gICAgICAgIHByb2Nlc3NlZE9wdHMuZGVsaW1pdGVyID0gcHJvY2Vzc2VkT3B0cy5kZWxpbWl0ZXIgfHwgJywnO1xuICAgICAgICBwcm9jZXNzZWRPcHRzLmVvbCA9IHByb2Nlc3NlZE9wdHMuZW9sIHx8IG9zLkVPTDtcbiAgICAgICAgcHJvY2Vzc2VkT3B0cy5xdW90ZSA9IHR5cGVvZiBwcm9jZXNzZWRPcHRzLnF1b3RlID09PSAnc3RyaW5nJyA/IHByb2Nlc3NlZE9wdHMucXVvdGUgOiAnXCInO1xuICAgICAgICBwcm9jZXNzZWRPcHRzLmVzY2FwZWRRdW90ZSA9IHR5cGVvZiBwcm9jZXNzZWRPcHRzLmVzY2FwZWRRdW90ZSA9PT0gJ3N0cmluZycgPyBwcm9jZXNzZWRPcHRzLmVzY2FwZWRRdW90ZSA6IFwiXCIuY29uY2F0KHByb2Nlc3NlZE9wdHMucXVvdGUpLmNvbmNhdChwcm9jZXNzZWRPcHRzLnF1b3RlKTtcbiAgICAgICAgcHJvY2Vzc2VkT3B0cy5oZWFkZXIgPSBwcm9jZXNzZWRPcHRzLmhlYWRlciAhPT0gZmFsc2U7XG4gICAgICAgIHByb2Nlc3NlZE9wdHMuaW5jbHVkZUVtcHR5Um93cyA9IHByb2Nlc3NlZE9wdHMuaW5jbHVkZUVtcHR5Um93cyB8fCBmYWxzZTtcbiAgICAgICAgcHJvY2Vzc2VkT3B0cy53aXRoQk9NID0gcHJvY2Vzc2VkT3B0cy53aXRoQk9NIHx8IGZhbHNlO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkT3B0cztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2sgYW5kIG5vcm1hbGl6ZSB0aGUgZmllbGRzIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdClbXX0gZmllbGRzIEZpZWxkcyBjb25maWd1cmF0aW9uIHByb3ZpZGVkIGJ5IHRoZSB1c2VyXG4gICAgICAgKiBvciBpbmZlcnJlZCBmcm9tIHRoZSBkYXRhXG4gICAgICAgKiBAcmV0dXJucyB7b2JqZWN0W119IHByZXByb2Nlc3NlZCBGaWVsZHNJbmZvIGFycmF5XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcmVwcm9jZXNzRmllbGRzSW5mb1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByZXByb2Nlc3NGaWVsZHNJbmZvKGZpZWxkcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBmaWVsZHMubWFwKGZ1bmN0aW9uIChmaWVsZEluZm8pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkSW5mbyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGxhYmVsOiBmaWVsZEluZm8sXG4gICAgICAgICAgICAgIHZhbHVlOiBmaWVsZEluZm8uaW5jbHVkZXMoJy4nKSB8fCBmaWVsZEluZm8uaW5jbHVkZXMoJ1snKSA/IGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9kYXNoX2dldChyb3csIGZpZWxkSW5mbywgX3RoaXMub3B0cy5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wJDEocm93LCBmaWVsZEluZm8sIF90aGlzLm9wdHMuZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX3R5cGVvZihmaWVsZEluZm8pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9ICdkZWZhdWx0JyBpbiBmaWVsZEluZm8gPyBmaWVsZEluZm8uZGVmYXVsdCA6IF90aGlzLm9wdHMuZGVmYXVsdFZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkSW5mby52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogZmllbGRJbmZvLmxhYmVsIHx8IGZpZWxkSW5mby52YWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZmllbGRJbmZvLnZhbHVlLmluY2x1ZGVzKCcuJykgfHwgZmllbGRJbmZvLnZhbHVlLmluY2x1ZGVzKCdbJykgPyBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbG9kYXNoX2dldChyb3csIGZpZWxkSW5mby52YWx1ZSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3AkMShyb3csIGZpZWxkSW5mby52YWx1ZSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGRJbmZvLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHZhciBsYWJlbCA9IGZpZWxkSW5mby5sYWJlbCB8fCBmaWVsZEluZm8udmFsdWUubmFtZSB8fCAnJztcbiAgICAgICAgICAgICAgdmFyIGZpZWxkID0ge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBkZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJvdykge1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZmllbGRJbmZvLnZhbHVlKHJvdywgZmllbGQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZpZWxkIGluZm8gb3B0aW9uLiAnICsgSlNPTi5zdHJpbmdpZnkoZmllbGRJbmZvKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgdGhlIHRpdGxlIHJvdyB3aXRoIGFsbCB0aGUgcHJvdmlkZWQgZmllbGRzIGFzIGNvbHVtbiBoZWFkaW5nc1xuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRpdGxlcyBhcyBhIHN0cmluZ1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0SGVhZGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVhZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICByZXR1cm4gZmFzdEpvaW4kMSh0aGlzLm9wdHMuZmllbGRzLm1hcChmdW5jdGlvbiAoZmllbGRJbmZvKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5wcm9jZXNzVmFsdWUoZmllbGRJbmZvLmxhYmVsKTtcbiAgICAgICAgfSksIHRoaXMub3B0cy5kZWxpbWl0ZXIpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBQcmVwcm9jZXNzIGVhY2ggb2JqZWN0IGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gdHJhbnNmb3JtcyAodW53aW5kLCBmbGF0dGVuLCBldGMuKS5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByb3cgSlNPTiBvYmplY3QgdG8gYmUgY29udmVydGVkIGluIGEgQ1NWIHJvd1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJlcHJvY2Vzc1Jvd1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByZXByb2Nlc3NSb3cocm93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdHMudHJhbnNmb3Jtcy5yZWR1Y2UoZnVuY3Rpb24gKHJvd3MsIHRyYW5zZm9ybSkge1xuICAgICAgICAgIHJldHVybiByb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtKHJvdyk7XG4gICAgICAgICAgfSkucmVkdWNlKGZsYXR0ZW5SZWR1Y2VyJDEsIFtdKTtcbiAgICAgICAgfSwgW3Jvd10pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgdGhlIGNvbnRlbnQgb2YgYSBzcGVjaWZpYyBDU1Ygcm93XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJvdyBKU09OIG9iamVjdCB0byBiZSBjb252ZXJ0ZWQgaW4gYSBDU1Ygcm93XG4gICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBDU1Ygc3RyaW5nIChyb3cpXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcm9jZXNzUm93XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1Jvdyhyb3cpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb2Nlc3NlZFJvdyA9IHRoaXMub3B0cy5maWVsZHMubWFwKGZ1bmN0aW9uIChmaWVsZEluZm8pIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLnByb2Nlc3NDZWxsKHJvdywgZmllbGRJbmZvKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdHMuaW5jbHVkZUVtcHR5Um93cyAmJiBwcm9jZXNzZWRSb3cuZXZlcnkoZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgcmV0dXJuIGZpZWxkID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYXN0Sm9pbiQxKHByb2Nlc3NlZFJvdywgdGhpcy5vcHRzLmRlbGltaXRlcik7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSB0aGUgY29udGVudCBvZiBhIHNwZWNmaWMgQ1NWIHJvdyBjZWxsXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJvdyBKU09OIG9iamVjdCByZXByZXNlbnRpbmcgdGhlICBDU1Ygcm93IHRoYXQgdGhlIGNlbGwgYmVsb25ncyB0b1xuICAgICAgICogQHBhcmFtIHtGaWVsZEluZm99IGZpZWxkSW5mbyBEZXRhaWxzIG9mIHRoZSBmaWVsZCB0byBwcm9jZXNzIHRvIGJlIGEgQ1NWIGNlbGxcbiAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IENTViBzdHJpbmcgKGNlbGwpXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcm9jZXNzQ2VsbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NDZWxsKHJvdywgZmllbGRJbmZvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NWYWx1ZShmaWVsZEluZm8udmFsdWUocm93KSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSB0aGUgY29udGVudCBvZiBhIHNwZWNmaWMgQ1NWIHJvdyBjZWxsXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtBbnl9IHZhbHVlIFZhbHVlIHRvIGJlIGluY2x1ZGVkIGluIGEgQ1NWIGNlbGxcbiAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFZhbHVlIHN0cmluZ2lmaWVkIGFuZCBwcm9jZXNzZWRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInByb2Nlc3NWYWx1ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWVUeXBlID0gX3R5cGVvZih2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlVHlwZSAhPT0gJ2Jvb2xlYW4nICYmIHZhbHVlVHlwZSAhPT0gJ251bWJlcicgJiYgdmFsdWVUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlWzBdID09PSAnXCInKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL15cIiguKylcIiQvLCAnJDEnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0aGlzLm9wdHMuZXhjZWxTdHJpbmdzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXModGhpcy5vcHRzLnF1b3RlKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UobmV3IFJlZ0V4cCh0aGlzLm9wdHMucXVvdGUsICdnJyksIFwiXCIuY29uY2F0KHRoaXMub3B0cy5lc2NhcGVkUXVvdGUpLmNvbmNhdCh0aGlzLm9wdHMuZXNjYXBlZFF1b3RlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gXCJcXFwiPVxcXCJcXFwiXCIuY29uY2F0KHZhbHVlLCBcIlxcXCJcXFwiXFxcIlwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKHRoaXMub3B0cy5xdW90ZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5vcHRzLnF1b3RlLCAnZycpLCB0aGlzLm9wdHMuZXNjYXBlZFF1b3RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSBcIlwiLmNvbmNhdCh0aGlzLm9wdHMucXVvdGUpLmNvbmNhdCh2YWx1ZSkuY29uY2F0KHRoaXMub3B0cy5xdW90ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBKU09OMkNTVkJhc2U7XG4gIH0oKTtcblxuICB2YXIgSlNPTjJDU1ZCYXNlXzEgPSBKU09OMkNTVkJhc2U7XG5cbiAgdmFyIGZhc3RKb2luJDIgPSB1dGlscy5mYXN0Sm9pbixcbiAgICAgIGZsYXR0ZW5SZWR1Y2VyJDIgPSB1dGlscy5mbGF0dGVuUmVkdWNlcjtcblxuICB2YXIgSlNPTjJDU1ZQYXJzZXIgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfSlNPTjJDU1ZCYXNlKSB7XG4gICAgX2luaGVyaXRzKEpTT04yQ1NWUGFyc2VyLCBfSlNPTjJDU1ZCYXNlKTtcblxuICAgIGZ1bmN0aW9uIEpTT04yQ1NWUGFyc2VyKG9wdHMpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEpTT04yQ1NWUGFyc2VyKTtcblxuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoSlNPTjJDU1ZQYXJzZXIpLmNhbGwodGhpcywgb3B0cykpO1xuXG4gICAgICBpZiAoX3RoaXMub3B0cy5maWVsZHMpIHtcbiAgICAgICAgX3RoaXMub3B0cy5maWVsZHMgPSBfdGhpcy5wcmVwcm9jZXNzRmllbGRzSW5mbyhfdGhpcy5vcHRzLmZpZWxkcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFpbiBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIGpzb24gdG8gY3N2LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGRhdGEgQXJyYXkgb2YgSlNPTiBvYmplY3RzIHRvIGJlIGNvbnZlcnRlZCB0byBDU1ZcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgQ1NWIGZvcm1hdGVkIGRhdGEgYXMgYSBzdHJpbmdcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEpTT04yQ1NWUGFyc2VyLCBbe1xuICAgICAga2V5OiBcInBhcnNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoZGF0YSkge1xuICAgICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IHRoaXMucHJlcHJvY2Vzc0RhdGEoZGF0YSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdHMuZmllbGRzKSB7XG4gICAgICAgICAgdGhpcy5vcHRzLmZpZWxkcyA9IHByb2Nlc3NlZERhdGEucmVkdWNlKGZ1bmN0aW9uIChmaWVsZHMsIGl0ZW0pIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGl0ZW0pLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgIGlmICghZmllbGRzLmluY2x1ZGVzKGZpZWxkKSkge1xuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRzO1xuICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICB0aGlzLm9wdHMuZmllbGRzID0gdGhpcy5wcmVwcm9jZXNzRmllbGRzSW5mbyh0aGlzLm9wdHMuZmllbGRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoZWFkZXIgPSB0aGlzLm9wdHMuaGVhZGVyID8gdGhpcy5nZXRIZWFkZXIoKSA6ICcnO1xuICAgICAgICB2YXIgcm93cyA9IHRoaXMucHJvY2Vzc0RhdGEocHJvY2Vzc2VkRGF0YSk7XG4gICAgICAgIHZhciBjc3YgPSAodGhpcy5vcHRzLndpdGhCT00gPyBcIlxcdUZFRkZcIiA6ICcnKSArIGhlYWRlciArIChoZWFkZXIgJiYgcm93cyA/IHRoaXMub3B0cy5lb2wgOiAnJykgKyByb3dzO1xuICAgICAgICByZXR1cm4gY3N2O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBQcmVwcm9jZXNzIHRoZSBkYXRhIGFjY29yZGluZyB0byB0aGUgZ2l2ZSBvcHRzICh1bndpbmQsIGZsYXR0ZW4sIGV0Yy4pXG4gICAgICAgIGFuZCBjYWxjdWxhdGUgdGhlIGZpZWxkcyBhbmQgZmllbGQgbmFtZXMgaWYgdGhleSBhcmUgbm90IHByb3ZpZGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBkYXRhIEFycmF5IG9yIG9iamVjdCB0byBiZSBjb252ZXJ0ZWQgdG8gQ1NWXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcmVwcm9jZXNzRGF0YVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByZXByb2Nlc3NEYXRhKGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YSA6IFtkYXRhXTtcblxuICAgICAgICBpZiAoIXRoaXMub3B0cy5maWVsZHMgJiYgKHByb2Nlc3NlZERhdGEubGVuZ3RoID09PSAwIHx8IF90eXBlb2YocHJvY2Vzc2VkRGF0YVswXSkgIT09ICdvYmplY3QnKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBzaG91bGQgbm90IGJlIGVtcHR5IG9yIHRoZSBcImZpZWxkc1wiIG9wdGlvbiBzaG91bGQgYmUgaW5jbHVkZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdHMudHJhbnNmb3Jtcy5sZW5ndGggPT09IDApIHJldHVybiBwcm9jZXNzZWREYXRhO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRGF0YS5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgIHJldHVybiBfdGhpczIucHJlcHJvY2Vzc1Jvdyhyb3cpO1xuICAgICAgICB9KS5yZWR1Y2UoZmxhdHRlblJlZHVjZXIkMiwgW10pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgdGhlIGNvbnRlbnQgcm93IGJ5IHJvdyBiZWxvdyB0aGUgaGVhZGVyXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBBcnJheSBvZiBKU09OIG9iamVjdHMgdG8gYmUgY29udmVydGVkIHRvIENTVlxuICAgICAgICogQHJldHVybnMge1N0cmluZ30gQ1NWIHN0cmluZyAoYm9keSlcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInByb2Nlc3NEYXRhXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0RhdGEoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gZmFzdEpvaW4kMihkYXRhLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5wcm9jZXNzUm93KHJvdyk7XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfSksIC8vIEZpbHRlciBlbXB0eSByb3dzXG4gICAgICAgIHRoaXMub3B0cy5lb2wpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBKU09OMkNTVlBhcnNlcjtcbiAgfShKU09OMkNTVkJhc2VfMSk7XG5cbiAgdmFyIEpTT04yQ1NWUGFyc2VyXzEgPSBKU09OMkNTVlBhcnNlcjtcblxuICAvKmdsb2JhbCBCdWZmZXIqL1xuICAvLyBOYW1lZCBjb25zdGFudHMgd2l0aCB1bmlxdWUgaW50ZWdlciB2YWx1ZXNcbiAgdmFyIEMgPSB7fTtcbiAgLy8gVG9rZW5zXG4gIHZhciBMRUZUX0JSQUNFICAgID0gQy5MRUZUX0JSQUNFICAgID0gMHgxO1xuICB2YXIgUklHSFRfQlJBQ0UgICA9IEMuUklHSFRfQlJBQ0UgICA9IDB4MjtcbiAgdmFyIExFRlRfQlJBQ0tFVCAgPSBDLkxFRlRfQlJBQ0tFVCAgPSAweDM7XG4gIHZhciBSSUdIVF9CUkFDS0VUID0gQy5SSUdIVF9CUkFDS0VUID0gMHg0O1xuICB2YXIgQ09MT04gICAgICAgICA9IEMuQ09MT04gICAgICAgICA9IDB4NTtcbiAgdmFyIENPTU1BICAgICAgICAgPSBDLkNPTU1BICAgICAgICAgPSAweDY7XG4gIHZhciBUUlVFICAgICAgICAgID0gQy5UUlVFICAgICAgICAgID0gMHg3O1xuICB2YXIgRkFMU0UgICAgICAgICA9IEMuRkFMU0UgICAgICAgICA9IDB4ODtcbiAgdmFyIE5VTEwgICAgICAgICAgPSBDLk5VTEwgICAgICAgICAgPSAweDk7XG4gIHZhciBTVFJJTkcgICAgICAgID0gQy5TVFJJTkcgICAgICAgID0gMHhhO1xuICB2YXIgTlVNQkVSICAgICAgICA9IEMuTlVNQkVSICAgICAgICA9IDB4YjtcbiAgLy8gVG9rZW5pemVyIFN0YXRlc1xuICB2YXIgU1RBUlQgICA9IEMuU1RBUlQgICA9IDB4MTE7XG4gIHZhciBTVE9QICAgID0gQy5TVE9QICAgID0gMHgxMjtcbiAgdmFyIFRSVUUxICAgPSBDLlRSVUUxICAgPSAweDIxO1xuICB2YXIgVFJVRTIgICA9IEMuVFJVRTIgICA9IDB4MjI7XG4gIHZhciBUUlVFMyAgID0gQy5UUlVFMyAgID0gMHgyMztcbiAgdmFyIEZBTFNFMSAgPSBDLkZBTFNFMSAgPSAweDMxO1xuICB2YXIgRkFMU0UyICA9IEMuRkFMU0UyICA9IDB4MzI7XG4gIHZhciBGQUxTRTMgID0gQy5GQUxTRTMgID0gMHgzMztcbiAgdmFyIEZBTFNFNCAgPSBDLkZBTFNFNCAgPSAweDM0O1xuICB2YXIgTlVMTDEgICA9IEMuTlVMTDEgICA9IDB4NDE7XG4gIHZhciBOVUxMMiAgID0gQy5OVUxMMiAgID0gMHg0MjtcbiAgdmFyIE5VTEwzICAgPSBDLk5VTEwzICAgPSAweDQzO1xuICB2YXIgTlVNQkVSMSA9IEMuTlVNQkVSMSA9IDB4NTE7XG4gIHZhciBOVU1CRVIzID0gQy5OVU1CRVIzID0gMHg1MztcbiAgdmFyIFNUUklORzEgPSBDLlNUUklORzEgPSAweDYxO1xuICB2YXIgU1RSSU5HMiA9IEMuU1RSSU5HMiA9IDB4NjI7XG4gIHZhciBTVFJJTkczID0gQy5TVFJJTkczID0gMHg2MztcbiAgdmFyIFNUUklORzQgPSBDLlNUUklORzQgPSAweDY0O1xuICB2YXIgU1RSSU5HNSA9IEMuU1RSSU5HNSA9IDB4NjU7XG4gIHZhciBTVFJJTkc2ID0gQy5TVFJJTkc2ID0gMHg2NjtcbiAgLy8gUGFyc2VyIFN0YXRlc1xuICB2YXIgVkFMVUUgICA9IEMuVkFMVUUgICA9IDB4NzE7XG4gIHZhciBLRVkgICAgID0gQy5LRVkgICAgID0gMHg3MjtcbiAgLy8gUGFyc2VyIE1vZGVzXG4gIHZhciBPQkpFQ1QgID0gQy5PQkpFQ1QgID0gMHg4MTtcbiAgdmFyIEFSUkFZICAgPSBDLkFSUkFZICAgPSAweDgyO1xuICAvLyBDaGFyYWN0ZXIgY29uc3RhbnRzXG4gIHZhciBCQUNLX1NMQVNIID0gICAgICBcIlxcXFxcIi5jaGFyQ29kZUF0KDApO1xuICB2YXIgRk9SV0FSRF9TTEFTSCA9ICAgXCJcXC9cIi5jaGFyQ29kZUF0KDApO1xuICB2YXIgQkFDS1NQQUNFID0gICAgICAgXCJcXGJcIi5jaGFyQ29kZUF0KDApO1xuICB2YXIgRk9STV9GRUVEID0gICAgICAgXCJcXGZcIi5jaGFyQ29kZUF0KDApO1xuICB2YXIgTkVXTElORSA9ICAgICAgICAgXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xuICB2YXIgQ0FSUklBR0VfUkVUVVJOID0gXCJcXHJcIi5jaGFyQ29kZUF0KDApO1xuICB2YXIgVEFCID0gICAgICAgICAgICAgXCJcXHRcIi5jaGFyQ29kZUF0KDApO1xuXG4gIHZhciBTVFJJTkdfQlVGRkVSX1NJWkUgPSA2NCAqIDEwMjQ7XG5cbiAgZnVuY3Rpb24gUGFyc2VyKCkge1xuICAgIHRoaXMudFN0YXRlID0gU1RBUlQ7XG4gICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuc3RyaW5nID0gdW5kZWZpbmVkOyAvLyBzdHJpbmcgZGF0YVxuICAgIHRoaXMuc3RyaW5nQnVmZmVyID0gQnVmZmVyLmFsbG9jID8gQnVmZmVyLmFsbG9jKFNUUklOR19CVUZGRVJfU0laRSkgOiBuZXcgQnVmZmVyKFNUUklOR19CVUZGRVJfU0laRSk7XG4gICAgdGhpcy5zdHJpbmdCdWZmZXJPZmZzZXQgPSAwO1xuICAgIHRoaXMudW5pY29kZSA9IHVuZGVmaW5lZDsgLy8gdW5pY29kZSBlc2NhcGVzXG4gICAgdGhpcy5oaWdoU3Vycm9nYXRlID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5rZXkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tb2RlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLnN0YXRlID0gVkFMVUU7XG4gICAgdGhpcy5ieXRlc19yZW1haW5pbmcgPSAwOyAvLyBudW1iZXIgb2YgYnl0ZXMgcmVtYWluaW5nIGluIG11bHRpIGJ5dGUgdXRmOCBjaGFyIHRvIHJlYWQgYWZ0ZXIgc3BsaXQgYm91bmRhcnlcbiAgICB0aGlzLmJ5dGVzX2luX3NlcXVlbmNlID0gMDsgLy8gYnl0ZXMgaW4gbXVsdGkgYnl0ZSB1dGY4IGNoYXIgdG8gcmVhZFxuICAgIHRoaXMudGVtcF9idWZmcyA9IHsgXCIyXCI6IG5ldyBCdWZmZXIoMiksIFwiM1wiOiBuZXcgQnVmZmVyKDMpLCBcIjRcIjogbmV3IEJ1ZmZlcig0KSB9OyAvLyBmb3IgcmVidWlsZGluZyBjaGFycyBzcGxpdCBiZWZvcmUgYm91bmRhcnkgaXMgcmVhY2hlZFxuXG4gICAgLy8gU3RyZWFtIG9mZnNldFxuICAgIHRoaXMub2Zmc2V0ID0gLTE7XG4gIH1cblxuICAvLyBTbG93IGNvZGUgdG8gc3RyaW5nIGNvbnZlcnRlciAob25seSB1c2VkIHdoZW4gdGhyb3dpbmcgc3ludGF4IGVycm9ycylcbiAgUGFyc2VyLnRva25hbSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhDKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChDW2tleV0gPT09IGNvZGUpIHsgcmV0dXJuIGtleTsgfVxuICAgIH1cbiAgICByZXR1cm4gY29kZSAmJiAoXCIweFwiICsgY29kZS50b1N0cmluZygxNikpO1xuICB9O1xuXG4gIHZhciBwcm90byA9IFBhcnNlci5wcm90b3R5cGU7XG4gIHByb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IHRocm93IGVycjsgfTtcbiAgcHJvdG8uY2hhckVycm9yID0gZnVuY3Rpb24gKGJ1ZmZlciwgaSkge1xuICAgIHRoaXMudFN0YXRlID0gU1RPUDtcbiAgICB0aGlzLm9uRXJyb3IobmV3IEVycm9yKFwiVW5leHBlY3RlZCBcIiArIEpTT04uc3RyaW5naWZ5KFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZmVyW2ldKSkgKyBcIiBhdCBwb3NpdGlvbiBcIiArIGkgKyBcIiBpbiBzdGF0ZSBcIiArIFBhcnNlci50b2tuYW0odGhpcy50U3RhdGUpKSk7XG4gIH07XG4gIHByb3RvLmFwcGVuZFN0cmluZ0NoYXIgPSBmdW5jdGlvbiAoY2hhcikge1xuICAgIGlmICh0aGlzLnN0cmluZ0J1ZmZlck9mZnNldCA+PSBTVFJJTkdfQlVGRkVSX1NJWkUpIHtcbiAgICAgIHRoaXMuc3RyaW5nICs9IHRoaXMuc3RyaW5nQnVmZmVyLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICB0aGlzLnN0cmluZ0J1ZmZlck9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5zdHJpbmdCdWZmZXJbdGhpcy5zdHJpbmdCdWZmZXJPZmZzZXQrK10gPSBjaGFyO1xuICB9O1xuICBwcm90by5hcHBlbmRTdHJpbmdCdWYgPSBmdW5jdGlvbiAoYnVmLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHNpemUgPSBidWYubGVuZ3RoO1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgICAvLyBhZGRpbmcgYSBuZWdhdGl2ZSBlbmQgZGVjcmVlc2VzIHRoZSBzaXplXG4gICAgICAgICAgc2l6ZSA9IGJ1Zi5sZW5ndGggLSBzdGFydCArIGVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaXplID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBidWYubGVuZ3RoIC0gc3RhcnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICBzaXplID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdHJpbmdCdWZmZXJPZmZzZXQgKyBzaXplID4gU1RSSU5HX0JVRkZFUl9TSVpFKSB7XG4gICAgICB0aGlzLnN0cmluZyArPSB0aGlzLnN0cmluZ0J1ZmZlci50b1N0cmluZygndXRmOCcsIDAsIHRoaXMuc3RyaW5nQnVmZmVyT2Zmc2V0KTtcbiAgICAgIHRoaXMuc3RyaW5nQnVmZmVyT2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBidWYuY29weSh0aGlzLnN0cmluZ0J1ZmZlciwgdGhpcy5zdHJpbmdCdWZmZXJPZmZzZXQsIHN0YXJ0LCBlbmQpO1xuICAgIHRoaXMuc3RyaW5nQnVmZmVyT2Zmc2V0ICs9IHNpemU7XG4gIH07XG4gIHByb3RvLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSBcInN0cmluZ1wiKSBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlcik7XG4gICAgdmFyIG47XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBidWZmZXIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy50U3RhdGUgPT09IFNUQVJUKXtcbiAgICAgICAgbiA9IGJ1ZmZlcltpXTtcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgaWYobiA9PT0gMHg3Yil7IHRoaXMub25Ub2tlbihMRUZUX0JSQUNFLCBcIntcIik7IC8vIHtcbiAgICAgICAgfWVsc2UgaWYobiA9PT0gMHg3ZCl7IHRoaXMub25Ub2tlbihSSUdIVF9CUkFDRSwgXCJ9XCIpOyAvLyB9XG4gICAgICAgIH1lbHNlIGlmKG4gPT09IDB4NWIpeyB0aGlzLm9uVG9rZW4oTEVGVF9CUkFDS0VULCBcIltcIik7IC8vIFtcbiAgICAgICAgfWVsc2UgaWYobiA9PT0gMHg1ZCl7IHRoaXMub25Ub2tlbihSSUdIVF9CUkFDS0VULCBcIl1cIik7IC8vIF1cbiAgICAgICAgfWVsc2UgaWYobiA9PT0gMHgzYSl7IHRoaXMub25Ub2tlbihDT0xPTiwgXCI6XCIpOyAgLy8gOlxuICAgICAgICB9ZWxzZSBpZihuID09PSAweDJjKXsgdGhpcy5vblRva2VuKENPTU1BLCBcIixcIik7IC8vICxcbiAgICAgICAgfWVsc2UgaWYobiA9PT0gMHg3NCl7IHRoaXMudFN0YXRlID0gVFJVRTE7ICAvLyB0XG4gICAgICAgIH1lbHNlIGlmKG4gPT09IDB4NjYpeyB0aGlzLnRTdGF0ZSA9IEZBTFNFMTsgIC8vIGZcbiAgICAgICAgfWVsc2UgaWYobiA9PT0gMHg2ZSl7IHRoaXMudFN0YXRlID0gTlVMTDE7IC8vIG5cbiAgICAgICAgfWVsc2UgaWYobiA9PT0gMHgyMil7IC8vIFwiXG4gICAgICAgICAgdGhpcy5zdHJpbmcgPSBcIlwiO1xuICAgICAgICAgIHRoaXMuc3RyaW5nQnVmZmVyT2Zmc2V0ID0gMDtcbiAgICAgICAgICB0aGlzLnRTdGF0ZSA9IFNUUklORzE7XG4gICAgICAgIH1lbHNlIGlmKG4gPT09IDB4MmQpeyB0aGlzLnN0cmluZyA9IFwiLVwiOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjE7IC8vIC1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgaWYgKG4gPj0gMHgzMCAmJiBuIDwgMHg0MCkgeyAvLyAxLTlcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZShuKTsgdGhpcy50U3RhdGUgPSBOVU1CRVIzO1xuICAgICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMHgyMCB8fCBuID09PSAweDA5IHx8IG4gPT09IDB4MGEgfHwgbiA9PT0gMHgwZCkgOyBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBTVFJJTkcxKXsgLy8gQWZ0ZXIgb3BlbiBxdW90ZVxuICAgICAgICBuID0gYnVmZmVyW2ldOyAvLyBnZXQgY3VycmVudCBieXRlIGZyb20gYnVmZmVyXG4gICAgICAgIC8vIGNoZWNrIGZvciBjYXJyeSBvdmVyIG9mIGEgbXVsdGkgYnl0ZSBjaGFyIHNwbGl0IGJldHdlZW4gZGF0YSBjaHVua3NcbiAgICAgICAgLy8gJiBmaWxsIHRlbXAgYnVmZmVyIGl0IHdpdGggc3RhcnQgb2YgdGhpcyBkYXRhIGNodW5rIHVwIHRvIHRoZSBib3VuZGFyeSBsaW1pdCBzZXQgaW4gdGhlIGxhc3QgaXRlcmF0aW9uXG4gICAgICAgIGlmICh0aGlzLmJ5dGVzX3JlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuYnl0ZXNfcmVtYWluaW5nOyBqKyspIHtcbiAgICAgICAgICAgIHRoaXMudGVtcF9idWZmc1t0aGlzLmJ5dGVzX2luX3NlcXVlbmNlXVt0aGlzLmJ5dGVzX2luX3NlcXVlbmNlIC0gdGhpcy5ieXRlc19yZW1haW5pbmcgKyBqXSA9IGJ1ZmZlcltqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmFwcGVuZFN0cmluZ0J1Zih0aGlzLnRlbXBfYnVmZnNbdGhpcy5ieXRlc19pbl9zZXF1ZW5jZV0pO1xuICAgICAgICAgIHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UgPSB0aGlzLmJ5dGVzX3JlbWFpbmluZyA9IDA7XG4gICAgICAgICAgaSA9IGkgKyBqIC0gMTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmJ5dGVzX3JlbWFpbmluZyA9PT0gMCAmJiBuID49IDEyOCkgeyAvLyBlbHNlIGlmIG5vIHJlbWFpbmRlciBieXRlcyBjYXJyaWVkIG92ZXIsIHBhcnNlIG11bHRpIGJ5dGUgKD49MTI4KSBjaGFycyBvbmUgYXQgYSB0aW1lXG4gICAgICAgICAgaWYgKG4gPD0gMTkzIHx8IG4gPiAyNDQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uRXJyb3IobmV3IEVycm9yKFwiSW52YWxpZCBVVEYtOCBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gXCIgKyBpICsgXCIgaW4gc3RhdGUgXCIgKyBQYXJzZXIudG9rbmFtKHRoaXMudFN0YXRlKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKG4gPj0gMTk0KSAmJiAobiA8PSAyMjMpKSB0aGlzLmJ5dGVzX2luX3NlcXVlbmNlID0gMjtcbiAgICAgICAgICBpZiAoKG4gPj0gMjI0KSAmJiAobiA8PSAyMzkpKSB0aGlzLmJ5dGVzX2luX3NlcXVlbmNlID0gMztcbiAgICAgICAgICBpZiAoKG4gPj0gMjQwKSAmJiAobiA8PSAyNDQpKSB0aGlzLmJ5dGVzX2luX3NlcXVlbmNlID0gNDtcbiAgICAgICAgICBpZiAoKHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UgKyBpKSA+IGJ1ZmZlci5sZW5ndGgpIHsgLy8gaWYgYnl0ZXMgbmVlZGVkIHRvIGNvbXBsZXRlIGNoYXIgZmFsbCBvdXRzaWRlIGJ1ZmZlciBsZW5ndGgsIHdlIGhhdmUgYSBib3VuZGFyeSBzcGxpdFxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPD0gKGJ1ZmZlci5sZW5ndGggLSAxIC0gaSk7IGsrKykge1xuICAgICAgICAgICAgICB0aGlzLnRlbXBfYnVmZnNbdGhpcy5ieXRlc19pbl9zZXF1ZW5jZV1ba10gPSBidWZmZXJbaSArIGtdOyAvLyBmaWxsIHRlbXAgYnVmZmVyIG9mIGNvcnJlY3Qgc2l6ZSB3aXRoIGJ5dGVzIGF2YWlsYWJsZSBpbiB0aGlzIGNodW5rXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ5dGVzX3JlbWFpbmluZyA9IChpICsgdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSkgLSBidWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaSA9IGJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFN0cmluZ0J1ZihidWZmZXIsIGksIGkgKyB0aGlzLmJ5dGVzX2luX3NlcXVlbmNlKTtcbiAgICAgICAgICAgIGkgPSBpICsgdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG4gPT09IDB4MjIpIHtcbiAgICAgICAgICB0aGlzLnRTdGF0ZSA9IFNUQVJUO1xuICAgICAgICAgIHRoaXMuc3RyaW5nICs9IHRoaXMuc3RyaW5nQnVmZmVyLnRvU3RyaW5nKCd1dGY4JywgMCwgdGhpcy5zdHJpbmdCdWZmZXJPZmZzZXQpO1xuICAgICAgICAgIHRoaXMuc3RyaW5nQnVmZmVyT2Zmc2V0ID0gMDtcbiAgICAgICAgICB0aGlzLm9uVG9rZW4oU1RSSU5HLCB0aGlzLnN0cmluZyk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gQnVmZmVyLmJ5dGVMZW5ndGgodGhpcy5zdHJpbmcsICd1dGY4JykgKyAxO1xuICAgICAgICAgIHRoaXMuc3RyaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPT09IDB4NWMpIHtcbiAgICAgICAgICB0aGlzLnRTdGF0ZSA9IFNUUklORzI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiA+PSAweDIwKSB7IHRoaXMuYXBwZW5kU3RyaW5nQ2hhcihuKTsgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpO1xuICAgICAgICB9XG4gICAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IFNUUklORzIpeyAvLyBBZnRlciBiYWNrc2xhc2hcbiAgICAgICAgbiA9IGJ1ZmZlcltpXTtcbiAgICAgICAgaWYobiA9PT0gMHgyMil7IHRoaXMuYXBwZW5kU3RyaW5nQ2hhcihuKTsgdGhpcy50U3RhdGUgPSBTVFJJTkcxO1xuICAgICAgICB9ZWxzZSBpZihuID09PSAweDVjKXsgdGhpcy5hcHBlbmRTdHJpbmdDaGFyKEJBQ0tfU0xBU0gpOyB0aGlzLnRTdGF0ZSA9IFNUUklORzE7XG4gICAgICAgIH1lbHNlIGlmKG4gPT09IDB4MmYpeyB0aGlzLmFwcGVuZFN0cmluZ0NoYXIoRk9SV0FSRF9TTEFTSCk7IHRoaXMudFN0YXRlID0gU1RSSU5HMTtcbiAgICAgICAgfWVsc2UgaWYobiA9PT0gMHg2Mil7IHRoaXMuYXBwZW5kU3RyaW5nQ2hhcihCQUNLU1BBQ0UpOyB0aGlzLnRTdGF0ZSA9IFNUUklORzE7XG4gICAgICAgIH1lbHNlIGlmKG4gPT09IDB4NjYpeyB0aGlzLmFwcGVuZFN0cmluZ0NoYXIoRk9STV9GRUVEKTsgdGhpcy50U3RhdGUgPSBTVFJJTkcxO1xuICAgICAgICB9ZWxzZSBpZihuID09PSAweDZlKXsgdGhpcy5hcHBlbmRTdHJpbmdDaGFyKE5FV0xJTkUpOyB0aGlzLnRTdGF0ZSA9IFNUUklORzE7XG4gICAgICAgIH1lbHNlIGlmKG4gPT09IDB4NzIpeyB0aGlzLmFwcGVuZFN0cmluZ0NoYXIoQ0FSUklBR0VfUkVUVVJOKTsgdGhpcy50U3RhdGUgPSBTVFJJTkcxO1xuICAgICAgICB9ZWxzZSBpZihuID09PSAweDc0KXsgdGhpcy5hcHBlbmRTdHJpbmdDaGFyKFRBQik7IHRoaXMudFN0YXRlID0gU1RSSU5HMTtcbiAgICAgICAgfWVsc2UgaWYobiA9PT0gMHg3NSl7IHRoaXMudW5pY29kZSA9IFwiXCI7IHRoaXMudFN0YXRlID0gU1RSSU5HMztcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gU1RSSU5HMyB8fCB0aGlzLnRTdGF0ZSA9PT0gU1RSSU5HNCB8fCB0aGlzLnRTdGF0ZSA9PT0gU1RSSU5HNSB8fCB0aGlzLnRTdGF0ZSA9PT0gU1RSSU5HNil7IC8vIHVuaWNvZGUgaGV4IGNvZGVzXG4gICAgICAgIG4gPSBidWZmZXJbaV07XG4gICAgICAgIC8vIDAtOSBBLUYgYS1mXG4gICAgICAgIGlmICgobiA+PSAweDMwICYmIG4gPCAweDQwKSB8fCAobiA+IDB4NDAgJiYgbiA8PSAweDQ2KSB8fCAobiA+IDB4NjAgJiYgbiA8PSAweDY2KSkge1xuICAgICAgICAgIHRoaXMudW5pY29kZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG4pO1xuICAgICAgICAgIGlmICh0aGlzLnRTdGF0ZSsrID09PSBTVFJJTkc2KSB7XG4gICAgICAgICAgICB2YXIgaW50VmFsID0gcGFyc2VJbnQodGhpcy51bmljb2RlLCAxNik7XG4gICAgICAgICAgICB0aGlzLnVuaWNvZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodGhpcy5oaWdoU3Vycm9nYXRlICE9PSB1bmRlZmluZWQgJiYgaW50VmFsID49IDB4REMwMCAmJiBpbnRWYWwgPCAoMHhERkZGICsgMSkpIHsgLy88NTYzMjAsNTczNDM+IC0gbG93U3Vycm9nYXRlXG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kU3RyaW5nQnVmKG5ldyBCdWZmZXIoU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmhpZ2hTdXJyb2dhdGUsIGludFZhbCkpKTtcbiAgICAgICAgICAgICAgdGhpcy5oaWdoU3Vycm9nYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhpZ2hTdXJyb2dhdGUgPT09IHVuZGVmaW5lZCAmJiBpbnRWYWwgPj0gMHhEODAwICYmIGludFZhbCA8ICgweERCRkYgKyAxKSkgeyAvLzw1NTI5Niw1NjMxOT4gLSBoaWdoU3Vycm9nYXRlXG4gICAgICAgICAgICAgIHRoaXMuaGlnaFN1cnJvZ2F0ZSA9IGludFZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmhpZ2hTdXJyb2dhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kU3RyaW5nQnVmKG5ldyBCdWZmZXIoU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmhpZ2hTdXJyb2dhdGUpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdoU3Vycm9nYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kU3RyaW5nQnVmKG5ldyBCdWZmZXIoU3RyaW5nLmZyb21DaGFyQ29kZShpbnRWYWwpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRTdGF0ZSA9IFNUUklORzE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVU1CRVIxIHx8IHRoaXMudFN0YXRlID09PSBOVU1CRVIzKSB7XG4gICAgICAgICAgbiA9IGJ1ZmZlcltpXTtcblxuICAgICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICAgICAgY2FzZSAweDMwOiAvLyAwXG4gICAgICAgICAgICBjYXNlIDB4MzE6IC8vIDFcbiAgICAgICAgICAgIGNhc2UgMHgzMjogLy8gMlxuICAgICAgICAgICAgY2FzZSAweDMzOiAvLyAzXG4gICAgICAgICAgICBjYXNlIDB4MzQ6IC8vIDRcbiAgICAgICAgICAgIGNhc2UgMHgzNTogLy8gNVxuICAgICAgICAgICAgY2FzZSAweDM2OiAvLyA2XG4gICAgICAgICAgICBjYXNlIDB4Mzc6IC8vIDdcbiAgICAgICAgICAgIGNhc2UgMHgzODogLy8gOFxuICAgICAgICAgICAgY2FzZSAweDM5OiAvLyA5XG4gICAgICAgICAgICBjYXNlIDB4MmU6IC8vIC5cbiAgICAgICAgICAgIGNhc2UgMHg2NTogLy8gZVxuICAgICAgICAgICAgY2FzZSAweDQ1OiAvLyBFXG4gICAgICAgICAgICBjYXNlIDB4MmI6IC8vICtcbiAgICAgICAgICAgIGNhc2UgMHgyZDogLy8gLVxuICAgICAgICAgICAgICB0aGlzLnN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG4pO1xuICAgICAgICAgICAgICB0aGlzLnRTdGF0ZSA9IE5VTUJFUjM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhpcy50U3RhdGUgPSBTVEFSVDtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IE51bWJlcih0aGlzLnN0cmluZyk7XG5cbiAgICAgICAgICAgICAgaWYgKGlzTmFOKHJlc3VsdCkpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCh0aGlzLnN0cmluZy5tYXRjaCgvWzAtOV0rLykgPT0gdGhpcy5zdHJpbmcpICYmIChyZXN1bHQudG9TdHJpbmcoKSAhPSB0aGlzLnN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAvLyBMb25nIHN0cmluZyBvZiBkaWdpdHMgd2hpY2ggaXMgYW4gSUQgc3RyaW5nIGFuZCBub3QgdmFsaWQgYW5kL29yIHNhZmUgSmF2YVNjcmlwdCBpbnRlZ2VyIE51bWJlclxuICAgICAgICAgICAgICAgIHRoaXMub25Ub2tlbihTVFJJTkcsIHRoaXMuc3RyaW5nKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVG9rZW4oTlVNQkVSLCByZXN1bHQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gdGhpcy5zdHJpbmcubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgdGhpcy5zdHJpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBUUlVFMSl7IC8vIHJcbiAgICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gMHg3MikgeyB0aGlzLnRTdGF0ZSA9IFRSVUUyOyB9XG4gICAgICAgIGVsc2UgeyByZXR1cm4gdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBUUlVFMil7IC8vIHVcbiAgICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gMHg3NSkgeyB0aGlzLnRTdGF0ZSA9IFRSVUUzOyB9XG4gICAgICAgIGVsc2UgeyByZXR1cm4gdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBUUlVFMyl7IC8vIGVcbiAgICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gMHg2NSkgeyB0aGlzLnRTdGF0ZSA9IFNUQVJUOyB0aGlzLm9uVG9rZW4oVFJVRSwgdHJ1ZSk7IHRoaXMub2Zmc2V0Kz0gMzsgfVxuICAgICAgICBlbHNlIHsgcmV0dXJuIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gRkFMU0UxKXsgLy8gYVxuICAgICAgICBpZiAoYnVmZmVyW2ldID09PSAweDYxKSB7IHRoaXMudFN0YXRlID0gRkFMU0UyOyB9XG4gICAgICAgIGVsc2UgeyByZXR1cm4gdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBGQUxTRTIpeyAvLyBsXG4gICAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NmMpIHsgdGhpcy50U3RhdGUgPSBGQUxTRTM7IH1cbiAgICAgICAgZWxzZSB7IHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IEZBTFNFMyl7IC8vIHNcbiAgICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gMHg3MykgeyB0aGlzLnRTdGF0ZSA9IEZBTFNFNDsgfVxuICAgICAgICBlbHNlIHsgcmV0dXJuIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gRkFMU0U0KXsgLy8gZVxuICAgICAgICBpZiAoYnVmZmVyW2ldID09PSAweDY1KSB7IHRoaXMudFN0YXRlID0gU1RBUlQ7IHRoaXMub25Ub2tlbihGQUxTRSwgZmFsc2UpOyB0aGlzLm9mZnNldCs9IDQ7IH1cbiAgICAgICAgZWxzZSB7IHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IE5VTEwxKXsgLy8gdVxuICAgICAgICBpZiAoYnVmZmVyW2ldID09PSAweDc1KSB7IHRoaXMudFN0YXRlID0gTlVMTDI7IH1cbiAgICAgICAgZWxzZSB7IHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IE5VTEwyKXsgLy8gbFxuICAgICAgICBpZiAoYnVmZmVyW2ldID09PSAweDZjKSB7IHRoaXMudFN0YXRlID0gTlVMTDM7IH1cbiAgICAgICAgZWxzZSB7IHJldHVybiB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IE5VTEwzKXsgLy8gbFxuICAgICAgICBpZiAoYnVmZmVyW2ldID09PSAweDZjKSB7IHRoaXMudFN0YXRlID0gU1RBUlQ7IHRoaXMub25Ub2tlbihOVUxMLCBudWxsKTsgdGhpcy5vZmZzZXQgKz0gMzsgfVxuICAgICAgICBlbHNlIHsgcmV0dXJuIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHByb3RvLm9uVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIHZhbHVlKSB7XG4gICAgLy8gT3ZlcnJpZGUgdGhpcyB0byBnZXQgZXZlbnRzXG4gIH07XG5cbiAgcHJvdG8ucGFyc2VFcnJvciA9IGZ1bmN0aW9uICh0b2tlbiwgdmFsdWUpIHtcbiAgICB0aGlzLnRTdGF0ZSA9IFNUT1A7XG4gICAgdGhpcy5vbkVycm9yKG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyBQYXJzZXIudG9rbmFtKHRva2VuKSArICh2YWx1ZSA/IChcIihcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArIFwiKVwiKSA6IFwiXCIpICsgXCIgaW4gc3RhdGUgXCIgKyBQYXJzZXIudG9rbmFtKHRoaXMuc3RhdGUpKSk7XG4gIH07XG4gIHByb3RvLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKHt2YWx1ZTogdGhpcy52YWx1ZSwga2V5OiB0aGlzLmtleSwgbW9kZTogdGhpcy5tb2RlfSk7XG4gIH07XG4gIHByb3RvLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIHRoaXMudmFsdWUgPSBwYXJlbnQudmFsdWU7XG4gICAgdGhpcy5rZXkgPSBwYXJlbnQua2V5O1xuICAgIHRoaXMubW9kZSA9IHBhcmVudC5tb2RlO1xuICAgIHRoaXMuZW1pdCh2YWx1ZSk7XG4gICAgaWYgKCF0aGlzLm1vZGUpIHsgdGhpcy5zdGF0ZSA9IFZBTFVFOyB9XG4gIH07XG4gIHByb3RvLmVtaXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5tb2RlKSB7IHRoaXMuc3RhdGUgPSBDT01NQTsgfVxuICAgIHRoaXMub25WYWx1ZSh2YWx1ZSk7XG4gIH07XG4gIHByb3RvLm9uVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBPdmVycmlkZSBtZVxuICB9O1xuICBwcm90by5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuLCB2YWx1ZSkge1xuICAgIGlmKHRoaXMuc3RhdGUgPT09IFZBTFVFKXtcbiAgICAgIGlmKHRva2VuID09PSBTVFJJTkcgfHwgdG9rZW4gPT09IE5VTUJFUiB8fCB0b2tlbiA9PT0gVFJVRSB8fCB0b2tlbiA9PT0gRkFMU0UgfHwgdG9rZW4gPT09IE5VTEwpe1xuICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICAgIHRoaXMudmFsdWVbdGhpcy5rZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KHZhbHVlKTtcbiAgICAgIH1lbHNlIGlmKHRva2VuID09PSBMRUZUX0JSQUNFKXtcbiAgICAgICAgdGhpcy5wdXNoKCk7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWVbdGhpcy5rZXldID0ge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0YXRlID0gS0VZO1xuICAgICAgICB0aGlzLm1vZGUgPSBPQkpFQ1Q7XG4gICAgICB9ZWxzZSBpZih0b2tlbiA9PT0gTEVGVF9CUkFDS0VUKXtcbiAgICAgICAgdGhpcy5wdXNoKCk7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWVbdGhpcy5rZXldID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2V5ID0gMDtcbiAgICAgICAgdGhpcy5tb2RlID0gQVJSQVk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBWQUxVRTtcbiAgICAgIH1lbHNlIGlmKHRva2VuID09PSBSSUdIVF9CUkFDRSl7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IE9CSkVDVCkge1xuICAgICAgICAgIHRoaXMucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcih0b2tlbiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9ZWxzZSBpZih0b2tlbiA9PT0gUklHSFRfQlJBQ0tFVCl7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IEFSUkFZKSB7XG4gICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKHRva2VuLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKHRva2VuLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfWVsc2UgaWYodGhpcy5zdGF0ZSA9PT0gS0VZKXtcbiAgICAgIGlmICh0b2tlbiA9PT0gU1RSSU5HKSB7XG4gICAgICAgIHRoaXMua2V5ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDT0xPTjtcbiAgICAgIH0gZWxzZSBpZiAodG9rZW4gPT09IFJJR0hUX0JSQUNFKSB7XG4gICAgICAgIHRoaXMucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKHRva2VuLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfWVsc2UgaWYodGhpcy5zdGF0ZSA9PT0gQ09MT04pe1xuICAgICAgaWYgKHRva2VuID09PSBDT0xPTikgeyB0aGlzLnN0YXRlID0gVkFMVUU7IH1cbiAgICAgIGVsc2UgeyByZXR1cm4gdGhpcy5wYXJzZUVycm9yKHRva2VuLCB2YWx1ZSk7IH1cbiAgICB9ZWxzZSBpZih0aGlzLnN0YXRlID09PSBDT01NQSl7XG4gICAgICBpZiAodG9rZW4gPT09IENPTU1BKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IEFSUkFZKSB7IHRoaXMua2V5Kys7IHRoaXMuc3RhdGUgPSBWQUxVRTsgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm1vZGUgPT09IE9CSkVDVCkgeyB0aGlzLnN0YXRlID0gS0VZOyB9XG5cbiAgICAgIH0gZWxzZSBpZiAodG9rZW4gPT09IFJJR0hUX0JSQUNLRVQgJiYgdGhpcy5tb2RlID09PSBBUlJBWSB8fCB0b2tlbiA9PT0gUklHSFRfQlJBQ0UgJiYgdGhpcy5tb2RlID09PSBPQkpFQ1QpIHtcbiAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgUGFyc2VyLkMgPSBDO1xuXG4gIHZhciBqc29ucGFyc2UgPSBQYXJzZXI7XG5cbiAgdmFyIFRyYW5zZm9ybSQxID0gU3RyZWFtLlRyYW5zZm9ybTtcblxuICB2YXIgSlNPTjJDU1ZUcmFuc2Zvcm0gPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfVHJhbnNmb3JtKSB7XG4gICAgX2luaGVyaXRzKEpTT04yQ1NWVHJhbnNmb3JtLCBfVHJhbnNmb3JtKTtcblxuICAgIGZ1bmN0aW9uIEpTT04yQ1NWVHJhbnNmb3JtKG9wdHMsIHRyYW5zZm9ybU9wdHMpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEpTT04yQ1NWVHJhbnNmb3JtKTtcblxuICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoSlNPTjJDU1ZUcmFuc2Zvcm0pLmNhbGwodGhpcywgdHJhbnNmb3JtT3B0cykpOyAvLyBJbmhlcml0IG1ldGhvZHMgZnJvbSBKU09OMkNTVkJhc2Ugc2luY2UgZXh0ZW5kcyBkb2Vzbid0XG4gICAgICAvLyBhbGxvdyBtdWx0aXBsZSBpbmhlcml0YW5jZSBhbmQgbWFudWFsbHkgcHJlcHJvY2VzcyBvcHRzXG5cbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKEpTT04yQ1NWQmFzZV8xLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBfdGhpc1trZXldID0gSlNPTjJDU1ZCYXNlXzEucHJvdG90eXBlW2tleV07XG4gICAgICB9KTtcbiAgICAgIF90aGlzLm9wdHMgPSBfdGhpcy5wcmVwcm9jZXNzT3B0cyhvcHRzKTtcbiAgICAgIF90aGlzLl9kYXRhID0gJyc7XG4gICAgICBfdGhpcy5faGFzV3JpdHRlbiA9IGZhbHNlO1xuXG4gICAgICBpZiAoX3RoaXMuX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZSkge1xuICAgICAgICBfdGhpcy5pbml0T2JqZWN0TW9kZVBhcnNlKCk7XG4gICAgICB9IGVsc2UgaWYgKF90aGlzLm9wdHMubmRqc29uKSB7XG4gICAgICAgIF90aGlzLmluaXROREpTT05QYXJzZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuaW5pdEpTT05QYXJzZXIoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLm9wdHMud2l0aEJPTSkge1xuICAgICAgICBfdGhpcy5wdXNoKFwiXFx1RkVGRlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLm9wdHMuZmllbGRzKSB7XG4gICAgICAgIF90aGlzLm9wdHMuZmllbGRzID0gX3RoaXMucHJlcHJvY2Vzc0ZpZWxkc0luZm8oX3RoaXMub3B0cy5maWVsZHMpO1xuXG4gICAgICAgIF90aGlzLnB1c2hIZWFkZXIoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0IHRoZSB0cmFuc2Zvcm0gd2l0aCBhIHBhcnNlciB0byBwcm9jZXNzIGRhdGEgaW4gb2JqZWN0IG1vZGUuXG4gICAgICogSXQgcmVjZWl2ZXMgSlNPTiBvYmplY3RzIG9uZSBieSBvbmUgYW5kIHNlbmQgdGhlbSB0byBgcHVzaExpbmUgZm9yIHByb2Nlc3NpbmcuXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhKU09OMkNTVlRyYW5zZm9ybSwgW3tcbiAgICAgIGtleTogXCJpbml0T2JqZWN0TW9kZVBhcnNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdE9iamVjdE1vZGVQYXJzZSgpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXM7XG4gICAgICAgIHRoaXMucGFyc2VyID0ge1xuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShsaW5lKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0ucHVzaExpbmUobGluZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRQZW5kaW5nRGF0YTogZnVuY3Rpb24gZ2V0UGVuZGluZ0RhdGEoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogSW5pdCB0aGUgdHJhbnNmb3JtIHdpdGggYSBwYXJzZXIgdG8gcHJvY2VzcyBOREpTT04gZGF0YS5cbiAgICAgICAqIEl0IG1haW50YWlucyBhIGJ1ZmZlciBvZiByZWNlaXZlZCBkYXRhLCBwYXJzZXMgZWFjaCBsaW5lXG4gICAgICAgKiBhcyBKU09OIGFuZCBzZW5kIGl0IHRvIGBwdXNoTGluZSBmb3IgcHJvY2Vzc2luZy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImluaXROREpTT05QYXJzZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXROREpTT05QYXJzZSgpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXM7XG4gICAgICAgIHRoaXMucGFyc2VyID0ge1xuICAgICAgICAgIF9kYXRhOiAnJyxcbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgKz0gY2h1bmsudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5fZGF0YS5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsaW5lLnRyaW0oKTtcbiAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICByZXR1cm4gbGluZSAhPT0gJyc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHBlbmRpbmdEYXRhID0gZmFsc2U7XG4gICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lLCBpKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLnB1c2hMaW5lKEpTT04ucGFyc2UobGluZSkpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgIHBlbmRpbmdEYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gXCJJbnZhbGlkIEpTT04gKFwiLmNvbmNhdChsaW5lLCBcIilcIik7XG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IHBlbmRpbmdEYXRhID8gdGhpcy5fZGF0YS5zbGljZSh0aGlzLl9kYXRhLmxhc3RJbmRleE9mKCdcXG4nKSkgOiAnJztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldFBlbmRpbmdEYXRhOiBmdW5jdGlvbiBnZXRQZW5kaW5nRGF0YSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogSW5pdCB0aGUgdHJhbnNmb3JtIHdpdGggYSBwYXJzZXIgdG8gcHJvY2VzcyBKU09OIGRhdGEuXG4gICAgICAgKiBJdCBtYWludGFpbnMgYSBidWZmZXIgb2YgcmVjZWl2ZWQgZGF0YSwgcGFyc2VzIGVhY2ggYXMgSlNPTiBcbiAgICAgICAqIGl0ZW0gaWYgdGhlIGRhdGEgaXMgYW4gYXJyYXkgb3IgdGhlIGRhdGEgaXRzZWxmIG90aGVyd2lzZVxuICAgICAgICogYW5kIHNlbmQgaXQgdG8gYHB1c2hMaW5lYCBmb3IgcHJvY2Vzc2luZy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcImluaXRKU09OUGFyc2VyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdEpTT05QYXJzZXIoKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzO1xuICAgICAgICB0aGlzLnBhcnNlciA9IG5ldyBqc29ucGFyc2UoKTtcblxuICAgICAgICB0aGlzLnBhcnNlci5vblZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoICE9PSB0aGlzLmRlcHRoVG9FbWl0KSByZXR1cm47XG4gICAgICAgICAgdHJhbnNmb3JtLnB1c2hMaW5lKHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnBhcnNlci5fb25Ub2tlbiA9IHRoaXMucGFyc2VyLm9uVG9rZW47XG5cbiAgICAgICAgdGhpcy5wYXJzZXIub25Ub2tlbiA9IGZ1bmN0aW9uICh0b2tlbiwgdmFsdWUpIHtcbiAgICAgICAgICB0cmFuc2Zvcm0ucGFyc2VyLl9vblRva2VuKHRva2VuLCB2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDAgJiYgIXRyYW5zZm9ybS5vcHRzLmZpZWxkcyAmJiB0aGlzLm1vZGUgIT09IGpzb25wYXJzZS5DLkFSUkFZICYmIHRoaXMubW9kZSAhPT0ganNvbnBhcnNlLkMuT0JKRUNUKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IobmV3IEVycm9yKCdEYXRhIHNob3VsZCBub3QgYmUgZW1wdHkgb3IgdGhlIFwiZmllbGRzXCIgb3B0aW9uIHNob3VsZCBiZSBpbmNsdWRlZCcpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlcHRoVG9FbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgLy8gSWYgQXJyYXkgZW1pdCBpdHMgY29udGVudCwgZWxzZSBlbWl0IGl0c2VsZlxuICAgICAgICAgICAgICB0aGlzLmRlcHRoVG9FbWl0ID0gdGhpcy5tb2RlID09PSBqc29ucGFyc2UuQy5BUlJBWSA/IDEgOiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5kZXB0aFRvRW1pdCAhPT0gMCAmJiB0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIHN0b3JlIHRoZSB3aG9sZSByb290IGFycmF5IGluIG1lbW9yeVxuICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnBhcnNlci5nZXRQZW5kaW5nRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnBhcnNlci5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcygnVW5leHBlY3RlZCcpKSB7XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IFwiSW52YWxpZCBKU09OIChcIi5jb25jYXQoZXJyLm1lc3NhZ2UsIFwiKVwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cmFuc2Zvcm0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBNYWluIGZ1bmN0aW9uIHRoYXQgc2VuZCBkYXRhIHRvIHRoZSBwYXJzZSB0byBiZSBwcm9jZXNzZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEluY29taW5nIGRhdGFcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZyBFbmNvZGluZyBvZiB0aGUgaW5jb21pbmcgZGF0YS4gRGVmYXVsdHMgdG8gJ3V0ZjgnXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lIENhbGxlZCB3aGVuIHRoZSBwcm9jZWVzaW5nIG9mIHRoZSBzdXBwbGllZCBjaHVuayBpcyBkb25lXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfdHJhbnNmb3JtXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGRvbmUpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIud3JpdGUoY2h1bmspO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9mbHVzaFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9mbHVzaChkb25lKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlci5nZXRQZW5kaW5nRGF0YSgpKSB7XG4gICAgICAgICAgZG9uZShuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YSByZWNlaXZlZCBmcm9tIHN0ZGluJywgdGhpcy5wYXJzZXIuZ2V0UGVuZGluZ0RhdGEoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBHZW5lcmF0ZSB0aGUgY3N2IGhlYWRlciBhbmQgcHVzaGVzIGl0IGRvd25zdHJlYW0uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwdXNoSGVhZGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaEhlYWRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5oZWFkZXIpIHtcbiAgICAgICAgICB2YXIgaGVhZGVyID0gdGhpcy5nZXRIZWFkZXIoKTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2hlYWRlcicsIGhlYWRlcik7XG4gICAgICAgICAgdGhpcy5wdXNoKGhlYWRlcik7XG4gICAgICAgICAgdGhpcy5faGFzV3JpdHRlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNmb3JtcyBhbiBpbmNvbWluZyBqc29uIGRhdGEgdG8gY3N2IGFuZCBwdXNoZXMgaXQgZG93bnN0cmVhbS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBKU09OIG9iamVjdCB0byBiZSBjb252ZXJ0ZWQgaW4gYSBDU1Ygcm93XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwdXNoTGluZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2hMaW5lKGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSB0aGlzLnByZXByb2Nlc3NSb3coZGF0YSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNXcml0dGVuKSB7XG4gICAgICAgICAgdGhpcy5vcHRzLmZpZWxkcyA9IHRoaXMub3B0cy5maWVsZHMgfHwgdGhpcy5wcmVwcm9jZXNzRmllbGRzSW5mbyhPYmplY3Qua2V5cyhwcm9jZXNzZWREYXRhWzBdKSk7XG4gICAgICAgICAgdGhpcy5wdXNoSGVhZGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzZWREYXRhLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgIHZhciBsaW5lID0gX3RoaXMyLnByb2Nlc3NSb3cocm93LCBfdGhpczIub3B0cyk7XG5cbiAgICAgICAgICBpZiAobGluZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgICAgICBfdGhpczIuZW1pdCgnbGluZScsIGxpbmUpO1xuXG4gICAgICAgICAgX3RoaXMyLnB1c2goX3RoaXMyLl9oYXNXcml0dGVuID8gX3RoaXMyLm9wdHMuZW9sICsgbGluZSA6IGxpbmUpO1xuXG4gICAgICAgICAgX3RoaXMyLl9oYXNXcml0dGVuID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEpTT04yQ1NWVHJhbnNmb3JtO1xuICB9KFRyYW5zZm9ybSQxKTtcblxuICB2YXIgSlNPTjJDU1ZUcmFuc2Zvcm1fMSA9IEpTT04yQ1NWVHJhbnNmb3JtO1xuXG4gIHZhciBUcmFuc2Zvcm0kMiA9IFN0cmVhbS5UcmFuc2Zvcm07XG4gIHZhciBmYXN0Sm9pbiQzID0gdXRpbHMuZmFzdEpvaW47XG5cbiAgdmFyIEpTT04yQ1NWQXN5bmNQYXJzZXIgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKU09OMkNTVkFzeW5jUGFyc2VyKG9wdHMsIHRyYW5zZm9ybU9wdHMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKU09OMkNTVkFzeW5jUGFyc2VyKTtcblxuICAgICAgdGhpcy5pbnB1dCA9IG5ldyBUcmFuc2Zvcm0kMih0cmFuc2Zvcm1PcHRzKTtcblxuICAgICAgdGhpcy5pbnB1dC5fcmVhZCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBKU09OMkNTVlRyYW5zZm9ybV8xKG9wdHMsIHRyYW5zZm9ybU9wdHMpO1xuICAgICAgdGhpcy5wcm9jZXNzb3IgPSB0aGlzLmlucHV0LnBpcGUodGhpcy50cmFuc2Zvcm0pO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhKU09OMkNTVkFzeW5jUGFyc2VyLCBbe1xuICAgICAga2V5OiBcImZyb21JbnB1dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21JbnB1dChpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5faW5wdXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FzeW5jIHBhcnNlciBhbHJlYWR5IGhhcyBhbiBpbnB1dC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLl9pbnB1dC5waXBlKHRoaXMucHJvY2Vzc29yKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInRocm91Z2hUcmFuc2Zvcm1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0aHJvdWdoVHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgICAgICBpZiAodGhpcy5fb3V0cHV0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGFkZCB0cmFuc2Zvcm1zIG9uY2UgYW4gb3V0cHV0IGhhcyBiZWVuIGFkZGVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9jZXNzb3IgPSB0aGlzLnByb2Nlc3Nvci5waXBlKHRyYW5zZm9ybSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b091dHB1dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvT3V0cHV0KG91dHB1dCkge1xuICAgICAgICBpZiAodGhpcy5fb3V0cHV0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBc3luYyBwYXJzZXIgYWxyZWFkeSBoYXMgYW4gb3V0cHV0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb3V0cHV0ID0gb3V0cHV0O1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHRoaXMucHJvY2Vzc29yLnBpcGUob3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInByb21pc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9taXNlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciByZXR1cm5DU1YgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaWYgKCFyZXR1cm5DU1YpIHtcbiAgICAgICAgICAgIF90aGlzLnByb2Nlc3Nvci5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSkub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjc3ZCdWZmZXIgPSBbXTtcblxuICAgICAgICAgIF90aGlzLnByb2Nlc3Nvci5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgICAgcmV0dXJuIGNzdkJ1ZmZlci5wdXNoKGNodW5rLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH0pLm9uKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmYXN0Sm9pbiQzKGNzdkJ1ZmZlciwgJycpKTtcbiAgICAgICAgICB9KS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBKU09OMkNTVkFzeW5jUGFyc2VyO1xuICB9KCk7XG5cbiAgdmFyIEpTT04yQ1NWQXN5bmNQYXJzZXJfMSA9IEpTT04yQ1NWQXN5bmNQYXJzZXI7XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIHRoZSBmbGF0dGVuaW5nIG9mIGEgZGF0YSByb3cgcmVjdXJzaXZlbHlcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlcGFyYXRvciBTZXBhcmF0b3IgdG8gYmUgdXNlZCBhcyB0aGUgZmxhdHRlbmVkIGZpZWxkIG5hbWVcbiAgICogQHJldHVybnMge09iamVjdCA9PiBPYmplY3R9IEZsYXR0ZW5lZCBvYmplY3RcbiAgICovXG4gIGZ1bmN0aW9uIGZsYXR0ZW4oKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBfcmVmJG9iamVjdHMgPSBfcmVmLm9iamVjdHMsXG4gICAgICAgIG9iamVjdHMgPSBfcmVmJG9iamVjdHMgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJG9iamVjdHMsXG4gICAgICAgIF9yZWYkYXJyYXlzID0gX3JlZi5hcnJheXMsXG4gICAgICAgIGFycmF5cyA9IF9yZWYkYXJyYXlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkYXJyYXlzLFxuICAgICAgICBfcmVmJHNlcGFyYXRvciA9IF9yZWYuc2VwYXJhdG9yLFxuICAgICAgICBzZXBhcmF0b3IgPSBfcmVmJHNlcGFyYXRvciA9PT0gdm9pZCAwID8gJy4nIDogX3JlZiRzZXBhcmF0b3I7XG5cbiAgICBmdW5jdGlvbiBzdGVwKG9iaiwgZmxhdERhdGFSb3csIGN1cnJlbnRQYXRoKSB7XG4gICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgbmV3UGF0aCA9IGN1cnJlbnRQYXRoID8gXCJcIi5jb25jYXQoY3VycmVudFBhdGgpLmNvbmNhdChzZXBhcmF0b3IpLmNvbmNhdChrZXkpIDoga2V5O1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcblxuICAgICAgICBpZiAob2JqZWN0cyAmJiBfdHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZS50b0pTT04pICE9PSAnW29iamVjdCBGdW5jdGlvbl0nICYmIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgpIHtcbiAgICAgICAgICBzdGVwKHZhbHVlLCBmbGF0RGF0YVJvdywgbmV3UGF0aCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFycmF5cyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHN0ZXAodmFsdWUsIGZsYXREYXRhUm93LCBuZXdQYXRoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmbGF0RGF0YVJvd1tuZXdQYXRoXSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmxhdERhdGFSb3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhUm93KSB7XG4gICAgICByZXR1cm4gc3RlcChkYXRhUm93LCB7fSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBmbGF0dGVuXzEgPSBmbGF0dGVuO1xuXG4gIHZhciBzZXRQcm9wJDEgPSB1dGlscy5zZXRQcm9wLFxuICAgICAgdW5zZXRQcm9wJDEgPSB1dGlscy51bnNldFByb3AsXG4gICAgICBmbGF0dGVuUmVkdWNlciQzID0gdXRpbHMuZmxhdHRlblJlZHVjZXI7XG5cbiAgZnVuY3Rpb24gZ2V0VW53aW5kYWJsZVBhdGhzKG9iaiwgY3VycmVudFBhdGgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoZnVuY3Rpb24gKHVud2luZGFibGVQYXRocywga2V5KSB7XG4gICAgICB2YXIgbmV3UGF0aCA9IGN1cnJlbnRQYXRoID8gXCJcIi5jb25jYXQoY3VycmVudFBhdGgsIFwiLlwiKS5jb25jYXQoa2V5KSA6IGtleTtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICBpZiAoX3R5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUudG9KU09OKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJyAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoKSB7XG4gICAgICAgIHVud2luZGFibGVQYXRocyA9IHVud2luZGFibGVQYXRocy5jb25jYXQoZ2V0VW53aW5kYWJsZVBhdGhzKHZhbHVlLCBuZXdQYXRoKSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHVud2luZGFibGVQYXRocy5wdXNoKG5ld1BhdGgpO1xuICAgICAgICB1bndpbmRhYmxlUGF0aHMgPSB1bndpbmRhYmxlUGF0aHMuY29uY2F0KHZhbHVlLm1hcChmdW5jdGlvbiAoYXJyT2JqKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFVud2luZGFibGVQYXRocyhhcnJPYmosIG5ld1BhdGgpO1xuICAgICAgICB9KS5yZWR1Y2UoZmxhdHRlblJlZHVjZXIkMywgW10pLmZpbHRlcihmdW5jdGlvbiAoaXRlbSwgaW5kZXgsIGFycikge1xuICAgICAgICAgIHJldHVybiBhcnIuaW5kZXhPZihpdGVtKSAhPT0gaW5kZXg7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVud2luZGFibGVQYXRocztcbiAgICB9LCBbXSk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIHRoZSB1bndpbmQgcmVjdXJzaXZlbHkgaW4gc3BlY2lmaWVkIHNlcXVlbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IHVud2luZFBhdGhzIFRoZSBwYXRocyBhcyBzdHJpbmdzIHRvIGJlIHVzZWQgdG8gZGVjb25zdHJ1Y3QgdGhlIGFycmF5XG4gICAqIEByZXR1cm5zIHtPYmplY3QgPT4gQXJyYXl9IEFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyBhbGwgcm93cyBhZnRlciB1bndpbmQgb2YgY2hvc2VuIHBhdGhzXG4gICovXG5cblxuICBmdW5jdGlvbiB1bndpbmQoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBfcmVmJHBhdGhzID0gX3JlZi5wYXRocyxcbiAgICAgICAgcGF0aHMgPSBfcmVmJHBhdGhzID09PSB2b2lkIDAgPyB1bmRlZmluZWQgOiBfcmVmJHBhdGhzLFxuICAgICAgICBfcmVmJGJsYW5rT3V0ID0gX3JlZi5ibGFua091dCxcbiAgICAgICAgYmxhbmtPdXQgPSBfcmVmJGJsYW5rT3V0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkYmxhbmtPdXQ7XG5cbiAgICBmdW5jdGlvbiB1bndpbmRSZWR1Y2VyKHJvd3MsIHVud2luZFBhdGgpIHtcbiAgICAgIHJldHVybiByb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciB1bndpbmRBcnJheSA9IGxvZGFzaF9nZXQocm93LCB1bndpbmRQYXRoKTtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodW53aW5kQXJyYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdW53aW5kQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHVuc2V0UHJvcCQxKHJvdywgdW53aW5kUGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW53aW5kQXJyYXkubWFwKGZ1bmN0aW9uICh1bndpbmRSb3csIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGNsb25lZFJvdyA9IGJsYW5rT3V0ICYmIGluZGV4ID4gMCA/IHt9IDogcm93O1xuICAgICAgICAgIHJldHVybiBzZXRQcm9wJDEoY2xvbmVkUm93LCB1bndpbmRQYXRoLCB1bndpbmRSb3cpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLnJlZHVjZShmbGF0dGVuUmVkdWNlciQzLCBbXSk7XG4gICAgfVxuXG4gICAgcGF0aHMgPSBBcnJheS5pc0FycmF5KHBhdGhzKSA/IHBhdGhzIDogcGF0aHMgPyBbcGF0aHNdIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YVJvdykge1xuICAgICAgcmV0dXJuIChwYXRocyB8fCBnZXRVbndpbmRhYmxlUGF0aHMoZGF0YVJvdykpLnJlZHVjZSh1bndpbmRSZWR1Y2VyLCBbZGF0YVJvd10pO1xuICAgIH07XG4gIH1cblxuICB2YXIgdW53aW5kXzEgPSB1bndpbmQ7XG5cbiAgdmFyIFJlYWRhYmxlJDEgPSBTdHJlYW0uUmVhZGFibGU7XG4gIHZhciBQYXJzZXIkMSA9IEpTT04yQ1NWUGFyc2VyXzE7XG4gIHZhciBBc3luY1BhcnNlciA9IEpTT04yQ1NWQXN5bmNQYXJzZXJfMTtcbiAgdmFyIFRyYW5zZm9ybSQzID0gSlNPTjJDU1ZUcmFuc2Zvcm1fMTsgLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIGtlZXAgdGhlIEFQSSBzaW1pbGFyIHRvIHZlcnNpb24gMy5YXG5cbiAgdmFyIHBhcnNlID0gZnVuY3Rpb24gcGFyc2UoZGF0YSwgb3B0cykge1xuICAgIHJldHVybiBuZXcgSlNPTjJDU1ZQYXJzZXJfMShvcHRzKS5wYXJzZShkYXRhKTtcbiAgfTtcblxuICB2YXIgcGFyc2VBc3luYyA9IGZ1bmN0aW9uIHBhcnNlQXN5bmMoZGF0YSwgb3B0cywgdHJhbnNmb3JtT3B0cykge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgUmVhZGFibGUkMSkpIHtcbiAgICAgICAgdHJhbnNmb3JtT3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHRyYW5zZm9ybU9wdHMsIHtcbiAgICAgICAgICBvYmplY3RNb2RlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXN5bmNQYXJzZXIgPSBuZXcgSlNPTjJDU1ZBc3luY1BhcnNlcl8xKG9wdHMsIHRyYW5zZm9ybU9wdHMpO1xuICAgICAgdmFyIHByb21pc2UgPSBhc3luY1BhcnNlci5wcm9taXNlKCk7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBhc3luY1BhcnNlci5pbnB1dC5wdXNoKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYXN5bmNQYXJzZXIuaW5wdXQucHVzaChudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFJlYWRhYmxlJDEpIHtcbiAgICAgICAgYXN5bmNQYXJzZXIuZnJvbUlucHV0KGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXN5bmNQYXJzZXIuaW5wdXQucHVzaChkYXRhKTtcbiAgICAgICAgYXN5bmNQYXJzZXIuaW5wdXQucHVzaChudWxsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHRyYW5zZm9ybXMgPSB7XG4gICAgZmxhdHRlbjogZmxhdHRlbl8xLFxuICAgIHVud2luZDogdW53aW5kXzFcbiAgfTtcbiAgdmFyIGpzb24yY3N2ID0ge1xuICAgIFBhcnNlcjogUGFyc2VyJDEsXG4gICAgQXN5bmNQYXJzZXI6IEFzeW5jUGFyc2VyLFxuICAgIFRyYW5zZm9ybTogVHJhbnNmb3JtJDMsXG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIHBhcnNlQXN5bmM6IHBhcnNlQXN5bmMsXG4gICAgdHJhbnNmb3JtczogdHJhbnNmb3Jtc1xuICB9O1xuXG4gIGV4cG9ydHMuQXN5bmNQYXJzZXIgPSBBc3luY1BhcnNlcjtcbiAgZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXIkMTtcbiAgZXhwb3J0cy5UcmFuc2Zvcm0gPSBUcmFuc2Zvcm0kMztcbiAgZXhwb3J0cy5kZWZhdWx0ID0ganNvbjJjc3Y7XG4gIGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbiAgZXhwb3J0cy5wYXJzZUFzeW5jID0gcGFyc2VBc3luYztcbiAgZXhwb3J0cy50cmFuc2Zvcm1zID0gdHJhbnNmb3JtcztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCAiLyogVmVyc2lvbjogMC40LjIxIC0gTm92ZW1iZXIgMjAsIDIwMjEgMTQ6NDE6MTcgKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRHVtbXkgcHJvcGVydHkgdG8gYXZvaWQgc29tZSByb2xsdXAgd2FybmluZ3MgYWJvdXQgYW4gXCJlbXB0eSBjaHVua1wiIChzaW5jZSB0aGlzIGlzIG9ubHkgdHlwaW5ncykuXHJcbmNvbnN0IERBVEFWSUVXX1BMQUNFSE9MREVSX1ZBTFVFID0gbnVsbDtcblxuZXhwb3J0cy5EQVRBVklFV19QTEFDRUhPTERFUl9WQUxVRSA9IERBVEFWSUVXX1BMQUNFSE9MREVSX1ZBTFVFO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCAiaW1wb3J0IHsgRGF0ZVRpbWUgfSBmcm9tIFwibHV4b25cIjtcclxuaW1wb3J0IHsgUGFyc2VyLCB0cmFuc2Zvcm1zIH0gZnJvbSBcImpzb24yY3N2XCI7XHJcbmltcG9ydCB7IG5vcm1hbGl6ZVBhdGgsIE5vdGljZSwgUGx1Z2luIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7IERhdGF2aWV3QXBpIH0gZnJvbSBcIm9ic2lkaWFuLWRhdGF2aWV3XCI7XHJcbmltcG9ydCB7IENoYXJ0TW9kYWwgfSBmcm9tIFwiLi9DaGFydE1vZGFsXCI7XHJcbmltcG9ydCB7IERFRkFVTFRfU0VUVElOR1MsIGRyb3BIZWFkZXJPckFsaWFzLCBzcGxpdExpbmtzUmVnZXggfSBmcm9tIFwiLi9jb25zdFwiO1xyXG5pbXBvcnQgeyBEYXRhVHlwZSwgU2V0dGluZ3MgfSBmcm9tIFwiLi9pbnRlcmZhY2VzXCI7XHJcbmltcG9ydCB7IFNldHRpbmdUYWIgfSBmcm9tIFwiLi9TZXR0aW5nVGFiXCI7XHJcbmltcG9ydCB7IFN0YXRzTW9kYWwgfSBmcm9tIFwiLi9TdGF0c01vZGFsXCI7XHJcbmltcG9ydCB7XHJcblx0YXJyYXlPdmVybGFwLFxyXG5cdG1ha2VBcnIsXHJcblx0c3BsaXRBbmRUcmltLFxyXG5cdHN0cmluZ1RvTnVsbE9yVW5kZWZpbmVkLFxyXG59IGZyb20gXCIuL3V0aWxzXCI7XHJcbmltcG9ydCB7IGdldFBlYXJzb25Db3JyZWxhdGlvbiwgZ2V0UG9pbnRCaXNlcmlhbENvcnJlbGF0aW9uIH0gZnJvbSBcIi4vYW5hbHlzZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGFBbmFseXNpc1BsdWdpbiBleHRlbmRzIFBsdWdpbiB7XHJcblx0c2V0dGluZ3M6IFNldHRpbmdzO1xyXG5cdGluZGV4OiB7XHJcblx0XHRkYXRhOiB7IFtmaWVsZDogc3RyaW5nXTogRGF0YVR5cGUgfVtdO1xyXG5cdFx0bWluRGF0ZTogRGF0ZVRpbWU7XHJcblx0XHRtYXhEYXRlOiBEYXRlVGltZTtcclxuXHR9ID0ge1xyXG5cdFx0ZGF0YTogdW5kZWZpbmVkLFxyXG5cdFx0bWluRGF0ZTogdW5kZWZpbmVkLFxyXG5cdFx0bWF4RGF0ZTogdW5kZWZpbmVkLFxyXG5cdH07XHJcblx0LyogeyBmb29kczogW1wiYmFuYW5hXCJdIH0gKi9cclxuXHR1bndyYXBwZWRGaWVsZHM6IHsgW2ZpZWxkOiBzdHJpbmddOiBzdHJpbmdbXSB9ID0ge307XHJcblxyXG5cdGFzeW5jIG9ubG9hZCgpIHtcclxuXHRcdGNvbnNvbGUubG9nKFwiTG9hZGluZyBkYXRhLWFuYWx5c2lzIHBsdWdpblwiKTtcclxuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XHJcblxyXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuYXBwLnBsdWdpbnMuZW5hYmxlZFBsdWdpbnMuaGFzKFwiZGF0YXZpZXdcIikpIHtcclxuXHRcdFx0Y29uc3QgYXBpID0gdGhpcy5hcHAucGx1Z2lucy5wbHVnaW5zLmRhdGF2aWV3Py5hcGk7XHJcblx0XHRcdGlmIChhcGkpIHRoaXMucmVmcmVzaEluZGV4KGFwaSk7XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMucmVnaXN0ZXJFdmVudChcclxuXHRcdFx0XHRcdHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUub24oXCJkYXRhdmlldzphcGktcmVhZHlcIiwgKGFwaSkgPT4ge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnJlZnJlc2hJbmRleChhcGkpO1xyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRuZXcgTm90aWNlKFxyXG5cdFx0XHRcdFwiRGF0YXZpZXcgbXVzdCBiZSBlbmFibGVkIGZvciB0aGUgRGF0YSBBbmFseXNpcyBwbHVnaW4gdG8gd29ya1wiXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcclxuXHRcdFx0aWQ6IFwicmVmcmVzaC1pbmRleFwiLFxyXG5cdFx0XHRuYW1lOiBcIlJlZnJlc2ggSW5kZXhcIixcclxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+XHJcblx0XHRcdFx0YXdhaXQgdGhpcy5yZWZyZXNoSW5kZXgodGhpcy5hcHAucGx1Z2lucy5wbHVnaW5zLmRhdGF2aWV3Py5hcGkpLFxyXG5cdFx0fSk7XHJcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xyXG5cdFx0XHRpZDogXCJjaGFydC12aWV3XCIsXHJcblx0XHRcdG5hbWU6IFwiT3BlbiBDaGFydCBNb2RhbFwiLFxyXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4gbmV3IENoYXJ0TW9kYWwodGhpcy5hcHAsIHRoaXMpLm9wZW4oKSxcclxuXHRcdH0pO1xyXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcclxuXHRcdFx0aWQ6IFwic3RhdHMtdmlld1wiLFxyXG5cdFx0XHRuYW1lOiBcIk9wZW4gU3RhdHMgTW9kYWxcIixcclxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IG5ldyBTdGF0c01vZGFsKHRoaXMuYXBwLCB0aGlzKS5vcGVuKCksXHJcblx0XHR9KTtcclxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XHJcblx0XHRcdGlkOiBcImJ1aWxkcy1jb3Jyc1wiLFxyXG5cdFx0XHRuYW1lOiBcIkJ1aWxkIENvcnJlbGF0aW9uc1wiLFxyXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4gY29uc29sZS5sb2codGhpcy5idWlsZEFsbENvcnJlbGF0aW9ucygpKSxcclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XHJcblx0XHRcdGlkOiBcIndyaXRlLW1ldGFkYXRhZnJhbWVcIixcclxuXHRcdFx0bmFtZTogXCJXcml0ZSBNZXRhZGF0YWZyYW1lXCIsXHJcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGNvbnN0IGpzREYgPSBhd2FpdCB0aGlzLmNyZWF0ZUpTREYoKTtcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGpzREYpO1xyXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy53cml0ZU1ldGFkYXRhZnJhbWUoanNERik7XHJcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcclxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJBbiBlcnJvciBvY2N1cmVkLiBQbGVhc2UgY2hlY2sgdGhlIGNvbnNvbGUuXCIpO1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coZXJyb3IpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0b251bmxvYWQoKSB7fVxyXG5cclxuXHR1bnByb3h5KGl0ZW06IGFueSk6IERhdGFUeXBlW10ge1xyXG5cdFx0Y29uc3QgdW5wcm94aWVkID0gW107XHJcblxyXG5cdFx0Y29uc3QgcXVldWUgPSBbaXRlbV07XHJcblx0XHR3aGlsZSAocXVldWUubGVuZ3RoKSB7XHJcblx0XHRcdGNvbnN0IGN1cnJJdGVtID0gcXVldWUuc2hpZnQoKTtcclxuXHRcdFx0Ly8gXCJQcm94eVwiIGZvciBjaGVja2luZyBpZiBgY3Vyckl0ZW1gIGlzIGEgcHJveHlcclxuXHRcdFx0aWYgKHR5cGVvZiBjdXJySXRlbS5kZWZhdWx0Q29tcGFyYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRcdFx0Y29uc3QgcG9zc2libGVVbnByb3hpZWQgPSBPYmplY3QuYXNzaWduKHt9LCBjdXJySXRlbSk7XHJcblx0XHRcdFx0Y29uc3QgeyB2YWx1ZXMgfSA9IHBvc3NpYmxlVW5wcm94aWVkO1xyXG5cdFx0XHRcdGlmICh2YWx1ZXMpIHF1ZXVlLnB1c2goLi4udmFsdWVzKTtcclxuXHRcdFx0XHRlbHNlIHVucHJveGllZC5wdXNoKHBvc3NpYmxlVW5wcm94aWVkKTtcclxuXHRcdFx0fSBlbHNlIHVucHJveGllZC5wdXNoKGN1cnJJdGVtKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB1bnByb3hpZWQ7XHJcblx0fVxyXG5cclxuXHRnZXRJbm5lclZhbHVlKHZhbHVlOiBhbnkpIHtcclxuXHRcdGNvbnN0IHVucHJveGllZCA9IHRoaXMudW5wcm94eSh2YWx1ZSk7XHJcblx0XHRpZiAodW5wcm94aWVkLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHRpZiAodHlwZW9mIHVucHJveGllZFswXSA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRcdGxldCBsaXN0ID0gdW5wcm94aWVkWzBdO1xyXG5cdFx0XHRcdGlmIChsaXN0LnN0YXJ0c1dpdGgoXCJbXCIpICYmIGxpc3QuZW5kc1dpdGgoXCJdXCIpKSB7XHJcblx0XHRcdFx0XHRsaXN0ID0gbGlzdC5zbGljZSgxLCAtMSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNvbnN0IHNwbGl0cyA9IHNwbGl0QW5kVHJpbShsaXN0KS5tYXAoKGl0ZW0pID0+IHtcclxuXHRcdFx0XHRcdGlmIChpdGVtLnN0YXJ0c1dpdGgoYFwiYCkgJiYgaXRlbS5lbmRzV2l0aChgXCJgKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gaXRlbS5zbGljZSgxLCAtMSk7XHJcblx0XHRcdFx0XHR9IGVsc2UgcmV0dXJuIGl0ZW07XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0aWYgKHNwbGl0cy5sZW5ndGggPT09IDEpIHJldHVybiBzcGxpdHNbMF07XHJcblx0XHRcdFx0ZWxzZSByZXR1cm4gc3BsaXRzO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmICh1bnByb3hpZWRbMF0udHlwZSA9PT0gXCJmaWxlXCIpIHtcclxuXHRcdFx0XHRcdHJldHVybiB1bnByb3hpZWRbMF0ucGF0aDtcclxuXHRcdFx0XHR9IGVsc2UgcmV0dXJuIHVucHJveGllZFswXTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKHVucHJveGllZFswXS50eXBlID09PSBcImZpbGVcIikge1xyXG5cdFx0XHRcdHJldHVybiB1bnByb3hpZWQubWFwKChsaW5rKSA9PiBsaW5rLnBhdGgpO1xyXG5cdFx0XHR9IGVsc2UgcmV0dXJuIHVucHJveGllZDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHVud3JhcFN0ckxpc3RzKGRhdGE6IHsgW2ZpZWxkOiBzdHJpbmddOiBhbnkgfVtdKSB7XHJcblx0XHRjb25zdCB7IHVud3JhcHBlZEZpZWxkcyB9ID0gdGhpcztcclxuXHRcdGNvbnN0IHsgZmllbGRzVG9DaGVjayB9ID0gdGhpcy5zZXR0aW5ncztcclxuXHJcblx0XHRmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkc1RvQ2hlY2spIHtcclxuXHRcdFx0dW53cmFwcGVkRmllbGRzW2ZpZWxkXSA9IFtdO1xyXG5cdFx0XHRkYXRhLmZvckVhY2goKGQpID0+IHtcclxuXHRcdFx0XHRjb25zdCB2YWwgPSBkW2ZpZWxkXTtcclxuXHRcdFx0XHRpZiAodmFsKSB7XHJcblx0XHRcdFx0XHRpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRcdFx0XHRkW3ZhbF0gPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRpZiAoIXVud3JhcHBlZEZpZWxkc1tmaWVsZF0uaW5jbHVkZXModmFsKSlcclxuXHRcdFx0XHRcdFx0XHR1bndyYXBwZWRGaWVsZHNbZmllbGRdLnB1c2godmFsKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoXHJcblx0XHRcdFx0XHRcdHZhbD8uZXZlcnkgJiZcclxuXHRcdFx0XHRcdFx0dmFsLmV2ZXJ5KCh4OiBhbnkpID0+IHR5cGVvZiB4ID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHRcdHZhbC5mb3JFYWNoKChzdHI6IHN0cmluZykgPT4ge1xyXG5cdFx0XHRcdFx0XHRcdGRbc3RyXSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCF1bndyYXBwZWRGaWVsZHNbZmllbGRdLmluY2x1ZGVzKHN0cikpXHJcblx0XHRcdFx0XHRcdFx0XHR1bndyYXBwZWRGaWVsZHNbZmllbGRdLnB1c2goc3RyKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcblx0YXN5bmMgcmVmcmVzaEluZGV4KGR2QXBpOiBEYXRhdmlld0FwaSkge1xyXG5cdFx0Y29uc3Qgbm90aWNlID0gbmV3IE5vdGljZShcIkluZGV4IHJlZnJlc2hpbmcuLi5cIik7XHJcblx0XHRpZiAoIWR2QXBpKSB7XHJcblx0XHRcdG5vdGljZS5zZXRNZXNzYWdlKFwiRGF0YXZpZXcgbXVzdCBiZSBlbmFibGVkXCIpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRjb25zdCB7IGZpZWxkc1RvQ2hlY2ssIGZpZWxkTGlzdHMgfSA9IHRoaXMuc2V0dGluZ3M7XHJcblx0XHRmb3IgKGNvbnN0IHBhdGggb2YgZmllbGRMaXN0cykge1xyXG5cdFx0XHRjb25zdCBmaWxlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChwYXRoLCBcIlwiKTtcclxuXHRcdFx0aWYgKCFmaWxlKSBjb250aW51ZTtcclxuXHJcblx0XHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5jYWNoZWRSZWFkKGZpbGUpO1xyXG5cdFx0XHRjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoXCJcXG5cIik7XHJcblx0XHRcdGxpbmVzLmZvckVhY2goKGxpbmUpID0+IHtcclxuXHRcdFx0XHRjb25zdCBmaWVsZCA9IGxpbmUuc3RhcnRzV2l0aChcIltbXCIpID8gbGluZS5zbGljZSgyLCAtMikgOiBsaW5lO1xyXG5cdFx0XHRcdGlmICghZmllbGRzVG9DaGVjay5pbmNsdWRlcyhmaWVsZCkpIGZpZWxkc1RvQ2hlY2sucHVzaChmaWVsZCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLnNldHRpbmdzLmZpZWxkc1RvQ2hlY2sgPSBmaWVsZHNUb0NoZWNrO1xyXG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHBhZ2VzOiB7IFtmaWVsZDogc3RyaW5nXTogYW55IH1bXSA9IGR2QXBpLnBhZ2VzKCkudmFsdWVzO1xyXG5cdFx0Y29uc3QgZGF0ZXM6IERhdGVUaW1lW10gPSBbXTtcclxuXHRcdHBhZ2VzLmZvckVhY2goKHBhZ2UpID0+IHtcclxuXHRcdFx0Y29uc3QgcG90ZW50aWFsRGF0ZSA9IERhdGVUaW1lLmZyb21JU08ocGFnZS5maWxlLm5hbWUpO1xyXG5cdFx0XHRpZiAocG90ZW50aWFsRGF0ZS5pc1ZhbGlkKSBkYXRlcy5wdXNoKHBvdGVudGlhbERhdGUpO1xyXG5cclxuXHRcdFx0ZmllbGRzVG9DaGVjay5mb3JFYWNoKChmaWVsZCkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gcGFnZVtmaWVsZF07XHJcblx0XHRcdFx0aWYgKHZhbHVlKSBwYWdlW2ZpZWxkXSA9IHRoaXMuZ2V0SW5uZXJWYWx1ZSh2YWx1ZSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy51bndyYXBTdHJMaXN0cyhwYWdlcyk7XHJcblxyXG5cdFx0dGhpcy5pbmRleCA9IHtcclxuXHRcdFx0ZGF0YTogcGFnZXMsXHJcblx0XHRcdG1pbkRhdGU6IERhdGVUaW1lLm1pbiguLi5kYXRlcyksXHJcblx0XHRcdG1heERhdGU6IERhdGVUaW1lLm1heCguLi5kYXRlcyksXHJcblx0XHR9O1xyXG5cdFx0Y29uc29sZS5sb2codGhpcy5pbmRleCk7XHJcblx0XHRub3RpY2Uuc2V0TWVzc2FnZShcIkluZGV4IHJlZnJlc2hlZCBcdTI3MDVcIik7XHJcblx0fVxyXG5cclxuXHRhbGxVbmlxdWVWYWx1ZXNGb3JGaWVsZChmaWVsZDogc3RyaW5nKSB7XHJcblx0XHRjb25zdCB2YWx1ZXM6IGFueVtdID0gW107XHJcblx0XHR0aGlzLmluZGV4LmRhdGEuZm9yRWFjaCgocGFnZSkgPT4ge1xyXG5cdFx0XHRjb25zdCB2YWx1ZSA9IHBhZ2VbZmllbGRdO1xyXG5cdFx0XHRpZiAodmFsdWUpIHZhbHVlcy5wdXNoKC4uLm1ha2VBcnIodmFsdWUpKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBbLi4ubmV3IFNldChbLi4udmFsdWVzXSldO1xyXG5cdH1cclxuXHJcblx0aW5mZXJUeXBlKFxyXG5cdFx0eHM6IChzdHJpbmcgfCBudW1iZXIpW11cclxuXHQpOiBcInN0cmluZ1wiIHwgXCJudW1iZXJcIiB8IFwib2JqZWN0XCIgfCBcInVuZGVmaW5lZFwiIHtcclxuXHRcdGNvbnN0IGRlZmluZWRzID0geHMuZmlsdGVyKCh4KSA9PiB4KTtcclxuXHRcdGNvbnN0IHR5cGVzID0gZGVmaW5lZHMubWFwKCh4KSA9PiB0eXBlb2YgeCk7XHJcblx0XHRpZiAoIWRlZmluZWRzLmxlbmd0aCkgcmV0dXJuIFwidW5kZWZpbmVkXCI7XHJcblx0XHRjb25zdCB0aHJlc2ggPSBkZWZpbmVkcy5sZW5ndGggLyAyO1xyXG5cclxuXHRcdGlmICh0eXBlcy5maWx0ZXIoKHgpID0+IHggPT09IFwibnVtYmVyXCIpLmxlbmd0aCA+PSB0aHJlc2gpXHJcblx0XHRcdHJldHVybiBcIm51bWJlclwiO1xyXG5cdFx0ZWxzZSBpZiAodHlwZXMuZmlsdGVyKCh4KSA9PiB4ID09PSBcInN0cmluZ1wiKS5sZW5ndGggPj0gdGhyZXNoKVxyXG5cdFx0XHRyZXR1cm4gXCJzdHJpbmdcIjtcclxuXHRcdGVsc2UgcmV0dXJuIFwib2JqZWN0XCI7XHJcblx0fVxyXG5cclxuXHRyZXBsYWNlTWlzc2luZyh4czogKHN0cmluZyB8IG51bWJlcilbXSkge1xyXG5cdFx0Y29uc3QgdHlwZSA9IHRoaXMuaW5mZXJUeXBlKHhzKTtcclxuXHRcdHJldHVybiB4cy5tYXAoKHgpID0+IHggPz8gKHR5cGUgPT09IFwibnVtYmVyXCIgPyAwIDogXCJOL0FcIikpO1xyXG5cdH1cclxuXHJcblx0YnVpbGRBbGxDb3JyZWxhdGlvbnMoKSB7XHJcblx0XHRjb25zdCB7IGRhdGEgfSA9IHRoaXMuaW5kZXg7XHJcblx0XHRjb25zdCB7IGZpZWxkc1RvQ2hlY2sgfSA9IHRoaXMuc2V0dGluZ3M7XHJcblx0XHRjb25zdCBjb3JyczogeyBbZkE6IHN0cmluZ106IHsgW2ZCOiBzdHJpbmddOiBudW1iZXIgfSB9ID0ge307XHJcblxyXG5cdFx0Zm9yIChjb25zdCBmQSBvZiBmaWVsZHNUb0NoZWNrKSB7XHJcblx0XHRcdGNvcnJzW2ZBXSA9IHt9O1xyXG5cdFx0XHRjb25zdCB2QSA9IGRhdGEubWFwKChkKSA9PiBkW2ZBXSk7XHJcblx0XHRcdGNvbnN0IHRBID0gdGhpcy5pbmZlclR5cGUodkEpO1xyXG5cdFx0XHRmb3IgKGNvbnN0IGZCIG9mIGZpZWxkc1RvQ2hlY2spIHtcclxuXHRcdFx0XHRpZiAoZkEgPT09IGZCKSBjb250aW51ZTtcclxuXHRcdFx0XHRjb25zdCB2QiA9IGRhdGEubWFwKChkKSA9PiBkW2ZCXSk7XHJcblx0XHRcdFx0Y29uc3QgdEIgPSB0aGlzLmluZmVyVHlwZSh2Qik7XHJcblxyXG5cdFx0XHRcdGlmICh0QSA9PT0gXCJudW1iZXJcIiAmJiB0QiA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRcdFx0Y29uc3QgW29BLCBvQl0gPSBhcnJheU92ZXJsYXAodkEsIHZCKTtcclxuXHRcdFx0XHRcdC8vIFNraXAgZW1wdHkgYXJyYXlzXHJcblx0XHRcdFx0XHQvLyBBbHNvIGNhbid0IGdldCBjb3JyIG9mIG9uZSB2YWx1ZVxyXG5cdFx0XHRcdFx0aWYgKG9BLmxlbmd0aCA8PSAxIHx8IG9CLmxlbmd0aCA8PSAxKSB7XHJcblx0XHRcdFx0XHRcdGNvcnJzW2ZBXVtmQl0gPSBudWxsO1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGNvbnN0IGNvcnIgPSBnZXRQZWFyc29uQ29ycmVsYXRpb24ob0EsIG9CKTtcclxuXHRcdFx0XHRcdGNvcnJzW2ZBXVtmQl0gPSBjb3JyO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAodEEgPT09IFwibnVtYmVyXCIgJiYgdEIgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0XHRcdGNvbnN0IG9BID0gdkEuZmlsdGVyKChhKSA9PiBhKTtcclxuXHRcdFx0XHRcdGNvbnN0IG9CID0gdkJcclxuXHRcdFx0XHRcdFx0LmZpbHRlcigoYiwgaSkgPT4gdkFbaV0gIT09IHVuZGVmaW5lZClcclxuXHRcdFx0XHRcdFx0Lm1hcCgoYikgPT4gYiA/PyAwKTtcclxuXHJcblx0XHRcdFx0XHRjb25zdCB1bmlxdWVTdHJzID0gWy4uLm5ldyBTZXQob0IpXS5maWx0ZXIoXHJcblx0XHRcdFx0XHRcdChzdHIpID0+IHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCJcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHR1bmlxdWVTdHJzLmZvckVhY2goKHN1YkYpID0+IHtcclxuXHRcdFx0XHRcdFx0Y29uc3Qgc3ViQSA9IG9BO1xyXG5cdFx0XHRcdFx0XHRjb25zdCBzdWJCID0gb0IubWFwKChiKSA9PiAoYiA9PT0gc3ViRiA/IDEgOiAwKSk7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBjb3JyID0gZ2V0UG9pbnRCaXNlcmlhbENvcnJlbGF0aW9uKHN1YkIsIHN1YkEpO1xyXG5cdFx0XHRcdFx0XHRjb3Jyc1tmQV1bc3ViRl0gPSBjb3JyO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmICh0QSA9PT0gXCJudW1iZXJcIiAmJiB0QiA9PT0gXCJvYmplY3RcIikge1xyXG5cdFx0XHRcdFx0Y29uc3Qgb0EgPSB2QS5maWx0ZXIoKGEpID0+IGEpO1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coeyB2QiB9KTtcclxuXHRcdFx0XHRcdGNvbnN0IG9CID0gdkIgYXMgc3RyaW5nW11bXTtcclxuXHRcdFx0XHRcdC8vIC5maWx0ZXIoKGIsIGkpID0+IHZBW2ldICE9PSB1bmRlZmluZWQpXHJcblx0XHRcdFx0XHQvLyAubWFwKChiKSA9PiBiID8/IDApO1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coeyB2QSwgdkIsIG9BLCBvQiB9KTtcclxuXHJcblx0XHRcdFx0XHRjb25zdCB1bmlxdWVTdHJzID0gWy4uLm5ldyBTZXQob0IpXS5maWx0ZXIoXHJcblx0XHRcdFx0XHRcdChzdHIpID0+IHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCJcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHR1bmlxdWVTdHJzLmZvckVhY2goKHN1YkYpID0+IHtcclxuXHRcdFx0XHRcdFx0Y29uc3Qgc3ViQSA9IG9BO1xyXG5cdFx0XHRcdFx0XHRjb25zdCBzdWJCID0gb0IubWFwKChiKSA9PiAoYiA9PT0gc3ViRiA/IDEgOiAwKSk7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBjb3JyID0gZ2V0UG9pbnRCaXNlcmlhbENvcnJlbGF0aW9uKHN1YkIsIHN1YkEpO1xyXG5cdFx0XHRcdFx0XHRjb3Jyc1tmQV1bc3ViRl0gPSBjb3JyO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmICh0QSA9PT0gXCJzdHJpbmdcIiAmJiB0QiA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAodEEgPT09IFwic3RyaW5nXCIgJiYgdEIgPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHRBID09PSBcInN0cmluZ1wiICYmIHRCID09PSBcIm9iamVjdFwiKSB7XHJcblx0XHRcdFx0fSBlbHNlIGlmICh0QSA9PT0gXCJvYmplY3RcIiAmJiB0QiA9PT0gXCJvYmplY3RcIikge1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAodEEgPT09IFwib2JqZWN0XCIgJiYgdEIgPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHRBID09PSBcIm9iamVjdFwiICYmIHRCID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRjb25zb2xlLmxvZyh7IGNvcnJzIH0pO1xyXG5cdH1cclxuXHJcblx0Z2V0QWxsQ29ycnNGb3JGaWVsZChmaWVsZEE6IHN0cmluZykge1xyXG5cdFx0Y29uc3QgeyBkYXRhIH0gPSB0aGlzLmluZGV4O1xyXG5cdFx0Y29uc3QgeyBmaWVsZHNUb0NoZWNrIH0gPSB0aGlzLnNldHRpbmdzO1xyXG5cdFx0Y29uc3QgY29ycmVsYXRpb25zID0ge307XHJcblxyXG5cdFx0Y29uc3QgZmllbGRzRm9yQSA9IHRoaXMuYWxsVW5pcXVlVmFsdWVzRm9yRmllbGQoZmllbGRBKTtcclxuXHJcblx0XHRmaWVsZHNUb0NoZWNrLmZvckVhY2goKGZpZWxkQikgPT4ge1xyXG5cdFx0XHRjb25zdCBmaWVsZHNGb3JCID0gdGhpcy5hbGxVbmlxdWVWYWx1ZXNGb3JGaWVsZChmaWVsZEIpO1xyXG5cclxuXHRcdFx0Y29uc3QgdmFsc0luQ29tbW9uOiB7XHJcblx0XHRcdFx0W2ZpZWxkQTogc3RyaW5nXToge1xyXG5cdFx0XHRcdFx0W2ZpZWxkQjogc3RyaW5nXTogW1xyXG5cdFx0XHRcdFx0XHRzdHJpbmcgfCBudW1iZXIgfCBzdHJpbmdbXSxcclxuXHRcdFx0XHRcdFx0c3RyaW5nIHwgbnVtYmVyIHwgc3RyaW5nW11cclxuXHRcdFx0XHRcdF07XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fSA9IHt9O1xyXG5cclxuXHRcdFx0aWYgKCF2YWxzSW5Db21tb24uaGFzT3duUHJvcGVydHkoZmllbGRBKSkge1xyXG5cdFx0XHRcdHZhbHNJbkNvbW1vbltmaWVsZEFdID0ge307XHJcblx0XHRcdH1cclxuXHRcdFx0Y29uc3QgdmFsc0EgPSBkYXRhLm1hcCgoZCkgPT4gZFtmaWVsZEFdKTtcclxuXHRcdFx0Y29uc3QgdmFsc0IgPSBkYXRhLm1hcCgoZCkgPT4gZFtmaWVsZEJdKTtcclxuXHJcblx0XHRcdHZhbHNBLmZvckVhY2goKHZhbEEpID0+IHtcclxuXHRcdFx0XHRpZiAodHlwZW9mIHZhbEEgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0XHRcdC8vIHZhbHNJbkNvbW1vbltmaWVsZEEgKyB2YWxBXSA9IHZhbEE7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dmFsc0luQ29tbW9uW2ZpZWxkQV1bZmllbGRCXSA9IFt2YWxzQSwgdmFsc0JdO1xyXG5cclxuXHRcdFx0Ly8gZm9yIChjb25zdCBmaWVsZEEgaW4gdmFsc0luQ29tbW9uKSB7XHJcblx0XHRcdC8vIFx0Zm9yIChjb25zdCBmaWVsZEIgaW4gdmFsc0luQ29tbW9uKSB7XHJcblx0XHRcdC8vIFx0XHRjb25zdCBbdmFsQSwgdmFsQl0gPSB2YWxzSW5Db21tb25bZmllbGRBXVtmaWVsZEJdO1xyXG5cdFx0XHQvLyBcdFx0W3ZhbEEsIHZhbEJdLmZvckVhY2goKHZhbCwgaSkgPT4ge1xyXG5cdFx0XHQvLyBcdFx0XHRjb25zdCBhcnIgPSBtYWtlQXJyKHZhbCk7XHJcblx0XHRcdC8vIFx0XHRcdGlmICh0eXBlb2YgYXJyWzBdID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdC8vIFx0XHRcdFx0dmFsc0luQ29tbW9uW2ZpZWxkQV1bZmllbGRCXVtpXSA9IGFyci5tYXAoKHgpID0+IHtcclxuXHRcdFx0Ly8gXHRcdFx0XHRcdGlmIChpID09PSAwKVxyXG5cdFx0XHQvLyBcdFx0XHRcdFx0XHRyZXR1cm4gZmllbGRzRm9yQS5pbmNsdWRlcyh4KSA/IDEgOiAwO1xyXG5cdFx0XHQvLyBcdFx0XHRcdFx0ZWxzZSByZXR1cm4gZmllbGRzRm9yQi5pbmNsdWRlcyh4KSA/IDEgOiAwO1xyXG5cdFx0XHQvLyBcdFx0XHRcdH0pO1xyXG5cdFx0XHQvLyBcdFx0XHR9XHJcblx0XHRcdC8vIFx0XHR9KTtcclxuXHRcdFx0Ly8gXHR9XHJcblx0XHRcdC8vIH1cclxuXHRcdFx0Y29uc29sZS5sb2codmFsc0luQ29tbW9uKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgY3JlYXRlSlNERigpIHtcclxuXHRcdGNvbnN0IHsgc2V0dGluZ3MgfSA9IHRoaXM7XHJcblx0XHRjb25zdCB7XHJcblx0XHRcdGFkZE5vdGVDb250ZW50LFxyXG5cdFx0XHRhZGRGaWxlRGF0YSxcclxuXHRcdFx0bnVsbFZhbHVlLFxyXG5cdFx0XHR1bmRlZmluZWRWYWx1ZSxcclxuXHRcdFx0ZmllbGRzVG9DaGVjayxcclxuXHRcdH0gPSBzZXR0aW5ncztcclxuXHJcblx0XHRsZXQgeWFtbGRmOiB7IFtrZXk6IHN0cmluZ106IGFueSB9W10gPSBbXTtcclxuXHRcdGxldCB1bmlxdWVLZXlzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuXHRcdGxldCBhY3R1YWxOdWxsVmFsdWUgPSBzdHJpbmdUb051bGxPclVuZGVmaW5lZChudWxsVmFsdWUpO1xyXG5cclxuXHRcdGZvciAoY29uc3QgcGFnZSBvZiB0aGlzLmluZGV4LmRhdGEpIHtcclxuXHRcdFx0Y29uc3QgeyBmaWxlIH0gPSBwYWdlO1xyXG5cclxuXHRcdFx0Y29uc3QgY3VyclJvdyA9IHsgZmlsZTogeyBwYXRoOiBmaWxlLnBhdGggfSwgY29udGVudDogXCJcIiB9O1xyXG5cclxuXHRcdFx0aWYgKGFkZE5vdGVDb250ZW50KSB7XHJcblx0XHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNhY2hlZFJlYWQoZmlsZSk7XHJcblx0XHRcdFx0Y3VyclJvd1tcImNvbnRlbnRcIl0gPSBjb250ZW50O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKGNvbnN0IGtleSBvZiBmaWVsZHNUb0NoZWNrKSB7XHJcblx0XHRcdFx0Ly8gUHJvY2VzcyB2YWx1ZXNcclxuXHRcdFx0XHRpZiAoa2V5ICE9PSBcInBvc2l0aW9uXCIpIHtcclxuXHRcdFx0XHRcdGlmIChrZXkgIT09IFwiZmlsZVwiIHx8IGFkZEZpbGVEYXRhKSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gcGFnZVtrZXldO1xyXG5cdFx0XHRcdFx0XHRjb25zdCBhcnJWYWx1ZXMgPSBbdmFsdWVdLmZsYXQoNCk7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBDb2xsZWN0IHVuaXF1ZSBrZXlzIGZvciBsYXRlclxyXG5cdFx0XHRcdFx0XHRpZiAoIXVuaXF1ZUtleXMuaW5jbHVkZXMoa2V5KSkgdW5pcXVlS2V5cy5wdXNoKGtleSk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIXZhbHVlKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gTnVsbCB2YWx1ZXNcclxuXHRcdFx0XHRcdFx0XHRjdXJyUm93W2tleV0gPSBhY3R1YWxOdWxsVmFsdWU7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gU3RyaW5nIHZhbHVlc1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjb25zdCBzcGxpdHMgPSB2YWx1ZS5tYXRjaChzcGxpdExpbmtzUmVnZXgpO1xyXG5cdFx0XHRcdFx0XHRcdGlmIChzcGxpdHMgIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHN0cnMgPSBzcGxpdHNcclxuXHRcdFx0XHRcdFx0XHRcdFx0Lm1hcCgobGluaykgPT4ge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGRyb3BwZWQgPVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bGluay5tYXRjaChkcm9wSGVhZGVyT3JBbGlhcyk/LlsxXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoZHJvcHBlZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGBbWyR7ZHJvcHBlZH1dXWA7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBsaW5rO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0fSlcclxuXHRcdFx0XHRcdFx0XHRcdFx0LmpvaW4oXCIsIFwiKTtcclxuXHRcdFx0XHRcdFx0XHRcdGN1cnJSb3dba2V5XSA9IHN0cnM7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdGN1cnJSb3dba2V5XSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChhcnJWYWx1ZXM/LlswXT8udHMpIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBEYXRlc1xyXG5cdFx0XHRcdFx0XHRcdGN1cnJSb3dba2V5XSA9IGFyclZhbHVlc1xyXG5cdFx0XHRcdFx0XHRcdFx0Lm1hcCgodmFsKSA9PiB2YWw/LnRzKVxyXG5cdFx0XHRcdFx0XHRcdFx0LmpvaW4oXCIsIFwiKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChhcnJWYWx1ZXM/LlswXT8ucGF0aCkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIExpbmsgb2JqZWN0c1xyXG5cdFx0XHRcdFx0XHRcdGN1cnJSb3dba2V5XSA9IGFyclZhbHVlc1xyXG5cdFx0XHRcdFx0XHRcdFx0Lm1hcCgodmFsKSA9PiBgW1ske3ZhbD8ucGF0aH1dXWApXHJcblx0XHRcdFx0XHRcdFx0XHQuam9pbihcIiwgXCIpO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKFxyXG5cdFx0XHRcdFx0XHRcdE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09XHJcblx0XHRcdFx0XHRcdFx0XCJbb2JqZWN0IE9iamVjdF1cIlxyXG5cdFx0XHRcdFx0XHQpIHtcclxuXHRcdFx0XHRcdFx0XHRjdXJyUm93W2tleV0gPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBNaXNjZWxsYW5lb3VzIGFycmF5cyBhcmUgam9pbmVkIGludG8gc3RyaW5nc1xyXG5cdFx0XHRcdFx0XHRcdGN1cnJSb3dba2V5XSA9IGFyclZhbHVlcy5qb2luKFwiLCBcIik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHlhbWxkZi5wdXNoKGN1cnJSb3cpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBhY3R1YWxVbmRlZmluZWRWYWx1ZSA9IHN0cmluZ1RvTnVsbE9yVW5kZWZpbmVkKHVuZGVmaW5lZFZhbHVlKTtcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IE9iamVjdC5rZXlzKHlhbWxkZikubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dW5pcXVlS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcclxuXHRcdFx0XHRpZiAoeWFtbGRmW2ldW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0eWFtbGRmW2ldW2tleV0gPSBhY3R1YWxVbmRlZmluZWRWYWx1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHlhbWxkZjtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHdyaXRlTWV0YWRhdGFmcmFtZShqc0RGOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB9W10pIHtcclxuXHRcdGNvbnN0IHsgbnVsbFZhbHVlLCBkZWZhdWx0U2F2ZVBhdGggfSA9IHRoaXMuc2V0dGluZ3M7XHJcblx0XHRjb25zdCBkZWZhdWx0VmFsdWUgPSBudWxsVmFsdWU7XHJcblxyXG5cdFx0Y29uc3Qgb3B0cyA9IHsgZGVmYXVsdFZhbHVlLCB0cmFuc2Zvcm1zOiBbdHJhbnNmb3Jtcy5mbGF0dGVuKCldIH07XHJcblxyXG5cdFx0bGV0IGNzdiA9IFwiXCI7XHJcblx0XHR0cnkge1xyXG5cdFx0XHRjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdHMpO1xyXG5cdFx0XHRjc3YgPSBwYXJzZXIucGFyc2UoanNERik7XHJcblxyXG5cdFx0XHRpZiAoZGVmYXVsdFNhdmVQYXRoID09PSBcIlwiICYmIGNzdiAhPT0gXCJcIikge1xyXG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJQbGVhc2UgY2hvb3NlIGEgcGF0aCB0byBzYXZlIHRvIGluIHNldHRpbmdzXCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcImhlcmVcIik7XHJcblx0XHRcdFx0XHRjb25zdCBzYXZlUGF0aCA9IG5vcm1hbGl6ZVBhdGgoZGVmYXVsdFNhdmVQYXRoKTtcclxuXHRcdFx0XHRcdGNvbnN0IG5vdyA9IHdpbmRvdy5tb21lbnQoKS5mb3JtYXQoXCJZWVlZLU1NLUREIEhIbW1zc1wiKTtcclxuXHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoYCR7c2F2ZVBhdGh9ICR7bm93fS5jc3ZgLCBjc3YpO1xyXG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIldyaXRlIE1ldGFkYXRhZnJhbWUgY29tcGxldGVcIik7XHJcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcclxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJGaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcclxuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKFxyXG5cdFx0XHR7fSxcclxuXHRcdFx0REVGQVVMVF9TRVRUSU5HUyxcclxuXHRcdFx0YXdhaXQgdGhpcy5sb2FkRGF0YSgpXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xyXG5cdFx0YXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcclxuXHR9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgTW9kYWwgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IENoYXJ0IGZyb20gXCIuL0NvbXBvbmVudHMvQ2hhcnQuc3ZlbHRlXCI7XHJcbmltcG9ydCB0eXBlIERhdGFBbmFseXNpc1BsdWdpbiBmcm9tIFwiLi9tYWluXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgQ2hhcnRNb2RhbCBleHRlbmRzIE1vZGFsIHtcclxuXHRwbHVnaW46IERhdGFBbmFseXNpc1BsdWdpbjtcclxuXHRtb2RhbDogQ2hhcnRNb2RhbDtcclxuXHJcblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogRGF0YUFuYWx5c2lzUGx1Z2luKSB7XHJcblx0XHRzdXBlcihhcHApO1xyXG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcblx0XHR0aGlzLm1vZGFsID0gdGhpcztcclxuXHR9XHJcblxyXG5cdG9uT3BlbigpIHtcclxuXHRcdGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG5cdFx0Y29udGVudEVsLmVtcHR5KCk7XHJcblxyXG5cdFx0bmV3IENoYXJ0KHtcclxuXHRcdFx0dGFyZ2V0OiBjb250ZW50RWwsXHJcblx0XHRcdHByb3BzOiB7XHJcblx0XHRcdFx0bW9kYWw6IHRoaXMsXHJcblx0XHRcdH0sXHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdG9uQ2xvc2UoKSB7XHJcblx0XHR0aGlzLmNvbnRlbnRFbC5lbXB0eSgpO1xyXG5cdH1cclxufVxyXG4iLCAiZnVuY3Rpb24gbm9vcCgpIHsgfVxuY29uc3QgaWRlbnRpdHkgPSB4ID0+IHg7XG5mdW5jdGlvbiBhc3NpZ24odGFyLCBzcmMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZm9yIChjb25zdCBrIGluIHNyYylcbiAgICAgICAgdGFyW2tdID0gc3JjW2tdO1xuICAgIHJldHVybiB0YXI7XG59XG5mdW5jdGlvbiBpc19wcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBhZGRfbG9jYXRpb24oZWxlbWVudCwgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyKSB7XG4gICAgZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuICAgICAgICBsb2M6IHsgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcnVuKGZuKSB7XG4gICAgcmV0dXJuIGZuKCk7XG59XG5mdW5jdGlvbiBibGFua19vYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5mdW5jdGlvbiBydW5fYWxsKGZucykge1xuICAgIGZucy5mb3JFYWNoKHJ1bik7XG59XG5mdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGIgfHwgKChhICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JykgfHwgdHlwZW9mIGEgPT09ICdmdW5jdGlvbicpO1xufVxubGV0IHNyY191cmxfZXF1YWxfYW5jaG9yO1xuZnVuY3Rpb24gc3JjX3VybF9lcXVhbChlbGVtZW50X3NyYywgdXJsKSB7XG4gICAgaWYgKCFzcmNfdXJsX2VxdWFsX2FuY2hvcikge1xuICAgICAgICBzcmNfdXJsX2VxdWFsX2FuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB9XG4gICAgc3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZiA9IHVybDtcbiAgICByZXR1cm4gZWxlbWVudF9zcmMgPT09IHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWY7XG59XG5mdW5jdGlvbiBub3RfZXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiO1xufVxuZnVuY3Rpb24gaXNfZW1wdHkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfc3RvcmUoc3RvcmUsIG5hbWUpIHtcbiAgICBpZiAoc3RvcmUgIT0gbnVsbCAmJiB0eXBlb2Ygc3RvcmUuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJyR7bmFtZX0nIGlzIG5vdCBhIHN0b3JlIHdpdGggYSAnc3Vic2NyaWJlJyBtZXRob2RgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJzY3JpYmUoc3RvcmUsIC4uLmNhbGxiYWNrcykge1xuICAgIGlmIChzdG9yZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBjb25zdCB1bnN1YiA9IHN0b3JlLnN1YnNjcmliZSguLi5jYWxsYmFja3MpO1xuICAgIHJldHVybiB1bnN1Yi51bnN1YnNjcmliZSA/ICgpID0+IHVuc3ViLnVuc3Vic2NyaWJlKCkgOiB1bnN1Yjtcbn1cbmZ1bmN0aW9uIGdldF9zdG9yZV92YWx1ZShzdG9yZSkge1xuICAgIGxldCB2YWx1ZTtcbiAgICBzdWJzY3JpYmUoc3RvcmUsIF8gPT4gdmFsdWUgPSBfKSgpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbXBvbmVudF9zdWJzY3JpYmUoY29tcG9uZW50LCBzdG9yZSwgY2FsbGJhY2spIHtcbiAgICBjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKHN1YnNjcmliZShzdG9yZSwgY2FsbGJhY2spKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9zbG90KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBzbG90X2N0eCA9IGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbik7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uWzBdKHNsb3RfY3R4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICByZXR1cm4gZGVmaW5pdGlvblsxXSAmJiBmblxuICAgICAgICA/IGFzc2lnbigkJHNjb3BlLmN0eC5zbGljZSgpLCBkZWZpbml0aW9uWzFdKGZuKGN0eCkpKVxuICAgICAgICA6ICQkc2NvcGUuY3R4O1xufVxuZnVuY3Rpb24gZ2V0X3Nsb3RfY2hhbmdlcyhkZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvblsyXSAmJiBmbikge1xuICAgICAgICBjb25zdCBsZXRzID0gZGVmaW5pdGlvblsyXShmbihkaXJ0eSkpO1xuICAgICAgICBpZiAoJCRzY29wZS5kaXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxldHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWF4KCQkc2NvcGUuZGlydHkubGVuZ3RoLCBsZXRzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW2ldID0gJCRzY29wZS5kaXJ0eVtpXSB8IGxldHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkJHNjb3BlLmRpcnR5IHwgbGV0cztcbiAgICB9XG4gICAgcmV0dXJuICQkc2NvcGUuZGlydHk7XG59XG5mdW5jdGlvbiB1cGRhdGVfc2xvdF9iYXNlKHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBzbG90X2NoYW5nZXMsIGdldF9zbG90X2NvbnRleHRfZm4pIHtcbiAgICBpZiAoc2xvdF9jaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHNsb3RfY29udGV4dCA9IGdldF9zbG90X2NvbnRleHQoc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGdldF9zbG90X2NvbnRleHRfZm4pO1xuICAgICAgICBzbG90LnAoc2xvdF9jb250ZXh0LCBzbG90X2NoYW5nZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZV9zbG90KHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbiwgZ2V0X3Nsb3RfY29udGV4dF9mbikge1xuICAgIGNvbnN0IHNsb3RfY2hhbmdlcyA9IGdldF9zbG90X2NoYW5nZXMoc2xvdF9kZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbik7XG4gICAgdXBkYXRlX3Nsb3RfYmFzZShzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgc2xvdF9jaGFuZ2VzLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbn1cbmZ1bmN0aW9uIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSgkJHNjb3BlKSB7XG4gICAgaWYgKCQkc2NvcGUuY3R4Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIGNvbnN0IGRpcnR5ID0gW107XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9ICQkc2NvcGUuY3R4Lmxlbmd0aCAvIDMyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkaXJ0eVtpXSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJ0eTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZXhjbHVkZV9pbnRlcm5hbF9wcm9wcyhwcm9wcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBwcm9wcylcbiAgICAgICAgaWYgKGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3VsdFtrXSA9IHByb3BzW2tdO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlX3Jlc3RfcHJvcHMocHJvcHMsIGtleXMpIHtcbiAgICBjb25zdCByZXN0ID0ge307XG4gICAga2V5cyA9IG5ldyBTZXQoa2V5cyk7XG4gICAgZm9yIChjb25zdCBrIGluIHByb3BzKVxuICAgICAgICBpZiAoIWtleXMuaGFzKGspICYmIGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3Rba10gPSBwcm9wc1trXTtcbiAgICByZXR1cm4gcmVzdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVfc2xvdHMoc2xvdHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgICByZXN1bHRba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgbGV0IHJhbiA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBpZiAocmFuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICBmbi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICAgIH07XG59XG5mdW5jdGlvbiBudWxsX3RvX2VtcHR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0X3N0b3JlX3ZhbHVlKHN0b3JlLCByZXQsIHZhbHVlKSB7XG4gICAgc3RvcmUuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmV0O1xufVxuY29uc3QgaGFzX3Byb3AgPSAob2JqLCBwcm9wKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbmZ1bmN0aW9uIGFjdGlvbl9kZXN0cm95ZXIoYWN0aW9uX3Jlc3VsdCkge1xuICAgIHJldHVybiBhY3Rpb25fcmVzdWx0ICYmIGlzX2Z1bmN0aW9uKGFjdGlvbl9yZXN1bHQuZGVzdHJveSkgPyBhY3Rpb25fcmVzdWx0LmRlc3Ryb3kgOiBub29wO1xufVxuXG5jb25zdCBpc19jbGllbnQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmxldCBub3cgPSBpc19jbGllbnRcbiAgICA/ICgpID0+IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKVxuICAgIDogKCkgPT4gRGF0ZS5ub3coKTtcbmxldCByYWYgPSBpc19jbGllbnQgPyBjYiA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpIDogbm9vcDtcbi8vIHVzZWQgaW50ZXJuYWxseSBmb3IgdGVzdGluZ1xuZnVuY3Rpb24gc2V0X25vdyhmbikge1xuICAgIG5vdyA9IGZuO1xufVxuZnVuY3Rpb24gc2V0X3JhZihmbikge1xuICAgIHJhZiA9IGZuO1xufVxuXG5jb25zdCB0YXNrcyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHJ1bl90YXNrcyhub3cpIHtcbiAgICB0YXNrcy5mb3JFYWNoKHRhc2sgPT4ge1xuICAgICAgICBpZiAoIXRhc2suYyhub3cpKSB7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUodGFzayk7XG4gICAgICAgICAgICB0YXNrLmYoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0YXNrcy5zaXplICE9PSAwKVxuICAgICAgICByYWYocnVuX3Rhc2tzKTtcbn1cbi8qKlxuICogRm9yIHRlc3RpbmcgcHVycG9zZXMgb25seSFcbiAqL1xuZnVuY3Rpb24gY2xlYXJfbG9vcHMoKSB7XG4gICAgdGFza3MuY2xlYXIoKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0YXNrIHRoYXQgcnVucyBvbiBlYWNoIHJhZiBmcmFtZVxuICogdW50aWwgaXQgcmV0dXJucyBhIGZhbHN5IHZhbHVlIG9yIGlzIGFib3J0ZWRcbiAqL1xuZnVuY3Rpb24gbG9vcChjYWxsYmFjaykge1xuICAgIGxldCB0YXNrO1xuICAgIGlmICh0YXNrcy5zaXplID09PSAwKVxuICAgICAgICByYWYocnVuX3Rhc2tzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlOiBuZXcgUHJvbWlzZShmdWxmaWxsID0+IHtcbiAgICAgICAgICAgIHRhc2tzLmFkZCh0YXNrID0geyBjOiBjYWxsYmFjaywgZjogZnVsZmlsbCB9KTtcbiAgICAgICAgfSksXG4gICAgICAgIGFib3J0KCkge1xuICAgICAgICAgICAgdGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8gVHJhY2sgd2hpY2ggbm9kZXMgYXJlIGNsYWltZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVW5jbGFpbWVkIG5vZGVzIGNhbiB0aGVuIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NXG4vLyBhdCB0aGUgZW5kIG9mIGh5ZHJhdGlvbiB3aXRob3V0IHRvdWNoaW5nIHRoZSByZW1haW5pbmcgbm9kZXMuXG5sZXQgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG5mdW5jdGlvbiBzdGFydF9oeWRyYXRpbmcoKSB7XG4gICAgaXNfaHlkcmF0aW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVuZF9oeWRyYXRpbmcoKSB7XG4gICAgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG59XG5mdW5jdGlvbiB1cHBlcl9ib3VuZChsb3csIGhpZ2gsIGtleSwgdmFsdWUpIHtcbiAgICAvLyBSZXR1cm4gZmlyc3QgaW5kZXggb2YgdmFsdWUgbGFyZ2VyIHRoYW4gaW5wdXQgdmFsdWUgaW4gdGhlIHJhbmdlIFtsb3csIGhpZ2gpXG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgY29uc3QgbWlkID0gbG93ICsgKChoaWdoIC0gbG93KSA+PiAxKTtcbiAgICAgICAgaWYgKGtleShtaWQpIDw9IHZhbHVlKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG93O1xufVxuZnVuY3Rpb24gaW5pdF9oeWRyYXRlKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuaHlkcmF0ZV9pbml0KVxuICAgICAgICByZXR1cm47XG4gICAgdGFyZ2V0Lmh5ZHJhdGVfaW5pdCA9IHRydWU7XG4gICAgLy8gV2Uga25vdyB0aGF0IGFsbCBjaGlsZHJlbiBoYXZlIGNsYWltX29yZGVyIHZhbHVlcyBzaW5jZSB0aGUgdW5jbGFpbWVkIGhhdmUgYmVlbiBkZXRhY2hlZCBpZiB0YXJnZXQgaXMgbm90IDxoZWFkPlxuICAgIGxldCBjaGlsZHJlbiA9IHRhcmdldC5jaGlsZE5vZGVzO1xuICAgIC8vIElmIHRhcmdldCBpcyA8aGVhZD4sIHRoZXJlIG1heSBiZSBjaGlsZHJlbiB3aXRob3V0IGNsYWltX29yZGVyXG4gICAgaWYgKHRhcmdldC5ub2RlTmFtZSA9PT0gJ0hFQUQnKSB7XG4gICAgICAgIGNvbnN0IG15Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG15Q2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbiA9IG15Q2hpbGRyZW47XG4gICAgfVxuICAgIC8qXG4gICAgKiBSZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5LlxuICAgICogV2UgY2FuIHJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkgYnkgZmluZGluZyB0aGUgbG9uZ2VzdCBzdWJzZXF1ZW5jZSBvZlxuICAgICogbm9kZXMgdGhhdCBhcmUgYWxyZWFkeSBjbGFpbWVkIGluIG9yZGVyIGFuZCBvbmx5IG1vdmluZyB0aGUgcmVzdC4gVGhlIGxvbmdlc3RcbiAgICAqIHN1YnNlcXVlbmNlIHN1YnNlcXVlbmNlIG9mIG5vZGVzIHRoYXQgYXJlIGNsYWltZWQgaW4gb3JkZXIgY2FuIGJlIGZvdW5kIGJ5XG4gICAgKiBjb21wdXRpbmcgdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiAuY2xhaW1fb3JkZXIgdmFsdWVzLlxuICAgICpcbiAgICAqIFRoaXMgYWxnb3JpdGhtIGlzIG9wdGltYWwgaW4gZ2VuZXJhdGluZyB0aGUgbGVhc3QgYW1vdW50IG9mIHJlb3JkZXIgb3BlcmF0aW9uc1xuICAgICogcG9zc2libGUuXG4gICAgKlxuICAgICogUHJvb2Y6XG4gICAgKiBXZSBrbm93IHRoYXQsIGdpdmVuIGEgc2V0IG9mIHJlb3JkZXJpbmcgb3BlcmF0aW9ucywgdGhlIG5vZGVzIHRoYXQgZG8gbm90IG1vdmVcbiAgICAqIGFsd2F5cyBmb3JtIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2UsIHNpbmNlIHRoZXkgZG8gbm90IG1vdmUgYW1vbmcgZWFjaCBvdGhlclxuICAgICogbWVhbmluZyB0aGF0IHRoZXkgbXVzdCBiZSBhbHJlYWR5IG9yZGVyZWQgYW1vbmcgZWFjaCBvdGhlci4gVGh1cywgdGhlIG1heGltYWxcbiAgICAqIHNldCBvZiBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlIGZvcm0gYSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2UuXG4gICAgKi9cbiAgICAvLyBDb21wdXRlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuICAgIC8vIG06IHN1YnNlcXVlbmNlIGxlbmd0aCBqID0+IGluZGV4IGsgb2Ygc21hbGxlc3QgdmFsdWUgdGhhdCBlbmRzIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgbGVuZ3RoIGpcbiAgICBjb25zdCBtID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoICsgMSk7XG4gICAgLy8gUHJlZGVjZXNzb3IgaW5kaWNlcyArIDFcbiAgICBjb25zdCBwID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICBtWzBdID0gLTE7XG4gICAgbGV0IGxvbmdlc3QgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGNoaWxkcmVuW2ldLmNsYWltX29yZGVyO1xuICAgICAgICAvLyBGaW5kIHRoZSBsYXJnZXN0IHN1YnNlcXVlbmNlIGxlbmd0aCBzdWNoIHRoYXQgaXQgZW5kcyBpbiBhIHZhbHVlIGxlc3MgdGhhbiBvdXIgY3VycmVudCB2YWx1ZVxuICAgICAgICAvLyB1cHBlcl9ib3VuZCByZXR1cm5zIGZpcnN0IGdyZWF0ZXIgdmFsdWUsIHNvIHdlIHN1YnRyYWN0IG9uZVxuICAgICAgICAvLyB3aXRoIGZhc3QgcGF0aCBmb3Igd2hlbiB3ZSBhcmUgb24gdGhlIGN1cnJlbnQgbG9uZ2VzdCBzdWJzZXF1ZW5jZVxuICAgICAgICBjb25zdCBzZXFMZW4gPSAoKGxvbmdlc3QgPiAwICYmIGNoaWxkcmVuW21bbG9uZ2VzdF1dLmNsYWltX29yZGVyIDw9IGN1cnJlbnQpID8gbG9uZ2VzdCArIDEgOiB1cHBlcl9ib3VuZCgxLCBsb25nZXN0LCBpZHggPT4gY2hpbGRyZW5bbVtpZHhdXS5jbGFpbV9vcmRlciwgY3VycmVudCkpIC0gMTtcbiAgICAgICAgcFtpXSA9IG1bc2VxTGVuXSArIDE7XG4gICAgICAgIGNvbnN0IG5ld0xlbiA9IHNlcUxlbiArIDE7XG4gICAgICAgIC8vIFdlIGNhbiBndWFyYW50ZWUgdGhhdCBjdXJyZW50IGlzIHRoZSBzbWFsbGVzdCB2YWx1ZS4gT3RoZXJ3aXNlLCB3ZSB3b3VsZCBoYXZlIGdlbmVyYXRlZCBhIGxvbmdlciBzZXF1ZW5jZS5cbiAgICAgICAgbVtuZXdMZW5dID0gaTtcbiAgICAgICAgbG9uZ2VzdCA9IE1hdGgubWF4KG5ld0xlbiwgbG9uZ2VzdCk7XG4gICAgfVxuICAgIC8vIFRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgKGluaXRpYWxseSByZXZlcnNlZClcbiAgICBjb25zdCBsaXMgPSBbXTtcbiAgICAvLyBUaGUgcmVzdCBvZiB0aGUgbm9kZXMsIG5vZGVzIHRoYXQgd2lsbCBiZSBtb3ZlZFxuICAgIGNvbnN0IHRvTW92ZSA9IFtdO1xuICAgIGxldCBsYXN0ID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBjdXIgPSBtW2xvbmdlc3RdICsgMTsgY3VyICE9IDA7IGN1ciA9IHBbY3VyIC0gMV0pIHtcbiAgICAgICAgbGlzLnB1c2goY2hpbGRyZW5bY3VyIC0gMV0pO1xuICAgICAgICBmb3IgKDsgbGFzdCA+PSBjdXI7IGxhc3QtLSkge1xuICAgICAgICAgICAgdG9Nb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QtLTtcbiAgICB9XG4gICAgZm9yICg7IGxhc3QgPj0gMDsgbGFzdC0tKSB7XG4gICAgICAgIHRvTW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcbiAgICB9XG4gICAgbGlzLnJldmVyc2UoKTtcbiAgICAvLyBXZSBzb3J0IHRoZSBub2RlcyBiZWluZyBtb3ZlZCB0byBndWFyYW50ZWUgdGhhdCB0aGVpciBpbnNlcnRpb24gb3JkZXIgbWF0Y2hlcyB0aGUgY2xhaW0gb3JkZXJcbiAgICB0b01vdmUuc29ydCgoYSwgYikgPT4gYS5jbGFpbV9vcmRlciAtIGIuY2xhaW1fb3JkZXIpO1xuICAgIC8vIEZpbmFsbHksIHdlIG1vdmUgdGhlIG5vZGVzXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgdG9Nb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdoaWxlIChqIDwgbGlzLmxlbmd0aCAmJiB0b01vdmVbaV0uY2xhaW1fb3JkZXIgPj0gbGlzW2pdLmNsYWltX29yZGVyKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5jaG9yID0gaiA8IGxpcy5sZW5ndGggPyBsaXNbal0gOiBudWxsO1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHRvTW92ZVtpXSwgYW5jaG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xufVxuZnVuY3Rpb24gYXBwZW5kX3N0eWxlcyh0YXJnZXQsIHN0eWxlX3NoZWV0X2lkLCBzdHlsZXMpIHtcbiAgICBjb25zdCBhcHBlbmRfc3R5bGVzX3RvID0gZ2V0X3Jvb3RfZm9yX3N0eWxlKHRhcmdldCk7XG4gICAgaWYgKCFhcHBlbmRfc3R5bGVzX3RvLmdldEVsZW1lbnRCeUlkKHN0eWxlX3NoZWV0X2lkKSkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlLmlkID0gc3R5bGVfc2hlZXRfaWQ7XG4gICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gc3R5bGVzO1xuICAgICAgICBhcHBlbmRfc3R5bGVzaGVldChhcHBlbmRfc3R5bGVzX3RvLCBzdHlsZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICBjb25zdCByb290ID0gbm9kZS5nZXRSb290Tm9kZSA/IG5vZGUuZ2V0Um9vdE5vZGUoKSA6IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICBpZiAocm9vdCAmJiByb290Lmhvc3QpIHtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSB7XG4gICAgY29uc3Qgc3R5bGVfZWxlbWVudCA9IGVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgYXBwZW5kX3N0eWxlc2hlZXQoZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpLCBzdHlsZV9lbGVtZW50KTtcbiAgICByZXR1cm4gc3R5bGVfZWxlbWVudDtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9zdHlsZXNoZWV0KG5vZGUsIHN0eWxlKSB7XG4gICAgYXBwZW5kKG5vZGUuaGVhZCB8fCBub2RlLCBzdHlsZSk7XG59XG5mdW5jdGlvbiBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSkge1xuICAgIGlmIChpc19oeWRyYXRpbmcpIHtcbiAgICAgICAgaW5pdF9oeWRyYXRlKHRhcmdldCk7XG4gICAgICAgIGlmICgodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPT09IHVuZGVmaW5lZCkgfHwgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCkgJiYgKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLnBhcmVudEVsZW1lbnQgIT09IHRhcmdldCkpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNraXAgbm9kZXMgb2YgdW5kZWZpbmVkIG9yZGVyaW5nXG4gICAgICAgIHdoaWxlICgodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgIT09IG51bGwpICYmICh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5jbGFpbV9vcmRlciA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSAhPT0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpIHtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgaW5zZXJ0IGlmIHRoZSBvcmRlcmluZyBvZiB0aGlzIG5vZGUgc2hvdWxkIGJlIG1vZGlmaWVkIG9yIHRoZSBwYXJlbnQgbm9kZSBpcyBub3QgdGFyZ2V0XG4gICAgICAgICAgICBpZiAobm9kZS5jbGFpbV9vcmRlciAhPT0gdW5kZWZpbmVkIHx8IG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQgfHwgbm9kZS5uZXh0U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG59XG5mdW5jdGlvbiBpbnNlcnRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgaWYgKGlzX2h5ZHJhdGluZyAmJiAhYW5jaG9yKSB7XG4gICAgICAgIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQgfHwgbm9kZS5uZXh0U2libGluZyAhPSBhbmNob3IpIHtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoKG5vZGUpIHtcbiAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG59XG5mdW5jdGlvbiBkZXN0cm95X2VhY2goaXRlcmF0aW9ucywgZGV0YWNoaW5nKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChpdGVyYXRpb25zW2ldKVxuICAgICAgICAgICAgaXRlcmF0aW9uc1tpXS5kKGRldGFjaGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZWxlbWVudChuYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSk7XG59XG5mdW5jdGlvbiBlbGVtZW50X2lzKG5hbWUsIGlzKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSwgeyBpcyB9KTtcbn1cbmZ1bmN0aW9uIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMob2JqLCBleGNsdWRlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0ge307XG4gICAgZm9yIChjb25zdCBrIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzX3Byb3Aob2JqLCBrKVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgJiYgZXhjbHVkZS5pbmRleE9mKGspID09PSAtMSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGFyZ2V0W2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzdmdfZWxlbWVudChuYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIHRleHQoZGF0YSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhKTtcbn1cbmZ1bmN0aW9uIHNwYWNlKCkge1xuICAgIHJldHVybiB0ZXh0KCcgJyk7XG59XG5mdW5jdGlvbiBlbXB0eSgpIHtcbiAgICByZXR1cm4gdGV4dCgnJyk7XG59XG5mdW5jdGlvbiBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcHJldmVudF9kZWZhdWx0KGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc3RvcF9wcm9wYWdhdGlvbihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzZWxmKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpXG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdHJ1c3RlZChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZXZlbnQuaXNUcnVzdGVkKVxuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgIGVsc2UgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkgIT09IHZhbHVlKVxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNldF9hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhub2RlLl9fcHJvdG9fXyk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICBub2RlLnN0eWxlLmNzc1RleHQgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnX192YWx1ZScpIHtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVzY3JpcHRvcnNba2V5XSAmJiBkZXNjcmlwdG9yc1trZXldLnNldCkge1xuICAgICAgICAgICAgbm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfc3ZnX2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgYXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICBpZiAocHJvcCBpbiBub2RlKSB7XG4gICAgICAgIG5vZGVbcHJvcF0gPSB0eXBlb2Ygbm9kZVtwcm9wXSA9PT0gJ2Jvb2xlYW4nICYmIHZhbHVlID09PSAnJyA/IHRydWUgOiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF0dHIobm9kZSwgcHJvcCwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHhsaW5rX2F0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGdyb3VwLCBfX3ZhbHVlLCBjaGVja2VkKSB7XG4gICAgY29uc3QgdmFsdWUgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoZ3JvdXBbaV0uY2hlY2tlZClcbiAgICAgICAgICAgIHZhbHVlLmFkZChncm91cFtpXS5fX3ZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCFjaGVja2VkKSB7XG4gICAgICAgIHZhbHVlLmRlbGV0ZShfX3ZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xufVxuZnVuY3Rpb24gdG9fbnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAnJyA/IG51bGwgOiArdmFsdWU7XG59XG5mdW5jdGlvbiB0aW1lX3Jhbmdlc190b19hcnJheShyYW5nZXMpIHtcbiAgICBjb25zdCBhcnJheSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGFycmF5LnB1c2goeyBzdGFydDogcmFuZ2VzLnN0YXJ0KGkpLCBlbmQ6IHJhbmdlcy5lbmQoaSkgfSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpO1xufVxuZnVuY3Rpb24gaW5pdF9jbGFpbV9pbmZvKG5vZGVzKSB7XG4gICAgaWYgKG5vZGVzLmNsYWltX2luZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2Rlcy5jbGFpbV9pbmZvID0geyBsYXN0X2luZGV4OiAwLCB0b3RhbF9jbGFpbWVkOiAwIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY2xhaW1fbm9kZShub2RlcywgcHJlZGljYXRlLCBwcm9jZXNzTm9kZSwgY3JlYXRlTm9kZSwgZG9udFVwZGF0ZUxhc3RJbmRleCA9IGZhbHNlKSB7XG4gICAgLy8gVHJ5IHRvIGZpbmQgbm9kZXMgaW4gYW4gb3JkZXIgc3VjaCB0aGF0IHdlIGxlbmd0aGVuIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2VcbiAgICBpbml0X2NsYWltX2luZm8obm9kZXMpO1xuICAgIGNvbnN0IHJlc3VsdE5vZGUgPSAoKCkgPT4ge1xuICAgICAgICAvLyBXZSBmaXJzdCB0cnkgdG8gZmluZCBhbiBlbGVtZW50IGFmdGVyIHRoZSBwcmV2aW91cyBvbmVcbiAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRvbnRVcGRhdGVMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSB0cnkgdG8gZmluZCBvbmUgYmVmb3JlXG4gICAgICAgIC8vIFdlIGl0ZXJhdGUgaW4gcmV2ZXJzZSBzbyB0aGF0IHdlIGRvbid0IGdvIHRvbyBmYXIgYmFja1xuICAgICAgICBmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHByb2Nlc3NOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZG9udFVwZGF0ZUxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHdlIHNwbGljZWQgYmVmb3JlIHRoZSBsYXN0X2luZGV4LCB3ZSBkZWNyZWFzZSBpdFxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgY2FuJ3QgZmluZCBhbnkgbWF0Y2hpbmcgbm9kZSwgd2UgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICByZXR1cm4gY3JlYXRlTm9kZSgpO1xuICAgIH0pKCk7XG4gICAgcmVzdWx0Tm9kZS5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcbiAgICBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcbiAgICByZXR1cm4gcmVzdWx0Tm9kZTtcbn1cbmZ1bmN0aW9uIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgY3JlYXRlX2VsZW1lbnQpIHtcbiAgICByZXR1cm4gY2xhaW1fbm9kZShub2RlcywgKG5vZGUpID0+IG5vZGUubm9kZU5hbWUgPT09IG5hbWUsIChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlbW92ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlID0gbm9kZS5hdHRyaWJ1dGVzW2pdO1xuICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzW2F0dHJpYnV0ZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZS5wdXNoKGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW1vdmUuZm9yRWFjaCh2ID0+IG5vZGUucmVtb3ZlQXR0cmlidXRlKHYpKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LCAoKSA9PiBjcmVhdGVfZWxlbWVudChuYW1lKSk7XG59XG5mdW5jdGlvbiBjbGFpbV9lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgZWxlbWVudCk7XG59XG5mdW5jdGlvbiBjbGFpbV9zdmdfZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIHN2Z19lbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGNsYWltX3RleHQobm9kZXMsIGRhdGEpIHtcbiAgICByZXR1cm4gY2xhaW1fbm9kZShub2RlcywgKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDMsIChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGFTdHIgPSAnJyArIGRhdGE7XG4gICAgICAgIGlmIChub2RlLmRhdGEuc3RhcnRzV2l0aChkYXRhU3RyKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuZGF0YS5sZW5ndGggIT09IGRhdGFTdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3BsaXRUZXh0KGRhdGFTdHIubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IGRhdGFTdHI7XG4gICAgICAgIH1cbiAgICB9LCAoKSA9PiB0ZXh0KGRhdGEpLCB0cnVlIC8vIFRleHQgbm9kZXMgc2hvdWxkIG5vdCB1cGRhdGUgbGFzdCBpbmRleCBzaW5jZSBpdCBpcyBsaWtlbHkgbm90IHdvcnRoIGl0IHRvIGVsaW1pbmF0ZSBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIGFjdHVhbCBlbGVtZW50c1xuICAgICk7XG59XG5mdW5jdGlvbiBjbGFpbV9zcGFjZShub2Rlcykge1xuICAgIHJldHVybiBjbGFpbV90ZXh0KG5vZGVzLCAnICcpO1xufVxuZnVuY3Rpb24gZmluZF9jb21tZW50KG5vZGVzLCB0ZXh0LCBzdGFydCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogY29tbWVudCBub2RlICovICYmIG5vZGUudGV4dENvbnRlbnQudHJpbSgpID09PSB0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gY2xhaW1faHRtbF90YWcobm9kZXMpIHtcbiAgICAvLyBmaW5kIGh0bWwgb3BlbmluZyB0YWdcbiAgICBjb25zdCBzdGFydF9pbmRleCA9IGZpbmRfY29tbWVudChub2RlcywgJ0hUTUxfVEFHX1NUQVJUJywgMCk7XG4gICAgY29uc3QgZW5kX2luZGV4ID0gZmluZF9jb21tZW50KG5vZGVzLCAnSFRNTF9UQUdfRU5EJywgc3RhcnRfaW5kZXgpO1xuICAgIGlmIChzdGFydF9pbmRleCA9PT0gZW5kX2luZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbigpO1xuICAgIH1cbiAgICBpbml0X2NsYWltX2luZm8obm9kZXMpO1xuICAgIGNvbnN0IGh0bWxfdGFnX25vZGVzID0gbm9kZXMuc3BsaWNlKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXggKyAxKTtcbiAgICBkZXRhY2goaHRtbF90YWdfbm9kZXNbMF0pO1xuICAgIGRldGFjaChodG1sX3RhZ19ub2Rlc1todG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxXSk7XG4gICAgY29uc3QgY2xhaW1lZF9ub2RlcyA9IGh0bWxfdGFnX25vZGVzLnNsaWNlKDEsIGh0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDEpO1xuICAgIGZvciAoY29uc3QgbiBvZiBjbGFpbWVkX25vZGVzKSB7XG4gICAgICAgIG4uY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG4gICAgICAgIG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24oY2xhaW1lZF9ub2Rlcyk7XG59XG5mdW5jdGlvbiBzZXRfZGF0YSh0ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgICBpZiAodGV4dC53aG9sZVRleHQgIT09IGRhdGEpXG4gICAgICAgIHRleHQuZGF0YSA9IGRhdGE7XG59XG5mdW5jdGlvbiBzZXRfaW5wdXRfdmFsdWUoaW5wdXQsIHZhbHVlKSB7XG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldF9pbnB1dF90eXBlKGlucHV0LCB0eXBlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaW5wdXQudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfc3R5bGUobm9kZSwga2V5LCB2YWx1ZSwgaW1wb3J0YW50KSB7XG4gICAgbm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlLCBpbXBvcnRhbnQgPyAnaW1wb3J0YW50JyA6ICcnKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdF9vcHRpb24oc2VsZWN0LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIGlmIChvcHRpb24uX192YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0LnNlbGVjdGVkSW5kZXggPSAtMTsgLy8gbm8gb3B0aW9uIHNob3VsZCBiZSBzZWxlY3RlZFxufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbnMoc2VsZWN0LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IH52YWx1ZS5pbmRleE9mKG9wdGlvbi5fX3ZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3RfdmFsdWUoc2VsZWN0KSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRfb3B0aW9uID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJykgfHwgc2VsZWN0Lm9wdGlvbnNbMF07XG4gICAgcmV0dXJuIHNlbGVjdGVkX29wdGlvbiAmJiBzZWxlY3RlZF9vcHRpb24uX192YWx1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdF9tdWx0aXBsZV92YWx1ZShzZWxlY3QpIHtcbiAgICByZXR1cm4gW10ubWFwLmNhbGwoc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJzpjaGVja2VkJyksIG9wdGlvbiA9PiBvcHRpb24uX192YWx1ZSk7XG59XG4vLyB1bmZvcnR1bmF0ZWx5IHRoaXMgY2FuJ3QgYmUgYSBjb25zdGFudCBhcyB0aGF0IHdvdWxkbid0IGJlIHRyZWUtc2hha2VhYmxlXG4vLyBzbyB3ZSBjYWNoZSB0aGUgcmVzdWx0IGluc3RlYWRcbmxldCBjcm9zc29yaWdpbjtcbmZ1bmN0aW9uIGlzX2Nyb3Nzb3JpZ2luKCkge1xuICAgIGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNyb3Nzb3JpZ2luID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHZvaWQgd2luZG93LnBhcmVudC5kb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NvcmlnaW47XG59XG5mdW5jdGlvbiBhZGRfcmVzaXplX2xpc3RlbmVyKG5vZGUsIGZuKSB7XG4gICAgY29uc3QgY29tcHV0ZWRfc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGlmIChjb21wdXRlZF9zdHlsZS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgfVxuICAgIGNvbnN0IGlmcmFtZSA9IGVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgJyArXG4gICAgICAgICdvdmVyZmxvdzogaGlkZGVuOyBib3JkZXI6IDA7IG9wYWNpdHk6IDA7IHBvaW50ZXItZXZlbnRzOiBub25lOyB6LWluZGV4OiAtMTsnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgaWZyYW1lLnRhYkluZGV4ID0gLTE7XG4gICAgY29uc3QgY3Jvc3NvcmlnaW4gPSBpc19jcm9zc29yaWdpbigpO1xuICAgIGxldCB1bnN1YnNjcmliZTtcbiAgICBpZiAoY3Jvc3NvcmlnaW4pIHtcbiAgICAgICAgaWZyYW1lLnNyYyA9IFwiZGF0YTp0ZXh0L2h0bWwsPHNjcmlwdD5vbnJlc2l6ZT1mdW5jdGlvbigpe3BhcmVudC5wb3N0TWVzc2FnZSgwLCcqJyl9PC9zY3JpcHQ+XCI7XG4gICAgICAgIHVuc3Vic2NyaWJlID0gbGlzdGVuKHdpbmRvdywgJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGlmcmFtZS5jb250ZW50V2luZG93KVxuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG4gICAgICAgIGlmcmFtZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGxpc3RlbihpZnJhbWUuY29udGVudFdpbmRvdywgJ3Jlc2l6ZScsIGZuKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXBwZW5kKG5vZGUsIGlmcmFtZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGNyb3Nzb3JpZ2luKSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuc3Vic2NyaWJlICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGRldGFjaChpZnJhbWUpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0b2dnbGVfY2xhc3MoZWxlbWVudCwgbmFtZSwgdG9nZ2xlKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3RbdG9nZ2xlID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG59XG5mdW5jdGlvbiBjdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsLCBidWJibGVzID0gZmFsc2UpIHtcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgZS5pbml0Q3VzdG9tRXZlbnQodHlwZSwgYnViYmxlcywgZmFsc2UsIGRldGFpbCk7XG4gICAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBxdWVyeV9zZWxlY3Rvcl9hbGwoc2VsZWN0b3IsIHBhcmVudCA9IGRvY3VtZW50LmJvZHkpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xufVxuY2xhc3MgSHRtbFRhZyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG4gICAgfVxuICAgIGMoaHRtbCkge1xuICAgICAgICB0aGlzLmgoaHRtbCk7XG4gICAgfVxuICAgIG0oaHRtbCwgdGFyZ2V0LCBhbmNob3IgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5lKSB7XG4gICAgICAgICAgICB0aGlzLmUgPSBlbGVtZW50KHRhcmdldC5ub2RlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLnQgPSB0YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmMoaHRtbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pKGFuY2hvcik7XG4gICAgfVxuICAgIGgoaHRtbCkge1xuICAgICAgICB0aGlzLmUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgdGhpcy5uID0gQXJyYXkuZnJvbSh0aGlzLmUuY2hpbGROb2Rlcyk7XG4gICAgfVxuICAgIGkoYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbnNlcnQodGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcChodG1sKSB7XG4gICAgICAgIHRoaXMuZCgpO1xuICAgICAgICB0aGlzLmgoaHRtbCk7XG4gICAgICAgIHRoaXMuaSh0aGlzLmEpO1xuICAgIH1cbiAgICBkKCkge1xuICAgICAgICB0aGlzLm4uZm9yRWFjaChkZXRhY2gpO1xuICAgIH1cbn1cbmNsYXNzIEh0bWxUYWdIeWRyYXRpb24gZXh0ZW5kcyBIdG1sVGFnIHtcbiAgICBjb25zdHJ1Y3RvcihjbGFpbWVkX25vZGVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG4gICAgICAgIHRoaXMubCA9IGNsYWltZWRfbm9kZXM7XG4gICAgfVxuICAgIGMoaHRtbCkge1xuICAgICAgICBpZiAodGhpcy5sKSB7XG4gICAgICAgICAgICB0aGlzLm4gPSB0aGlzLmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5jKGh0bWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGkoYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbnNlcnRfaHlkcmF0aW9uKHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXR0cmlidXRlX3RvX29iamVjdChhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xuICAgICAgICByZXN1bHRbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyhlbGVtZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgcmVzdWx0W25vZGUuc2xvdCB8fCAnZGVmYXVsdCddID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBhY3RpdmVfZG9jcyA9IG5ldyBTZXQoKTtcbmxldCBhY3RpdmUgPSAwO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2gvYmxvYi9tYXN0ZXIvaW5kZXguanNcbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gICAgbGV0IGhhc2ggPSA1MzgxO1xuICAgIGxldCBpID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgXiBzdHIuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gaGFzaCA+Pj4gMDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9ydWxlKG5vZGUsIGEsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzZSwgZm4sIHVpZCA9IDApIHtcbiAgICBjb25zdCBzdGVwID0gMTYuNjY2IC8gZHVyYXRpb247XG4gICAgbGV0IGtleWZyYW1lcyA9ICd7XFxuJztcbiAgICBmb3IgKGxldCBwID0gMDsgcCA8PSAxOyBwICs9IHN0ZXApIHtcbiAgICAgICAgY29uc3QgdCA9IGEgKyAoYiAtIGEpICogZWFzZShwKTtcbiAgICAgICAga2V5ZnJhbWVzICs9IHAgKiAxMDAgKyBgJXske2ZuKHQsIDEgLSB0KX19XFxuYDtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IGtleWZyYW1lcyArIGAxMDAlIHske2ZuKGIsIDEgLSBiKX19XFxufWA7XG4gICAgY29uc3QgbmFtZSA9IGBfX3N2ZWx0ZV8ke2hhc2gocnVsZSl9XyR7dWlkfWA7XG4gICAgY29uc3QgZG9jID0gZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpO1xuICAgIGFjdGl2ZV9kb2NzLmFkZChkb2MpO1xuICAgIGNvbnN0IHN0eWxlc2hlZXQgPSBkb2MuX19zdmVsdGVfc3R5bGVzaGVldCB8fCAoZG9jLl9fc3ZlbHRlX3N0eWxlc2hlZXQgPSBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKS5zaGVldCk7XG4gICAgY29uc3QgY3VycmVudF9ydWxlcyA9IGRvYy5fX3N2ZWx0ZV9ydWxlcyB8fCAoZG9jLl9fc3ZlbHRlX3J1bGVzID0ge30pO1xuICAgIGlmICghY3VycmVudF9ydWxlc1tuYW1lXSkge1xuICAgICAgICBjdXJyZW50X3J1bGVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgc3R5bGVzaGVldC5pbnNlcnRSdWxlKGBAa2V5ZnJhbWVzICR7bmFtZX0gJHtydWxlfWAsIHN0eWxlc2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9uID0gbm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJyc7XG4gICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBgJHthbmltYXRpb24gPyBgJHthbmltYXRpb259LCBgIDogJyd9JHtuYW1lfSAke2R1cmF0aW9ufW1zIGxpbmVhciAke2RlbGF5fW1zIDEgYm90aGA7XG4gICAgYWN0aXZlICs9IDE7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiBkZWxldGVfcnVsZShub2RlLCBuYW1lKSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSAobm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIGNvbnN0IG5leHQgPSBwcmV2aW91cy5maWx0ZXIobmFtZVxuICAgICAgICA/IGFuaW0gPT4gYW5pbS5pbmRleE9mKG5hbWUpIDwgMCAvLyByZW1vdmUgc3BlY2lmaWMgYW5pbWF0aW9uXG4gICAgICAgIDogYW5pbSA9PiBhbmltLmluZGV4T2YoJ19fc3ZlbHRlJykgPT09IC0xIC8vIHJlbW92ZSBhbGwgU3ZlbHRlIGFuaW1hdGlvbnNcbiAgICApO1xuICAgIGNvbnN0IGRlbGV0ZWQgPSBwcmV2aW91cy5sZW5ndGggLSBuZXh0Lmxlbmd0aDtcbiAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICBub2RlLnN0eWxlLmFuaW1hdGlvbiA9IG5leHQuam9pbignLCAnKTtcbiAgICAgICAgYWN0aXZlIC09IGRlbGV0ZWQ7XG4gICAgICAgIGlmICghYWN0aXZlKVxuICAgICAgICAgICAgY2xlYXJfcnVsZXMoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGVhcl9ydWxlcygpIHtcbiAgICByYWYoKCkgPT4ge1xuICAgICAgICBpZiAoYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBhY3RpdmVfZG9jcy5mb3JFYWNoKGRvYyA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZXNoZWV0ID0gZG9jLl9fc3ZlbHRlX3N0eWxlc2hlZXQ7XG4gICAgICAgICAgICBsZXQgaSA9IHN0eWxlc2hlZXQuY3NzUnVsZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0LmRlbGV0ZVJ1bGUoaSk7XG4gICAgICAgICAgICBkb2MuX19zdmVsdGVfcnVsZXMgPSB7fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFjdGl2ZV9kb2NzLmNsZWFyKCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9hbmltYXRpb24obm9kZSwgZnJvbSwgZm4sIHBhcmFtcykge1xuICAgIGlmICghZnJvbSlcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgY29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChmcm9tLmxlZnQgPT09IHRvLmxlZnQgJiYgZnJvbS5yaWdodCA9PT0gdG8ucmlnaHQgJiYgZnJvbS50b3AgPT09IHRvLnRvcCAmJiBmcm9tLmJvdHRvbSA9PT0gdG8uYm90dG9tKVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCBcbiAgICAvLyBAdHMtaWdub3JlIHRvZG86IHNob3VsZCB0aGlzIGJlIHNlcGFyYXRlZCBmcm9tIGRlc3RydWN0dXJpbmc/IE9yIHN0YXJ0L2VuZCBhZGRlZCB0byBwdWJsaWMgYXBpIGFuZCBkb2N1bWVudGF0aW9uP1xuICAgIHN0YXJ0OiBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheSwgXG4gICAgLy8gQHRzLWlnbm9yZSB0b2RvOlxuICAgIGVuZCA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbiwgdGljayA9IG5vb3AsIGNzcyB9ID0gZm4obm9kZSwgeyBmcm9tLCB0byB9LCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBuYW1lO1xuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICBuYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWxheSkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpO1xuICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgaWYgKCFzdGFydGVkICYmIG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRlZCAmJiBub3cgPj0gZW5kKSB7XG4gICAgICAgICAgICB0aWNrKDEsIDApO1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gbm93IC0gc3RhcnRfdGltZTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSAwICsgMSAqIGVhc2luZyhwIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgc3RhcnQoKTtcbiAgICB0aWNrKDAsIDEpO1xuICAgIHJldHVybiBzdG9wO1xufVxuZnVuY3Rpb24gZml4X3Bvc2l0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgaWYgKHN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHN0eWxlLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc3R5bGU7XG4gICAgICAgIGNvbnN0IGEgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYWRkX3RyYW5zZm9ybShub2RlLCBhKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRfdHJhbnNmb3JtKG5vZGUsIGEpIHtcbiAgICBjb25zdCBiID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoYS5sZWZ0ICE9PSBiLmxlZnQgfHwgYS50b3AgIT09IGIudG9wKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBgJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke2EubGVmdCAtIGIubGVmdH1weCwgJHthLnRvcCAtIGIudG9wfXB4KWA7XG4gICAgfVxufVxuXG5sZXQgY3VycmVudF9jb21wb25lbnQ7XG5mdW5jdGlvbiBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgY3VycmVudF9jb21wb25lbnQgPSBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiBnZXRfY3VycmVudF9jb21wb25lbnQoKSB7XG4gICAgaWYgKCFjdXJyZW50X2NvbXBvbmVudClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjYWxsZWQgb3V0c2lkZSBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24nKTtcbiAgICByZXR1cm4gY3VycmVudF9jb21wb25lbnQ7XG59XG5mdW5jdGlvbiBiZWZvcmVVcGRhdGUoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5iZWZvcmVfdXBkYXRlLnB1c2goZm4pO1xufVxuZnVuY3Rpb24gb25Nb3VudChmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX21vdW50LnB1c2goZm4pO1xufVxuZnVuY3Rpb24gYWZ0ZXJVcGRhdGUoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5hZnRlcl91cGRhdGUucHVzaChmbik7XG59XG5mdW5jdGlvbiBvbkRlc3Ryb3koZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9kZXN0cm95LnB1c2goZm4pO1xufVxuZnVuY3Rpb24gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuICAgIHJldHVybiAodHlwZSwgZGV0YWlsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbdHlwZV07XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gYXJlIHRoZXJlIHNpdHVhdGlvbnMgd2hlcmUgZXZlbnRzIGNvdWxkIGJlIGRpc3BhdGNoZWRcbiAgICAgICAgICAgIC8vIGluIGEgc2VydmVyIChub24tRE9NKSBlbnZpcm9ubWVudD9cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCk7XG4gICAgICAgICAgICBjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKGZuID0+IHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGNvbXBvbmVudCwgZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gc2V0Q29udGV4dChrZXksIGNvbnRleHQpIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LnNldChrZXksIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gZ2V0Q29udGV4dChrZXkpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5nZXQoa2V5KTtcbn1cbmZ1bmN0aW9uIGdldEFsbENvbnRleHRzKCkge1xuICAgIHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0O1xufVxuZnVuY3Rpb24gaGFzQ29udGV4dChrZXkpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5oYXMoa2V5KTtcbn1cbi8vIFRPRE8gZmlndXJlIG91dCBpZiB3ZSBzdGlsbCB3YW50IHRvIHN1cHBvcnRcbi8vIHNob3J0aGFuZCBldmVudHMsIG9yIGlmIHdlIHdhbnQgdG8gaW1wbGVtZW50XG4vLyBhIHJlYWwgYnViYmxpbmcgbWVjaGFuaXNtXG5mdW5jdGlvbiBidWJibGUoY29tcG9uZW50LCBldmVudCkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbZXZlbnQudHlwZV07XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4gZm4uY2FsbCh0aGlzLCBldmVudCkpO1xuICAgIH1cbn1cblxuY29uc3QgZGlydHlfY29tcG9uZW50cyA9IFtdO1xuY29uc3QgaW50cm9zID0geyBlbmFibGVkOiBmYWxzZSB9O1xuY29uc3QgYmluZGluZ19jYWxsYmFja3MgPSBbXTtcbmNvbnN0IHJlbmRlcl9jYWxsYmFja3MgPSBbXTtcbmNvbnN0IGZsdXNoX2NhbGxiYWNrcyA9IFtdO1xuY29uc3QgcmVzb2x2ZWRfcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xubGV0IHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIHNjaGVkdWxlX3VwZGF0ZSgpIHtcbiAgICBpZiAoIXVwZGF0ZV9zY2hlZHVsZWQpIHtcbiAgICAgICAgdXBkYXRlX3NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmVkX3Byb21pc2UudGhlbihmbHVzaCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdGljaygpIHtcbiAgICBzY2hlZHVsZV91cGRhdGUoKTtcbiAgICByZXR1cm4gcmVzb2x2ZWRfcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGFkZF9yZW5kZXJfY2FsbGJhY2soZm4pIHtcbiAgICByZW5kZXJfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuZnVuY3Rpb24gYWRkX2ZsdXNoX2NhbGxiYWNrKGZuKSB7XG4gICAgZmx1c2hfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuLy8gZmx1c2goKSBjYWxscyBjYWxsYmFja3MgaW4gdGhpcyBvcmRlcjpcbi8vIDEuIEFsbCBiZWZvcmVVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW5cbi8vIDIuIEFsbCBiaW5kOnRoaXMgY2FsbGJhY2tzLCBpbiByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIDMuIEFsbCBhZnRlclVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlbi4gRVhDRVBUXG4vLyAgICBmb3IgYWZ0ZXJVcGRhdGVzIGNhbGxlZCBkdXJpbmcgdGhlIGluaXRpYWwgb25Nb3VudCwgd2hpY2ggYXJlIGNhbGxlZCBpblxuLy8gICAgcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyBTaW5jZSBjYWxsYmFja3MgbWlnaHQgdXBkYXRlIGNvbXBvbmVudCB2YWx1ZXMsIHdoaWNoIGNvdWxkIHRyaWdnZXIgYW5vdGhlclxuLy8gY2FsbCB0byBmbHVzaCgpLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGd1YXJkIGFnYWluc3QgdGhpczpcbi8vIDEuIER1cmluZyBiZWZvcmVVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBiZSBhZGRlZCB0byB0aGVcbi8vICAgIGRpcnR5X2NvbXBvbmVudHMgYXJyYXkgYW5kIHdpbGwgY2F1c2UgYSByZWVudHJhbnQgY2FsbCB0byBmbHVzaCgpLiBCZWNhdXNlXG4vLyAgICB0aGUgZmx1c2ggaW5kZXggaXMga2VwdCBvdXRzaWRlIHRoZSBmdW5jdGlvbiwgdGhlIHJlZW50cmFudCBjYWxsIHdpbGwgcGlja1xuLy8gICAgdXAgd2hlcmUgdGhlIGVhcmxpZXIgY2FsbCBsZWZ0IG9mZiBhbmQgZ28gdGhyb3VnaCBhbGwgZGlydHkgY29tcG9uZW50cy4gVGhlXG4vLyAgICBjdXJyZW50X2NvbXBvbmVudCB2YWx1ZSBpcyBzYXZlZCBhbmQgcmVzdG9yZWQgc28gdGhhdCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbFxuLy8gICAgbm90IGludGVyZmVyZSB3aXRoIHRoZSBcInBhcmVudFwiIGZsdXNoKCkgY2FsbC5cbi8vIDIuIGJpbmQ6dGhpcyBjYWxsYmFja3MgY2Fubm90IHRyaWdnZXIgbmV3IGZsdXNoKCkgY2FsbHMuXG4vLyAzLiBEdXJpbmcgYWZ0ZXJVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBOT1QgaGF2ZSB0aGVpciBhZnRlclVwZGF0ZVxuLy8gICAgY2FsbGJhY2sgY2FsbGVkIGEgc2Vjb25kIHRpbWU7IHRoZSBzZWVuX2NhbGxiYWNrcyBzZXQsIG91dHNpZGUgdGhlIGZsdXNoKClcbi8vICAgIGZ1bmN0aW9uLCBndWFyYW50ZWVzIHRoaXMgYmVoYXZpb3IuXG5jb25zdCBzZWVuX2NhbGxiYWNrcyA9IG5ldyBTZXQoKTtcbmxldCBmbHVzaGlkeCA9IDA7IC8vIERvICpub3QqIG1vdmUgdGhpcyBpbnNpZGUgdGhlIGZsdXNoKCkgZnVuY3Rpb25cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIGNvbnN0IHNhdmVkX2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgIGRvIHtcbiAgICAgICAgLy8gZmlyc3QsIGNhbGwgYmVmb3JlVXBkYXRlIGZ1bmN0aW9uc1xuICAgICAgICAvLyBhbmQgdXBkYXRlIGNvbXBvbmVudHNcbiAgICAgICAgd2hpbGUgKGZsdXNoaWR4IDwgZGlydHlfY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGRpcnR5X2NvbXBvbmVudHNbZmx1c2hpZHhdO1xuICAgICAgICAgICAgZmx1c2hpZHgrKztcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGNvbXBvbmVudC4kJCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIGZsdXNoaWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKGJpbmRpbmdfY2FsbGJhY2tzLmxlbmd0aClcbiAgICAgICAgICAgIGJpbmRpbmdfY2FsbGJhY2tzLnBvcCgpKCk7XG4gICAgICAgIC8vIHRoZW4sIG9uY2UgY29tcG9uZW50cyBhcmUgdXBkYXRlZCwgY2FsbFxuICAgICAgICAvLyBhZnRlclVwZGF0ZSBmdW5jdGlvbnMuIFRoaXMgbWF5IGNhdXNlXG4gICAgICAgIC8vIHN1YnNlcXVlbnQgdXBkYXRlcy4uLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gcmVuZGVyX2NhbGxiYWNrc1tpXTtcbiAgICAgICAgICAgIGlmICghc2Vlbl9jYWxsYmFja3MuaGFzKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIC8vIC4uLnNvIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgbG9vcHNcbiAgICAgICAgICAgICAgICBzZWVuX2NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIH0gd2hpbGUgKGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKTtcbiAgICB3aGlsZSAoZmx1c2hfY2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICBmbHVzaF9jYWxsYmFja3MucG9wKCkoKTtcbiAgICB9XG4gICAgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHNlZW5fY2FsbGJhY2tzLmNsZWFyKCk7XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHNhdmVkX2NvbXBvbmVudCk7XG59XG5mdW5jdGlvbiB1cGRhdGUoJCQpIHtcbiAgICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgJCQudXBkYXRlKCk7XG4gICAgICAgIHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG4gICAgICAgIGNvbnN0IGRpcnR5ID0gJCQuZGlydHk7XG4gICAgICAgICQkLmRpcnR5ID0gWy0xXTtcbiAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQucCgkJC5jdHgsIGRpcnR5KTtcbiAgICAgICAgJCQuYWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG4gICAgfVxufVxuXG5sZXQgcHJvbWlzZTtcbmZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgaWYgKCFwcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgcHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBkaXNwYXRjaChub2RlLCBkaXJlY3Rpb24sIGtpbmQpIHtcbiAgICBub2RlLmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KGAke2RpcmVjdGlvbiA/ICdpbnRybycgOiAnb3V0cm8nfSR7a2luZH1gKSk7XG59XG5jb25zdCBvdXRyb2luZyA9IG5ldyBTZXQoKTtcbmxldCBvdXRyb3M7XG5mdW5jdGlvbiBncm91cF9vdXRyb3MoKSB7XG4gICAgb3V0cm9zID0ge1xuICAgICAgICByOiAwLFxuICAgICAgICBjOiBbXSxcbiAgICAgICAgcDogb3V0cm9zIC8vIHBhcmVudCBncm91cFxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja19vdXRyb3MoKSB7XG4gICAgaWYgKCFvdXRyb3Mucikge1xuICAgICAgICBydW5fYWxsKG91dHJvcy5jKTtcbiAgICB9XG4gICAgb3V0cm9zID0gb3V0cm9zLnA7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uX2luKGJsb2NrLCBsb2NhbCkge1xuICAgIGlmIChibG9jayAmJiBibG9jay5pKSB7XG4gICAgICAgIG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG4gICAgICAgIGJsb2NrLmkobG9jYWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25fb3V0KGJsb2NrLCBsb2NhbCwgZGV0YWNoLCBjYWxsYmFjaykge1xuICAgIGlmIChibG9jayAmJiBibG9jay5vKSB7XG4gICAgICAgIGlmIChvdXRyb2luZy5oYXMoYmxvY2spKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvdXRyb2luZy5hZGQoYmxvY2spO1xuICAgICAgICBvdXRyb3MuYy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZGV0YWNoKVxuICAgICAgICAgICAgICAgICAgICBibG9jay5kKDEpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBibG9jay5vKGxvY2FsKTtcbiAgICB9XG59XG5jb25zdCBudWxsX3RyYW5zaXRpb24gPSB7IGR1cmF0aW9uOiAwIH07XG5mdW5jdGlvbiBjcmVhdGVfaW5fdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcyk7XG4gICAgbGV0IHJ1bm5pbmcgPSBmYWxzZTtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWU7XG4gICAgbGV0IHRhc2s7XG4gICAgbGV0IHVpZCA9IDA7XG4gICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcywgdWlkKyspO1xuICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcbiAgICAgICAgY29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG4gICAgICAgIGlmICh0YXNrKVxuICAgICAgICAgICAgdGFzay5hYm9ydCgpO1xuICAgICAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCB0cnVlLCAnc3RhcnQnKSk7XG4gICAgICAgIHRhc2sgPSBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gZW5kX3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGljaygxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0KCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlKTtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKCk7XG4gICAgICAgICAgICAgICAgd2FpdCgpLnRoZW4oZ28pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9vdXRfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcyk7XG4gICAgbGV0IHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxldCBhbmltYXRpb25fbmFtZTtcbiAgICBjb25zdCBncm91cCA9IG91dHJvcztcbiAgICBncm91cC5yICs9IDE7XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDEsIDAsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcbiAgICAgICAgY29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdzdGFydCcpKTtcbiAgICAgICAgbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobm93ID49IGVuZF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLS1ncm91cC5yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgcmVzdWx0IGluIGBlbmQoKWAgYmVpbmcgY2FsbGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBjbGVhbiB1cCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5fYWxsKGdyb3VwLmMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDEgLSB0LCB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVubmluZztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgIHdhaXQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZygpO1xuICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbygpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmQocmVzZXQpIHtcbiAgICAgICAgICAgIGlmIChyZXNldCAmJiBjb25maWcudGljaykge1xuICAgICAgICAgICAgICAgIGNvbmZpZy50aWNrKDEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zLCBpbnRybykge1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMpO1xuICAgIGxldCB0ID0gaW50cm8gPyAwIDogMTtcbiAgICBsZXQgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcbiAgICBsZXQgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWUgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGNsZWFyX2FuaW1hdGlvbigpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0KHByb2dyYW0sIGR1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGQgPSAocHJvZ3JhbS5iIC0gdCk7XG4gICAgICAgIGR1cmF0aW9uICo9IE1hdGguYWJzKGQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYTogdCxcbiAgICAgICAgICAgIGI6IHByb2dyYW0uYixcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIHN0YXJ0OiBwcm9ncmFtLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBwcm9ncmFtLnN0YXJ0ICsgZHVyYXRpb24sXG4gICAgICAgICAgICBncm91cDogcHJvZ3JhbS5ncm91cFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnbyhiKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSB7XG4gICAgICAgICAgICBzdGFydDogbm93KCkgKyBkZWxheSxcbiAgICAgICAgICAgIGJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgcHJvZ3JhbS5ncm91cCA9IG91dHJvcztcbiAgICAgICAgICAgIG91dHJvcy5yICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgIHBlbmRpbmdfcHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGludHJvLCBhbmQgdGhlcmUncyBhIGRlbGF5LCB3ZSBuZWVkIHRvIGRvXG4gICAgICAgICAgICAvLyBhbiBpbml0aWFsIHRpY2sgYW5kL29yIGFwcGx5IENTUyBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIpXG4gICAgICAgICAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocHJvZ3JhbSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBiLCAnc3RhcnQnKSk7XG4gICAgICAgICAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdfcHJvZ3JhbSAmJiBub3cgPiBwZW5kaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gaW5pdChwZW5kaW5nX3Byb2dyYW0sIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgcnVubmluZ19wcm9ncmFtLmIsIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbiwgMCwgZWFzaW5nLCBjb25maWcuY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0ID0gcnVubmluZ19wcm9ncmFtLmIsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBlbmRpbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtLmIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50cm8gXHUyMDE0IHdlIGNhbiB0aWR5IHVwIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3V0cm8gXHUyMDE0IG5lZWRzIHRvIGJlIGNvb3JkaW5hdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghLS1ydW5uaW5nX3Byb2dyYW0uZ3JvdXAucilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hbGwocnVubmluZ19wcm9ncmFtLmdyb3VwLmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IG5vdyAtIHJ1bm5pbmdfcHJvZ3JhbS5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBydW5uaW5nX3Byb2dyYW0uYSArIHJ1bm5pbmdfcHJvZ3JhbS5kICogZWFzaW5nKHAgLyBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcnVuKGIpIHtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgd2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZygpO1xuICAgICAgICAgICAgICAgICAgICBnbyhiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdvKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVfcHJvbWlzZShwcm9taXNlLCBpbmZvKSB7XG4gICAgY29uc3QgdG9rZW4gPSBpbmZvLnRva2VuID0ge307XG4gICAgZnVuY3Rpb24gdXBkYXRlKHR5cGUsIGluZGV4LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpbmZvLnRva2VuICE9PSB0b2tlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaW5mby5yZXNvbHZlZCA9IHZhbHVlO1xuICAgICAgICBsZXQgY2hpbGRfY3R4ID0gaW5mby5jdHg7XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hpbGRfY3R4ID0gY2hpbGRfY3R4LnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZF9jdHhba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdHlwZSAmJiAoaW5mby5jdXJyZW50ID0gdHlwZSkoY2hpbGRfY3R4KTtcbiAgICAgICAgbGV0IG5lZWRzX2ZsdXNoID0gZmFsc2U7XG4gICAgICAgIGlmIChpbmZvLmJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoaW5mby5ibG9ja3MpIHtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2Nrcy5mb3JFYWNoKChibG9jaywgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaW5kZXggJiYgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwX291dHJvcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5ibG9ja3NbaV0gPT09IGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uYmxvY2tzW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2NrLmQoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jay5jKCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICAgICAgICAgIGJsb2NrLm0oaW5mby5tb3VudCgpLCBpbmZvLmFuY2hvcik7XG4gICAgICAgICAgICBuZWVkc19mbHVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5ibG9jayA9IGJsb2NrO1xuICAgICAgICBpZiAoaW5mby5ibG9ja3MpXG4gICAgICAgICAgICBpbmZvLmJsb2Nrc1tpbmRleF0gPSBibG9jaztcbiAgICAgICAgaWYgKG5lZWRzX2ZsdXNoKSB7XG4gICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc19wcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRfY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG4gICAgICAgIHByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGluZm8uY2F0Y2gsIDIsIGluZm8uZXJyb3IsIGVycm9yKTtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgICAgIGlmICghaW5mby5oYXNDYXRjaCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gaWYgd2UgcHJldmlvdXNseSBoYWQgYSB0aGVuL2NhdGNoIGJsb2NrLCBkZXN0cm95IGl0XG4gICAgICAgIGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8ucGVuZGluZykge1xuICAgICAgICAgICAgdXBkYXRlKGluZm8ucGVuZGluZywgMCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGluZm8uY3VycmVudCAhPT0gaW5mby50aGVuKSB7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby50aGVuLCAxLCBpbmZvLnZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluZm8ucmVzb2x2ZWQgPSBwcm9taXNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZV9hd2FpdF9ibG9ja19icmFuY2goaW5mbywgY3R4LCBkaXJ0eSkge1xuICAgIGNvbnN0IGNoaWxkX2N0eCA9IGN0eC5zbGljZSgpO1xuICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IGluZm87XG4gICAgaWYgKGluZm8uY3VycmVudCA9PT0gaW5mby50aGVuKSB7XG4gICAgICAgIGNoaWxkX2N0eFtpbmZvLnZhbHVlXSA9IHJlc29sdmVkO1xuICAgIH1cbiAgICBpZiAoaW5mby5jdXJyZW50ID09PSBpbmZvLmNhdGNoKSB7XG4gICAgICAgIGNoaWxkX2N0eFtpbmZvLmVycm9yXSA9IHJlc29sdmVkO1xuICAgIH1cbiAgICBpbmZvLmJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSk7XG59XG5cbmNvbnN0IGdsb2JhbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHdpbmRvd1xuICAgIDogdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gZ2xvYmFsVGhpc1xuICAgICAgICA6IGdsb2JhbCk7XG5cbmZ1bmN0aW9uIGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmQoMSk7XG4gICAgbG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xufVxuZnVuY3Rpb24gb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG4gICAgICAgIGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZpeF9hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZigpO1xuICAgIGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5mdW5jdGlvbiBmaXhfYW5kX291dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5mKCk7XG4gICAgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5mdW5jdGlvbiB1cGRhdGVfa2V5ZWRfZWFjaChvbGRfYmxvY2tzLCBkaXJ0eSwgZ2V0X2tleSwgZHluYW1pYywgY3R4LCBsaXN0LCBsb29rdXAsIG5vZGUsIGRlc3Ryb3ksIGNyZWF0ZV9lYWNoX2Jsb2NrLCBuZXh0LCBnZXRfY29udGV4dCkge1xuICAgIGxldCBvID0gb2xkX2Jsb2Nrcy5sZW5ndGg7XG4gICAgbGV0IG4gPSBsaXN0Lmxlbmd0aDtcbiAgICBsZXQgaSA9IG87XG4gICAgY29uc3Qgb2xkX2luZGV4ZXMgPSB7fTtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBvbGRfaW5kZXhlc1tvbGRfYmxvY2tzW2ldLmtleV0gPSBpO1xuICAgIGNvbnN0IG5ld19ibG9ja3MgPSBbXTtcbiAgICBjb25zdCBuZXdfbG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRlbHRhcyA9IG5ldyBNYXAoKTtcbiAgICBpID0gbjtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkX2N0eCA9IGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSk7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldF9rZXkoY2hpbGRfY3R4KTtcbiAgICAgICAgbGV0IGJsb2NrID0gbG9va3VwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWJsb2NrKSB7XG4gICAgICAgICAgICBibG9jayA9IGNyZWF0ZV9lYWNoX2Jsb2NrKGtleSwgY2hpbGRfY3R4KTtcbiAgICAgICAgICAgIGJsb2NrLmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICBibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpO1xuICAgICAgICB9XG4gICAgICAgIG5ld19sb29rdXAuc2V0KGtleSwgbmV3X2Jsb2Nrc1tpXSA9IGJsb2NrKTtcbiAgICAgICAgaWYgKGtleSBpbiBvbGRfaW5kZXhlcylcbiAgICAgICAgICAgIGRlbHRhcy5zZXQoa2V5LCBNYXRoLmFicyhpIC0gb2xkX2luZGV4ZXNba2V5XSkpO1xuICAgIH1cbiAgICBjb25zdCB3aWxsX21vdmUgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgZGlkX21vdmUgPSBuZXcgU2V0KCk7XG4gICAgZnVuY3Rpb24gaW5zZXJ0KGJsb2NrKSB7XG4gICAgICAgIHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuICAgICAgICBibG9jay5tKG5vZGUsIG5leHQpO1xuICAgICAgICBsb29rdXAuc2V0KGJsb2NrLmtleSwgYmxvY2spO1xuICAgICAgICBuZXh0ID0gYmxvY2suZmlyc3Q7XG4gICAgICAgIG4tLTtcbiAgICB9XG4gICAgd2hpbGUgKG8gJiYgbikge1xuICAgICAgICBjb25zdCBuZXdfYmxvY2sgPSBuZXdfYmxvY2tzW24gLSAxXTtcbiAgICAgICAgY29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvIC0gMV07XG4gICAgICAgIGNvbnN0IG5ld19rZXkgPSBuZXdfYmxvY2sua2V5O1xuICAgICAgICBjb25zdCBvbGRfa2V5ID0gb2xkX2Jsb2NrLmtleTtcbiAgICAgICAgaWYgKG5ld19ibG9jayA9PT0gb2xkX2Jsb2NrKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgICAgICBuZXh0ID0gbmV3X2Jsb2NrLmZpcnN0O1xuICAgICAgICAgICAgby0tO1xuICAgICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfa2V5KSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIG9sZCBibG9ja1xuICAgICAgICAgICAgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWxvb2t1cC5oYXMobmV3X2tleSkgfHwgd2lsbF9tb3ZlLmhhcyhuZXdfa2V5KSkge1xuICAgICAgICAgICAgaW5zZXJ0KG5ld19ibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlkX21vdmUuaGFzKG9sZF9rZXkpKSB7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGFzLmdldChuZXdfa2V5KSA+IGRlbHRhcy5nZXQob2xkX2tleSkpIHtcbiAgICAgICAgICAgIGRpZF9tb3ZlLmFkZChuZXdfa2V5KTtcbiAgICAgICAgICAgIGluc2VydChuZXdfYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2lsbF9tb3ZlLmFkZChvbGRfa2V5KTtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoby0tKSB7XG4gICAgICAgIGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3Nbb107XG4gICAgICAgIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2Jsb2NrLmtleSkpXG4gICAgICAgICAgICBkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcbiAgICB9XG4gICAgd2hpbGUgKG4pXG4gICAgICAgIGluc2VydChuZXdfYmxvY2tzW24gLSAxXSk7XG4gICAgcmV0dXJuIG5ld19ibG9ja3M7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2tleXMoY3R4LCBsaXN0LCBnZXRfY29udGV4dCwgZ2V0X2tleSkge1xuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldF9rZXkoZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKSk7XG4gICAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXZlIGR1cGxpY2F0ZSBrZXlzIGluIGEga2V5ZWQgZWFjaCcpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRfc3ByZWFkX3VwZGF0ZShsZXZlbHMsIHVwZGF0ZXMpIHtcbiAgICBjb25zdCB1cGRhdGUgPSB7fTtcbiAgICBjb25zdCB0b19udWxsX291dCA9IHt9O1xuICAgIGNvbnN0IGFjY291bnRlZF9mb3IgPSB7ICQkc2NvcGU6IDEgfTtcbiAgICBsZXQgaSA9IGxldmVscy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBvID0gbGV2ZWxzW2ldO1xuICAgICAgICBjb25zdCBuID0gdXBkYXRlc1tpXTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gbikpXG4gICAgICAgICAgICAgICAgICAgIHRvX251bGxfb3V0W2tleV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbikge1xuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudGVkX2ZvcltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVtrZXldID0gbltrZXldO1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsc1tpXSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudGVkX2ZvcltrZXldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0b19udWxsX291dCkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdXBkYXRlKSlcbiAgICAgICAgICAgIHVwZGF0ZVtrZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZ2V0X3NwcmVhZF9vYmplY3Qoc3ByZWFkX3Byb3BzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzcHJlYWRfcHJvcHMgPT09ICdvYmplY3QnICYmIHNwcmVhZF9wcm9wcyAhPT0gbnVsbCA/IHNwcmVhZF9wcm9wcyA6IHt9O1xufVxuXG4vLyBzb3VyY2U6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbFxuY29uc3QgYm9vbGVhbl9hdHRyaWJ1dGVzID0gbmV3IFNldChbXG4gICAgJ2FsbG93ZnVsbHNjcmVlbicsXG4gICAgJ2FsbG93cGF5bWVudHJlcXVlc3QnLFxuICAgICdhc3luYycsXG4gICAgJ2F1dG9mb2N1cycsXG4gICAgJ2F1dG9wbGF5JyxcbiAgICAnY2hlY2tlZCcsXG4gICAgJ2NvbnRyb2xzJyxcbiAgICAnZGVmYXVsdCcsXG4gICAgJ2RlZmVyJyxcbiAgICAnZGlzYWJsZWQnLFxuICAgICdmb3Jtbm92YWxpZGF0ZScsXG4gICAgJ2hpZGRlbicsXG4gICAgJ2lzbWFwJyxcbiAgICAnbG9vcCcsXG4gICAgJ211bHRpcGxlJyxcbiAgICAnbXV0ZWQnLFxuICAgICdub21vZHVsZScsXG4gICAgJ25vdmFsaWRhdGUnLFxuICAgICdvcGVuJyxcbiAgICAncGxheXNpbmxpbmUnLFxuICAgICdyZWFkb25seScsXG4gICAgJ3JlcXVpcmVkJyxcbiAgICAncmV2ZXJzZWQnLFxuICAgICdzZWxlY3RlZCdcbl0pO1xuXG5jb25zdCBpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3RlciA9IC9bXFxzJ1wiPi89XFx1e0ZERDB9LVxcdXtGREVGfVxcdXtGRkZFfVxcdXtGRkZGfVxcdXsxRkZGRX1cXHV7MUZGRkZ9XFx1ezJGRkZFfVxcdXsyRkZGRn1cXHV7M0ZGRkV9XFx1ezNGRkZGfVxcdXs0RkZGRX1cXHV7NEZGRkZ9XFx1ezVGRkZFfVxcdXs1RkZGRn1cXHV7NkZGRkV9XFx1ezZGRkZGfVxcdXs3RkZGRX1cXHV7N0ZGRkZ9XFx1ezhGRkZFfVxcdXs4RkZGRn1cXHV7OUZGRkV9XFx1ezlGRkZGfVxcdXtBRkZGRX1cXHV7QUZGRkZ9XFx1e0JGRkZFfVxcdXtCRkZGRn1cXHV7Q0ZGRkV9XFx1e0NGRkZGfVxcdXtERkZGRX1cXHV7REZGRkZ9XFx1e0VGRkZFfVxcdXtFRkZGRn1cXHV7RkZGRkV9XFx1e0ZGRkZGfVxcdXsxMEZGRkV9XFx1ezEwRkZGRn1dL3U7XG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNub25jaGFyYWN0ZXJcbmZ1bmN0aW9uIHNwcmVhZChhcmdzLCBjbGFzc2VzX3RvX2FkZCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5hcmdzKTtcbiAgICBpZiAoY2xhc3Nlc190b19hZGQpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMuY2xhc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5jbGFzcyA9IGNsYXNzZXNfdG9fYWRkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5jbGFzcyArPSAnICcgKyBjbGFzc2VzX3RvX2FkZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RyID0gJyc7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgaWYgKGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLnRlc3QobmFtZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKVxuICAgICAgICAgICAgc3RyICs9ICcgJyArIG5hbWU7XG4gICAgICAgIGVsc2UgaWYgKGJvb2xlYW5fYXR0cmlidXRlcy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIHN0ciArPSAnICcgKyBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciArPSBgICR7bmFtZX09XCIke3ZhbHVlfVwiYDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG59XG5jb25zdCBlc2NhcGVkID0ge1xuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnLFxuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7J1xufTtcbmZ1bmN0aW9uIGVzY2FwZShodG1sKSB7XG4gICAgcmV0dXJuIFN0cmluZyhodG1sKS5yZXBsYWNlKC9bXCInJjw+XS9nLCBtYXRjaCA9PiBlc2NhcGVkW21hdGNoXSk7XG59XG5mdW5jdGlvbiBlc2NhcGVfYXR0cmlidXRlX3ZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBlc2NhcGUodmFsdWUpIDogdmFsdWU7XG59XG5mdW5jdGlvbiBlc2NhcGVfb2JqZWN0KG9iaikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICByZXN1bHRba2V5XSA9IGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZWFjaChpdGVtcywgZm4pIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdHIgKz0gZm4oaXRlbXNbaV0sIGkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuY29uc3QgbWlzc2luZ19jb21wb25lbnQgPSB7XG4gICAgJCRyZW5kZXI6ICgpID0+ICcnXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVfY29tcG9uZW50KGNvbXBvbmVudCwgbmFtZSkge1xuICAgIGlmICghY29tcG9uZW50IHx8ICFjb21wb25lbnQuJCRyZW5kZXIpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdzdmVsdGU6Y29tcG9uZW50JylcbiAgICAgICAgICAgIG5hbWUgKz0gJyB0aGlzPXsuLi59JztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGA8JHtuYW1lfT4gaXMgbm90IGEgdmFsaWQgU1NSIGNvbXBvbmVudC4gWW91IG1heSBuZWVkIHRvIHJldmlldyB5b3VyIGJ1aWxkIGNvbmZpZyB0byBlbnN1cmUgdGhhdCBkZXBlbmRlbmNpZXMgYXJlIGNvbXBpbGVkLCByYXRoZXIgdGhhbiBpbXBvcnRlZCBhcyBwcmUtY29tcGlsZWQgbW9kdWxlc2ApO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xufVxuZnVuY3Rpb24gZGVidWcoZmlsZSwgbGluZSwgY29sdW1uLCB2YWx1ZXMpIHtcbiAgICBjb25zb2xlLmxvZyhge0BkZWJ1Z30gJHtmaWxlID8gZmlsZSArICcgJyA6ICcnfSgke2xpbmV9OiR7Y29sdW1ufSlgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5sb2codmFsdWVzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgcmV0dXJuICcnO1xufVxubGV0IG9uX2Rlc3Ryb3k7XG5mdW5jdGlvbiBjcmVhdGVfc3NyX2NvbXBvbmVudChmbikge1xuICAgIGZ1bmN0aW9uICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cywgY29udGV4dCkge1xuICAgICAgICBjb25zdCBwYXJlbnRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgICAgIGNvbnN0ICQkID0ge1xuICAgICAgICAgICAgb25fZGVzdHJveSxcbiAgICAgICAgICAgIGNvbnRleHQ6IG5ldyBNYXAoY29udGV4dCB8fCAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSksXG4gICAgICAgICAgICAvLyB0aGVzZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGRpc2NhcmRlZFxuICAgICAgICAgICAgb25fbW91bnQ6IFtdLFxuICAgICAgICAgICAgYmVmb3JlX3VwZGF0ZTogW10sXG4gICAgICAgICAgICBhZnRlcl91cGRhdGU6IFtdLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBibGFua19vYmplY3QoKVxuICAgICAgICB9O1xuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoeyAkJCB9KTtcbiAgICAgICAgY29uc3QgaHRtbCA9IGZuKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cyk7XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlcjogKHByb3BzID0ge30sIHsgJCRzbG90cyA9IHt9LCBjb250ZXh0ID0gbmV3IE1hcCgpIH0gPSB7fSkgPT4ge1xuICAgICAgICAgICAgb25fZGVzdHJveSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB0aXRsZTogJycsIGhlYWQ6ICcnLCBjc3M6IG5ldyBTZXQoKSB9O1xuICAgICAgICAgICAgY29uc3QgaHRtbCA9ICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIHt9LCAkJHNsb3RzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJ1bl9hbGwob25fZGVzdHJveSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGh0bWwsXG4gICAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IEFycmF5LmZyb20ocmVzdWx0LmNzcykubWFwKGNzcyA9PiBjc3MuY29kZSkuam9pbignXFxuJyksXG4gICAgICAgICAgICAgICAgICAgIG1hcDogbnVsbCAvLyBUT0RPXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWFkOiByZXN1bHQudGl0bGUgKyByZXN1bHQuaGVhZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgJCRyZW5kZXJcbiAgICB9O1xufVxuZnVuY3Rpb24gYWRkX2F0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgYm9vbGVhbikge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IChib29sZWFuICYmICF2YWx1ZSkpXG4gICAgICAgIHJldHVybiAnJztcbiAgICByZXR1cm4gYCAke25hbWV9JHt2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogYD0ke3R5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeShlc2NhcGUodmFsdWUpKSA6IGBcIiR7dmFsdWV9XCJgfWB9YDtcbn1cbmZ1bmN0aW9uIGFkZF9jbGFzc2VzKGNsYXNzZXMpIHtcbiAgICByZXR1cm4gY2xhc3NlcyA/IGAgY2xhc3M9XCIke2NsYXNzZXN9XCJgIDogJyc7XG59XG5cbmZ1bmN0aW9uIGJpbmQoY29tcG9uZW50LCBuYW1lLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGluZGV4ID0gY29tcG9uZW50LiQkLnByb3BzW25hbWVdO1xuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXBvbmVudC4kJC5ib3VuZFtpbmRleF0gPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2soY29tcG9uZW50LiQkLmN0eFtpbmRleF0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZV9jb21wb25lbnQoYmxvY2spIHtcbiAgICBibG9jayAmJiBibG9jay5jKCk7XG59XG5mdW5jdGlvbiBjbGFpbV9jb21wb25lbnQoYmxvY2ssIHBhcmVudF9ub2Rlcykge1xuICAgIGJsb2NrICYmIGJsb2NrLmwocGFyZW50X25vZGVzKTtcbn1cbmZ1bmN0aW9uIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIHRhcmdldCwgYW5jaG9yLCBjdXN0b21FbGVtZW50KSB7XG4gICAgY29uc3QgeyBmcmFnbWVudCwgb25fbW91bnQsIG9uX2Rlc3Ryb3ksIGFmdGVyX3VwZGF0ZSB9ID0gY29tcG9uZW50LiQkO1xuICAgIGZyYWdtZW50ICYmIGZyYWdtZW50Lm0odGFyZ2V0LCBhbmNob3IpO1xuICAgIGlmICghY3VzdG9tRWxlbWVudCkge1xuICAgICAgICAvLyBvbk1vdW50IGhhcHBlbnMgYmVmb3JlIHRoZSBpbml0aWFsIGFmdGVyVXBkYXRlXG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3X29uX2Rlc3Ryb3kgPSBvbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICAgICAgaWYgKG9uX2Rlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBvbl9kZXN0cm95LnB1c2goLi4ubmV3X29uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRWRnZSBjYXNlIC0gY29tcG9uZW50IHdhcyBkZXN0cm95ZWQgaW1tZWRpYXRlbHksXG4gICAgICAgICAgICAgICAgLy8gbW9zdCBsaWtlbHkgYXMgYSByZXN1bHQgb2YgYSBiaW5kaW5nIGluaXRpYWxpc2luZ1xuICAgICAgICAgICAgICAgIHJ1bl9hbGwobmV3X29uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50LiQkLm9uX21vdW50ID0gW107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lfY29tcG9uZW50KGNvbXBvbmVudCwgZGV0YWNoaW5nKSB7XG4gICAgY29uc3QgJCQgPSBjb21wb25lbnQuJCQ7XG4gICAgaWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHJ1bl9hbGwoJCQub25fZGVzdHJveSk7XG4gICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmQoZGV0YWNoaW5nKTtcbiAgICAgICAgLy8gVE9ETyBudWxsIG91dCBvdGhlciByZWZzLCBpbmNsdWRpbmcgY29tcG9uZW50LiQkIChidXQgbmVlZCB0b1xuICAgICAgICAvLyBwcmVzZXJ2ZSBmaW5hbCBzdGF0ZT8pXG4gICAgICAgICQkLm9uX2Rlc3Ryb3kgPSAkJC5mcmFnbWVudCA9IG51bGw7XG4gICAgICAgICQkLmN0eCA9IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKSB7XG4gICAgaWYgKGNvbXBvbmVudC4kJC5kaXJ0eVswXSA9PT0gLTEpIHtcbiAgICAgICAgZGlydHlfY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgIHNjaGVkdWxlX3VwZGF0ZSgpO1xuICAgICAgICBjb21wb25lbnQuJCQuZGlydHkuZmlsbCgwKTtcbiAgICB9XG4gICAgY29tcG9uZW50LiQkLmRpcnR5WyhpIC8gMzEpIHwgMF0gfD0gKDEgPDwgKGkgJSAzMSkpO1xufVxuZnVuY3Rpb24gaW5pdChjb21wb25lbnQsIG9wdGlvbnMsIGluc3RhbmNlLCBjcmVhdGVfZnJhZ21lbnQsIG5vdF9lcXVhbCwgcHJvcHMsIGFwcGVuZF9zdHlsZXMsIGRpcnR5ID0gWy0xXSkge1xuICAgIGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcbiAgICBjb25zdCAkJCA9IGNvbXBvbmVudC4kJCA9IHtcbiAgICAgICAgZnJhZ21lbnQ6IG51bGwsXG4gICAgICAgIGN0eDogbnVsbCxcbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHVwZGF0ZTogbm9vcCxcbiAgICAgICAgbm90X2VxdWFsLFxuICAgICAgICBib3VuZDogYmxhbmtfb2JqZWN0KCksXG4gICAgICAgIC8vIGxpZmVjeWNsZVxuICAgICAgICBvbl9tb3VudDogW10sXG4gICAgICAgIG9uX2Rlc3Ryb3k6IFtdLFxuICAgICAgICBvbl9kaXNjb25uZWN0OiBbXSxcbiAgICAgICAgYmVmb3JlX3VwZGF0ZTogW10sXG4gICAgICAgIGFmdGVyX3VwZGF0ZTogW10sXG4gICAgICAgIGNvbnRleHQ6IG5ldyBNYXAob3B0aW9ucy5jb250ZXh0IHx8IChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogW10pKSxcbiAgICAgICAgLy8gZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KCksXG4gICAgICAgIGRpcnR5LFxuICAgICAgICBza2lwX2JvdW5kOiBmYWxzZSxcbiAgICAgICAgcm9vdDogb3B0aW9ucy50YXJnZXQgfHwgcGFyZW50X2NvbXBvbmVudC4kJC5yb290XG4gICAgfTtcbiAgICBhcHBlbmRfc3R5bGVzICYmIGFwcGVuZF9zdHlsZXMoJCQucm9vdCk7XG4gICAgbGV0IHJlYWR5ID0gZmFsc2U7XG4gICAgJCQuY3R4ID0gaW5zdGFuY2VcbiAgICAgICAgPyBpbnN0YW5jZShjb21wb25lbnQsIG9wdGlvbnMucHJvcHMgfHwge30sIChpLCByZXQsIC4uLnJlc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdC5sZW5ndGggPyByZXN0WzBdIDogcmV0O1xuICAgICAgICAgICAgaWYgKCQkLmN0eCAmJiBub3RfZXF1YWwoJCQuY3R4W2ldLCAkJC5jdHhbaV0gPSB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoISQkLnNraXBfYm91bmQgJiYgJCQuYm91bmRbaV0pXG4gICAgICAgICAgICAgICAgICAgICQkLmJvdW5kW2ldKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVhZHkpXG4gICAgICAgICAgICAgICAgICAgIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0pXG4gICAgICAgIDogW107XG4gICAgJCQudXBkYXRlKCk7XG4gICAgcmVhZHkgPSB0cnVlO1xuICAgIHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG4gICAgLy8gYGZhbHNlYCBhcyBhIHNwZWNpYWwgY2FzZSBvZiBubyBET00gY29tcG9uZW50XG4gICAgJCQuZnJhZ21lbnQgPSBjcmVhdGVfZnJhZ21lbnQgPyBjcmVhdGVfZnJhZ21lbnQoJCQuY3R4KSA6IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLnRhcmdldCkge1xuICAgICAgICBpZiAob3B0aW9ucy5oeWRyYXRlKSB7XG4gICAgICAgICAgICBzdGFydF9oeWRyYXRpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gY2hpbGRyZW4ob3B0aW9ucy50YXJnZXQpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50Lmwobm9kZXMpO1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChkZXRhY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbnRybylcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oY29tcG9uZW50LiQkLmZyYWdtZW50KTtcbiAgICAgICAgbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgb3B0aW9ucy50YXJnZXQsIG9wdGlvbnMuYW5jaG9yLCBvcHRpb25zLmN1c3RvbUVsZW1lbnQpO1xuICAgICAgICBlbmRfaHlkcmF0aW5nKCk7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgfVxuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbn1cbmxldCBTdmVsdGVFbGVtZW50O1xuaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFN2ZWx0ZUVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9uX21vdW50IH0gPSB0aGlzLiQkO1xuICAgICAgICAgICAgdGhpcy4kJC5vbl9kaXNjb25uZWN0ID0gb25fbW91bnQubWFwKHJ1bikuZmlsdGVyKGlzX2Z1bmN0aW9uKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLiQkLnNsb3R0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy4kJC5zbG90dGVkW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzW2F0dHJdID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBydW5fYWxsKHRoaXMuJCQub25fZGlzY29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgJGRlc3Ryb3koKSB7XG4gICAgICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgICAgIHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gVE9ETyBzaG91bGQgdGhpcyBkZWxlZ2F0ZSB0byBhZGRFdmVudExpc3RlbmVyP1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKSk7XG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAkc2V0KCQkcHJvcHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eSgkJHByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy4kJHNldCgkJHByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzLiBVc2VkIHdoZW4gZGV2PWZhbHNlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnQge1xuICAgICRkZXN0cm95KCkge1xuICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgfVxuICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pKTtcbiAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAkc2V0KCQkcHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KCQkcHJvcHMpKSB7XG4gICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kJHNldCgkJHByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaF9kZXYodHlwZSwgZGV0YWlsKSB7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQodHlwZSwgT2JqZWN0LmFzc2lnbih7IHZlcnNpb246ICczLjQ0LjMnIH0sIGRldGFpbCksIHRydWUpKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9kZXYodGFyZ2V0LCBub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSB9KTtcbiAgICBhcHBlbmQodGFyZ2V0LCBub2RlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb25fZGV2KHRhcmdldCwgbm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUgfSk7XG4gICAgYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2Rldih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcbiAgICBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbl9kZXYodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlLCBhbmNob3IgfSk7XG4gICAgaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG59XG5mdW5jdGlvbiBkZXRhY2hfZGV2KG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZScsIHsgbm9kZSB9KTtcbiAgICBkZXRhY2gobm9kZSk7XG59XG5mdW5jdGlvbiBkZXRhY2hfYmV0d2Vlbl9kZXYoYmVmb3JlLCBhZnRlcikge1xuICAgIHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcgJiYgYmVmb3JlLm5leHRTaWJsaW5nICE9PSBhZnRlcikge1xuICAgICAgICBkZXRhY2hfZGV2KGJlZm9yZS5uZXh0U2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoX2JlZm9yZV9kZXYoYWZ0ZXIpIHtcbiAgICB3aGlsZSAoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2hfYWZ0ZXJfZGV2KGJlZm9yZSkge1xuICAgIHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgZGV0YWNoX2RldihiZWZvcmUubmV4dFNpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpc3Rlbl9kZXYobm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMsIGhhc19wcmV2ZW50X2RlZmF1bHQsIGhhc19zdG9wX3Byb3BhZ2F0aW9uKSB7XG4gICAgY29uc3QgbW9kaWZpZXJzID0gb3B0aW9ucyA9PT0gdHJ1ZSA/IFsnY2FwdHVyZSddIDogb3B0aW9ucyA/IEFycmF5LmZyb20oT2JqZWN0LmtleXMob3B0aW9ucykpIDogW107XG4gICAgaWYgKGhhc19wcmV2ZW50X2RlZmF1bHQpXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdwcmV2ZW50RGVmYXVsdCcpO1xuICAgIGlmIChoYXNfc3RvcF9wcm9wYWdhdGlvbilcbiAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3N0b3BQcm9wYWdhdGlvbicpO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NQWRkRXZlbnRMaXN0ZW5lcicsIHsgbm9kZSwgZXZlbnQsIGhhbmRsZXIsIG1vZGlmaWVycyB9KTtcbiAgICBjb25zdCBkaXNwb3NlID0gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZUV2ZW50TGlzdGVuZXInLCB7IG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBtb2RpZmllcnMgfSk7XG4gICAgICAgIGRpc3Bvc2UoKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYXR0cl9kZXYobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlQXR0cmlidXRlJywgeyBub2RlLCBhdHRyaWJ1dGUgfSk7XG4gICAgZWxzZVxuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldEF0dHJpYnV0ZScsIHsgbm9kZSwgYXR0cmlidXRlLCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIHByb3BfZGV2KG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIG5vZGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXRQcm9wZXJ0eScsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gZGF0YXNldF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbm9kZS5kYXRhc2V0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YXNldCcsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gc2V0X2RhdGFfZGV2KHRleHQsIGRhdGEpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgIGlmICh0ZXh0Lndob2xlVGV4dCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YScsIHsgbm9kZTogdGV4dCwgZGF0YSB9KTtcbiAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9hcmd1bWVudChhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ3N0cmluZycgJiYgIShhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gYXJnKSkge1xuICAgICAgICBsZXQgbXNnID0gJ3sjZWFjaH0gb25seSBpdGVyYXRlcyBvdmVyIGFycmF5LWxpa2Ugb2JqZWN0cy4nO1xuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIGFyZykge1xuICAgICAgICAgICAgbXNnICs9ICcgWW91IGNhbiB1c2UgYSBzcHJlYWQgdG8gY29udmVydCB0aGlzIGl0ZXJhYmxlIGludG8gYW4gYXJyYXkuJztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9zbG90cyhuYW1lLCBzbG90LCBrZXlzKSB7XG4gICAgZm9yIChjb25zdCBzbG90X2tleSBvZiBPYmplY3Qua2V5cyhzbG90KSkge1xuICAgICAgICBpZiAoIX5rZXlzLmluZGV4T2Yoc2xvdF9rZXkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYDwke25hbWV9PiByZWNlaXZlZCBhbiB1bmV4cGVjdGVkIHNsb3QgXCIke3Nsb3Rfa2V5fVwiLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cyB3aXRoIHNvbWUgbWlub3IgZGV2LWVuaGFuY2VtZW50cy4gVXNlZCB3aGVuIGRldj10cnVlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnREZXYgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8ICghb3B0aW9ucy50YXJnZXQgJiYgIW9wdGlvbnMuJCRpbmxpbmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIndGFyZ2V0JyBpcyBhIHJlcXVpcmVkIG9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuJGRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ29tcG9uZW50IHdhcyBhbHJlYWR5IGRlc3Ryb3llZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgJGNhcHR1cmVfc3RhdGUoKSB7IH1cbiAgICAkaW5qZWN0X3N0YXRlKCkgeyB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgdG8gY3JlYXRlIHN0cm9uZ2x5IHR5cGVkIFN2ZWx0ZSBjb21wb25lbnRzLlxuICogVGhpcyBvbmx5IGV4aXN0cyBmb3IgdHlwaW5nIHB1cnBvc2VzIGFuZCBzaG91bGQgYmUgdXNlZCBpbiBgLmQudHNgIGZpbGVzLlxuICpcbiAqICMjIyBFeGFtcGxlOlxuICpcbiAqIFlvdSBoYXZlIGNvbXBvbmVudCBsaWJyYXJ5IG9uIG5wbSBjYWxsZWQgYGNvbXBvbmVudC1saWJyYXJ5YCwgZnJvbSB3aGljaFxuICogeW91IGV4cG9ydCBhIGNvbXBvbmVudCBjYWxsZWQgYE15Q29tcG9uZW50YC4gRm9yIFN2ZWx0ZStUeXBlU2NyaXB0IHVzZXJzLFxuICogeW91IHdhbnQgdG8gcHJvdmlkZSB0eXBpbmdzLiBUaGVyZWZvcmUgeW91IGNyZWF0ZSBhIGBpbmRleC5kLnRzYDpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBTdmVsdGVDb21wb25lbnRUeXBlZCB9IGZyb20gXCJzdmVsdGVcIjtcbiAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudFR5cGVkPHtmb286IHN0cmluZ30+IHt9XG4gKiBgYGBcbiAqIFR5cGluZyB0aGlzIG1ha2VzIGl0IHBvc3NpYmxlIGZvciBJREVzIGxpa2UgVlMgQ29kZSB3aXRoIHRoZSBTdmVsdGUgZXh0ZW5zaW9uXG4gKiB0byBwcm92aWRlIGludGVsbGlzZW5zZSBhbmQgdG8gdXNlIHRoZSBjb21wb25lbnQgbGlrZSB0aGlzIGluIGEgU3ZlbHRlIGZpbGVcbiAqIHdpdGggVHlwZVNjcmlwdDpcbiAqIGBgYHN2ZWx0ZVxuICogPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAqIFx0aW1wb3J0IHsgTXlDb21wb25lbnQgfSBmcm9tIFwiY29tcG9uZW50LWxpYnJhcnlcIjtcbiAqIDwvc2NyaXB0PlxuICogPE15Q29tcG9uZW50IGZvbz17J2Jhcid9IC8+XG4gKiBgYGBcbiAqXG4gKiAjIyMjIFdoeSBub3QgbWFrZSB0aGlzIHBhcnQgb2YgYFN2ZWx0ZUNvbXBvbmVudChEZXYpYD9cbiAqIEJlY2F1c2VcbiAqIGBgYHRzXG4gKiBjbGFzcyBBU3ViY2xhc3NPZlN2ZWx0ZUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudDx7Zm9vOiBzdHJpbmd9PiB7fVxuICogY29uc3QgY29tcG9uZW50OiB0eXBlb2YgU3ZlbHRlQ29tcG9uZW50ID0gQVN1YmNsYXNzT2ZTdmVsdGVDb21wb25lbnQ7XG4gKiBgYGBcbiAqIHdpbGwgdGhyb3cgYSB0eXBlIGVycm9yLCBzbyB3ZSBuZWVkIHRvIHNlcGFyYXRlIHRoZSBtb3JlIHN0cmljdGx5IHR5cGVkIGNsYXNzLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnRUeXBlZCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudERldiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsb29wX2d1YXJkKHRpbWVvdXQpIHtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydCA+IHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCBkZXRlY3RlZCcpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgSHRtbFRhZywgSHRtbFRhZ0h5ZHJhdGlvbiwgU3ZlbHRlQ29tcG9uZW50LCBTdmVsdGVDb21wb25lbnREZXYsIFN2ZWx0ZUNvbXBvbmVudFR5cGVkLCBTdmVsdGVFbGVtZW50LCBhY3Rpb25fZGVzdHJveWVyLCBhZGRfYXR0cmlidXRlLCBhZGRfY2xhc3NlcywgYWRkX2ZsdXNoX2NhbGxiYWNrLCBhZGRfbG9jYXRpb24sIGFkZF9yZW5kZXJfY2FsbGJhY2ssIGFkZF9yZXNpemVfbGlzdGVuZXIsIGFkZF90cmFuc2Zvcm0sIGFmdGVyVXBkYXRlLCBhcHBlbmQsIGFwcGVuZF9kZXYsIGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0LCBhcHBlbmRfaHlkcmF0aW9uLCBhcHBlbmRfaHlkcmF0aW9uX2RldiwgYXBwZW5kX3N0eWxlcywgYXNzaWduLCBhdHRyLCBhdHRyX2RldiwgYXR0cmlidXRlX3RvX29iamVjdCwgYmVmb3JlVXBkYXRlLCBiaW5kLCBiaW5kaW5nX2NhbGxiYWNrcywgYmxhbmtfb2JqZWN0LCBidWJibGUsIGNoZWNrX291dHJvcywgY2hpbGRyZW4sIGNsYWltX2NvbXBvbmVudCwgY2xhaW1fZWxlbWVudCwgY2xhaW1faHRtbF90YWcsIGNsYWltX3NwYWNlLCBjbGFpbV9zdmdfZWxlbWVudCwgY2xhaW1fdGV4dCwgY2xlYXJfbG9vcHMsIGNvbXBvbmVudF9zdWJzY3JpYmUsIGNvbXB1dGVfcmVzdF9wcm9wcywgY29tcHV0ZV9zbG90cywgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBjcmVhdGVfYW5pbWF0aW9uLCBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uLCBjcmVhdGVfY29tcG9uZW50LCBjcmVhdGVfaW5fdHJhbnNpdGlvbiwgY3JlYXRlX291dF90cmFuc2l0aW9uLCBjcmVhdGVfc2xvdCwgY3JlYXRlX3Nzcl9jb21wb25lbnQsIGN1cnJlbnRfY29tcG9uZW50LCBjdXN0b21fZXZlbnQsIGRhdGFzZXRfZGV2LCBkZWJ1ZywgZGVzdHJveV9ibG9jaywgZGVzdHJveV9jb21wb25lbnQsIGRlc3Ryb3lfZWFjaCwgZGV0YWNoLCBkZXRhY2hfYWZ0ZXJfZGV2LCBkZXRhY2hfYmVmb3JlX2RldiwgZGV0YWNoX2JldHdlZW5fZGV2LCBkZXRhY2hfZGV2LCBkaXJ0eV9jb21wb25lbnRzLCBkaXNwYXRjaF9kZXYsIGVhY2gsIGVsZW1lbnQsIGVsZW1lbnRfaXMsIGVtcHR5LCBlbmRfaHlkcmF0aW5nLCBlc2NhcGUsIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUsIGVzY2FwZV9vYmplY3QsIGVzY2FwZWQsIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMsIGZpeF9hbmRfZGVzdHJveV9ibG9jaywgZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jaywgZml4X3Bvc2l0aW9uLCBmbHVzaCwgZ2V0QWxsQ29udGV4dHMsIGdldENvbnRleHQsIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSwgZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUsIGdldF9jdXJyZW50X2NvbXBvbmVudCwgZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cywgZ2V0X3Jvb3RfZm9yX3N0eWxlLCBnZXRfc2xvdF9jaGFuZ2VzLCBnZXRfc3ByZWFkX29iamVjdCwgZ2V0X3NwcmVhZF91cGRhdGUsIGdldF9zdG9yZV92YWx1ZSwgZ2xvYmFscywgZ3JvdXBfb3V0cm9zLCBoYW5kbGVfcHJvbWlzZSwgaGFzQ29udGV4dCwgaGFzX3Byb3AsIGlkZW50aXR5LCBpbml0LCBpbnNlcnQsIGluc2VydF9kZXYsIGluc2VydF9oeWRyYXRpb24sIGluc2VydF9oeWRyYXRpb25fZGV2LCBpbnRyb3MsIGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLCBpc19jbGllbnQsIGlzX2Nyb3Nzb3JpZ2luLCBpc19lbXB0eSwgaXNfZnVuY3Rpb24sIGlzX3Byb21pc2UsIGxpc3RlbiwgbGlzdGVuX2RldiwgbG9vcCwgbG9vcF9ndWFyZCwgbWlzc2luZ19jb21wb25lbnQsIG1vdW50X2NvbXBvbmVudCwgbm9vcCwgbm90X2VxdWFsLCBub3csIG51bGxfdG9fZW1wdHksIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMsIG9uRGVzdHJveSwgb25Nb3VudCwgb25jZSwgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIHByZXZlbnRfZGVmYXVsdCwgcHJvcF9kZXYsIHF1ZXJ5X3NlbGVjdG9yX2FsbCwgcmFmLCBydW4sIHJ1bl9hbGwsIHNhZmVfbm90X2VxdWFsLCBzY2hlZHVsZV91cGRhdGUsIHNlbGVjdF9tdWx0aXBsZV92YWx1ZSwgc2VsZWN0X29wdGlvbiwgc2VsZWN0X29wdGlvbnMsIHNlbGVjdF92YWx1ZSwgc2VsZiwgc2V0Q29udGV4dCwgc2V0X2F0dHJpYnV0ZXMsIHNldF9jdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEsIHNldF9kYXRhLCBzZXRfZGF0YV9kZXYsIHNldF9pbnB1dF90eXBlLCBzZXRfaW5wdXRfdmFsdWUsIHNldF9ub3csIHNldF9yYWYsIHNldF9zdG9yZV92YWx1ZSwgc2V0X3N0eWxlLCBzZXRfc3ZnX2F0dHJpYnV0ZXMsIHNwYWNlLCBzcHJlYWQsIHNyY191cmxfZXF1YWwsIHN0YXJ0X2h5ZHJhdGluZywgc3RvcF9wcm9wYWdhdGlvbiwgc3Vic2NyaWJlLCBzdmdfZWxlbWVudCwgdGV4dCwgdGljaywgdGltZV9yYW5nZXNfdG9fYXJyYXksIHRvX251bWJlciwgdG9nZ2xlX2NsYXNzLCB0cmFuc2l0aW9uX2luLCB0cmFuc2l0aW9uX291dCwgdHJ1c3RlZCwgdXBkYXRlX2F3YWl0X2Jsb2NrX2JyYW5jaCwgdXBkYXRlX2tleWVkX2VhY2gsIHVwZGF0ZV9zbG90LCB1cGRhdGVfc2xvdF9iYXNlLCB2YWxpZGF0ZV9jb21wb25lbnQsIHZhbGlkYXRlX2VhY2hfYXJndW1lbnQsIHZhbGlkYXRlX2VhY2hfa2V5cywgdmFsaWRhdGVfc2xvdHMsIHZhbGlkYXRlX3N0b3JlLCB4bGlua19hdHRyIH07XG4iLCAiPHNjcmlwdCBsYW5nPVwidHNcIj5cclxuXHRpbXBvcnQgdHlwZSBCQ1BsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5cclxuXHRleHBvcnQgbGV0IHBsdWdpbjogQkNQbHVnaW47XHJcblx0ZXhwb3J0IGxldCBvcHRpb25zOiBzdHJpbmdbXTtcclxuXHRleHBvcnQgbGV0IHNlbGVjdGVkOiBzdHJpbmdbXTtcclxuXHJcblx0bGV0IHRvTm9uZSA9IHNlbGVjdGVkLmxlbmd0aCA9PT0gMCA/IGZhbHNlIDogdHJ1ZTtcclxuXHQkOiB0b05vbmUgPSBzZWxlY3RlZC5sZW5ndGggPT09IDAgPyBmYWxzZSA6IHRydWU7XHJcbjwvc2NyaXB0PlxyXG5cclxuPGRpdj5cclxuXHQ8YnV0dG9uXHJcblx0XHRvbjpjbGljaz17YXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRpZiAodG9Ob25lKSBzZWxlY3RlZCA9IFtdO1xyXG5cdFx0XHRlbHNlIHNlbGVjdGVkID0gb3B0aW9ucztcclxuXHRcdH19XHJcblx0PlxyXG5cdFx0e3RvTm9uZSA/IFwiTm9uZVwiIDogXCJBbGxcIn1cclxuXHQ8L2J1dHRvbj5cclxuPC9kaXY+XHJcblxyXG48ZGl2IGNsYXNzPVwiZ3JpZFwiPlxyXG5cdHsjZWFjaCBvcHRpb25zIGFzIG9wdGlvbn1cclxuXHRcdDxkaXY+XHJcblx0XHRcdDxsYWJlbD5cclxuXHRcdFx0XHQ8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9e29wdGlvbn0gYmluZDpncm91cD17c2VsZWN0ZWR9IC8+XHJcblx0XHRcdFx0e29wdGlvbn1cclxuXHRcdFx0PC9sYWJlbD5cclxuXHRcdDwvZGl2PlxyXG5cdHsvZWFjaH1cclxuPC9kaXY+XHJcblxyXG48c3R5bGU+XHJcblx0LmdyaWQge1xyXG5cdFx0ZGlzcGxheTogZ3JpZDtcclxuXHRcdGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KGF1dG8tZml0LCBtaW5tYXgoMTAwcHgsIDFmcikpO1xyXG5cdFx0LyogZ3JpZC1nYXA6IDEwcHg7ICovXHJcblx0fVxyXG48L3N0eWxlPlxyXG4iLCAiPHNjcmlwdCBsYW5nPVwidHNcIj5cclxuXHRpbXBvcnQgeyBEYXRlVGltZSB9IGZyb20gXCJsdXhvblwiO1xyXG5cclxuXHRleHBvcnQgbGV0IGNvbG91cjogc3RyaW5nO1xyXG5cdGV4cG9ydCBsZXQgc3RhcnREYXRlOiBEYXRlVGltZTtcclxuXHRleHBvcnQgbGV0IGVuZERhdGU6IERhdGVUaW1lO1xyXG5cdGV4cG9ydCBsZXQgZG5Pbmx5OiBib29sZWFuO1xyXG5cclxuXHRjb25zdCBtaW5EYXRlU3RyOiBzdHJpbmcgPSBzdGFydERhdGUudG9JU09EYXRlKCk7XHJcblx0Y29uc3QgbWF4RGF0ZVN0cjogc3RyaW5nID0gZW5kRGF0ZS50b0lTT0RhdGUoKTtcclxuPC9zY3JpcHQ+XHJcblxyXG48aW5wdXQgdHlwZT1cImNvbG9yXCIgYmluZDp2YWx1ZT17Y29sb3VyfSAvPlxyXG48bGFiZWxcclxuXHQ+RGF0ZSBSYW5nZTxpbnB1dFxyXG5cdFx0dHlwZT1cImNoZWNrYm94XCJcclxuXHRcdGNoZWNrZWQ9e2RuT25seX1cclxuXHRcdG9uOmNoYW5nZT17KCkgPT4gKGRuT25seSA9ICFkbk9ubHkpfVxyXG5cdC8+PC9sYWJlbFxyXG4+XHJcbnsjaWYgZG5Pbmx5fVxyXG5cdDxsYWJlbD5cclxuXHRcdFN0YXJ0XHJcblx0XHQ8aW5wdXRcclxuXHRcdFx0dHlwZT1cImRhdGVcIlxyXG5cdFx0XHR2YWx1ZT17bWluRGF0ZVN0cn1cclxuXHRcdFx0bWluPXttaW5EYXRlU3RyfVxyXG5cdFx0XHRtYXg9e21heERhdGVTdHJ9XHJcblx0XHRcdG9uOmNoYW5nZT17KGUpID0+IChzdGFydERhdGUgPSBEYXRlVGltZS5mcm9tSVNPKGUudGFyZ2V0LnZhbHVlKSl9XHJcblx0XHQvPlxyXG5cdDwvbGFiZWw+XHJcblx0PGxhYmVsPlxyXG5cdFx0RW5kXHJcblx0XHQ8aW5wdXRcclxuXHRcdFx0dHlwZT1cImRhdGVcIlxyXG5cdFx0XHR2YWx1ZT17bWF4RGF0ZVN0cn1cclxuXHRcdFx0bWluPXttaW5EYXRlU3RyfVxyXG5cdFx0XHRtYXg9e21heERhdGVTdHJ9XHJcblx0XHRcdG9uOmNoYW5nZT17KGUpID0+IChlbmREYXRlID0gRGF0ZVRpbWUuZnJvbUlTTyhlLnRhcmdldC52YWx1ZSkpfVxyXG5cdFx0Lz5cclxuXHQ8L2xhYmVsPlxyXG57L2lmfVxyXG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGNsZWFuKCQkcHJvcHMsIGV4dHJhX2tleXMpIHtcbiAgbGV0IGtleXMgPSBbXCJjaGlsZHJlblwiLCBcIiQkc2NvcGVcIiwgXCIkJHNsb3RzXCJdLmNvbmNhdChleHRyYV9rZXlzKVxuICBjb25zdCByZXN0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKCQkcHJvcHMpKSB7XG4gICAgaWYgKCEoa2V5cy5pbmNsdWRlcyhrZXkpKSkge1xuICAgICAgcmVzdFtrZXldID0gJCRwcm9wc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdDtcbn1cbiIsICIvKiFcbiAqIENoYXJ0LmpzIHYzLjcuMFxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDIxIENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGZvbnRTdHJpbmcocGl4ZWxTaXplLCBmb250U3R5bGUsIGZvbnRGYW1pbHkpIHtcbiAgcmV0dXJuIGZvbnRTdHlsZSArICcgJyArIHBpeGVsU2l6ZSArICdweCAnICsgZm9udEZhbWlseTtcbn1cbmNvbnN0IHJlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbn0oKSk7XG5mdW5jdGlvbiB0aHJvdHRsZWQoZm4sIHRoaXNBcmcsIHVwZGF0ZUZuKSB7XG4gIGNvbnN0IHVwZGF0ZUFyZ3MgPSB1cGRhdGVGbiB8fCAoKGFyZ3MpID0+IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpKTtcbiAgbGV0IHRpY2tpbmcgPSBmYWxzZTtcbiAgbGV0IGFyZ3MgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLnJlc3QpIHtcbiAgICBhcmdzID0gdXBkYXRlQXJncyhyZXN0KTtcbiAgICBpZiAoIXRpY2tpbmcpIHtcbiAgICAgIHRpY2tpbmcgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgICB0aWNraW5nID0gZmFsc2U7XG4gICAgICAgIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZGVib3VuY2UoZm4sIGRlbGF5KSB7XG4gIGxldCB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGlmIChkZWxheSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZm4sIGRlbGF5LCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBkZWxheTtcbiAgfTtcbn1cbmNvbnN0IF90b0xlZnRSaWdodENlbnRlciA9IChhbGlnbikgPT4gYWxpZ24gPT09ICdzdGFydCcgPyAnbGVmdCcgOiBhbGlnbiA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2NlbnRlcic7XG5jb25zdCBfYWxpZ25TdGFydEVuZCA9IChhbGlnbiwgc3RhcnQsIGVuZCkgPT4gYWxpZ24gPT09ICdzdGFydCcgPyBzdGFydCA6IGFsaWduID09PSAnZW5kJyA/IGVuZCA6IChzdGFydCArIGVuZCkgLyAyO1xuY29uc3QgX3RleHRYID0gKGFsaWduLCBsZWZ0LCByaWdodCwgcnRsKSA9PiB7XG4gIGNvbnN0IGNoZWNrID0gcnRsID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgcmV0dXJuIGFsaWduID09PSBjaGVjayA/IHJpZ2h0IDogYWxpZ24gPT09ICdjZW50ZXInID8gKGxlZnQgKyByaWdodCkgLyAyIDogbGVmdDtcbn07XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuY29uc3QgdWlkID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgaWQgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlkKys7XG4gIH07XG59KCkpO1xuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHR5cGUuc3Vic3RyKDAsIDcpID09PSAnW29iamVjdCcgJiYgdHlwZS5zdWJzdHIoLTYpID09PSAnQXJyYXldJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cbmNvbnN0IGlzTnVtYmVyRmluaXRlID0gKHZhbHVlKSA9PiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgaXNGaW5pdGUoK3ZhbHVlKTtcbmZ1bmN0aW9uIGZpbml0ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiBpc051bWJlckZpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cbmZ1bmN0aW9uIHZhbHVlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbn1cbmNvbnN0IHRvUGVyY2VudGFnZSA9ICh2YWx1ZSwgZGltZW5zaW9uKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwXG4gICAgOiB2YWx1ZSAvIGRpbWVuc2lvbjtcbmNvbnN0IHRvRGltZW5zaW9uID0gKHZhbHVlLCBkaW1lbnNpb24pID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/XG4gICAgcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBkaW1lbnNpb25cbiAgICA6ICt2YWx1ZTtcbmZ1bmN0aW9uIGNhbGxiYWNrKGZuLCBhcmdzLCB0aGlzQXJnKSB7XG4gIGlmIChmbiAmJiB0eXBlb2YgZm4uY2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZWFjaChsb29wYWJsZSwgZm4sIHRoaXNBcmcsIHJldmVyc2UpIHtcbiAgbGV0IGksIGxlbiwga2V5cztcbiAgaWYgKGlzQXJyYXkobG9vcGFibGUpKSB7XG4gICAgbGVuID0gbG9vcGFibGUubGVuZ3RoO1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChsb29wYWJsZSkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xuICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfZWxlbWVudHNFcXVhbChhMCwgYTEpIHtcbiAgbGV0IGksIGlsZW4sIHYwLCB2MTtcbiAgaWYgKCFhMCB8fCAhYTEgfHwgYTAubGVuZ3RoICE9PSBhMS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHYwID0gYTBbaV07XG4gICAgdjEgPSBhMVtpXTtcbiAgICBpZiAodjAuZGF0YXNldEluZGV4ICE9PSB2MS5kYXRhc2V0SW5kZXggfHwgdjAuaW5kZXggIT09IHYxLmluZGV4KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2xvbmUkMShzb3VyY2UpIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2UubWFwKGNsb25lJDEpO1xuICB9XG4gIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBjb25zdCBrbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGsgPSAwO1xuICAgIGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICB0YXJnZXRba2V5c1trXV0gPSBjbG9uZSQxKHNvdXJjZVtrZXlzW2tdXSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgcmV0dXJuIHNvdXJjZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBbJ19fcHJvdG9fXycsICdwcm90b3R5cGUnLCAnY29uc3RydWN0b3InXS5pbmRleE9mKGtleSkgPT09IC0xO1xufVxuZnVuY3Rpb24gX21lcmdlcihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICBtZXJnZSh0dmFsLCBzdmFsLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lJDEoc3ZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNvdXJjZXMgPSBpc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBbc291cmNlXTtcbiAgY29uc3QgaWxlbiA9IHNvdXJjZXMubGVuZ3RoO1xuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBtZXJnZXIgPSBvcHRpb25zLm1lcmdlciB8fCBfbWVyZ2VyO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgaWYgKCFpc09iamVjdChzb3VyY2UpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgZm9yIChsZXQgayA9IDAsIGtsZW4gPSBrZXlzLmxlbmd0aDsgayA8IGtsZW47ICsraykge1xuICAgICAgbWVyZ2VyKGtleXNba10sIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIG1lcmdlSWYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG1lcmdlKHRhcmdldCwgc291cmNlLCB7bWVyZ2VyOiBfbWVyZ2VySWZ9KTtcbn1cbmZ1bmN0aW9uIF9tZXJnZXJJZihrZXksIHRhcmdldCwgc291cmNlKSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICBtZXJnZUlmKHR2YWwsIHN2YWwpO1xuICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZSQxKHN2YWwpO1xuICB9XG59XG5mdW5jdGlvbiBfZGVwcmVjYXRlZChzY29wZSwgdmFsdWUsIHByZXZpb3VzLCBjdXJyZW50KSB7XG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKHNjb3BlICsgJzogXCInICsgcHJldmlvdXMgK1xuXHRcdFx0J1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCInICsgY3VycmVudCArICdcIiBpbnN0ZWFkJyk7XG4gIH1cbn1cbmNvbnN0IGVtcHR5U3RyaW5nID0gJyc7XG5jb25zdCBkb3QgPSAnLic7XG5mdW5jdGlvbiBpbmRleE9mRG90T3JMZW5ndGgoa2V5LCBzdGFydCkge1xuICBjb25zdCBpZHggPSBrZXkuaW5kZXhPZihkb3QsIHN0YXJ0KTtcbiAgcmV0dXJuIGlkeCA9PT0gLTEgPyBrZXkubGVuZ3RoIDogaWR4O1xufVxuZnVuY3Rpb24gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSkge1xuICBpZiAoa2V5ID09PSBlbXB0eVN0cmluZykge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgbGV0IHBvcyA9IDA7XG4gIGxldCBpZHggPSBpbmRleE9mRG90T3JMZW5ndGgoa2V5LCBwb3MpO1xuICB3aGlsZSAob2JqICYmIGlkeCA+IHBvcykge1xuICAgIG9iaiA9IG9ialtrZXkuc3Vic3RyKHBvcywgaWR4IC0gcG9zKV07XG4gICAgcG9zID0gaWR4ICsgMTtcbiAgICBpZHggPSBpbmRleE9mRG90T3JMZW5ndGgoa2V5LCBwb3MpO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfY2FwaXRhbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cbmNvbnN0IGRlZmluZWQgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG5jb25zdCBzZXRzRXF1YWwgPSAoYSwgYikgPT4ge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBpdGVtIG9mIGEpIHtcbiAgICBpZiAoIWIuaGFzKGl0ZW0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIF9pc0NsaWNrRXZlbnQoZSkge1xuICByZXR1cm4gZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ2NvbnRleHRtZW51Jztcbn1cblxuY29uc3QgUEkgPSBNYXRoLlBJO1xuY29uc3QgVEFVID0gMiAqIFBJO1xuY29uc3QgUElUQVUgPSBUQVUgKyBQSTtcbmNvbnN0IElORklOSVRZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuY29uc3QgUkFEX1BFUl9ERUcgPSBQSSAvIDE4MDtcbmNvbnN0IEhBTEZfUEkgPSBQSSAvIDI7XG5jb25zdCBRVUFSVEVSX1BJID0gUEkgLyA0O1xuY29uc3QgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XG5jb25zdCBsb2cxMCA9IE1hdGgubG9nMTA7XG5jb25zdCBzaWduID0gTWF0aC5zaWduO1xuZnVuY3Rpb24gbmljZU51bShyYW5nZSkge1xuICBjb25zdCByb3VuZGVkUmFuZ2UgPSBNYXRoLnJvdW5kKHJhbmdlKTtcbiAgcmFuZ2UgPSBhbG1vc3RFcXVhbHMocmFuZ2UsIHJvdW5kZWRSYW5nZSwgcmFuZ2UgLyAxMDAwKSA/IHJvdW5kZWRSYW5nZSA6IHJhbmdlO1xuICBjb25zdCBuaWNlUmFuZ2UgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChyYW5nZSkpKTtcbiAgY29uc3QgZnJhY3Rpb24gPSByYW5nZSAvIG5pY2VSYW5nZTtcbiAgY29uc3QgbmljZUZyYWN0aW9uID0gZnJhY3Rpb24gPD0gMSA/IDEgOiBmcmFjdGlvbiA8PSAyID8gMiA6IGZyYWN0aW9uIDw9IDUgPyA1IDogMTA7XG4gIHJldHVybiBuaWNlRnJhY3Rpb24gKiBuaWNlUmFuZ2U7XG59XG5mdW5jdGlvbiBfZmFjdG9yaXplKHZhbHVlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0KHZhbHVlKTtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDE7IGkgPCBzcXJ0OyBpKyspIHtcbiAgICBpZiAodmFsdWUgJSBpID09PSAwKSB7XG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlIC8gaSk7XG4gICAgfVxuICB9XG4gIGlmIChzcXJ0ID09PSAoc3FydCB8IDApKSB7XG4gICAgcmVzdWx0LnB1c2goc3FydCk7XG4gIH1cbiAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IGEgLSBiKS5wb3AoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cbmZ1bmN0aW9uIGFsbW9zdEVxdWFscyh4LCB5LCBlcHNpbG9uKSB7XG4gIHJldHVybiBNYXRoLmFicyh4IC0geSkgPCBlcHNpbG9uO1xufVxuZnVuY3Rpb24gYWxtb3N0V2hvbGUoeCwgZXBzaWxvbikge1xuICBjb25zdCByb3VuZGVkID0gTWF0aC5yb3VuZCh4KTtcbiAgcmV0dXJuICgocm91bmRlZCAtIGVwc2lsb24pIDw9IHgpICYmICgocm91bmRlZCArIGVwc2lsb24pID49IHgpO1xufVxuZnVuY3Rpb24gX3NldE1pbkFuZE1heEJ5S2V5KGFycmF5LCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIHZhbHVlID0gYXJyYXlbaV1bcHJvcGVydHldO1xuICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICB0YXJnZXQubWluID0gTWF0aC5taW4odGFyZ2V0Lm1pbiwgdmFsdWUpO1xuICAgICAgdGFyZ2V0Lm1heCA9IE1hdGgubWF4KHRhcmdldC5tYXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzKSB7XG4gIHJldHVybiBkZWdyZWVzICogKFBJIC8gMTgwKTtcbn1cbmZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zKSB7XG4gIHJldHVybiByYWRpYW5zICogKDE4MCAvIFBJKTtcbn1cbmZ1bmN0aW9uIF9kZWNpbWFsUGxhY2VzKHgpIHtcbiAgaWYgKCFpc051bWJlckZpbml0ZSh4KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZSA9IDE7XG4gIGxldCBwID0gMDtcbiAgd2hpbGUgKE1hdGgucm91bmQoeCAqIGUpIC8gZSAhPT0geCkge1xuICAgIGUgKj0gMTA7XG4gICAgcCsrO1xuICB9XG4gIHJldHVybiBwO1xufVxuZnVuY3Rpb24gZ2V0QW5nbGVGcm9tUG9pbnQoY2VudHJlUG9pbnQsIGFuZ2xlUG9pbnQpIHtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWENlbnRlciA9IGFuZ2xlUG9pbnQueCAtIGNlbnRyZVBvaW50Lng7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVlDZW50ZXIgPSBhbmdsZVBvaW50LnkgLSBjZW50cmVQb2ludC55O1xuICBjb25zdCByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIgPSBNYXRoLnNxcnQoZGlzdGFuY2VGcm9tWENlbnRlciAqIGRpc3RhbmNlRnJvbVhDZW50ZXIgKyBkaXN0YW5jZUZyb21ZQ2VudGVyICogZGlzdGFuY2VGcm9tWUNlbnRlcik7XG4gIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XG4gIGlmIChhbmdsZSA8ICgtMC41ICogUEkpKSB7XG4gICAgYW5nbGUgKz0gVEFVO1xuICB9XG4gIHJldHVybiB7XG4gICAgYW5nbGUsXG4gICAgZGlzdGFuY2U6IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlclxuICB9O1xufVxuZnVuY3Rpb24gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHB0MSwgcHQyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocHQyLnggLSBwdDEueCwgMikgKyBNYXRoLnBvdyhwdDIueSAtIHB0MS55LCAyKSk7XG59XG5mdW5jdGlvbiBfYW5nbGVEaWZmKGEsIGIpIHtcbiAgcmV0dXJuIChhIC0gYiArIFBJVEFVKSAlIFRBVSAtIFBJO1xufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUFuZ2xlKGEpIHtcbiAgcmV0dXJuIChhICUgVEFVICsgVEFVKSAlIFRBVTtcbn1cbmZ1bmN0aW9uIF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0LCBlbmQsIHNhbWVBbmdsZUlzRnVsbENpcmNsZSkge1xuICBjb25zdCBhID0gX25vcm1hbGl6ZUFuZ2xlKGFuZ2xlKTtcbiAgY29uc3QgcyA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gIGNvbnN0IGUgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgY29uc3QgYW5nbGVUb1N0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHMgLSBhKTtcbiAgY29uc3QgYW5nbGVUb0VuZCA9IF9ub3JtYWxpemVBbmdsZShlIC0gYSk7XG4gIGNvbnN0IHN0YXJ0VG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gcyk7XG4gIGNvbnN0IGVuZFRvQW5nbGUgPSBfbm9ybWFsaXplQW5nbGUoYSAtIGUpO1xuICByZXR1cm4gYSA9PT0gcyB8fCBhID09PSBlIHx8IChzYW1lQW5nbGVJc0Z1bGxDaXJjbGUgJiYgcyA9PT0gZSlcbiAgICB8fCAoYW5nbGVUb1N0YXJ0ID4gYW5nbGVUb0VuZCAmJiBzdGFydFRvQW5nbGUgPCBlbmRUb0FuZ2xlKTtcbn1cbmZ1bmN0aW9uIF9saW1pdFZhbHVlKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBfaW50MTZSYW5nZSh2YWx1ZSkge1xuICByZXR1cm4gX2xpbWl0VmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xufVxuZnVuY3Rpb24gX2lzQmV0d2Vlbih2YWx1ZSwgc3RhcnQsIGVuZCwgZXBzaWxvbiA9IDFlLTYpIHtcbiAgcmV0dXJuIHZhbHVlID49IE1hdGgubWluKHN0YXJ0LCBlbmQpIC0gZXBzaWxvbiAmJiB2YWx1ZSA8PSBNYXRoLm1heChzdGFydCwgZW5kKSArIGVwc2lsb247XG59XG5cbmNvbnN0IGF0RWRnZSA9ICh0KSA9PiB0ID09PSAwIHx8IHQgPT09IDE7XG5jb25zdCBlbGFzdGljSW4gPSAodCwgcywgcCkgPT4gLShNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiBUQVUgLyBwKSk7XG5jb25zdCBlbGFzdGljT3V0ID0gKHQsIHMsIHApID0+IE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApICsgMTtcbmNvbnN0IGVmZmVjdHMgPSB7XG4gIGxpbmVhcjogdCA9PiB0LFxuICBlYXNlSW5RdWFkOiB0ID0+IHQgKiB0LFxuICBlYXNlT3V0UXVhZDogdCA9PiAtdCAqICh0IC0gMiksXG4gIGVhc2VJbk91dFF1YWQ6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHRcbiAgICA6IC0wLjUgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSksXG4gIGVhc2VJbkN1YmljOiB0ID0+IHQgKiB0ICogdCxcbiAgZWFzZU91dEN1YmljOiB0ID0+ICh0IC09IDEpICogdCAqIHQgKyAxLFxuICBlYXNlSW5PdXRDdWJpYzogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICsgMiksXG4gIGVhc2VJblF1YXJ0OiB0ID0+IHQgKiB0ICogdCAqIHQsXG4gIGVhc2VPdXRRdWFydDogdCA9PiAtKCh0IC09IDEpICogdCAqIHQgKiB0IC0gMSksXG4gIGVhc2VJbk91dFF1YXJ0OiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdCAqIHRcbiAgICA6IC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKSxcbiAgZWFzZUluUXVpbnQ6IHQgPT4gdCAqIHQgKiB0ICogdCAqIHQsXG4gIGVhc2VPdXRRdWludDogdCA9PiAodCAtPSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxLFxuICBlYXNlSW5PdXRRdWludDogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0ICogdFxuICAgIDogMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpLFxuICBlYXNlSW5TaW5lOiB0ID0+IC1NYXRoLmNvcyh0ICogSEFMRl9QSSkgKyAxLFxuICBlYXNlT3V0U2luZTogdCA9PiBNYXRoLnNpbih0ICogSEFMRl9QSSksXG4gIGVhc2VJbk91dFNpbmU6IHQgPT4gLTAuNSAqIChNYXRoLmNvcyhQSSAqIHQpIC0gMSksXG4gIGVhc2VJbkV4cG86IHQgPT4gKHQgPT09IDApID8gMCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSksXG4gIGVhc2VPdXRFeHBvOiB0ID0+ICh0ID09PSAxKSA/IDEgOiAtTWF0aC5wb3coMiwgLTEwICogdCkgKyAxLFxuICBlYXNlSW5PdXRFeHBvOiB0ID0+IGF0RWRnZSh0KSA/IHQgOiB0IDwgMC41XG4gICAgPyAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0ICogMiAtIDEpKVxuICAgIDogMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAodCAqIDIgLSAxKSkgKyAyKSxcbiAgZWFzZUluQ2lyYzogdCA9PiAodCA+PSAxKSA/IHQgOiAtKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSksXG4gIGVhc2VPdXRDaXJjOiB0ID0+IE1hdGguc3FydCgxIC0gKHQgLT0gMSkgKiB0KSxcbiAgZWFzZUluT3V0Q2lyYzogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSlcbiAgICA6IDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSxcbiAgZWFzZUluRWxhc3RpYzogdCA9PiBhdEVkZ2UodCkgPyB0IDogZWxhc3RpY0luKHQsIDAuMDc1LCAwLjMpLFxuICBlYXNlT3V0RWxhc3RpYzogdCA9PiBhdEVkZ2UodCkgPyB0IDogZWxhc3RpY091dCh0LCAwLjA3NSwgMC4zKSxcbiAgZWFzZUluT3V0RWxhc3RpYyh0KSB7XG4gICAgY29uc3QgcyA9IDAuMTEyNTtcbiAgICBjb25zdCBwID0gMC40NTtcbiAgICByZXR1cm4gYXRFZGdlKHQpID8gdCA6XG4gICAgICB0IDwgMC41XG4gICAgICAgID8gMC41ICogZWxhc3RpY0luKHQgKiAyLCBzLCBwKVxuICAgICAgICA6IDAuNSArIDAuNSAqIGVsYXN0aWNPdXQodCAqIDIgLSAxLCBzLCBwKTtcbiAgfSxcbiAgZWFzZUluQmFjayh0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH0sXG4gIGVhc2VPdXRCYWNrKHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gKHQgLT0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xuICB9LFxuICBlYXNlSW5PdXRCYWNrKHQpIHtcbiAgICBsZXQgcyA9IDEuNzAxNTg7XG4gICAgaWYgKCh0IC89IDAuNSkgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogKHQgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCAtIHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKTtcbiAgfSxcbiAgZWFzZUluQm91bmNlOiB0ID0+IDEgLSBlZmZlY3RzLmVhc2VPdXRCb3VuY2UoMSAtIHQpLFxuICBlYXNlT3V0Qm91bmNlKHQpIHtcbiAgICBjb25zdCBtID0gNy41NjI1O1xuICAgIGNvbnN0IGQgPSAyLjc1O1xuICAgIGlmICh0IDwgKDEgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiB0ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAoMiAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgxLjUgLyBkKSkgKiB0ICsgMC43NTtcbiAgICB9XG4gICAgaWYgKHQgPCAoMi41IC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDIuMjUgLyBkKSkgKiB0ICsgMC45Mzc1O1xuICAgIH1cbiAgICByZXR1cm4gbSAqICh0IC09ICgyLjYyNSAvIGQpKSAqIHQgKyAwLjk4NDM3NTtcbiAgfSxcbiAgZWFzZUluT3V0Qm91bmNlOiB0ID0+ICh0IDwgMC41KVxuICAgID8gZWZmZWN0cy5lYXNlSW5Cb3VuY2UodCAqIDIpICogMC41XG4gICAgOiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNSxcbn07XG5cbi8qIVxuICogQGt1cmtsZS9jb2xvciB2MC4xLjlcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rdXJrbGUvY29sb3IjcmVhZG1lXG4gKiAoYykgMjAyMCBKdWtrYSBLdXJrZWxhXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuY29uc3QgbWFwID0gezA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksIEE6IDEwLCBCOiAxMSwgQzogMTIsIEQ6IDEzLCBFOiAxNCwgRjogMTUsIGE6IDEwLCBiOiAxMSwgYzogMTIsIGQ6IDEzLCBlOiAxNCwgZjogMTV9O1xuY29uc3QgaGV4ID0gJzAxMjM0NTY3ODlBQkNERUYnO1xuY29uc3QgaDEgPSAoYikgPT4gaGV4W2IgJiAweEZdO1xuY29uc3QgaDIgPSAoYikgPT4gaGV4WyhiICYgMHhGMCkgPj4gNF0gKyBoZXhbYiAmIDB4Rl07XG5jb25zdCBlcSA9IChiKSA9PiAoKChiICYgMHhGMCkgPj4gNCkgPT09IChiICYgMHhGKSk7XG5mdW5jdGlvbiBpc1Nob3J0KHYpIHtcblx0cmV0dXJuIGVxKHYucikgJiYgZXEodi5nKSAmJiBlcSh2LmIpICYmIGVxKHYuYSk7XG59XG5mdW5jdGlvbiBoZXhQYXJzZShzdHIpIHtcblx0dmFyIGxlbiA9IHN0ci5sZW5ndGg7XG5cdHZhciByZXQ7XG5cdGlmIChzdHJbMF0gPT09ICcjJykge1xuXHRcdGlmIChsZW4gPT09IDQgfHwgbGVuID09PSA1KSB7XG5cdFx0XHRyZXQgPSB7XG5cdFx0XHRcdHI6IDI1NSAmIG1hcFtzdHJbMV1dICogMTcsXG5cdFx0XHRcdGc6IDI1NSAmIG1hcFtzdHJbMl1dICogMTcsXG5cdFx0XHRcdGI6IDI1NSAmIG1hcFtzdHJbM11dICogMTcsXG5cdFx0XHRcdGE6IGxlbiA9PT0gNSA/IG1hcFtzdHJbNF1dICogMTcgOiAyNTVcblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmIChsZW4gPT09IDcgfHwgbGVuID09PSA5KSB7XG5cdFx0XHRyZXQgPSB7XG5cdFx0XHRcdHI6IG1hcFtzdHJbMV1dIDw8IDQgfCBtYXBbc3RyWzJdXSxcblx0XHRcdFx0ZzogbWFwW3N0clszXV0gPDwgNCB8IG1hcFtzdHJbNF1dLFxuXHRcdFx0XHRiOiBtYXBbc3RyWzVdXSA8PCA0IHwgbWFwW3N0cls2XV0sXG5cdFx0XHRcdGE6IGxlbiA9PT0gOSA/IChtYXBbc3RyWzddXSA8PCA0IHwgbWFwW3N0cls4XV0pIDogMjU1XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gaGV4U3RyaW5nKHYpIHtcblx0dmFyIGYgPSBpc1Nob3J0KHYpID8gaDEgOiBoMjtcblx0cmV0dXJuIHZcblx0XHQ/ICcjJyArIGYodi5yKSArIGYodi5nKSArIGYodi5iKSArICh2LmEgPCAyNTUgPyBmKHYuYSkgOiAnJylcblx0XHQ6IHY7XG59XG5mdW5jdGlvbiByb3VuZCh2KSB7XG5cdHJldHVybiB2ICsgMC41IHwgMDtcbn1cbmNvbnN0IGxpbSA9ICh2LCBsLCBoKSA9PiBNYXRoLm1heChNYXRoLm1pbih2LCBoKSwgbCk7XG5mdW5jdGlvbiBwMmIodikge1xuXHRyZXR1cm4gbGltKHJvdW5kKHYgKiAyLjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIG4yYih2KSB7XG5cdHJldHVybiBsaW0ocm91bmQodiAqIDI1NSksIDAsIDI1NSk7XG59XG5mdW5jdGlvbiBiMm4odikge1xuXHRyZXR1cm4gbGltKHJvdW5kKHYgLyAyLjU1KSAvIDEwMCwgMCwgMSk7XG59XG5mdW5jdGlvbiBuMnAodikge1xuXHRyZXR1cm4gbGltKHJvdW5kKHYgKiAxMDApLCAwLCAxMDApO1xufVxuY29uc3QgUkdCX1JFID0gL15yZ2JhP1xcKFxccyooWy0rLlxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/KD86W1xccywvXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiByZ2JQYXJzZShzdHIpIHtcblx0Y29uc3QgbSA9IFJHQl9SRS5leGVjKHN0cik7XG5cdGxldCBhID0gMjU1O1xuXHRsZXQgciwgZywgYjtcblx0aWYgKCFtKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGlmIChtWzddICE9PSByKSB7XG5cdFx0Y29uc3QgdiA9ICttWzddO1xuXHRcdGEgPSAyNTUgJiAobVs4XSA/IHAyYih2KSA6IHYgKiAyNTUpO1xuXHR9XG5cdHIgPSArbVsxXTtcblx0ZyA9ICttWzNdO1xuXHRiID0gK21bNV07XG5cdHIgPSAyNTUgJiAobVsyXSA/IHAyYihyKSA6IHIpO1xuXHRnID0gMjU1ICYgKG1bNF0gPyBwMmIoZykgOiBnKTtcblx0YiA9IDI1NSAmIChtWzZdID8gcDJiKGIpIDogYik7XG5cdHJldHVybiB7XG5cdFx0cjogcixcblx0XHRnOiBnLFxuXHRcdGI6IGIsXG5cdFx0YTogYVxuXHR9O1xufVxuZnVuY3Rpb24gcmdiU3RyaW5nKHYpIHtcblx0cmV0dXJuIHYgJiYgKFxuXHRcdHYuYSA8IDI1NVxuXHRcdFx0PyBgcmdiYSgke3Yucn0sICR7di5nfSwgJHt2LmJ9LCAke2Iybih2LmEpfSlgXG5cdFx0XHQ6IGByZ2IoJHt2LnJ9LCAke3YuZ30sICR7di5ifSlgXG5cdCk7XG59XG5jb25zdCBIVUVfUkUgPSAvXihoc2xhP3xod2J8aHN2KVxcKFxccyooWy0rLmVcXGRdKykoPzpkZWcpP1tcXHMsXSsoWy0rLmVcXGRdKyklW1xccyxdKyhbLSsuZVxcZF0rKSUoPzpbXFxzLF0rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gaHNsMnJnYm4oaCwgcywgbCkge1xuXHRjb25zdCBhID0gcyAqIE1hdGgubWluKGwsIDEgLSBsKTtcblx0Y29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gMzApICUgMTIpID0+IGwgLSBhICogTWF0aC5tYXgoTWF0aC5taW4oayAtIDMsIDkgLSBrLCAxKSwgLTEpO1xuXHRyZXR1cm4gW2YoMCksIGYoOCksIGYoNCldO1xufVxuZnVuY3Rpb24gaHN2MnJnYm4oaCwgcywgdikge1xuXHRjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyA2MCkgJSA2KSA9PiB2IC0gdiAqIHMgKiBNYXRoLm1heChNYXRoLm1pbihrLCA0IC0gaywgMSksIDApO1xuXHRyZXR1cm4gW2YoNSksIGYoMyksIGYoMSldO1xufVxuZnVuY3Rpb24gaHdiMnJnYm4oaCwgdywgYikge1xuXHRjb25zdCByZ2IgPSBoc2wycmdibihoLCAxLCAwLjUpO1xuXHRsZXQgaTtcblx0aWYgKHcgKyBiID4gMSkge1xuXHRcdGkgPSAxIC8gKHcgKyBiKTtcblx0XHR3ICo9IGk7XG5cdFx0YiAqPSBpO1xuXHR9XG5cdGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRyZ2JbaV0gKj0gMSAtIHcgLSBiO1xuXHRcdHJnYltpXSArPSB3O1xuXHR9XG5cdHJldHVybiByZ2I7XG59XG5mdW5jdGlvbiByZ2IyaHNsKHYpIHtcblx0Y29uc3QgcmFuZ2UgPSAyNTU7XG5cdGNvbnN0IHIgPSB2LnIgLyByYW5nZTtcblx0Y29uc3QgZyA9IHYuZyAvIHJhbmdlO1xuXHRjb25zdCBiID0gdi5iIC8gcmFuZ2U7XG5cdGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXHRjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcblx0Y29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcblx0bGV0IGgsIHMsIGQ7XG5cdGlmIChtYXggIT09IG1pbikge1xuXHRcdGQgPSBtYXggLSBtaW47XG5cdFx0cyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuXHRcdGggPSBtYXggPT09IHJcblx0XHRcdD8gKChnIC0gYikgLyBkKSArIChnIDwgYiA/IDYgOiAwKVxuXHRcdFx0OiBtYXggPT09IGdcblx0XHRcdFx0PyAoYiAtIHIpIC8gZCArIDJcblx0XHRcdFx0OiAociAtIGcpIC8gZCArIDQ7XG5cdFx0aCA9IGggKiA2MCArIDAuNTtcblx0fVxuXHRyZXR1cm4gW2ggfCAwLCBzIHx8IDAsIGxdO1xufVxuZnVuY3Rpb24gY2FsbG4oZiwgYSwgYiwgYykge1xuXHRyZXR1cm4gKFxuXHRcdEFycmF5LmlzQXJyYXkoYSlcblx0XHRcdD8gZihhWzBdLCBhWzFdLCBhWzJdKVxuXHRcdFx0OiBmKGEsIGIsIGMpXG5cdCkubWFwKG4yYik7XG59XG5mdW5jdGlvbiBoc2wycmdiKGgsIHMsIGwpIHtcblx0cmV0dXJuIGNhbGxuKGhzbDJyZ2JuLCBoLCBzLCBsKTtcbn1cbmZ1bmN0aW9uIGh3YjJyZ2IoaCwgdywgYikge1xuXHRyZXR1cm4gY2FsbG4oaHdiMnJnYm4sIGgsIHcsIGIpO1xufVxuZnVuY3Rpb24gaHN2MnJnYihoLCBzLCB2KSB7XG5cdHJldHVybiBjYWxsbihoc3YycmdibiwgaCwgcywgdik7XG59XG5mdW5jdGlvbiBodWUoaCkge1xuXHRyZXR1cm4gKGggJSAzNjAgKyAzNjApICUgMzYwO1xufVxuZnVuY3Rpb24gaHVlUGFyc2Uoc3RyKSB7XG5cdGNvbnN0IG0gPSBIVUVfUkUuZXhlYyhzdHIpO1xuXHRsZXQgYSA9IDI1NTtcblx0bGV0IHY7XG5cdGlmICghbSkge1xuXHRcdHJldHVybjtcblx0fVxuXHRpZiAobVs1XSAhPT0gdikge1xuXHRcdGEgPSBtWzZdID8gcDJiKCttWzVdKSA6IG4yYigrbVs1XSk7XG5cdH1cblx0Y29uc3QgaCA9IGh1ZSgrbVsyXSk7XG5cdGNvbnN0IHAxID0gK21bM10gLyAxMDA7XG5cdGNvbnN0IHAyID0gK21bNF0gLyAxMDA7XG5cdGlmIChtWzFdID09PSAnaHdiJykge1xuXHRcdHYgPSBod2IycmdiKGgsIHAxLCBwMik7XG5cdH0gZWxzZSBpZiAobVsxXSA9PT0gJ2hzdicpIHtcblx0XHR2ID0gaHN2MnJnYihoLCBwMSwgcDIpO1xuXHR9IGVsc2Uge1xuXHRcdHYgPSBoc2wycmdiKGgsIHAxLCBwMik7XG5cdH1cblx0cmV0dXJuIHtcblx0XHRyOiB2WzBdLFxuXHRcdGc6IHZbMV0sXG5cdFx0YjogdlsyXSxcblx0XHRhOiBhXG5cdH07XG59XG5mdW5jdGlvbiByb3RhdGUodiwgZGVnKSB7XG5cdHZhciBoID0gcmdiMmhzbCh2KTtcblx0aFswXSA9IGh1ZShoWzBdICsgZGVnKTtcblx0aCA9IGhzbDJyZ2IoaCk7XG5cdHYuciA9IGhbMF07XG5cdHYuZyA9IGhbMV07XG5cdHYuYiA9IGhbMl07XG59XG5mdW5jdGlvbiBoc2xTdHJpbmcodikge1xuXHRpZiAoIXYpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0Y29uc3QgYSA9IHJnYjJoc2wodik7XG5cdGNvbnN0IGggPSBhWzBdO1xuXHRjb25zdCBzID0gbjJwKGFbMV0pO1xuXHRjb25zdCBsID0gbjJwKGFbMl0pO1xuXHRyZXR1cm4gdi5hIDwgMjU1XG5cdFx0PyBgaHNsYSgke2h9LCAke3N9JSwgJHtsfSUsICR7YjJuKHYuYSl9KWBcblx0XHQ6IGBoc2woJHtofSwgJHtzfSUsICR7bH0lKWA7XG59XG5jb25zdCBtYXAkMSA9IHtcblx0eDogJ2RhcmsnLFxuXHRaOiAnbGlnaHQnLFxuXHRZOiAncmUnLFxuXHRYOiAnYmx1Jyxcblx0VzogJ2dyJyxcblx0VjogJ21lZGl1bScsXG5cdFU6ICdzbGF0ZScsXG5cdEE6ICdlZScsXG5cdFQ6ICdvbCcsXG5cdFM6ICdvcicsXG5cdEI6ICdyYScsXG5cdEM6ICdsYXRlZycsXG5cdEQ6ICdpZ2h0cycsXG5cdFI6ICdpbicsXG5cdFE6ICd0dXJxdW9pcycsXG5cdEU6ICdoaScsXG5cdFA6ICdybycsXG5cdE86ICdhbCcsXG5cdE46ICdsZScsXG5cdE06ICdkZScsXG5cdEw6ICd5ZWxsbycsXG5cdEY6ICdlbicsXG5cdEs6ICdjaCcsXG5cdEc6ICdhcmtzJyxcblx0SDogJ2VhJyxcblx0STogJ2lnaHRnJyxcblx0SjogJ3doJ1xufTtcbmNvbnN0IG5hbWVzID0ge1xuXHRPaWNlWGU6ICdmMGY4ZmYnLFxuXHRhbnRpcXVld0V0ZTogJ2ZhZWJkNycsXG5cdGFxdWE6ICdmZmZmJyxcblx0YXF1YW1hclJlOiAnN2ZmZmQ0Jyxcblx0YXp1WTogJ2YwZmZmZicsXG5cdGJlaWdlOiAnZjVmNWRjJyxcblx0YmlzcXVlOiAnZmZlNGM0Jyxcblx0YmxhY2s6ICcwJyxcblx0YmxhbktlZE9tb25kOiAnZmZlYmNkJyxcblx0WGU6ICdmZicsXG5cdFhldmlUZXQ6ICc4YTJiZTInLFxuXHRiUHduOiAnYTUyYTJhJyxcblx0YnVybHl3b29kOiAnZGViODg3Jyxcblx0Y2FNdFhlOiAnNWY5ZWEwJyxcblx0S2FydFl1c2U6ICc3ZmZmMDAnLFxuXHRLb2NUYXRlOiAnZDI2OTFlJyxcblx0Y1NPOiAnZmY3ZjUwJyxcblx0Y1NuZmxvd2VyWGU6ICc2NDk1ZWQnLFxuXHRjU25zaWxrOiAnZmZmOGRjJyxcblx0Y3JpbXNvbjogJ2RjMTQzYycsXG5cdGN5YW46ICdmZmZmJyxcblx0eFhlOiAnOGInLFxuXHR4Y3lhbjogJzhiOGInLFxuXHR4Z1RNblBkOiAnYjg4NjBiJyxcblx0eFdheTogJ2E5YTlhOScsXG5cdHhnWUY6ICc2NDAwJyxcblx0eGdZeTogJ2E5YTlhOScsXG5cdHhraGFraTogJ2JkYjc2YicsXG5cdHhtYWdGdGE6ICc4YjAwOGInLFxuXHR4VGl2ZWdZRjogJzU1NmIyZicsXG5cdHhTYW5nZTogJ2ZmOGMwMCcsXG5cdHhTY0VkOiAnOTkzMmNjJyxcblx0eFlkOiAnOGIwMDAwJyxcblx0eHNPbW9uOiAnZTk5NjdhJyxcblx0eHNIZ1lGOiAnOGZiYzhmJyxcblx0eFVYZTogJzQ4M2Q4YicsXG5cdHhVV2F5OiAnMmY0ZjRmJyxcblx0eFVnWXk6ICcyZjRmNGYnLFxuXHR4UWU6ICdjZWQxJyxcblx0eHZpVGV0OiAnOTQwMGQzJyxcblx0ZEFwcFJrOiAnZmYxNDkzJyxcblx0ZEFwc2t5WGU6ICdiZmZmJyxcblx0ZGltV2F5OiAnNjk2OTY5Jyxcblx0ZGltZ1l5OiAnNjk2OTY5Jyxcblx0ZG9kZ2VyWGU6ICcxZTkwZmYnLFxuXHRmaVlicmljazogJ2IyMjIyMicsXG5cdGZsU093RXRlOiAnZmZmYWYwJyxcblx0Zm9Zc3RXQW46ICcyMjhiMjInLFxuXHRmdUtzaWE6ICdmZjAwZmYnLFxuXHRnYVJzYlNvOiAnZGNkY2RjJyxcblx0Z2hvc3R3RXRlOiAnZjhmOGZmJyxcblx0Z1RkOiAnZmZkNzAwJyxcblx0Z1RNblBkOiAnZGFhNTIwJyxcblx0V2F5OiAnODA4MDgwJyxcblx0Z1lGOiAnODAwMCcsXG5cdGdZRkx3OiAnYWRmZjJmJyxcblx0Z1l5OiAnODA4MDgwJyxcblx0aG9uZXlNdzogJ2YwZmZmMCcsXG5cdGhvdHBSazogJ2ZmNjliNCcsXG5cdFJkaWFuWWQ6ICdjZDVjNWMnLFxuXHRSZGlnbzogJzRiMDA4MicsXG5cdGl2U3k6ICdmZmZmZjAnLFxuXHRraGFraTogJ2YwZTY4YycsXG5cdGxhdkZNcjogJ2U2ZTZmYScsXG5cdGxhdkZNclhzaDogJ2ZmZjBmNScsXG5cdGxhd25nWUY6ICc3Y2ZjMDAnLFxuXHRObW9uY0VmZm9uOiAnZmZmYWNkJyxcblx0WlhlOiAnYWRkOGU2Jyxcblx0WmNTTzogJ2YwODA4MCcsXG5cdFpjeWFuOiAnZTBmZmZmJyxcblx0WmdUTW5QZEx3OiAnZmFmYWQyJyxcblx0WldheTogJ2QzZDNkMycsXG5cdFpnWUY6ICc5MGVlOTAnLFxuXHRaZ1l5OiAnZDNkM2QzJyxcblx0WnBSazogJ2ZmYjZjMScsXG5cdFpzT21vbjogJ2ZmYTA3YScsXG5cdFpzSGdZRjogJzIwYjJhYScsXG5cdFpza3lYZTogJzg3Y2VmYScsXG5cdFpVV2F5OiAnNzc4ODk5Jyxcblx0WlVnWXk6ICc3Nzg4OTknLFxuXHRac3RBbFhlOiAnYjBjNGRlJyxcblx0Wkx3OiAnZmZmZmUwJyxcblx0bGltZTogJ2ZmMDAnLFxuXHRsaW1lZ1lGOiAnMzJjZDMyJyxcblx0bFJGOiAnZmFmMGU2Jyxcblx0bWFnRnRhOiAnZmYwMGZmJyxcblx0bWFQb246ICc4MDAwMDAnLFxuXHRWYXF1YW1hclJlOiAnNjZjZGFhJyxcblx0VlhlOiAnY2QnLFxuXHRWU2NFZDogJ2JhNTVkMycsXG5cdFZwdXJwTjogJzkzNzBkYicsXG5cdFZzSGdZRjogJzNjYjM3MScsXG5cdFZVWGU6ICc3YjY4ZWUnLFxuXHRWc3ByUmdnWUY6ICdmYTlhJyxcblx0VlFlOiAnNDhkMWNjJyxcblx0VnZpVGV0WWQ6ICdjNzE1ODUnLFxuXHRtaWRuaWdodFhlOiAnMTkxOTcwJyxcblx0bVJ0Y1lhbTogJ2Y1ZmZmYScsXG5cdG1pc3R5UHNlOiAnZmZlNGUxJyxcblx0bW9jY2FzUjogJ2ZmZTRiNScsXG5cdG5hdmFqb3dFdGU6ICdmZmRlYWQnLFxuXHRuYXZ5OiAnODAnLFxuXHRUZGxhY2U6ICdmZGY1ZTYnLFxuXHRUaXZlOiAnODA4MDAwJyxcblx0VGl2ZWRCYjogJzZiOGUyMycsXG5cdFNhbmdlOiAnZmZhNTAwJyxcblx0U2FuZ2VZZDogJ2ZmNDUwMCcsXG5cdFNjRWQ6ICdkYTcwZDYnLFxuXHRwT2VnVE1uUGQ6ICdlZWU4YWEnLFxuXHRwT2VnWUY6ICc5OGZiOTgnLFxuXHRwT2VRZTogJ2FmZWVlZScsXG5cdHBPZXZpVGV0WWQ6ICdkYjcwOTMnLFxuXHRwYXBheWF3RXA6ICdmZmVmZDUnLFxuXHRwSEtwdWZmOiAnZmZkYWI5Jyxcblx0cGVydTogJ2NkODUzZicsXG5cdHBSazogJ2ZmYzBjYicsXG5cdHBsdW06ICdkZGEwZGQnLFxuXHRwb3dNclhlOiAnYjBlMGU2Jyxcblx0cHVycE46ICc4MDAwODAnLFxuXHRZYmVjY2FwdXJwTjogJzY2MzM5OScsXG5cdFlkOiAnZmYwMDAwJyxcblx0UHN5YnJvd246ICdiYzhmOGYnLFxuXHRQeU9YZTogJzQxNjllMScsXG5cdHNhZGROYlB3bjogJzhiNDUxMycsXG5cdHNPbW9uOiAnZmE4MDcyJyxcblx0c2FuZHliUHduOiAnZjRhNDYwJyxcblx0c0hnWUY6ICcyZThiNTcnLFxuXHRzSHNoZWxsOiAnZmZmNWVlJyxcblx0c2lGbmE6ICdhMDUyMmQnLFxuXHRzaWx2ZXI6ICdjMGMwYzAnLFxuXHRza3lYZTogJzg3Y2VlYicsXG5cdFVYZTogJzZhNWFjZCcsXG5cdFVXYXk6ICc3MDgwOTAnLFxuXHRVZ1l5OiAnNzA4MDkwJyxcblx0c25vdzogJ2ZmZmFmYScsXG5cdHNwclJnZ1lGOiAnZmY3ZicsXG5cdHN0QWxYZTogJzQ2ODJiNCcsXG5cdHRhbjogJ2QyYjQ4YycsXG5cdHRlTzogJzgwODAnLFxuXHR0RXN0TjogJ2Q4YmZkOCcsXG5cdHRvbWF0bzogJ2ZmNjM0NycsXG5cdFFlOiAnNDBlMGQwJyxcblx0dmlUZXQ6ICdlZTgyZWUnLFxuXHRKSHQ6ICdmNWRlYjMnLFxuXHR3RXRlOiAnZmZmZmZmJyxcblx0d0V0ZXNtb2tlOiAnZjVmNWY1Jyxcblx0THc6ICdmZmZmMDAnLFxuXHRMd2dZRjogJzlhY2QzMidcbn07XG5mdW5jdGlvbiB1bnBhY2soKSB7XG5cdGNvbnN0IHVucGFja2VkID0ge307XG5cdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhuYW1lcyk7XG5cdGNvbnN0IHRrZXlzID0gT2JqZWN0LmtleXMobWFwJDEpO1xuXHRsZXQgaSwgaiwgaywgb2ssIG5rO1xuXHRmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdG9rID0gbmsgPSBrZXlzW2ldO1xuXHRcdGZvciAoaiA9IDA7IGogPCB0a2V5cy5sZW5ndGg7IGorKykge1xuXHRcdFx0ayA9IHRrZXlzW2pdO1xuXHRcdFx0bmsgPSBuay5yZXBsYWNlKGssIG1hcCQxW2tdKTtcblx0XHR9XG5cdFx0ayA9IHBhcnNlSW50KG5hbWVzW29rXSwgMTYpO1xuXHRcdHVucGFja2VkW25rXSA9IFtrID4+IDE2ICYgMHhGRiwgayA+PiA4ICYgMHhGRiwgayAmIDB4RkZdO1xuXHR9XG5cdHJldHVybiB1bnBhY2tlZDtcbn1cbmxldCBuYW1lcyQxO1xuZnVuY3Rpb24gbmFtZVBhcnNlKHN0cikge1xuXHRpZiAoIW5hbWVzJDEpIHtcblx0XHRuYW1lcyQxID0gdW5wYWNrKCk7XG5cdFx0bmFtZXMkMS50cmFuc3BhcmVudCA9IFswLCAwLCAwLCAwXTtcblx0fVxuXHRjb25zdCBhID0gbmFtZXMkMVtzdHIudG9Mb3dlckNhc2UoKV07XG5cdHJldHVybiBhICYmIHtcblx0XHRyOiBhWzBdLFxuXHRcdGc6IGFbMV0sXG5cdFx0YjogYVsyXSxcblx0XHRhOiBhLmxlbmd0aCA9PT0gNCA/IGFbM10gOiAyNTVcblx0fTtcbn1cbmZ1bmN0aW9uIG1vZEhTTCh2LCBpLCByYXRpbykge1xuXHRpZiAodikge1xuXHRcdGxldCB0bXAgPSByZ2IyaHNsKHYpO1xuXHRcdHRtcFtpXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRtcFtpXSArIHRtcFtpXSAqIHJhdGlvLCBpID09PSAwID8gMzYwIDogMSkpO1xuXHRcdHRtcCA9IGhzbDJyZ2IodG1wKTtcblx0XHR2LnIgPSB0bXBbMF07XG5cdFx0di5nID0gdG1wWzFdO1xuXHRcdHYuYiA9IHRtcFsyXTtcblx0fVxufVxuZnVuY3Rpb24gY2xvbmUodiwgcHJvdG8pIHtcblx0cmV0dXJuIHYgPyBPYmplY3QuYXNzaWduKHByb3RvIHx8IHt9LCB2KSA6IHY7XG59XG5mdW5jdGlvbiBmcm9tT2JqZWN0KGlucHV0KSB7XG5cdHZhciB2ID0ge3I6IDAsIGc6IDAsIGI6IDAsIGE6IDI1NX07XG5cdGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuXHRcdGlmIChpbnB1dC5sZW5ndGggPj0gMykge1xuXHRcdFx0diA9IHtyOiBpbnB1dFswXSwgZzogaW5wdXRbMV0sIGI6IGlucHV0WzJdLCBhOiAyNTV9O1xuXHRcdFx0aWYgKGlucHV0Lmxlbmd0aCA+IDMpIHtcblx0XHRcdFx0di5hID0gbjJiKGlucHV0WzNdKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0diA9IGNsb25lKGlucHV0LCB7cjogMCwgZzogMCwgYjogMCwgYTogMX0pO1xuXHRcdHYuYSA9IG4yYih2LmEpO1xuXHR9XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25QYXJzZShzdHIpIHtcblx0aWYgKHN0ci5jaGFyQXQoMCkgPT09ICdyJykge1xuXHRcdHJldHVybiByZ2JQYXJzZShzdHIpO1xuXHR9XG5cdHJldHVybiBodWVQYXJzZShzdHIpO1xufVxuY2xhc3MgQ29sb3Ige1xuXHRjb25zdHJ1Y3RvcihpbnB1dCkge1xuXHRcdGlmIChpbnB1dCBpbnN0YW5jZW9mIENvbG9yKSB7XG5cdFx0XHRyZXR1cm4gaW5wdXQ7XG5cdFx0fVxuXHRcdGNvbnN0IHR5cGUgPSB0eXBlb2YgaW5wdXQ7XG5cdFx0bGV0IHY7XG5cdFx0aWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHR2ID0gZnJvbU9iamVjdChpbnB1dCk7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0diA9IGhleFBhcnNlKGlucHV0KSB8fCBuYW1lUGFyc2UoaW5wdXQpIHx8IGZ1bmN0aW9uUGFyc2UoaW5wdXQpO1xuXHRcdH1cblx0XHR0aGlzLl9yZ2IgPSB2O1xuXHRcdHRoaXMuX3ZhbGlkID0gISF2O1xuXHR9XG5cdGdldCB2YWxpZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmFsaWQ7XG5cdH1cblx0Z2V0IHJnYigpIHtcblx0XHR2YXIgdiA9IGNsb25lKHRoaXMuX3JnYik7XG5cdFx0aWYgKHYpIHtcblx0XHRcdHYuYSA9IGIybih2LmEpO1xuXHRcdH1cblx0XHRyZXR1cm4gdjtcblx0fVxuXHRzZXQgcmdiKG9iaikge1xuXHRcdHRoaXMuX3JnYiA9IGZyb21PYmplY3Qob2JqKTtcblx0fVxuXHRyZ2JTdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbGlkID8gcmdiU3RyaW5nKHRoaXMuX3JnYikgOiB0aGlzLl9yZ2I7XG5cdH1cblx0aGV4U3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLl92YWxpZCA/IGhleFN0cmluZyh0aGlzLl9yZ2IpIDogdGhpcy5fcmdiO1xuXHR9XG5cdGhzbFN0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmFsaWQgPyBoc2xTdHJpbmcodGhpcy5fcmdiKSA6IHRoaXMuX3JnYjtcblx0fVxuXHRtaXgoY29sb3IsIHdlaWdodCkge1xuXHRcdGNvbnN0IG1lID0gdGhpcztcblx0XHRpZiAoY29sb3IpIHtcblx0XHRcdGNvbnN0IGMxID0gbWUucmdiO1xuXHRcdFx0Y29uc3QgYzIgPSBjb2xvci5yZ2I7XG5cdFx0XHRsZXQgdzI7XG5cdFx0XHRjb25zdCBwID0gd2VpZ2h0ID09PSB3MiA/IDAuNSA6IHdlaWdodDtcblx0XHRcdGNvbnN0IHcgPSAyICogcCAtIDE7XG5cdFx0XHRjb25zdCBhID0gYzEuYSAtIGMyLmE7XG5cdFx0XHRjb25zdCB3MSA9ICgodyAqIGEgPT09IC0xID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcblx0XHRcdHcyID0gMSAtIHcxO1xuXHRcdFx0YzEuciA9IDB4RkYgJiB3MSAqIGMxLnIgKyB3MiAqIGMyLnIgKyAwLjU7XG5cdFx0XHRjMS5nID0gMHhGRiAmIHcxICogYzEuZyArIHcyICogYzIuZyArIDAuNTtcblx0XHRcdGMxLmIgPSAweEZGICYgdzEgKiBjMS5iICsgdzIgKiBjMi5iICsgMC41O1xuXHRcdFx0YzEuYSA9IHAgKiBjMS5hICsgKDEgLSBwKSAqIGMyLmE7XG5cdFx0XHRtZS5yZ2IgPSBjMTtcblx0XHR9XG5cdFx0cmV0dXJuIG1lO1xuXHR9XG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgQ29sb3IodGhpcy5yZ2IpO1xuXHR9XG5cdGFscGhhKGEpIHtcblx0XHR0aGlzLl9yZ2IuYSA9IG4yYihhKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRjbGVhcmVyKHJhdGlvKSB7XG5cdFx0Y29uc3QgcmdiID0gdGhpcy5fcmdiO1xuXHRcdHJnYi5hICo9IDEgLSByYXRpbztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRncmV5c2NhbGUoKSB7XG5cdFx0Y29uc3QgcmdiID0gdGhpcy5fcmdiO1xuXHRcdGNvbnN0IHZhbCA9IHJvdW5kKHJnYi5yICogMC4zICsgcmdiLmcgKiAwLjU5ICsgcmdiLmIgKiAwLjExKTtcblx0XHRyZ2IuciA9IHJnYi5nID0gcmdiLmIgPSB2YWw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0b3BhcXVlcihyYXRpbykge1xuXHRcdGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcblx0XHRyZ2IuYSAqPSAxICsgcmF0aW87XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bmVnYXRlKCkge1xuXHRcdGNvbnN0IHYgPSB0aGlzLl9yZ2I7XG5cdFx0di5yID0gMjU1IC0gdi5yO1xuXHRcdHYuZyA9IDI1NSAtIHYuZztcblx0XHR2LmIgPSAyNTUgLSB2LmI7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0bGlnaHRlbihyYXRpbykge1xuXHRcdG1vZEhTTCh0aGlzLl9yZ2IsIDIsIHJhdGlvKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRkYXJrZW4ocmF0aW8pIHtcblx0XHRtb2RIU0wodGhpcy5fcmdiLCAyLCAtcmF0aW8pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHNhdHVyYXRlKHJhdGlvKSB7XG5cdFx0bW9kSFNMKHRoaXMuX3JnYiwgMSwgcmF0aW8pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGRlc2F0dXJhdGUocmF0aW8pIHtcblx0XHRtb2RIU0wodGhpcy5fcmdiLCAxLCAtcmF0aW8pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHJvdGF0ZShkZWcpIHtcblx0XHRyb3RhdGUodGhpcy5fcmdiLCBkZWcpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5mdW5jdGlvbiBpbmRleF9lc20oaW5wdXQpIHtcblx0cmV0dXJuIG5ldyBDb2xvcihpbnB1dCk7XG59XG5cbmNvbnN0IGlzUGF0dGVybk9yR3JhZGllbnQgPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgQ2FudmFzR3JhZGllbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBDYW52YXNQYXR0ZXJuO1xuZnVuY3Rpb24gY29sb3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpID8gdmFsdWUgOiBpbmRleF9lc20odmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSlcbiAgICA/IHZhbHVlXG4gICAgOiBpbmRleF9lc20odmFsdWUpLnNhdHVyYXRlKDAuNSkuZGFya2VuKDAuMSkuaGV4U3RyaW5nKCk7XG59XG5cbmNvbnN0IG92ZXJyaWRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBnZXRTY29wZSQxKG5vZGUsIGtleSkge1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgIG5vZGUgPSBub2RlW2tdIHx8IChub2RlW2tdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzZXQocm9vdCwgc2NvcGUsIHZhbHVlcykge1xuICBpZiAodHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtZXJnZShnZXRTY29wZSQxKHJvb3QsIHNjb3BlKSwgdmFsdWVzKTtcbiAgfVxuICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUkMShyb290LCAnJyksIHNjb3BlKTtcbn1cbmNsYXNzIERlZmF1bHRzIHtcbiAgY29uc3RydWN0b3IoX2Rlc2NyaXB0b3JzKSB7XG4gICAgdGhpcy5hbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICB0aGlzLmJvcmRlckNvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5jb2xvciA9ICcjNjY2JztcbiAgICB0aGlzLmRhdGFzZXRzID0ge307XG4gICAgdGhpcy5kZXZpY2VQaXhlbFJhdGlvID0gKGNvbnRleHQpID0+IGNvbnRleHQuY2hhcnQucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLmV2ZW50cyA9IFtcbiAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgJ21vdXNlb3V0JyxcbiAgICAgICdjbGljaycsXG4gICAgICAndG91Y2hzdGFydCcsXG4gICAgICAndG91Y2htb3ZlJ1xuICAgIF07XG4gICAgdGhpcy5mb250ID0ge1xuICAgICAgZmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG4gICAgICBzaXplOiAxMixcbiAgICAgIHN0eWxlOiAnbm9ybWFsJyxcbiAgICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICAgIHdlaWdodDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5ob3ZlciA9IHt9O1xuICAgIHRoaXMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKTtcbiAgICB0aGlzLmhvdmVyQm9yZGVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xuICAgIHRoaXMuaG92ZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5jb2xvcik7XG4gICAgdGhpcy5pbmRleEF4aXMgPSAneCc7XG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IHtcbiAgICAgIG1vZGU6ICduZWFyZXN0JyxcbiAgICAgIGludGVyc2VjdDogdHJ1ZVxuICAgIH07XG4gICAgdGhpcy5tYWludGFpbkFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICB0aGlzLm9uSG92ZXIgPSBudWxsO1xuICAgIHRoaXMub25DbGljayA9IG51bGw7XG4gICAgdGhpcy5wYXJzaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmUgPSB0cnVlO1xuICAgIHRoaXMuc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLnNob3dMaW5lID0gdHJ1ZTtcbiAgICB0aGlzLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdHJ1ZTtcbiAgICB0aGlzLmRlc2NyaWJlKF9kZXNjcmlwdG9ycyk7XG4gIH1cbiAgc2V0KHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KHRoaXMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG4gIGdldChzY29wZSkge1xuICAgIHJldHVybiBnZXRTY29wZSQxKHRoaXMsIHNjb3BlKTtcbiAgfVxuICBkZXNjcmliZShzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldChkZXNjcmlwdG9ycywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cbiAgb3ZlcnJpZGUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQob3ZlcnJpZGVzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuICByb3V0ZShzY29wZSwgbmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpIHtcbiAgICBjb25zdCBzY29wZU9iamVjdCA9IGdldFNjb3BlJDEodGhpcywgc2NvcGUpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUkMSh0aGlzLCB0YXJnZXRTY29wZSk7XG4gICAgY29uc3QgcHJpdmF0ZU5hbWUgPSAnXycgKyBuYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNjb3BlT2JqZWN0LCB7XG4gICAgICBbcHJpdmF0ZU5hbWVdOiB7XG4gICAgICAgIHZhbHVlOiBzY29wZU9iamVjdFtuYW1lXSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IGxvY2FsID0gdGhpc1twcml2YXRlTmFtZV07XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0U2NvcGVPYmplY3RbdGFyZ2V0TmFtZV07XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KGxvY2FsKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgbG9jYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQobG9jYWwsIHRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXNbcHJpdmF0ZU5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxudmFyIGRlZmF1bHRzID0gbmV3IERlZmF1bHRzKHtcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2V2ZW50cycsXG4gIGhvdmVyOiB7XG4gICAgX2ZhbGxiYWNrOiAnaW50ZXJhY3Rpb24nXG4gIH0sXG4gIGludGVyYWN0aW9uOiB7XG4gICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9XG59KTtcblxuZnVuY3Rpb24gdG9Gb250U3RyaW5nKGZvbnQpIHtcbiAgaWYgKCFmb250IHx8IGlzTnVsbE9yVW5kZWYoZm9udC5zaXplKSB8fCBpc051bGxPclVuZGVmKGZvbnQuZmFtaWx5KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAoZm9udC5zdHlsZSA/IGZvbnQuc3R5bGUgKyAnICcgOiAnJylcblx0XHQrIChmb250LndlaWdodCA/IGZvbnQud2VpZ2h0ICsgJyAnIDogJycpXG5cdFx0KyBmb250LnNpemUgKyAncHggJ1xuXHRcdCsgZm9udC5mYW1pbHk7XG59XG5mdW5jdGlvbiBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgc3RyaW5nKSB7XG4gIGxldCB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XG4gIGlmICghdGV4dFdpZHRoKSB7XG4gICAgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddID0gY3R4Lm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG4gICAgZ2MucHVzaChzdHJpbmcpO1xuICB9XG4gIGlmICh0ZXh0V2lkdGggPiBsb25nZXN0KSB7XG4gICAgbG9uZ2VzdCA9IHRleHRXaWR0aDtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cbmZ1bmN0aW9uIF9sb25nZXN0VGV4dChjdHgsIGZvbnQsIGFycmF5T2ZUaGluZ3MsIGNhY2hlKSB7XG4gIGNhY2hlID0gY2FjaGUgfHwge307XG4gIGxldCBkYXRhID0gY2FjaGUuZGF0YSA9IGNhY2hlLmRhdGEgfHwge307XG4gIGxldCBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG4gIGlmIChjYWNoZS5mb250ICE9PSBmb250KSB7XG4gICAgZGF0YSA9IGNhY2hlLmRhdGEgPSB7fTtcbiAgICBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gW107XG4gICAgY2FjaGUuZm9udCA9IGZvbnQ7XG4gIH1cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSBmb250O1xuICBsZXQgbG9uZ2VzdCA9IDA7XG4gIGNvbnN0IGlsZW4gPSBhcnJheU9mVGhpbmdzLmxlbmd0aDtcbiAgbGV0IGksIGosIGpsZW4sIHRoaW5nLCBuZXN0ZWRUaGluZztcbiAgZm9yIChpID0gMDsgaSA8IGlsZW47IGkrKykge1xuICAgIHRoaW5nID0gYXJyYXlPZlRoaW5nc1tpXTtcbiAgICBpZiAodGhpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGluZyAhPT0gbnVsbCAmJiBpc0FycmF5KHRoaW5nKSAhPT0gdHJ1ZSkge1xuICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCB0aGluZyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHRoaW5nKSkge1xuICAgICAgZm9yIChqID0gMCwgamxlbiA9IHRoaW5nLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICBuZXN0ZWRUaGluZyA9IHRoaW5nW2pdO1xuICAgICAgICBpZiAobmVzdGVkVGhpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXN0ZWRUaGluZyAhPT0gbnVsbCAmJiAhaXNBcnJheShuZXN0ZWRUaGluZykpIHtcbiAgICAgICAgICBsb25nZXN0ID0gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIG5lc3RlZFRoaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjdHgucmVzdG9yZSgpO1xuICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gIGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyBpKyspIHtcbiAgICAgIGRlbGV0ZSBkYXRhW2djW2ldXTtcbiAgICB9XG4gICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cbmZ1bmN0aW9uIF9hbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgd2lkdGgpIHtcbiAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvO1xuICBjb25zdCBoYWxmV2lkdGggPSB3aWR0aCAhPT0gMCA/IE1hdGgubWF4KHdpZHRoIC8gMiwgMC41KSA6IDA7XG4gIHJldHVybiBNYXRoLnJvdW5kKChwaXhlbCAtIGhhbGZXaWR0aCkgKiBkZXZpY2VQaXhlbFJhdGlvKSAvIGRldmljZVBpeGVsUmF0aW8gKyBoYWxmV2lkdGg7XG59XG5mdW5jdGlvbiBjbGVhckNhbnZhcyhjYW52YXMsIGN0eCkge1xuICBjdHggPSBjdHggfHwgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBkcmF3UG9pbnQoY3R4LCBvcHRpb25zLCB4LCB5KSB7XG4gIGxldCB0eXBlLCB4T2Zmc2V0LCB5T2Zmc2V0LCBzaXplLCBjb3JuZXJSYWRpdXM7XG4gIGNvbnN0IHN0eWxlID0gb3B0aW9ucy5wb2ludFN0eWxlO1xuICBjb25zdCByb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb247XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzO1xuICBsZXQgcmFkID0gKHJvdGF0aW9uIHx8IDApICogUkFEX1BFUl9ERUc7XG4gIGlmIChzdHlsZSAmJiB0eXBlb2Ygc3R5bGUgPT09ICdvYmplY3QnKSB7XG4gICAgdHlwZSA9IHN0eWxlLnRvU3RyaW5nKCk7XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF0nKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGN0eC5yb3RhdGUocmFkKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3R5bGUsIC1zdHlsZS53aWR0aCAvIDIsIC1zdHlsZS5oZWlnaHQgLyAyLCBzdHlsZS53aWR0aCwgc3R5bGUuaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgc3dpdGNoIChzdHlsZSkge1xuICBkZWZhdWx0OlxuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBUQVUpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAndHJpYW5nbGUnOlxuICAgIGN0eC5tb3ZlVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAncmVjdFJvdW5kZWQnOlxuICAgIGNvcm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNTE2O1xuICAgIHNpemUgPSByYWRpdXMgLSBjb3JuZXJSYWRpdXM7XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgIGN0eC5hcmMoeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIFBJLCByYWQgLSBIQUxGX1BJKTtcbiAgICBjdHguYXJjKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBIQUxGX1BJLCByYWQpO1xuICAgIGN0eC5hcmMoeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCwgcmFkICsgSEFMRl9QSSk7XG4gICAgY3R4LmFyYyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkICsgSEFMRl9QSSwgcmFkICsgUEkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAncmVjdCc6XG4gICAgaWYgKCFyb3RhdGlvbikge1xuICAgICAgc2l6ZSA9IE1hdGguU1FSVDFfMiAqIHJhZGl1cztcbiAgICAgIGN0eC5yZWN0KHggLSBzaXplLCB5IC0gc2l6ZSwgMiAqIHNpemUsIDIgKiBzaXplKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgY2FzZSAncmVjdFJvdCc6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAnY3Jvc3NSb3QnOlxuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICBjYXNlICdjcm9zcyc6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIGJyZWFrO1xuICBjYXNlICdzdGFyJzpcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgcmFkICs9IFFVQVJURVJfUEk7XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIGJyZWFrO1xuICBjYXNlICdsaW5lJzpcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGJyZWFrO1xuICBjYXNlICdkYXNoJzpcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgIGN0eC5saW5lVG8oeCArIE1hdGguY29zKHJhZCkgKiByYWRpdXMsIHkgKyBNYXRoLnNpbihyYWQpICogcmFkaXVzKTtcbiAgICBicmVhaztcbiAgfVxuICBjdHguZmlsbCgpO1xuICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9pc1BvaW50SW5BcmVhKHBvaW50LCBhcmVhLCBtYXJnaW4pIHtcbiAgbWFyZ2luID0gbWFyZ2luIHx8IDAuNTtcbiAgcmV0dXJuICFhcmVhIHx8IChwb2ludCAmJiBwb2ludC54ID4gYXJlYS5sZWZ0IC0gbWFyZ2luICYmIHBvaW50LnggPCBhcmVhLnJpZ2h0ICsgbWFyZ2luICYmXG5cdFx0cG9pbnQueSA+IGFyZWEudG9wIC0gbWFyZ2luICYmIHBvaW50LnkgPCBhcmVhLmJvdHRvbSArIG1hcmdpbik7XG59XG5mdW5jdGlvbiBjbGlwQXJlYShjdHgsIGFyZWEpIHtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgucmVjdChhcmVhLmxlZnQsIGFyZWEudG9wLCBhcmVhLnJpZ2h0IC0gYXJlYS5sZWZ0LCBhcmVhLmJvdHRvbSAtIGFyZWEudG9wKTtcbiAgY3R4LmNsaXAoKTtcbn1cbmZ1bmN0aW9uIHVuY2xpcEFyZWEoY3R4KSB7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBfc3RlcHBlZExpbmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQsIGZsaXAsIG1vZGUpIHtcbiAgaWYgKCFwcmV2aW91cykge1xuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdtaWRkbGUnKSB7XG4gICAgY29uc3QgbWlkcG9pbnQgPSAocHJldmlvdXMueCArIHRhcmdldC54KSAvIDIuMDtcbiAgICBjdHgubGluZVRvKG1pZHBvaW50LCBwcmV2aW91cy55KTtcbiAgICBjdHgubGluZVRvKG1pZHBvaW50LCB0YXJnZXQueSk7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2FmdGVyJyAhPT0gISFmbGlwKSB7XG4gICAgY3R4LmxpbmVUbyhwcmV2aW91cy54LCB0YXJnZXQueSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmxpbmVUbyh0YXJnZXQueCwgcHJldmlvdXMueSk7XG4gIH1cbiAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuZnVuY3Rpb24gX2JlemllckN1cnZlVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0LCBmbGlwKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF4IDogcHJldmlvdXMuY3AyeCxcbiAgICBmbGlwID8gcHJldmlvdXMuY3AxeSA6IHByZXZpb3VzLmNwMnksXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ4IDogdGFyZ2V0LmNwMXgsXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ5IDogdGFyZ2V0LmNwMXksXG4gICAgdGFyZ2V0LngsXG4gICAgdGFyZ2V0LnkpO1xufVxuZnVuY3Rpb24gcmVuZGVyVGV4dChjdHgsIHRleHQsIHgsIHksIGZvbnQsIG9wdHMgPSB7fSkge1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkodGV4dCkgPyB0ZXh0IDogW3RleHRdO1xuICBjb25zdCBzdHJva2UgPSBvcHRzLnN0cm9rZVdpZHRoID4gMCAmJiBvcHRzLnN0cm9rZUNvbG9yICE9PSAnJztcbiAgbGV0IGksIGxpbmU7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gZm9udC5zdHJpbmc7XG4gIHNldFJlbmRlck9wdHMoY3R4LCBvcHRzKTtcbiAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIGlmIChvcHRzLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdHMuc3Ryb2tlQ29sb3I7XG4gICAgICB9XG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5zdHJva2VXaWR0aCkpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGg7XG4gICAgICB9XG4gICAgICBjdHguc3Ryb2tlVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICB9XG4gICAgY3R4LmZpbGxUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgIGRlY29yYXRlVGV4dChjdHgsIHgsIHksIGxpbmUsIG9wdHMpO1xuICAgIHkgKz0gZm9udC5saW5lSGVpZ2h0O1xuICB9XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBzZXRSZW5kZXJPcHRzKGN0eCwgb3B0cykge1xuICBpZiAob3B0cy50cmFuc2xhdGlvbikge1xuICAgIGN0eC50cmFuc2xhdGUob3B0cy50cmFuc2xhdGlvblswXSwgb3B0cy50cmFuc2xhdGlvblsxXSk7XG4gIH1cbiAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMucm90YXRpb24pKSB7XG4gICAgY3R4LnJvdGF0ZShvcHRzLnJvdGF0aW9uKTtcbiAgfVxuICBpZiAob3B0cy5jb2xvcikge1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzLmNvbG9yO1xuICB9XG4gIGlmIChvcHRzLnRleHRBbGlnbikge1xuICAgIGN0eC50ZXh0QWxpZ24gPSBvcHRzLnRleHRBbGlnbjtcbiAgfVxuICBpZiAob3B0cy50ZXh0QmFzZWxpbmUpIHtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gb3B0cy50ZXh0QmFzZWxpbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlY29yYXRlVGV4dChjdHgsIHgsIHksIGxpbmUsIG9wdHMpIHtcbiAgaWYgKG9wdHMuc3RyaWtldGhyb3VnaCB8fCBvcHRzLnVuZGVybGluZSkge1xuICAgIGNvbnN0IG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQobGluZSk7XG4gICAgY29uc3QgbGVmdCA9IHggLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdDtcbiAgICBjb25zdCByaWdodCA9IHggKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQ7XG4gICAgY29uc3QgdG9wID0geSAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgY29uc3QgYm90dG9tID0geSArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xuICAgIGNvbnN0IHlEZWNvcmF0aW9uID0gb3B0cy5zdHJpa2V0aHJvdWdoID8gKHRvcCArIGJvdHRvbSkgLyAyIDogYm90dG9tO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLmRlY29yYXRpb25XaWR0aCB8fCAyO1xuICAgIGN0eC5tb3ZlVG8obGVmdCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5saW5lVG8ocmlnaHQsIHlEZWNvcmF0aW9uKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHJlY3QpIHtcbiAgY29uc3Qge3gsIHksIHcsIGgsIHJhZGl1c30gPSByZWN0O1xuICBjdHguYXJjKHggKyByYWRpdXMudG9wTGVmdCwgeSArIHJhZGl1cy50b3BMZWZ0LCByYWRpdXMudG9wTGVmdCwgLUhBTEZfUEksIFBJLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0KTtcbiAgY3R4LmFyYyh4ICsgcmFkaXVzLmJvdHRvbUxlZnQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQsIHJhZGl1cy5ib3R0b21MZWZ0LCBQSSwgSEFMRl9QSSwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoKTtcbiAgY3R4LmFyYyh4ICsgdyAtIHJhZGl1cy5ib3R0b21SaWdodCwgeSArIGggLSByYWRpdXMuYm90dG9tUmlnaHQsIHJhZGl1cy5ib3R0b21SaWdodCwgSEFMRl9QSSwgMCwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCArIHcsIHkgKyByYWRpdXMudG9wUmlnaHQpO1xuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLnRvcFJpZ2h0LCB5ICsgcmFkaXVzLnRvcFJpZ2h0LCByYWRpdXMudG9wUmlnaHQsIDAsIC1IQUxGX1BJLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzLnRvcExlZnQsIHkpO1xufVxuXG5jb25zdCBMSU5FX0hFSUdIVCA9IG5ldyBSZWdFeHAoL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC8pO1xuY29uc3QgRk9OVF9TVFlMRSA9IG5ldyBSZWdFeHAoL14obm9ybWFsfGl0YWxpY3xpbml0aWFsfGluaGVyaXR8dW5zZXR8KG9ibGlxdWUoIC0/WzAtOV0/WzAtOV1kZWcpPykpJC8pO1xuZnVuY3Rpb24gdG9MaW5lSGVpZ2h0KHZhbHVlLCBzaXplKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSAoJycgKyB2YWx1ZSkubWF0Y2goTElORV9IRUlHSFQpO1xuICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlc1sxXSA9PT0gJ25vcm1hbCcpIHtcbiAgICByZXR1cm4gc2l6ZSAqIDEuMjtcbiAgfVxuICB2YWx1ZSA9ICttYXRjaGVzWzJdO1xuICBzd2l0Y2ggKG1hdGNoZXNbM10pIHtcbiAgY2FzZSAncHgnOlxuICAgIHJldHVybiB2YWx1ZTtcbiAgY2FzZSAnJSc6XG4gICAgdmFsdWUgLz0gMTAwO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBzaXplICogdmFsdWU7XG59XG5jb25zdCBudW1iZXJPclplcm8gPSB2ID0+ICt2IHx8IDA7XG5mdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgcHJvcHMpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGNvbnN0IG9ialByb3BzID0gaXNPYmplY3QocHJvcHMpO1xuICBjb25zdCBrZXlzID0gb2JqUHJvcHMgPyBPYmplY3Qua2V5cyhwcm9wcykgOiBwcm9wcztcbiAgY29uc3QgcmVhZCA9IGlzT2JqZWN0KHZhbHVlKVxuICAgID8gb2JqUHJvcHNcbiAgICAgID8gcHJvcCA9PiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZVtwcm9wXSwgdmFsdWVbcHJvcHNbcHJvcF1dKVxuICAgICAgOiBwcm9wID0+IHZhbHVlW3Byb3BdXG4gICAgOiAoKSA9PiB2YWx1ZTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIGtleXMpIHtcbiAgICByZXRbcHJvcF0gPSBudW1iZXJPclplcm8ocmVhZChwcm9wKSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHRvVFJCTCh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIHt0b3A6ICd5JywgcmlnaHQ6ICd4JywgYm90dG9tOiAneScsIGxlZnQ6ICd4J30pO1xufVxuZnVuY3Rpb24gdG9UUkJMQ29ybmVycyh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsndG9wTGVmdCcsICd0b3BSaWdodCcsICdib3R0b21MZWZ0JywgJ2JvdHRvbVJpZ2h0J10pO1xufVxuZnVuY3Rpb24gdG9QYWRkaW5nKHZhbHVlKSB7XG4gIGNvbnN0IG9iaiA9IHRvVFJCTCh2YWx1ZSk7XG4gIG9iai53aWR0aCA9IG9iai5sZWZ0ICsgb2JqLnJpZ2h0O1xuICBvYmouaGVpZ2h0ID0gb2JqLnRvcCArIG9iai5ib3R0b207XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiB0b0ZvbnQob3B0aW9ucywgZmFsbGJhY2spIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGZhbGxiYWNrID0gZmFsbGJhY2sgfHwgZGVmYXVsdHMuZm9udDtcbiAgbGV0IHNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnNpemUsIGZhbGxiYWNrLnNpemUpO1xuICBpZiAodHlwZW9mIHNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgc2l6ZSA9IHBhcnNlSW50KHNpemUsIDEwKTtcbiAgfVxuICBsZXQgc3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnN0eWxlLCBmYWxsYmFjay5zdHlsZSk7XG4gIGlmIChzdHlsZSAmJiAhKCcnICsgc3R5bGUpLm1hdGNoKEZPTlRfU1RZTEUpKSB7XG4gICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGZvbnQgc3R5bGUgc3BlY2lmaWVkOiBcIicgKyBzdHlsZSArICdcIicpO1xuICAgIHN0eWxlID0gJyc7XG4gIH1cbiAgY29uc3QgZm9udCA9IHtcbiAgICBmYW1pbHk6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZmFtaWx5LCBmYWxsYmFjay5mYW1pbHkpLFxuICAgIGxpbmVIZWlnaHQ6IHRvTGluZUhlaWdodCh2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmxpbmVIZWlnaHQsIGZhbGxiYWNrLmxpbmVIZWlnaHQpLCBzaXplKSxcbiAgICBzaXplLFxuICAgIHN0eWxlLFxuICAgIHdlaWdodDogdmFsdWVPckRlZmF1bHQob3B0aW9ucy53ZWlnaHQsIGZhbGxiYWNrLndlaWdodCksXG4gICAgc3RyaW5nOiAnJ1xuICB9O1xuICBmb250LnN0cmluZyA9IHRvRm9udFN0cmluZyhmb250KTtcbiAgcmV0dXJuIGZvbnQ7XG59XG5mdW5jdGlvbiByZXNvbHZlKGlucHV0cywgY29udGV4dCwgaW5kZXgsIGluZm8pIHtcbiAgbGV0IGNhY2hlYWJsZSA9IHRydWU7XG4gIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGlucHV0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IGlucHV0c1tpXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKGNvbnRleHQpO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlW2luZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluZm8gJiYgIWNhY2hlYWJsZSkge1xuICAgICAgICBpbmZvLmNhY2hlYWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX2FkZEdyYWNlKG1pbm1heCwgZ3JhY2UsIGJlZ2luQXRaZXJvKSB7XG4gIGNvbnN0IHttaW4sIG1heH0gPSBtaW5tYXg7XG4gIGNvbnN0IGNoYW5nZSA9IHRvRGltZW5zaW9uKGdyYWNlLCAobWF4IC0gbWluKSAvIDIpO1xuICBjb25zdCBrZWVwWmVybyA9ICh2YWx1ZSwgYWRkKSA9PiBiZWdpbkF0WmVybyAmJiB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSArIGFkZDtcbiAgcmV0dXJuIHtcbiAgICBtaW46IGtlZXBaZXJvKG1pbiwgLU1hdGguYWJzKGNoYW5nZSkpLFxuICAgIG1heDoga2VlcFplcm8obWF4LCBjaGFuZ2UpXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KHBhcmVudENvbnRleHQsIGNvbnRleHQpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShwYXJlbnRDb250ZXh0KSwgY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIF9sb29rdXAodGFibGUsIHZhbHVlLCBjbXApIHtcbiAgY21wID0gY21wIHx8ICgoaW5kZXgpID0+IHRhYmxlW2luZGV4XSA8IHZhbHVlKTtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IG1pZDtcbiAgd2hpbGUgKGhpIC0gbG8gPiAxKSB7XG4gICAgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgaWYgKGNtcChtaWQpKSB7XG4gICAgICBsbyA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7bG8sIGhpfTtcbn1cbmNvbnN0IF9sb29rdXBCeUtleSA9ICh0YWJsZSwga2V5LCB2YWx1ZSkgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldIDwgdmFsdWUpO1xuY29uc3QgX3Jsb29rdXBCeUtleSA9ICh0YWJsZSwga2V5LCB2YWx1ZSkgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldID49IHZhbHVlKTtcbmZ1bmN0aW9uIF9maWx0ZXJCZXR3ZWVuKHZhbHVlcywgbWluLCBtYXgpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IHZhbHVlcy5sZW5ndGg7XG4gIHdoaWxlIChzdGFydCA8IGVuZCAmJiB2YWx1ZXNbc3RhcnRdIDwgbWluKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgdmFsdWVzW2VuZCAtIDFdID4gbWF4KSB7XG4gICAgZW5kLS07XG4gIH1cbiAgcmV0dXJuIHN0YXJ0ID4gMCB8fCBlbmQgPCB2YWx1ZXMubGVuZ3RoXG4gICAgPyB2YWx1ZXMuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICA6IHZhbHVlcztcbn1cbmNvbnN0IGFycmF5RXZlbnRzID0gWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICdzcGxpY2UnLCAndW5zaGlmdCddO1xuZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG4gIGlmIChhcnJheS5fY2hhcnRqcykge1xuICAgIGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiB7XG4gICAgICBsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cbiAgICB9XG4gIH0pO1xuICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCBtZXRob2QgPSAnX29uRGF0YScgKyBfY2FwaXRhbGl6ZShrZXkpO1xuICAgIGNvbnN0IGJhc2UgPSBhcnJheVtrZXldO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYmFzZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLmZvckVhY2goKG9iamVjdCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdFttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgY29uc3Qgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuICBpZiAoIXN0dWIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbGlzdGVuZXJzID0gc3R1Yi5saXN0ZW5lcnM7XG4gIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGRlbGV0ZSBhcnJheVtrZXldO1xuICB9KTtcbiAgZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xufVxuZnVuY3Rpb24gX2FycmF5VW5pcXVlKGl0ZW1zKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBzZXQuYWRkKGl0ZW1zW2ldKTtcbiAgfVxuICBpZiAoc2V0LnNpemUgPT09IGlsZW4pIHtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVJlc29sdmVyKHNjb3BlcywgcHJlZml4ZXMgPSBbJyddLCByb290U2NvcGVzID0gc2NvcGVzLCBmYWxsYmFjaywgZ2V0VGFyZ2V0ID0gKCkgPT4gc2NvcGVzWzBdKSB7XG4gIGlmICghZGVmaW5lZChmYWxsYmFjaykpIHtcbiAgICBmYWxsYmFjayA9IF9yZXNvbHZlKCdfZmFsbGJhY2snLCBzY29wZXMpO1xuICB9XG4gIGNvbnN0IGNhY2hlID0ge1xuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnT2JqZWN0JyxcbiAgICBfY2FjaGVhYmxlOiB0cnVlLFxuICAgIF9zY29wZXM6IHNjb3BlcyxcbiAgICBfcm9vdFNjb3Blczogcm9vdFNjb3BlcyxcbiAgICBfZmFsbGJhY2s6IGZhbGxiYWNrLFxuICAgIF9nZXRUYXJnZXQ6IGdldFRhcmdldCxcbiAgICBvdmVycmlkZTogKHNjb3BlKSA9PiBfY3JlYXRlUmVzb2x2ZXIoW3Njb3BlLCAuLi5zY29wZXNdLCBwcmVmaXhlcywgcm9vdFNjb3BlcywgZmFsbGJhY2spLFxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdO1xuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5cztcbiAgICAgIGRlbGV0ZSBzY29wZXNbMF1bcHJvcF07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoUHJlZml4ZXMocHJvcCwgcHJlZml4ZXMsIHNjb3BlcywgdGFyZ2V0KSk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0Ll9zY29wZXNbMF0sIHByb3ApO1xuICAgIH0sXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihzY29wZXNbMF0pO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCkuaW5jbHVkZXMocHJvcCk7XG4gICAgfSxcbiAgICBvd25LZXlzKHRhcmdldCkge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCk7XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRhcmdldC5fc3RvcmFnZSB8fCAodGFyZ2V0Ll9zdG9yYWdlID0gZ2V0VGFyZ2V0KCkpO1xuICAgICAgdGFyZ2V0W3Byb3BdID0gc3RvcmFnZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5cztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBfYXR0YWNoQ29udGV4dChwcm94eSwgY29udGV4dCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cykge1xuICBjb25zdCBjYWNoZSA9IHtcbiAgICBfY2FjaGVhYmxlOiBmYWxzZSxcbiAgICBfcHJveHk6IHByb3h5LFxuICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgIF9zdWJQcm94eTogc3ViUHJveHksXG4gICAgX3N0YWNrOiBuZXcgU2V0KCksXG4gICAgX2Rlc2NyaXB0b3JzOiBfZGVzY3JpcHRvcnMocHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgc2V0Q29udGV4dDogKGN0eCkgPT4gX2F0dGFjaENvbnRleHQocHJveHksIGN0eCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgb3ZlcnJpZGU6IChzY29wZSkgPT4gX2F0dGFjaENvbnRleHQocHJveHkub3ZlcnJpZGUoc2NvcGUpLCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdO1xuICAgICAgZGVsZXRlIHByb3h5W3Byb3BdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhDb250ZXh0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpKTtcbiAgICB9LFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiB0YXJnZXQuX2Rlc2NyaXB0b3JzLmFsbEtleXNcbiAgICAgICAgPyBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCkgPyB7ZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSA6IHVuZGVmaW5lZFxuICAgICAgICA6IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YocHJveHkpO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuICAgIG93bktleXMoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHByb3h5KTtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBwcm94eVtwcm9wXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBfZGVzY3JpcHRvcnMocHJveHksIGRlZmF1bHRzID0ge3NjcmlwdGFibGU6IHRydWUsIGluZGV4YWJsZTogdHJ1ZX0pIHtcbiAgY29uc3Qge19zY3JpcHRhYmxlID0gZGVmYXVsdHMuc2NyaXB0YWJsZSwgX2luZGV4YWJsZSA9IGRlZmF1bHRzLmluZGV4YWJsZSwgX2FsbEtleXMgPSBkZWZhdWx0cy5hbGxLZXlzfSA9IHByb3h5O1xuICByZXR1cm4ge1xuICAgIGFsbEtleXM6IF9hbGxLZXlzLFxuICAgIHNjcmlwdGFibGU6IF9zY3JpcHRhYmxlLFxuICAgIGluZGV4YWJsZTogX2luZGV4YWJsZSxcbiAgICBpc1NjcmlwdGFibGU6IGlzRnVuY3Rpb24oX3NjcmlwdGFibGUpID8gX3NjcmlwdGFibGUgOiAoKSA9PiBfc2NyaXB0YWJsZSxcbiAgICBpc0luZGV4YWJsZTogaXNGdW5jdGlvbihfaW5kZXhhYmxlKSA/IF9pbmRleGFibGUgOiAoKSA9PiBfaW5kZXhhYmxlXG4gIH07XG59XG5jb25zdCByZWFkS2V5ID0gKHByZWZpeCwgbmFtZSkgPT4gcHJlZml4ID8gcHJlZml4ICsgX2NhcGl0YWxpemUobmFtZSkgOiBuYW1lO1xuY29uc3QgbmVlZHNTdWJSZXNvbHZlciA9IChwcm9wLCB2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmIHByb3AgIT09ICdhZGFwdGVycycgJiZcbiAgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGwgfHwgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCk7XG5mdW5jdGlvbiBfY2FjaGVkKHRhcmdldCwgcHJvcCwgcmVzb2x2ZSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgcHJvcCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICB9XG4gIGNvbnN0IHZhbHVlID0gcmVzb2x2ZSgpO1xuICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVXaXRoQ29udGV4dCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuICBsZXQgdmFsdWUgPSBfcHJveHlbcHJvcF07XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSAmJiBkZXNjcmlwdG9ycy5pc1NjcmlwdGFibGUocHJvcCkpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcik7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBkZXNjcmlwdG9ycy5pc0luZGV4YWJsZSk7XG4gIH1cbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgdmFsdWUgPSBfYXR0YWNoQ29udGV4dCh2YWx1ZSwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVNjcmlwdGFibGUocHJvcCwgdmFsdWUsIHRhcmdldCwgcmVjZWl2ZXIpIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX3N0YWNrfSA9IHRhcmdldDtcbiAgaWYgKF9zdGFjay5oYXMocHJvcCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBkZXRlY3RlZDogJyArIEFycmF5LmZyb20oX3N0YWNrKS5qb2luKCctPicpICsgJy0+JyArIHByb3ApO1xuICB9XG4gIF9zdGFjay5hZGQocHJvcCk7XG4gIHZhbHVlID0gdmFsdWUoX2NvbnRleHQsIF9zdWJQcm94eSB8fCByZWNlaXZlcik7XG4gIF9zdGFjay5kZWxldGUocHJvcCk7XG4gIGlmIChuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKSkge1xuICAgIHZhbHVlID0gY3JlYXRlU3ViUmVzb2x2ZXIoX3Byb3h5Ll9zY29wZXMsIF9wcm94eSwgcHJvcCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlQXJyYXkocHJvcCwgdmFsdWUsIHRhcmdldCwgaXNJbmRleGFibGUpIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX2Rlc2NyaXB0b3JzOiBkZXNjcmlwdG9yc30gPSB0YXJnZXQ7XG4gIGlmIChkZWZpbmVkKF9jb250ZXh0LmluZGV4KSAmJiBpc0luZGV4YWJsZShwcm9wKSkge1xuICAgIHZhbHVlID0gdmFsdWVbX2NvbnRleHQuaW5kZXggJSB2YWx1ZS5sZW5ndGhdO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlWzBdKSkge1xuICAgIGNvbnN0IGFyciA9IHZhbHVlO1xuICAgIGNvbnN0IHNjb3BlcyA9IF9wcm94eS5fc2NvcGVzLmZpbHRlcihzID0+IHMgIT09IGFycik7XG4gICAgdmFsdWUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICBjb25zdCByZXNvbHZlciA9IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgX3Byb3h5LCBwcm9wLCBpdGVtKTtcbiAgICAgIHZhbHVlLnB1c2goX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiByZXNvbHZlRmFsbGJhY2soZmFsbGJhY2ssIHByb3AsIHZhbHVlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKGZhbGxiYWNrKSA/IGZhbGxiYWNrKHByb3AsIHZhbHVlKSA6IGZhbGxiYWNrO1xufVxuY29uc3QgZ2V0U2NvcGUgPSAoa2V5LCBwYXJlbnQpID0+IGtleSA9PT0gdHJ1ZSA/IHBhcmVudFxuICA6IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gcmVzb2x2ZU9iamVjdEtleShwYXJlbnQsIGtleSkgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBhZGRTY29wZXMoc2V0LCBwYXJlbnRTY29wZXMsIGtleSwgcGFyZW50RmFsbGJhY2ssIHZhbHVlKSB7XG4gIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudFNjb3Blcykge1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGUoa2V5LCBwYXJlbnQpO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgc2V0LmFkZChzY29wZSk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhzY29wZS5fZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKGRlZmluZWQoZmFsbGJhY2spICYmIGZhbGxiYWNrICE9PSBrZXkgJiYgZmFsbGJhY2sgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjb3BlID09PSBmYWxzZSAmJiBkZWZpbmVkKHBhcmVudEZhbGxiYWNrKSAmJiBrZXkgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY3JlYXRlU3ViUmVzb2x2ZXIocGFyZW50U2NvcGVzLCByZXNvbHZlciwgcHJvcCwgdmFsdWUpIHtcbiAgY29uc3Qgcm9vdFNjb3BlcyA9IHJlc29sdmVyLl9yb290U2NvcGVzO1xuICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhyZXNvbHZlci5fZmFsbGJhY2ssIHByb3AsIHZhbHVlKTtcbiAgY29uc3QgYWxsU2NvcGVzID0gWy4uLnBhcmVudFNjb3BlcywgLi4ucm9vdFNjb3Blc107XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgc2V0LmFkZCh2YWx1ZSk7XG4gIGxldCBrZXkgPSBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBwcm9wLCBmYWxsYmFjayB8fCBwcm9wLCB2YWx1ZSk7XG4gIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRlZmluZWQoZmFsbGJhY2spICYmIGZhbGxiYWNrICE9PSBwcm9wKSB7XG4gICAga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVSZXNvbHZlcihBcnJheS5mcm9tKHNldCksIFsnJ10sIHJvb3RTY29wZXMsIGZhbGxiYWNrLFxuICAgICgpID0+IHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIGtleSwgZmFsbGJhY2ssIGl0ZW0pIHtcbiAgd2hpbGUgKGtleSkge1xuICAgIGtleSA9IGFkZFNjb3BlcyhzZXQsIGFsbFNjb3Blcywga2V5LCBmYWxsYmFjaywgaXRlbSk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCwgdmFsdWUpIHtcbiAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZXIuX2dldFRhcmdldCgpO1xuICBpZiAoIShwcm9wIGluIHBhcmVudCkpIHtcbiAgICBwYXJlbnRbcHJvcF0gPSB7fTtcbiAgfVxuICBjb25zdCB0YXJnZXQgPSBwYXJlbnRbcHJvcF07XG4gIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCBwcm94eSkge1xuICBsZXQgdmFsdWU7XG4gIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZShyZWFkS2V5KHByZWZpeCwgcHJvcCksIHNjb3Blcyk7XG4gICAgaWYgKGRlZmluZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gbmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSlcbiAgICAgICAgPyBjcmVhdGVTdWJSZXNvbHZlcihzY29wZXMsIHByb3h5LCBwcm9wLCB2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9yZXNvbHZlKGtleSwgc2NvcGVzKSB7XG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgaWYgKCFzY29wZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gc2NvcGVba2V5XTtcbiAgICBpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCkge1xuICBsZXQga2V5cyA9IHRhcmdldC5fa2V5cztcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IHRhcmdldC5fa2V5cyA9IHJlc29sdmVLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQuX3Njb3Blcyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiByZXNvbHZlS2V5c0Zyb21BbGxTY29wZXMoc2NvcGVzKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY29wZSkuZmlsdGVyKGsgPT4gIWsuc3RhcnRzV2l0aCgnXycpKSkge1xuICAgICAgc2V0LmFkZChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpO1xufVxuXG5jb25zdCBFUFNJTE9OID0gTnVtYmVyLkVQU0lMT04gfHwgMWUtMTQ7XG5jb25zdCBnZXRQb2ludCA9IChwb2ludHMsIGkpID0+IGkgPCBwb2ludHMubGVuZ3RoICYmICFwb2ludHNbaV0uc2tpcCAmJiBwb2ludHNbaV07XG5jb25zdCBnZXRWYWx1ZUF4aXMgPSAoaW5kZXhBeGlzKSA9PiBpbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcbmZ1bmN0aW9uIHNwbGluZUN1cnZlKGZpcnN0UG9pbnQsIG1pZGRsZVBvaW50LCBhZnRlclBvaW50LCB0KSB7XG4gIGNvbnN0IHByZXZpb3VzID0gZmlyc3RQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBmaXJzdFBvaW50O1xuICBjb25zdCBjdXJyZW50ID0gbWlkZGxlUG9pbnQ7XG4gIGNvbnN0IG5leHQgPSBhZnRlclBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGFmdGVyUG9pbnQ7XG4gIGNvbnN0IGQwMSA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhjdXJyZW50LCBwcmV2aW91cyk7XG4gIGNvbnN0IGQxMiA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhuZXh0LCBjdXJyZW50KTtcbiAgbGV0IHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xuICBsZXQgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG4gIHMwMSA9IGlzTmFOKHMwMSkgPyAwIDogczAxO1xuICBzMTIgPSBpc05hTihzMTIpID8gMCA6IHMxMjtcbiAgY29uc3QgZmEgPSB0ICogczAxO1xuICBjb25zdCBmYiA9IHQgKiBzMTI7XG4gIHJldHVybiB7XG4gICAgcHJldmlvdXM6IHtcbiAgICAgIHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9LFxuICAgIG5leHQ6IHtcbiAgICAgIHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtb25vdG9uZUFkanVzdChwb2ludHMsIGRlbHRhSywgbUspIHtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGFscGhhSywgYmV0YUssIHRhdUssIHNxdWFyZWRNYWduaXR1ZGUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbiAtIDE7ICsraSkge1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50IHx8ICFwb2ludEFmdGVyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFsbW9zdEVxdWFscyhkZWx0YUtbaV0sIDAsIEVQU0lMT04pKSB7XG4gICAgICBtS1tpXSA9IG1LW2kgKyAxXSA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYWxwaGFLID0gbUtbaV0gLyBkZWx0YUtbaV07XG4gICAgYmV0YUsgPSBtS1tpICsgMV0gLyBkZWx0YUtbaV07XG4gICAgc3F1YXJlZE1hZ25pdHVkZSA9IE1hdGgucG93KGFscGhhSywgMikgKyBNYXRoLnBvdyhiZXRhSywgMik7XG4gICAgaWYgKHNxdWFyZWRNYWduaXR1ZGUgPD0gOSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRhdUsgPSAzIC8gTWF0aC5zcXJ0KHNxdWFyZWRNYWduaXR1ZGUpO1xuICAgIG1LW2ldID0gYWxwaGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgICBtS1tpICsgMV0gPSBiZXRhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gIH1cbn1cbmZ1bmN0aW9uIG1vbm90b25lQ29tcHV0ZShwb2ludHMsIG1LLCBpbmRleEF4aXMgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBkZWx0YSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBpUGl4ZWwgPSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcbiAgICBjb25zdCB2UGl4ZWwgPSBwb2ludEN1cnJlbnRbdmFsdWVBeGlzXTtcbiAgICBpZiAocG9pbnRCZWZvcmUpIHtcbiAgICAgIGRlbHRhID0gKGlQaXhlbCAtIHBvaW50QmVmb3JlW2luZGV4QXhpc10pIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgLSBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgLSBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgZGVsdGEgPSAocG9pbnRBZnRlcltpbmRleEF4aXNdIC0gaVBpeGVsKSAvIDM7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7aW5kZXhBeGlzfWBdID0gaVBpeGVsICsgZGVsdGE7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7dmFsdWVBeGlzfWBdID0gdlBpeGVsICsgZGVsdGEgKiBtS1tpXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzLCBpbmRleEF4aXMgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IGRlbHRhSyA9IEFycmF5KHBvaW50c0xlbikuZmlsbCgwKTtcbiAgY29uc3QgbUsgPSBBcnJheShwb2ludHNMZW4pO1xuICBsZXQgaSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBjb25zdCBzbG9wZURlbHRhID0gcG9pbnRBZnRlcltpbmRleEF4aXNdIC0gcG9pbnRDdXJyZW50W2luZGV4QXhpc107XG4gICAgICBkZWx0YUtbaV0gPSBzbG9wZURlbHRhICE9PSAwID8gKHBvaW50QWZ0ZXJbdmFsdWVBeGlzXSAtIHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdKSAvIHNsb3BlRGVsdGEgOiAwO1xuICAgIH1cbiAgICBtS1tpXSA9ICFwb2ludEJlZm9yZSA/IGRlbHRhS1tpXVxuICAgICAgOiAhcG9pbnRBZnRlciA/IGRlbHRhS1tpIC0gMV1cbiAgICAgIDogKHNpZ24oZGVsdGFLW2kgLSAxXSkgIT09IHNpZ24oZGVsdGFLW2ldKSkgPyAwXG4gICAgICA6IChkZWx0YUtbaSAtIDFdICsgZGVsdGFLW2ldKSAvIDI7XG4gIH1cbiAgbW9ub3RvbmVBZGp1c3QocG9pbnRzLCBkZWx0YUssIG1LKTtcbiAgbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyk7XG59XG5mdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcbn1cbmZ1bmN0aW9uIGNhcEJlemllclBvaW50cyhwb2ludHMsIGFyZWEpIHtcbiAgbGV0IGksIGlsZW4sIHBvaW50LCBpbkFyZWEsIGluQXJlYVByZXY7XG4gIGxldCBpbkFyZWFOZXh0ID0gX2lzUG9pbnRJbkFyZWEocG9pbnRzWzBdLCBhcmVhKTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpbkFyZWFQcmV2ID0gaW5BcmVhO1xuICAgIGluQXJlYSA9IGluQXJlYU5leHQ7XG4gICAgaW5BcmVhTmV4dCA9IGkgPCBpbGVuIC0gMSAmJiBfaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLCBhcmVhKTtcbiAgICBpZiAoIWluQXJlYSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgIGlmIChpbkFyZWFQcmV2KSB7XG4gICAgICBwb2ludC5jcDF4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXgsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDF5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICAgIGlmIChpbkFyZWFOZXh0KSB7XG4gICAgICBwb2ludC5jcDJ4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDJ5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyhwb2ludHMsIG9wdGlvbnMsIGFyZWEsIGxvb3AsIGluZGV4QXhpcykge1xuICBsZXQgaSwgaWxlbiwgcG9pbnQsIGNvbnRyb2xQb2ludHM7XG4gIGlmIChvcHRpb25zLnNwYW5HYXBzKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLmZpbHRlcigocHQpID0+ICFwdC5za2lwKTtcbiAgfVxuICBpZiAob3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMsIGluZGV4QXhpcyk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHByZXYgPSBsb29wID8gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA6IHBvaW50c1swXTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb250cm9sUG9pbnRzID0gc3BsaW5lQ3VydmUoXG4gICAgICAgIHByZXYsXG4gICAgICAgIHBvaW50LFxuICAgICAgICBwb2ludHNbTWF0aC5taW4oaSArIDEsIGlsZW4gLSAobG9vcCA/IDAgOiAxKSkgJSBpbGVuXSxcbiAgICAgICAgb3B0aW9ucy50ZW5zaW9uXG4gICAgICApO1xuICAgICAgcG9pbnQuY3AxeCA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueDtcbiAgICAgIHBvaW50LmNwMXkgPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLnk7XG4gICAgICBwb2ludC5jcDJ4ID0gY29udHJvbFBvaW50cy5uZXh0Lng7XG4gICAgICBwb2ludC5jcDJ5ID0gY29udHJvbFBvaW50cy5uZXh0Lnk7XG4gICAgICBwcmV2ID0gcG9pbnQ7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLmNhcEJlemllclBvaW50cykge1xuICAgIGNhcEJlemllclBvaW50cyhwb2ludHMsIGFyZWEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pc0RvbVN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBfZ2V0UGFyZW50Tm9kZShkb21Ob2RlKSB7XG4gIGxldCBwYXJlbnQgPSBkb21Ob2RlLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNoYWRvd1Jvb3RdJykge1xuICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICB9XG4gIHJldHVybiBwYXJlbnQ7XG59XG5mdW5jdGlvbiBwYXJzZU1heFN0eWxlKHN0eWxlVmFsdWUsIG5vZGUsIHBhcmVudFByb3BlcnR5KSB7XG4gIGxldCB2YWx1ZUluUGl4ZWxzO1xuICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHBhcnNlSW50KHN0eWxlVmFsdWUsIDEwKTtcbiAgICBpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICB2YWx1ZUluUGl4ZWxzID0gdmFsdWVJblBpeGVscyAvIDEwMCAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xuICB9XG4gIHJldHVybiB2YWx1ZUluUGl4ZWxzO1xufVxuY29uc3QgZ2V0Q29tcHV0ZWRTdHlsZSA9IChlbGVtZW50KSA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbmZ1bmN0aW9uIGdldFN0eWxlKGVsLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG59XG5jb25zdCBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuZnVuY3Rpb24gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlcywgc3R5bGUsIHN1ZmZpeCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgc3VmZml4ID0gc3VmZml4ID8gJy0nICsgc3VmZml4IDogJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgY29uc3QgcG9zID0gcG9zaXRpb25zW2ldO1xuICAgIHJlc3VsdFtwb3NdID0gcGFyc2VGbG9hdChzdHlsZXNbc3R5bGUgKyAnLScgKyBwb3MgKyBzdWZmaXhdKSB8fCAwO1xuICB9XG4gIHJlc3VsdC53aWR0aCA9IHJlc3VsdC5sZWZ0ICsgcmVzdWx0LnJpZ2h0O1xuICByZXN1bHQuaGVpZ2h0ID0gcmVzdWx0LnRvcCArIHJlc3VsdC5ib3R0b207XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCB1c2VPZmZzZXRQb3MgPSAoeCwgeSwgdGFyZ2V0KSA9PiAoeCA+IDAgfHwgeSA+IDApICYmICghdGFyZ2V0IHx8ICF0YXJnZXQuc2hhZG93Um9vdCk7XG5mdW5jdGlvbiBnZXRDYW52YXNQb3NpdGlvbihldnQsIGNhbnZhcykge1xuICBjb25zdCBlID0gZXZ0Lm5hdGl2ZSB8fCBldnQ7XG4gIGNvbnN0IHRvdWNoZXMgPSBlLnRvdWNoZXM7XG4gIGNvbnN0IHNvdXJjZSA9IHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPyB0b3VjaGVzWzBdIDogZTtcbiAgY29uc3Qge29mZnNldFgsIG9mZnNldFl9ID0gc291cmNlO1xuICBsZXQgYm94ID0gZmFsc2U7XG4gIGxldCB4LCB5O1xuICBpZiAodXNlT2Zmc2V0UG9zKG9mZnNldFgsIG9mZnNldFksIGUudGFyZ2V0KSkge1xuICAgIHggPSBvZmZzZXRYO1xuICAgIHkgPSBvZmZzZXRZO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgeCA9IHNvdXJjZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgIHkgPSBzb3VyY2UuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgIGJveCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHt4LCB5LCBib3h9O1xufVxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihldnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHtjYW52YXMsIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvfSA9IGNoYXJ0O1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgYm9yZGVyQm94ID0gc3R5bGUuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCc7XG4gIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gIGNvbnN0IHt4LCB5LCBib3h9ID0gZ2V0Q2FudmFzUG9zaXRpb24oZXZ0LCBjYW52YXMpO1xuICBjb25zdCB4T2Zmc2V0ID0gcGFkZGluZ3MubGVmdCArIChib3ggJiYgYm9yZGVycy5sZWZ0KTtcbiAgY29uc3QgeU9mZnNldCA9IHBhZGRpbmdzLnRvcCArIChib3ggJiYgYm9yZGVycy50b3ApO1xuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY2hhcnQ7XG4gIGlmIChib3JkZXJCb3gpIHtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZCgoeCAtIHhPZmZzZXQpIC8gd2lkdGggKiBjYW52YXMud2lkdGggLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyksXG4gICAgeTogTWF0aC5yb3VuZCgoeSAtIHlPZmZzZXQpIC8gaGVpZ2h0ICogY2FudmFzLmhlaWdodCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgbGV0IG1heFdpZHRoLCBtYXhIZWlnaHQ7XG4gIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgd2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICBoZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgICBjb25zdCBjb250YWluZXJCb3JkZXIgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmcgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdwYWRkaW5nJyk7XG4gICAgICB3aWR0aCA9IHJlY3Qud2lkdGggLSBjb250YWluZXJQYWRkaW5nLndpZHRoIC0gY29udGFpbmVyQm9yZGVyLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLSBjb250YWluZXJQYWRkaW5nLmhlaWdodCAtIGNvbnRhaW5lckJvcmRlci5oZWlnaHQ7XG4gICAgICBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4V2lkdGgsIGNvbnRhaW5lciwgJ2NsaWVudFdpZHRoJyk7XG4gICAgICBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heEhlaWdodCwgY29udGFpbmVyLCAnY2xpZW50SGVpZ2h0Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG1heFdpZHRoOiBtYXhXaWR0aCB8fCBJTkZJTklUWSxcbiAgICBtYXhIZWlnaHQ6IG1heEhlaWdodCB8fCBJTkZJTklUWVxuICB9O1xufVxuY29uc3Qgcm91bmQxID0gdiA9PiBNYXRoLnJvdW5kKHYgKiAxMCkgLyAxMDtcbmZ1bmN0aW9uIGdldE1heGltdW1TaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBtYXJnaW5zID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnbWFyZ2luJyk7XG4gIGNvbnN0IG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhXaWR0aCwgY2FudmFzLCAnY2xpZW50V2lkdGgnKSB8fCBJTkZJTklUWTtcbiAgY29uc3QgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhIZWlnaHQsIGNhbnZhcywgJ2NsaWVudEhlaWdodCcpIHx8IElORklOSVRZO1xuICBjb25zdCBjb250YWluZXJTaXplID0gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXMsIGJiV2lkdGgsIGJiSGVpZ2h0KTtcbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNvbnRhaW5lclNpemU7XG4gIGlmIChzdHlsZS5ib3hTaXppbmcgPT09ICdjb250ZW50LWJveCcpIHtcbiAgICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gICAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIC0gbWFyZ2lucy53aWR0aCk7XG4gIGhlaWdodCA9IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gTWF0aC5mbG9vcih3aWR0aCAvIGFzcGVjdFJhdGlvKSA6IGhlaWdodCAtIG1hcmdpbnMuaGVpZ2h0KTtcbiAgd2lkdGggPSByb3VuZDEoTWF0aC5taW4od2lkdGgsIG1heFdpZHRoLCBjb250YWluZXJTaXplLm1heFdpZHRoKSk7XG4gIGhlaWdodCA9IHJvdW5kMShNYXRoLm1pbihoZWlnaHQsIG1heEhlaWdodCwgY29udGFpbmVyU2l6ZS5tYXhIZWlnaHQpKTtcbiAgaWYgKHdpZHRoICYmICFoZWlnaHQpIHtcbiAgICBoZWlnaHQgPSByb3VuZDEod2lkdGggLyAyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gcmV0aW5hU2NhbGUoY2hhcnQsIGZvcmNlUmF0aW8sIGZvcmNlU3R5bGUpIHtcbiAgY29uc3QgcGl4ZWxSYXRpbyA9IGZvcmNlUmF0aW8gfHwgMTtcbiAgY29uc3QgZGV2aWNlSGVpZ2h0ID0gTWF0aC5mbG9vcihjaGFydC5oZWlnaHQgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlV2lkdGggPSBNYXRoLmZsb29yKGNoYXJ0LndpZHRoICogcGl4ZWxSYXRpbyk7XG4gIGNoYXJ0LmhlaWdodCA9IGRldmljZUhlaWdodCAvIHBpeGVsUmF0aW87XG4gIGNoYXJ0LndpZHRoID0gZGV2aWNlV2lkdGggLyBwaXhlbFJhdGlvO1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGlmIChjYW52YXMuc3R5bGUgJiYgKGZvcmNlU3R5bGUgfHwgKCFjYW52YXMuc3R5bGUuaGVpZ2h0ICYmICFjYW52YXMuc3R5bGUud2lkdGgpKSkge1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtjaGFydC5oZWlnaHR9cHhgO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke2NoYXJ0LndpZHRofXB4YDtcbiAgfVxuICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IHBpeGVsUmF0aW9cbiAgICAgIHx8IGNhbnZhcy5oZWlnaHQgIT09IGRldmljZUhlaWdodFxuICAgICAgfHwgY2FudmFzLndpZHRoICE9PSBkZXZpY2VXaWR0aCkge1xuICAgIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICBjYW52YXMuaGVpZ2h0ID0gZGV2aWNlSGVpZ2h0O1xuICAgIGNhbnZhcy53aWR0aCA9IGRldmljZVdpZHRoO1xuICAgIGNoYXJ0LmN0eC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3Qgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IChmdW5jdGlvbigpIHtcbiAgbGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbn0oKSk7XG5mdW5jdGlvbiByZWFkVXNlZFNpemUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgY29uc3QgdmFsdWUgPSBnZXRTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSk7XG4gIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyArbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gX3BvaW50SW5MaW5lKHAxLCBwMiwgdCwgbW9kZSkge1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBwMS55ICsgdCAqIChwMi55IC0gcDEueSlcbiAgfTtcbn1cbmZ1bmN0aW9uIF9zdGVwcGVkSW50ZXJwb2xhdGlvbihwMSwgcDIsIHQsIG1vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgeTogbW9kZSA9PT0gJ21pZGRsZScgPyB0IDwgMC41ID8gcDEueSA6IHAyLnlcbiAgICA6IG1vZGUgPT09ICdhZnRlcicgPyB0IDwgMSA/IHAxLnkgOiBwMi55XG4gICAgOiB0ID4gMCA/IHAyLnkgOiBwMS55XG4gIH07XG59XG5mdW5jdGlvbiBfYmV6aWVySW50ZXJwb2xhdGlvbihwMSwgcDIsIHQsIG1vZGUpIHtcbiAgY29uc3QgY3AxID0ge3g6IHAxLmNwMngsIHk6IHAxLmNwMnl9O1xuICBjb25zdCBjcDIgPSB7eDogcDIuY3AxeCwgeTogcDIuY3AxeX07XG4gIGNvbnN0IGEgPSBfcG9pbnRJbkxpbmUocDEsIGNwMSwgdCk7XG4gIGNvbnN0IGIgPSBfcG9pbnRJbkxpbmUoY3AxLCBjcDIsIHQpO1xuICBjb25zdCBjID0gX3BvaW50SW5MaW5lKGNwMiwgcDIsIHQpO1xuICBjb25zdCBkID0gX3BvaW50SW5MaW5lKGEsIGIsIHQpO1xuICBjb25zdCBlID0gX3BvaW50SW5MaW5lKGIsIGMsIHQpO1xuICByZXR1cm4gX3BvaW50SW5MaW5lKGQsIGUsIHQpO1xufVxuXG5jb25zdCBpbnRsQ2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBjYWNoZUtleSA9IGxvY2FsZSArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICBsZXQgZm9ybWF0dGVyID0gaW50bENhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghZm9ybWF0dGVyKSB7XG4gICAgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgaW50bENhY2hlLnNldChjYWNoZUtleSwgZm9ybWF0dGVyKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0dGVyO1xufVxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gIHJldHVybiBnZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQobnVtKTtcbn1cblxuY29uc3QgZ2V0UmlnaHRUb0xlZnRBZGFwdGVyID0gZnVuY3Rpb24ocmVjdFgsIHdpZHRoKSB7XG4gIHJldHVybiB7XG4gICAgeCh4KSB7XG4gICAgICByZXR1cm4gcmVjdFggKyByZWN0WCArIHdpZHRoIC0geDtcbiAgICB9LFxuICAgIHNldFdpZHRoKHcpIHtcbiAgICAgIHdpZHRoID0gdztcbiAgICB9LFxuICAgIHRleHRBbGlnbihhbGlnbikge1xuICAgICAgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICByZXR1cm4gYWxpZ247XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH0sXG4gICAgeFBsdXMoeCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB4IC0gdmFsdWU7XG4gICAgfSxcbiAgICBsZWZ0Rm9yTHRyKHgsIGl0ZW1XaWR0aCkge1xuICAgICAgcmV0dXJuIHggLSBpdGVtV2lkdGg7XG4gICAgfSxcbiAgfTtcbn07XG5jb25zdCBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykge1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICByZXR1cm4gYWxpZ247XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggKyB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgX2l0ZW1XaWR0aCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgfTtcbn07XG5mdW5jdGlvbiBnZXRSdGxBZGFwdGVyKHJ0bCwgcmVjdFgsIHdpZHRoKSB7XG4gIHJldHVybiBydGwgPyBnZXRSaWdodFRvTGVmdEFkYXB0ZXIocmVjdFgsIHdpZHRoKSA6IGdldExlZnRUb1JpZ2h0QWRhcHRlcigpO1xufVxuZnVuY3Rpb24gb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKGN0eCwgZGlyZWN0aW9uKSB7XG4gIGxldCBzdHlsZSwgb3JpZ2luYWw7XG4gIGlmIChkaXJlY3Rpb24gPT09ICdsdHInIHx8IGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICBzdHlsZSA9IGN0eC5jYW52YXMuc3R5bGU7XG4gICAgb3JpZ2luYWwgPSBbXG4gICAgICBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSxcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkoJ2RpcmVjdGlvbicpLFxuICAgIF07XG4gICAgc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIGRpcmVjdGlvbiwgJ2ltcG9ydGFudCcpO1xuICAgIGN0eC5wcmV2VGV4dERpcmVjdGlvbiA9IG9yaWdpbmFsO1xuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlVGV4dERpcmVjdGlvbihjdHgsIG9yaWdpbmFsKSB7XG4gIGlmIChvcmlnaW5hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVsZXRlIGN0eC5wcmV2VGV4dERpcmVjdGlvbjtcbiAgICBjdHguY2FudmFzLnN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBvcmlnaW5hbFswXSwgb3JpZ2luYWxbMV0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5Rm4ocHJvcGVydHkpIHtcbiAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJldHdlZW46IF9hbmdsZUJldHdlZW4sXG4gICAgICBjb21wYXJlOiBfYW5nbGVEaWZmLFxuICAgICAgbm9ybWFsaXplOiBfbm9ybWFsaXplQW5nbGUsXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJldHdlZW46IF9pc0JldHdlZW4sXG4gICAgY29tcGFyZTogKGEsIGIpID0+IGEgLSBiLFxuICAgIG5vcm1hbGl6ZTogeCA9PiB4XG4gIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVTZWdtZW50KHtzdGFydCwgZW5kLCBjb3VudCwgbG9vcCwgc3R5bGV9KSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0ICUgY291bnQsXG4gICAgZW5kOiBlbmQgJSBjb3VudCxcbiAgICBsb29wOiBsb29wICYmIChlbmQgLSBzdGFydCArIDEpICUgY291bnQgPT09IDAsXG4gICAgc3R5bGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IHtiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IHtzdGFydCwgZW5kLCBsb29wfSA9IHNlZ21lbnQ7XG4gIGxldCBpLCBpbGVuO1xuICBpZiAobG9vcCkge1xuICAgIHN0YXJ0ICs9IGNvdW50O1xuICAgIGVuZCArPSBjb3VudDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICghYmV0d2Vlbihub3JtYWxpemUocG9pbnRzW3N0YXJ0ICUgY291bnRdW3Byb3BlcnR5XSksIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXJ0LS07XG4gICAgICBlbmQtLTtcbiAgICB9XG4gICAgc3RhcnQgJT0gY291bnQ7XG4gICAgZW5kICU9IGNvdW50O1xuICB9XG4gIGlmIChlbmQgPCBzdGFydCkge1xuICAgIGVuZCArPSBjb3VudDtcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlOiBzZWdtZW50LnN0eWxlfTtcbn1cbmZ1bmN0aW9uIF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgaWYgKCFib3VuZHMpIHtcbiAgICByZXR1cm4gW3NlZ21lbnRdO1xuICB9XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQ6IHN0YXJ0Qm91bmQsIGVuZDogZW5kQm91bmR9ID0gYm91bmRzO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHtjb21wYXJlLCBiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gIGNvbnN0IHtzdGFydCwgZW5kLCBsb29wLCBzdHlsZX0gPSBnZXRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgbGV0IHN1YlN0YXJ0ID0gbnVsbDtcbiAgbGV0IHZhbHVlLCBwb2ludCwgcHJldlZhbHVlO1xuICBjb25zdCBzdGFydElzQmVmb3JlID0gKCkgPT4gYmV0d2VlbihzdGFydEJvdW5kLCBwcmV2VmFsdWUsIHZhbHVlKSAmJiBjb21wYXJlKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSkgIT09IDA7XG4gIGNvbnN0IGVuZElzQmVmb3JlID0gKCkgPT4gY29tcGFyZShlbmRCb3VuZCwgdmFsdWUpID09PSAwIHx8IGJldHdlZW4oZW5kQm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpO1xuICBjb25zdCBzaG91bGRTdGFydCA9ICgpID0+IGluc2lkZSB8fCBzdGFydElzQmVmb3JlKCk7XG4gIGNvbnN0IHNob3VsZFN0b3AgPSAoKSA9PiAhaW5zaWRlIHx8IGVuZElzQmVmb3JlKCk7XG4gIGZvciAobGV0IGkgPSBzdGFydCwgcHJldiA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbaSAlIGNvdW50XTtcbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhbHVlID0gbm9ybWFsaXplKHBvaW50W3Byb3BlcnR5XSk7XG4gICAgaWYgKHZhbHVlID09PSBwcmV2VmFsdWUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpbnNpZGUgPSBiZXR3ZWVuKHZhbHVlLCBzdGFydEJvdW5kLCBlbmRCb3VuZCk7XG4gICAgaWYgKHN1YlN0YXJ0ID09PSBudWxsICYmIHNob3VsZFN0YXJ0KCkpIHtcbiAgICAgIHN1YlN0YXJ0ID0gY29tcGFyZSh2YWx1ZSwgc3RhcnRCb3VuZCkgPT09IDAgPyBpIDogcHJldjtcbiAgICB9XG4gICAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsICYmIHNob3VsZFN0b3AoKSkge1xuICAgICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7c3RhcnQ6IHN1YlN0YXJ0LCBlbmQ6IGksIGxvb3AsIGNvdW50LCBzdHlsZX0pKTtcbiAgICAgIHN1YlN0YXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgcHJldiA9IGk7XG4gICAgcHJldlZhbHVlID0gdmFsdWU7XG4gIH1cbiAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7c3RhcnQ6IHN1YlN0YXJ0LCBlbmQsIGxvb3AsIGNvdW50LCBzdHlsZX0pKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2JvdW5kU2VnbWVudHMobGluZSwgYm91bmRzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzdWIgPSBfYm91bmRTZWdtZW50KHNlZ21lbnRzW2ldLCBsaW5lLnBvaW50cywgYm91bmRzKTtcbiAgICBpZiAoc3ViLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2goLi4uc3ViKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcykge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gY291bnQgLSAxO1xuICBpZiAobG9vcCAmJiAhc3BhbkdhcHMpIHtcbiAgICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiAhcG9pbnRzW3N0YXJ0XS5za2lwKSB7XG4gICAgICBzdGFydCsrO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiBwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICBzdGFydCsrO1xuICB9XG4gIHN0YXJ0ICU9IGNvdW50O1xuICBpZiAobG9vcCkge1xuICAgIGVuZCArPSBzdGFydDtcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgcG9pbnRzW2VuZCAlIGNvdW50XS5za2lwKSB7XG4gICAgZW5kLS07XG4gIH1cbiAgZW5kICU9IGNvdW50O1xuICByZXR1cm4ge3N0YXJ0LCBlbmR9O1xufVxuZnVuY3Rpb24gc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGxvb3ApIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGxhc3QgPSBzdGFydDtcbiAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnRdO1xuICBsZXQgZW5kO1xuICBmb3IgKGVuZCA9IHN0YXJ0ICsgMTsgZW5kIDw9IG1heDsgKytlbmQpIHtcbiAgICBjb25zdCBjdXIgPSBwb2ludHNbZW5kICUgY291bnRdO1xuICAgIGlmIChjdXIuc2tpcCB8fCBjdXIuc3RvcCkge1xuICAgICAgaWYgKCFwcmV2LnNraXApIHtcbiAgICAgICAgbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHN0YXJ0ICUgY291bnQsIGVuZDogKGVuZCAtIDEpICUgY291bnQsIGxvb3B9KTtcbiAgICAgICAgc3RhcnQgPSBsYXN0ID0gY3VyLnN0b3AgPyBlbmQgOiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gZW5kO1xuICAgICAgaWYgKHByZXYuc2tpcCkge1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJldiA9IGN1cjtcbiAgfVxuICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiBsYXN0ICUgY291bnQsIGxvb3B9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2NvbXB1dGVTZWdtZW50cyhsaW5lLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3Qgc3BhbkdhcHMgPSBsaW5lLm9wdGlvbnMuc3BhbkdhcHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgaWYgKCFjb3VudCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBsb29wID0gISFsaW5lLl9sb29wO1xuICBjb25zdCB7c3RhcnQsIGVuZH0gPSBmaW5kU3RhcnRBbmRFbmQocG9pbnRzLCBjb3VudCwgbG9vcCwgc3BhbkdhcHMpO1xuICBpZiAoc3BhbkdhcHMgPT09IHRydWUpIHtcbiAgICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBbe3N0YXJ0LCBlbmQsIGxvb3B9XSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG4gIH1cbiAgY29uc3QgbWF4ID0gZW5kIDwgc3RhcnQgPyBlbmQgKyBjb3VudCA6IGVuZDtcbiAgY29uc3QgY29tcGxldGVMb29wID0gISFsaW5lLl9mdWxsTG9vcCAmJiBzdGFydCA9PT0gMCAmJiBlbmQgPT09IGNvdW50IC0gMTtcbiAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGNvbXBsZXRlTG9vcCksIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuZnVuY3Rpb24gc3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBpZiAoIXNlZ21lbnRPcHRpb25zIHx8ICFzZWdtZW50T3B0aW9ucy5zZXRDb250ZXh0IHx8ICFwb2ludHMpIHtcbiAgICByZXR1cm4gc2VnbWVudHM7XG4gIH1cbiAgcmV0dXJuIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkb1NwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpIHtcbiAgY29uc3QgY2hhcnRDb250ZXh0ID0gbGluZS5fY2hhcnQuZ2V0Q29udGV4dCgpO1xuICBjb25zdCBiYXNlU3R5bGUgPSByZWFkU3R5bGUobGluZS5vcHRpb25zKTtcbiAgY29uc3Qge19kYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleCwgb3B0aW9uczoge3NwYW5HYXBzfX0gPSBsaW5lO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgcHJldlN0eWxlID0gYmFzZVN0eWxlO1xuICBsZXQgc3RhcnQgPSBzZWdtZW50c1swXS5zdGFydDtcbiAgbGV0IGkgPSBzdGFydDtcbiAgZnVuY3Rpb24gYWRkU3R5bGUocywgZSwgbCwgc3QpIHtcbiAgICBjb25zdCBkaXIgPSBzcGFuR2FwcyA/IC0xIDogMTtcbiAgICBpZiAocyA9PT0gZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzICs9IGNvdW50O1xuICAgIHdoaWxlIChwb2ludHNbcyAlIGNvdW50XS5za2lwKSB7XG4gICAgICBzIC09IGRpcjtcbiAgICB9XG4gICAgd2hpbGUgKHBvaW50c1tlICUgY291bnRdLnNraXApIHtcbiAgICAgIGUgKz0gZGlyO1xuICAgIH1cbiAgICBpZiAocyAlIGNvdW50ICE9PSBlICUgY291bnQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogcyAlIGNvdW50LCBlbmQ6IGUgJSBjb3VudCwgbG9vcDogbCwgc3R5bGU6IHN0fSk7XG4gICAgICBwcmV2U3R5bGUgPSBzdDtcbiAgICAgIHN0YXJ0ID0gZSAlIGNvdW50O1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzdGFydCA9IHNwYW5HYXBzID8gc3RhcnQgOiBzZWdtZW50LnN0YXJ0O1xuICAgIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0ICUgY291bnRdO1xuICAgIGxldCBzdHlsZTtcbiAgICBmb3IgKGkgPSBzdGFydCArIDE7IGkgPD0gc2VnbWVudC5lbmQ7IGkrKykge1xuICAgICAgY29uc3QgcHQgPSBwb2ludHNbaSAlIGNvdW50XTtcbiAgICAgIHN0eWxlID0gcmVhZFN0eWxlKHNlZ21lbnRPcHRpb25zLnNldENvbnRleHQoY3JlYXRlQ29udGV4dChjaGFydENvbnRleHQsIHtcbiAgICAgICAgdHlwZTogJ3NlZ21lbnQnLFxuICAgICAgICBwMDogcHJldixcbiAgICAgICAgcDE6IHB0LFxuICAgICAgICBwMERhdGFJbmRleDogKGkgLSAxKSAlIGNvdW50LFxuICAgICAgICBwMURhdGFJbmRleDogaSAlIGNvdW50LFxuICAgICAgICBkYXRhc2V0SW5kZXhcbiAgICAgIH0pKSk7XG4gICAgICBpZiAoc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpKSB7XG4gICAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgICAgfVxuICAgICAgcHJldiA9IHB0O1xuICAgICAgcHJldlN0eWxlID0gc3R5bGU7XG4gICAgfVxuICAgIGlmIChzdGFydCA8IGkgLSAxKSB7XG4gICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJlYWRTdHlsZShvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICBib3JkZXJDYXBTdHlsZTogb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSxcbiAgICBib3JkZXJEYXNoOiBvcHRpb25zLmJvcmRlckRhc2gsXG4gICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgIGJvcmRlckpvaW5TdHlsZTogb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUsXG4gICAgYm9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3JcbiAgfTtcbn1cbmZ1bmN0aW9uIHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSB7XG4gIHJldHVybiBwcmV2U3R5bGUgJiYgSlNPTi5zdHJpbmdpZnkoc3R5bGUpICE9PSBKU09OLnN0cmluZ2lmeShwcmV2U3R5bGUpO1xufVxuXG5leHBvcnQgeyBfdG9MZWZ0UmlnaHRDZW50ZXIgYXMgJCwgX3Jsb29rdXBCeUtleSBhcyBBLCBnZXRBbmdsZUZyb21Qb2ludCBhcyBCLCB0b1BhZGRpbmcgYXMgQywgZWFjaCBhcyBELCBnZXRNYXhpbXVtU2l6ZSBhcyBFLCBfZ2V0UGFyZW50Tm9kZSBhcyBGLCByZWFkVXNlZFNpemUgYXMgRywgSEFMRl9QSSBhcyBILCB0aHJvdHRsZWQgYXMgSSwgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyBhcyBKLCBfaXNEb21TdXBwb3J0ZWQgYXMgSywgbG9nMTAgYXMgTCwgX2ZhY3Rvcml6ZSBhcyBNLCBmaW5pdGVPckRlZmF1bHQgYXMgTiwgY2FsbGJhY2sgYXMgTywgUEkgYXMgUCwgX2FkZEdyYWNlIGFzIFEsIHRvRGVncmVlcyBhcyBSLCBfbWVhc3VyZVRleHQgYXMgUywgVEFVIGFzIFQsIF9pbnQxNlJhbmdlIGFzIFUsIF9hbGlnblBpeGVsIGFzIFYsIGNsaXBBcmVhIGFzIFcsIHJlbmRlclRleHQgYXMgWCwgdW5jbGlwQXJlYSBhcyBZLCB0b0ZvbnQgYXMgWiwgX2FycmF5VW5pcXVlIGFzIF8sIHJlc29sdmUgYXMgYSwgX2FuZ2xlRGlmZiBhcyBhJCwgX2FsaWduU3RhcnRFbmQgYXMgYTAsIG92ZXJyaWRlcyBhcyBhMSwgbWVyZ2UgYXMgYTIsIF9jYXBpdGFsaXplIGFzIGEzLCBkZXNjcmlwdG9ycyBhcyBhNCwgaXNGdW5jdGlvbiBhcyBhNSwgX2F0dGFjaENvbnRleHQgYXMgYTYsIF9jcmVhdGVSZXNvbHZlciBhcyBhNywgX2Rlc2NyaXB0b3JzIGFzIGE4LCBtZXJnZUlmIGFzIGE5LCByZXN0b3JlVGV4dERpcmVjdGlvbiBhcyBhQSwgbm9vcCBhcyBhQiwgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIGFzIGFDLCBfc2V0TWluQW5kTWF4QnlLZXkgYXMgYUQsIG5pY2VOdW0gYXMgYUUsIGFsbW9zdFdob2xlIGFzIGFGLCBhbG1vc3RFcXVhbHMgYXMgYUcsIF9kZWNpbWFsUGxhY2VzIGFzIGFILCBfbG9uZ2VzdFRleHQgYXMgYUksIF9maWx0ZXJCZXR3ZWVuIGFzIGFKLCBfbG9va3VwIGFzIGFLLCBnZXRIb3ZlckNvbG9yIGFzIGFMLCBjbG9uZSQxIGFzIGFNLCBfbWVyZ2VyIGFzIGFOLCBfbWVyZ2VySWYgYXMgYU8sIF9kZXByZWNhdGVkIGFzIGFQLCB0b0ZvbnRTdHJpbmcgYXMgYVEsIHNwbGluZUN1cnZlIGFzIGFSLCBzcGxpbmVDdXJ2ZU1vbm90b25lIGFzIGFTLCBnZXRTdHlsZSBhcyBhVCwgZm9udFN0cmluZyBhcyBhVSwgdG9MaW5lSGVpZ2h0IGFzIGFWLCBQSVRBVSBhcyBhVywgSU5GSU5JVFkgYXMgYVgsIFJBRF9QRVJfREVHIGFzIGFZLCBRVUFSVEVSX1BJIGFzIGFaLCBUV09fVEhJUkRTX1BJIGFzIGFfLCB1aWQgYXMgYWEsIGRlYm91bmNlIGFzIGFiLCByZXRpbmFTY2FsZSBhcyBhYywgY2xlYXJDYW52YXMgYXMgYWQsIHNldHNFcXVhbCBhcyBhZSwgX2VsZW1lbnRzRXF1YWwgYXMgYWYsIF9pc0NsaWNrRXZlbnQgYXMgYWcsIF9pc0JldHdlZW4gYXMgYWgsIF9yZWFkVmFsdWVUb1Byb3BzIGFzIGFpLCBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyBhcyBhaiwgX2NvbXB1dGVTZWdtZW50cyBhcyBhaywgX2JvdW5kU2VnbWVudHMgYXMgYWwsIF9zdGVwcGVkSW50ZXJwb2xhdGlvbiBhcyBhbSwgX2JlemllckludGVycG9sYXRpb24gYXMgYW4sIF9wb2ludEluTGluZSBhcyBhbywgX3N0ZXBwZWRMaW5lVG8gYXMgYXAsIF9iZXppZXJDdXJ2ZVRvIGFzIGFxLCBkcmF3UG9pbnQgYXMgYXIsIGFkZFJvdW5kZWRSZWN0UGF0aCBhcyBhcywgdG9UUkJMIGFzIGF0LCB0b1RSQkxDb3JuZXJzIGFzIGF1LCBfYm91bmRTZWdtZW50IGFzIGF2LCBfbm9ybWFsaXplQW5nbGUgYXMgYXcsIGdldFJ0bEFkYXB0ZXIgYXMgYXgsIG92ZXJyaWRlVGV4dERpcmVjdGlvbiBhcyBheSwgX3RleHRYIGFzIGF6LCBpc0FycmF5IGFzIGIsIGNvbG9yIGFzIGMsIGRlZmF1bHRzIGFzIGQsIGVmZmVjdHMgYXMgZSwgcmVzb2x2ZU9iamVjdEtleSBhcyBmLCBpc051bWJlckZpbml0ZSBhcyBnLCBjcmVhdGVDb250ZXh0IGFzIGgsIGlzT2JqZWN0IGFzIGksIGRlZmluZWQgYXMgaiwgaXNOdWxsT3JVbmRlZiBhcyBrLCBsaXN0ZW5BcnJheUV2ZW50cyBhcyBsLCB0b1BlcmNlbnRhZ2UgYXMgbSwgdG9EaW1lbnNpb24gYXMgbiwgZm9ybWF0TnVtYmVyIGFzIG8sIF9hbmdsZUJldHdlZW4gYXMgcCwgaXNOdW1iZXIgYXMgcSwgcmVxdWVzdEFuaW1GcmFtZSBhcyByLCBzaWduIGFzIHMsIHRvUmFkaWFucyBhcyB0LCB1bmxpc3RlbkFycmF5RXZlbnRzIGFzIHUsIHZhbHVlT3JEZWZhdWx0IGFzIHYsIF9saW1pdFZhbHVlIGFzIHcsIF9sb29rdXBCeUtleSBhcyB4LCBnZXRSZWxhdGl2ZVBvc2l0aW9uIGFzIHksIF9pc1BvaW50SW5BcmVhIGFzIHogfTtcbiIsICIvKiFcbiAqIENoYXJ0LmpzIHYzLjcuMFxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDIxIENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHIgYXMgcmVxdWVzdEFuaW1GcmFtZSwgYSBhcyByZXNvbHZlLCBlIGFzIGVmZmVjdHMsIGMgYXMgY29sb3IsIGQgYXMgZGVmYXVsdHMsIGkgYXMgaXNPYmplY3QsIGIgYXMgaXNBcnJheSwgdiBhcyB2YWx1ZU9yRGVmYXVsdCwgdSBhcyB1bmxpc3RlbkFycmF5RXZlbnRzLCBsIGFzIGxpc3RlbkFycmF5RXZlbnRzLCBmIGFzIHJlc29sdmVPYmplY3RLZXksIGcgYXMgaXNOdW1iZXJGaW5pdGUsIGggYXMgY3JlYXRlQ29udGV4dCwgaiBhcyBkZWZpbmVkLCBzIGFzIHNpZ24sIGsgYXMgaXNOdWxsT3JVbmRlZiwgXyBhcyBfYXJyYXlVbmlxdWUsIHQgYXMgdG9SYWRpYW5zLCBtIGFzIHRvUGVyY2VudGFnZSwgbiBhcyB0b0RpbWVuc2lvbiwgVCBhcyBUQVUsIG8gYXMgZm9ybWF0TnVtYmVyLCBwIGFzIF9hbmdsZUJldHdlZW4sIEggYXMgSEFMRl9QSSwgUCBhcyBQSSwgcSBhcyBpc051bWJlciwgdyBhcyBfbGltaXRWYWx1ZSwgeCBhcyBfbG9va3VwQnlLZXksIHkgYXMgZ2V0UmVsYXRpdmVQb3NpdGlvbiQxLCB6IGFzIF9pc1BvaW50SW5BcmVhLCBBIGFzIF9ybG9va3VwQnlLZXksIEIgYXMgZ2V0QW5nbGVGcm9tUG9pbnQsIEMgYXMgdG9QYWRkaW5nLCBEIGFzIGVhY2gsIEUgYXMgZ2V0TWF4aW11bVNpemUsIEYgYXMgX2dldFBhcmVudE5vZGUsIEcgYXMgcmVhZFVzZWRTaXplLCBJIGFzIHRocm90dGxlZCwgSiBhcyBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zLCBLIGFzIF9pc0RvbVN1cHBvcnRlZCwgTCBhcyBsb2cxMCwgTSBhcyBfZmFjdG9yaXplLCBOIGFzIGZpbml0ZU9yRGVmYXVsdCwgTyBhcyBjYWxsYmFjaywgUSBhcyBfYWRkR3JhY2UsIFIgYXMgdG9EZWdyZWVzLCBTIGFzIF9tZWFzdXJlVGV4dCwgVSBhcyBfaW50MTZSYW5nZSwgViBhcyBfYWxpZ25QaXhlbCwgVyBhcyBjbGlwQXJlYSwgWCBhcyByZW5kZXJUZXh0LCBZIGFzIHVuY2xpcEFyZWEsIFogYXMgdG9Gb250LCAkIGFzIF90b0xlZnRSaWdodENlbnRlciwgYTAgYXMgX2FsaWduU3RhcnRFbmQsIGExIGFzIG92ZXJyaWRlcywgYTIgYXMgbWVyZ2UsIGEzIGFzIF9jYXBpdGFsaXplLCBhNCBhcyBkZXNjcmlwdG9ycywgYTUgYXMgaXNGdW5jdGlvbiwgYTYgYXMgX2F0dGFjaENvbnRleHQsIGE3IGFzIF9jcmVhdGVSZXNvbHZlciwgYTggYXMgX2Rlc2NyaXB0b3JzLCBhOSBhcyBtZXJnZUlmLCBhYSBhcyB1aWQsIGFiIGFzIGRlYm91bmNlLCBhYyBhcyByZXRpbmFTY2FsZSwgYWQgYXMgY2xlYXJDYW52YXMsIGFlIGFzIHNldHNFcXVhbCwgYWYgYXMgX2VsZW1lbnRzRXF1YWwsIGFnIGFzIF9pc0NsaWNrRXZlbnQsIGFoIGFzIF9pc0JldHdlZW4sIGFpIGFzIF9yZWFkVmFsdWVUb1Byb3BzLCBhaiBhcyBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cywgYWsgYXMgX2NvbXB1dGVTZWdtZW50cywgYWwgYXMgX2JvdW5kU2VnbWVudHMsIGFtIGFzIF9zdGVwcGVkSW50ZXJwb2xhdGlvbiwgYW4gYXMgX2JlemllckludGVycG9sYXRpb24sIGFvIGFzIF9wb2ludEluTGluZSwgYXAgYXMgX3N0ZXBwZWRMaW5lVG8sIGFxIGFzIF9iZXppZXJDdXJ2ZVRvLCBhciBhcyBkcmF3UG9pbnQsIGFzIGFzIGFkZFJvdW5kZWRSZWN0UGF0aCwgYXQgYXMgdG9UUkJMLCBhdSBhcyB0b1RSQkxDb3JuZXJzLCBhdiBhcyBfYm91bmRTZWdtZW50LCBhdyBhcyBfbm9ybWFsaXplQW5nbGUsIGF4IGFzIGdldFJ0bEFkYXB0ZXIsIGF5IGFzIG92ZXJyaWRlVGV4dERpcmVjdGlvbiwgYXogYXMgX3RleHRYLCBhQSBhcyByZXN0b3JlVGV4dERpcmVjdGlvbiwgYUIgYXMgbm9vcCwgYUMgYXMgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBhRCBhcyBfc2V0TWluQW5kTWF4QnlLZXksIGFFIGFzIG5pY2VOdW0sIGFGIGFzIGFsbW9zdFdob2xlLCBhRyBhcyBhbG1vc3RFcXVhbHMsIGFIIGFzIF9kZWNpbWFsUGxhY2VzLCBhSSBhcyBfbG9uZ2VzdFRleHQsIGFKIGFzIF9maWx0ZXJCZXR3ZWVuLCBhSyBhcyBfbG9va3VwIH0gZnJvbSAnLi9jaHVua3MvaGVscGVycy5zZWdtZW50LmpzJztcbmV4cG9ydCB7IGQgYXMgZGVmYXVsdHMgfSBmcm9tICcuL2NodW5rcy9oZWxwZXJzLnNlZ21lbnQuanMnO1xuXG5jbGFzcyBBbmltYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMuX2NoYXJ0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdERhdGUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsIHR5cGUpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBhbmltcy5saXN0ZW5lcnNbdHlwZV07XG4gICAgY29uc3QgbnVtU3RlcHMgPSBhbmltcy5kdXJhdGlvbjtcbiAgICBjYWxsYmFja3MuZm9yRWFjaChmbiA9PiBmbih7XG4gICAgICBjaGFydCxcbiAgICAgIGluaXRpYWw6IGFuaW1zLmluaXRpYWwsXG4gICAgICBudW1TdGVwcyxcbiAgICAgIGN1cnJlbnRTdGVwOiBNYXRoLm1pbihkYXRlIC0gYW5pbXMuc3RhcnQsIG51bVN0ZXBzKVxuICAgIH0pKTtcbiAgfVxuICBfcmVmcmVzaCgpIHtcbiAgICBpZiAodGhpcy5fcmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlKGRhdGUgPSBEYXRlLm5vdygpKSB7XG4gICAgbGV0IHJlbWFpbmluZyA9IDA7XG4gICAgdGhpcy5fY2hhcnRzLmZvckVhY2goKGFuaW1zLCBjaGFydCkgPT4ge1xuICAgICAgaWYgKCFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBkcmF3ID0gZmFsc2U7XG4gICAgICBsZXQgaXRlbTtcbiAgICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtLl9hY3RpdmUpIHtcbiAgICAgICAgICBpZiAoaXRlbS5fdG90YWwgPiBhbmltcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgYW5pbXMuZHVyYXRpb24gPSBpdGVtLl90b3RhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbS50aWNrKGRhdGUpO1xuICAgICAgICAgIGRyYXcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1zW2ldID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaXRlbXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkcmF3KSB7XG4gICAgICAgIGNoYXJ0LmRyYXcoKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ3Byb2dyZXNzJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBhbmltcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdjb21wbGV0ZScpO1xuICAgICAgICBhbmltcy5pbml0aWFsID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZW1haW5pbmcgKz0gaXRlbXMubGVuZ3RoO1xuICAgIH0pO1xuICAgIHRoaXMuX2xhc3REYXRlID0gZGF0ZTtcbiAgICBpZiAocmVtYWluaW5nID09PSAwKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIF9nZXRBbmltcyhjaGFydCkge1xuICAgIGNvbnN0IGNoYXJ0cyA9IHRoaXMuX2NoYXJ0cztcbiAgICBsZXQgYW5pbXMgPSBjaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICBhbmltcyA9IHtcbiAgICAgICAgcnVubmluZzogZmFsc2UsXG4gICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgY29tcGxldGU6IFtdLFxuICAgICAgICAgIHByb2dyZXNzOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhcnRzLnNldChjaGFydCwgYW5pbXMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbXM7XG4gIH1cbiAgbGlzdGVuKGNoYXJ0LCBldmVudCwgY2IpIHtcbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkubGlzdGVuZXJzW2V2ZW50XS5wdXNoKGNiKTtcbiAgfVxuICBhZGQoY2hhcnQsIGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5wdXNoKC4uLml0ZW1zKTtcbiAgfVxuICBoYXMoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLmxlbmd0aCA+IDA7XG4gIH1cbiAgc3RhcnQoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbXMucnVubmluZyA9IHRydWU7XG4gICAgYW5pbXMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGFuaW1zLmR1cmF0aW9uID0gYW5pbXMuaXRlbXMucmVkdWNlKChhY2MsIGN1cikgPT4gTWF0aC5tYXgoYWNjLCBjdXIuX2R1cmF0aW9uKSwgMCk7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIHJ1bm5pbmcoY2hhcnQpIHtcbiAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XG4gICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgaXRlbXNbaV0uY2FuY2VsKCk7XG4gICAgfVxuICAgIGFuaW1zLml0ZW1zID0gW107XG4gICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgRGF0ZS5ub3coKSwgJ2NvbXBsZXRlJyk7XG4gIH1cbiAgcmVtb3ZlKGNoYXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICB9XG59XG52YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoKTtcblxuY29uc3QgdHJhbnNwYXJlbnQgPSAndHJhbnNwYXJlbnQnO1xuY29uc3QgaW50ZXJwb2xhdG9ycyA9IHtcbiAgYm9vbGVhbihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZhY3RvciA+IDAuNSA/IHRvIDogZnJvbTtcbiAgfSxcbiAgY29sb3IoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIGNvbnN0IGMwID0gY29sb3IoZnJvbSB8fCB0cmFuc3BhcmVudCk7XG4gICAgY29uc3QgYzEgPSBjMC52YWxpZCAmJiBjb2xvcih0byB8fCB0cmFuc3BhcmVudCk7XG4gICAgcmV0dXJuIGMxICYmIGMxLnZhbGlkXG4gICAgICA/IGMxLm1peChjMCwgZmFjdG9yKS5oZXhTdHJpbmcoKVxuICAgICAgOiB0bztcbiAgfSxcbiAgbnVtYmVyKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogZmFjdG9yO1xuICB9XG59O1xuY2xhc3MgQW5pbWF0aW9uIHtcbiAgY29uc3RydWN0b3IoY2ZnLCB0YXJnZXQsIHByb3AsIHRvKSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuICAgIHRvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgIGNvbnN0IGZyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5fZm4gPSBjZmcuZm4gfHwgaW50ZXJwb2xhdG9yc1tjZmcudHlwZSB8fCB0eXBlb2YgZnJvbV07XG4gICAgdGhpcy5fZWFzaW5nID0gZWZmZWN0c1tjZmcuZWFzaW5nXSB8fCBlZmZlY3RzLmxpbmVhcjtcbiAgICB0aGlzLl9zdGFydCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSArIChjZmcuZGVsYXkgfHwgMCkpO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWwgPSBNYXRoLmZsb29yKGNmZy5kdXJhdGlvbik7XG4gICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuX3Byb3AgPSBwcm9wO1xuICAgIHRoaXMuX2Zyb20gPSBmcm9tO1xuICAgIHRoaXMuX3RvID0gdG87XG4gICAgdGhpcy5fcHJvbWlzZXMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cbiAgdXBkYXRlKGNmZywgdG8sIGRhdGUpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5fdGFyZ2V0W3RoaXMuX3Byb3BdO1xuICAgICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICAgIGNvbnN0IHJlbWFpbiA9IHRoaXMuX2R1cmF0aW9uIC0gZWxhcHNlZDtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gZGF0ZTtcbiAgICAgIHRoaXMuX2R1cmF0aW9uID0gTWF0aC5mbG9vcihNYXRoLm1heChyZW1haW4sIGNmZy5kdXJhdGlvbikpO1xuICAgICAgdGhpcy5fdG90YWwgKz0gZWxhcHNlZDtcbiAgICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xuICAgICAgdGhpcy5fdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgICB0aGlzLl9mcm9tID0gcmVzb2x2ZShbY2ZnLmZyb20sIGN1cnJlbnRWYWx1ZSwgdG9dKTtcbiAgICB9XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMudGljayhEYXRlLm5vdygpKTtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgdGljayhkYXRlKSB7XG4gICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgIGNvbnN0IHByb3AgPSB0aGlzLl9wcm9wO1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLl9mcm9tO1xuICAgIGNvbnN0IGxvb3AgPSB0aGlzLl9sb29wO1xuICAgIGNvbnN0IHRvID0gdGhpcy5fdG87XG4gICAgbGV0IGZhY3RvcjtcbiAgICB0aGlzLl9hY3RpdmUgPSBmcm9tICE9PSB0byAmJiAobG9vcCB8fCAoZWxhcHNlZCA8IGR1cmF0aW9uKSk7XG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRvO1xuICAgICAgdGhpcy5fbm90aWZ5KHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWxhcHNlZCA8IDApIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IGZyb207XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZhY3RvciA9IChlbGFwc2VkIC8gZHVyYXRpb24pICUgMjtcbiAgICBmYWN0b3IgPSBsb29wICYmIGZhY3RvciA+IDEgPyAyIC0gZmFjdG9yIDogZmFjdG9yO1xuICAgIGZhY3RvciA9IHRoaXMuX2Vhc2luZyhNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBmYWN0b3IpKSk7XG4gICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdGhpcy5fZm4oZnJvbSwgdG8sIGZhY3Rvcik7XG4gIH1cbiAgd2FpdCgpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8ICh0aGlzLl9wcm9taXNlcyA9IFtdKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICBwcm9taXNlcy5wdXNoKHtyZXMsIHJlan0pO1xuICAgIH0pO1xuICB9XG4gIF9ub3RpZnkocmVzb2x2ZWQpIHtcbiAgICBjb25zdCBtZXRob2QgPSByZXNvbHZlZCA/ICdyZXMnIDogJ3Jlaic7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLl9wcm9taXNlcyB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9taXNlc1tpXVttZXRob2RdKCk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IG51bWJlcnMgPSBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnLCAndGVuc2lvbiddO1xuY29uc3QgY29sb3JzID0gWydjb2xvcicsICdib3JkZXJDb2xvcicsICdiYWNrZ3JvdW5kQ29sb3InXTtcbmRlZmF1bHRzLnNldCgnYW5pbWF0aW9uJywge1xuICBkZWxheTogdW5kZWZpbmVkLFxuICBkdXJhdGlvbjogMTAwMCxcbiAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgZm46IHVuZGVmaW5lZCxcbiAgZnJvbTogdW5kZWZpbmVkLFxuICBsb29wOiB1bmRlZmluZWQsXG4gIHRvOiB1bmRlZmluZWQsXG4gIHR5cGU6IHVuZGVmaW5lZCxcbn0pO1xuY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmFuaW1hdGlvbik7XG5kZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9uJywge1xuICBfZmFsbGJhY2s6IGZhbHNlLFxuICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnb25Qcm9ncmVzcycgJiYgbmFtZSAhPT0gJ29uQ29tcGxldGUnICYmIG5hbWUgIT09ICdmbicsXG59KTtcbmRlZmF1bHRzLnNldCgnYW5pbWF0aW9ucycsIHtcbiAgY29sb3JzOiB7XG4gICAgdHlwZTogJ2NvbG9yJyxcbiAgICBwcm9wZXJ0aWVzOiBjb2xvcnNcbiAgfSxcbiAgbnVtYmVyczoge1xuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIHByb3BlcnRpZXM6IG51bWJlcnNcbiAgfSxcbn0pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ2FuaW1hdGlvbnMnLCB7XG4gIF9mYWxsYmFjazogJ2FuaW1hdGlvbicsXG59KTtcbmRlZmF1bHRzLnNldCgndHJhbnNpdGlvbnMnLCB7XG4gIGFjdGl2ZToge1xuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMFxuICAgIH1cbiAgfSxcbiAgcmVzaXplOiB7XG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogMFxuICAgIH1cbiAgfSxcbiAgc2hvdzoge1xuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIGNvbG9yczoge1xuICAgICAgICBmcm9tOiAndHJhbnNwYXJlbnQnXG4gICAgICB9LFxuICAgICAgdmlzaWJsZToge1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICB9LFxuICAgIH1cbiAgfSxcbiAgaGlkZToge1xuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIGNvbG9yczoge1xuICAgICAgICB0bzogJ3RyYW5zcGFyZW50J1xuICAgICAgfSxcbiAgICAgIHZpc2libGU6IHtcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICBmbjogdiA9PiB2IHwgMFxuICAgICAgfSxcbiAgICB9XG4gIH1cbn0pO1xuY2xhc3MgQW5pbWF0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBjb25maWcpIHtcbiAgICB0aGlzLl9jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jb25maWd1cmUoY29uZmlnKTtcbiAgfVxuICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgaWYgKCFpc09iamVjdChjb25maWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNvbmZpZykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgY2ZnID0gY29uZmlnW2tleV07XG4gICAgICBpZiAoIWlzT2JqZWN0KGNmZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzb2x2ZWQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGFuaW1hdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgcmVzb2x2ZWRbb3B0aW9uXSA9IGNmZ1tvcHRpb25dO1xuICAgICAgfVxuICAgICAgKGlzQXJyYXkoY2ZnLnByb3BlcnRpZXMpICYmIGNmZy5wcm9wZXJ0aWVzIHx8IFtrZXldKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmIChwcm9wID09PSBrZXkgfHwgIWFuaW1hdGVkUHJvcHMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgYW5pbWF0ZWRQcm9wcy5zZXQocHJvcCwgcmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBuZXdPcHRpb25zID0gdmFsdWVzLm9wdGlvbnM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKG9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgIGlmIChuZXdPcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIGF3YWl0QWxsKHRhcmdldC5vcHRpb25zLiRhbmltYXRpb25zLCBuZXdPcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIF9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHJ1bm5pbmcgPSB0YXJnZXQuJGFuaW1hdGlvbnMgfHwgKHRhcmdldC4kYW5pbWF0aW9ucyA9IHt9KTtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKHZhbHVlcyk7XG4gICAgY29uc3QgZGF0ZSA9IERhdGUubm93KCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gcHJvcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmIChwcm9wLmNoYXJBdCgwKSA9PT0gJyQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3AgPT09ICdvcHRpb25zJykge1xuICAgICAgICBhbmltYXRpb25zLnB1c2goLi4udGhpcy5fYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1twcm9wXTtcbiAgICAgIGxldCBhbmltYXRpb24gPSBydW5uaW5nW3Byb3BdO1xuICAgICAgY29uc3QgY2ZnID0gYW5pbWF0ZWRQcm9wcy5nZXQocHJvcCk7XG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIGlmIChjZmcgJiYgYW5pbWF0aW9uLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZShjZmcsIHZhbHVlLCBkYXRlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY2ZnIHx8ICFjZmcuZHVyYXRpb24pIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcnVubmluZ1twcm9wXSA9IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oY2ZnLCB0YXJnZXQsIHByb3AsIHZhbHVlKTtcbiAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICB1cGRhdGUodGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBpZiAodGhpcy5fcHJvcGVydGllcy5zaXplID09PSAwKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgdmFsdWVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpO1xuICAgIGlmIChhbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgYW5pbWF0b3IuYWRkKHRoaXMuX2NoYXJ0LCBhbmltYXRpb25zKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXdhaXRBbGwoYW5pbWF0aW9ucywgcHJvcGVydGllcykge1xuICBjb25zdCBydW5uaW5nID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYW5pbSA9IGFuaW1hdGlvbnNba2V5c1tpXV07XG4gICAgaWYgKGFuaW0gJiYgYW5pbS5hY3RpdmUoKSkge1xuICAgICAgcnVubmluZy5wdXNoKGFuaW0ud2FpdCgpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKHJ1bm5pbmcpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKSB7XG4gIGlmICghbmV3T3B0aW9ucykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb3B0aW9ucyA9IHRhcmdldC5vcHRpb25zO1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvcHRpb25zLiRzaGFyZWQpIHtcbiAgICB0YXJnZXQub3B0aW9ucyA9IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7JHNoYXJlZDogZmFsc2UsICRhbmltYXRpb25zOiB7fX0pO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiBzY2FsZUNsaXAoc2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBjb25zdCBvcHRzID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcmV2ZXJzZSA9IG9wdHMucmV2ZXJzZTtcbiAgY29uc3QgbWluID0gb3B0cy5taW4gPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIGNvbnN0IG1heCA9IG9wdHMubWF4ID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiByZXZlcnNlID8gbWF4IDogbWluLFxuICAgIGVuZDogcmV2ZXJzZSA/IG1pbiA6IG1heFxuICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdENsaXAoeFNjYWxlLCB5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBpZiAoYWxsb3dlZE92ZXJmbG93ID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB4ID0gc2NhbGVDbGlwKHhTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcbiAgY29uc3QgeSA9IHNjYWxlQ2xpcCh5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG4gIHJldHVybiB7XG4gICAgdG9wOiB5LmVuZCxcbiAgICByaWdodDogeC5lbmQsXG4gICAgYm90dG9tOiB5LnN0YXJ0LFxuICAgIGxlZnQ6IHguc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvQ2xpcCh2YWx1ZSkge1xuICBsZXQgdCwgciwgYiwgbDtcbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHQgPSB2YWx1ZS50b3A7XG4gICAgciA9IHZhbHVlLnJpZ2h0O1xuICAgIGIgPSB2YWx1ZS5ib3R0b207XG4gICAgbCA9IHZhbHVlLmxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgdCA9IHIgPSBiID0gbCA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdG9wOiB0LFxuICAgIHJpZ2h0OiByLFxuICAgIGJvdHRvbTogYixcbiAgICBsZWZ0OiBsLFxuICAgIGRpc2FibGVkOiB2YWx1ZSA9PT0gZmFsc2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCBmaWx0ZXJWaXNpYmxlKSB7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleXMucHVzaChtZXRhc2V0c1tpXS5pbmRleCk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgZHNJbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGtleXMgPSBzdGFjay5rZXlzO1xuICBjb25zdCBzaW5nbGVNb2RlID0gb3B0aW9ucy5tb2RlID09PSAnc2luZ2xlJztcbiAgbGV0IGksIGlsZW4sIGRhdGFzZXRJbmRleCwgb3RoZXJWYWx1ZTtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGRhdGFzZXRJbmRleCA9ICtrZXlzW2ldO1xuICAgIGlmIChkYXRhc2V0SW5kZXggPT09IGRzSW5kZXgpIHtcbiAgICAgIGlmIChvcHRpb25zLmFsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvdGhlclZhbHVlID0gc3RhY2sudmFsdWVzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKGlzTnVtYmVyRmluaXRlKG90aGVyVmFsdWUpICYmIChzaW5nbGVNb2RlIHx8ICh2YWx1ZSA9PT0gMCB8fCBzaWduKHZhbHVlKSA9PT0gc2lnbihvdGhlclZhbHVlKSkpKSB7XG4gICAgICB2YWx1ZSArPSBvdGhlclZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIGNvbnN0IGFkYXRhID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgbGV0IGksIGlsZW4sIGtleTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBhZGF0YVtpXSA9IHtcbiAgICAgIHg6IGtleSxcbiAgICAgIHk6IGRhdGFba2V5XVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFkYXRhO1xufVxuZnVuY3Rpb24gaXNTdGFja2VkKHNjYWxlLCBtZXRhKSB7XG4gIGNvbnN0IHN0YWNrZWQgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gIHJldHVybiBzdGFja2VkIHx8IChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGdldFN0YWNrS2V5KGluZGV4U2NhbGUsIHZhbHVlU2NhbGUsIG1ldGEpIHtcbiAgcmV0dXJuIGAke2luZGV4U2NhbGUuaWR9LiR7dmFsdWVTY2FsZS5pZH0uJHttZXRhLnN0YWNrIHx8IG1ldGEudHlwZX1gO1xufVxuZnVuY3Rpb24gZ2V0VXNlckJvdW5kcyhzY2FsZSkge1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gc2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICByZXR1cm4ge1xuICAgIG1pbjogbWluRGVmaW5lZCA/IG1pbiA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICBtYXg6IG1heERlZmluZWQgPyBtYXggOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBzdGFja0tleSwgaW5kZXhWYWx1ZSkge1xuICBjb25zdCBzdWJTdGFjayA9IHN0YWNrc1tzdGFja0tleV0gfHwgKHN0YWNrc1tzdGFja0tleV0gPSB7fSk7XG4gIHJldHVybiBzdWJTdGFja1tpbmRleFZhbHVlXSB8fCAoc3ViU3RhY2tbaW5kZXhWYWx1ZV0gPSB7fSk7XG59XG5mdW5jdGlvbiBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHBvc2l0aXZlLCB0eXBlKSB7XG4gIGZvciAoY29uc3QgbWV0YSBvZiB2U2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkucmV2ZXJzZSgpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdGFja1ttZXRhLmluZGV4XTtcbiAgICBpZiAoKHBvc2l0aXZlICYmIHZhbHVlID4gMCkgfHwgKCFwb3NpdGl2ZSAmJiB2YWx1ZSA8IDApKSB7XG4gICAgICByZXR1cm4gbWV0YS5pbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1cGRhdGVTdGFja3MoY29udHJvbGxlciwgcGFyc2VkKSB7XG4gIGNvbnN0IHtjaGFydCwgX2NhY2hlZE1ldGE6IG1ldGF9ID0gY29udHJvbGxlcjtcbiAgY29uc3Qgc3RhY2tzID0gY2hhcnQuX3N0YWNrcyB8fCAoY2hhcnQuX3N0YWNrcyA9IHt9KTtcbiAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBpbmRleDogZGF0YXNldEluZGV4fSA9IG1ldGE7XG4gIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gIGNvbnN0IGtleSA9IGdldFN0YWNrS2V5KGlTY2FsZSwgdlNjYWxlLCBtZXRhKTtcbiAgY29uc3QgaWxlbiA9IHBhcnNlZC5sZW5ndGg7XG4gIGxldCBzdGFjaztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCBpdGVtID0gcGFyc2VkW2ldO1xuICAgIGNvbnN0IHtbaUF4aXNdOiBpbmRleCwgW3ZBeGlzXTogdmFsdWV9ID0gaXRlbTtcbiAgICBjb25zdCBpdGVtU3RhY2tzID0gaXRlbS5fc3RhY2tzIHx8IChpdGVtLl9zdGFja3MgPSB7fSk7XG4gICAgc3RhY2sgPSBpdGVtU3RhY2tzW3ZBeGlzXSA9IGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBrZXksIGluZGV4KTtcbiAgICBzdGFja1tkYXRhc2V0SW5kZXhdID0gdmFsdWU7XG4gICAgc3RhY2suX3RvcCA9IGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgdHJ1ZSwgbWV0YS50eXBlKTtcbiAgICBzdGFjay5fYm90dG9tID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBmYWxzZSwgbWV0YS50eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCBheGlzKSB7XG4gIGNvbnN0IHNjYWxlcyA9IGNoYXJ0LnNjYWxlcztcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNjYWxlcykuZmlsdGVyKGtleSA9PiBzY2FsZXNba2V5XS5heGlzID09PSBheGlzKS5zaGlmdCgpO1xufVxuZnVuY3Rpb24gY3JlYXRlRGF0YXNldENvbnRleHQocGFyZW50LCBpbmRleCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsXG4gICAge1xuICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgIGRhdGFzZXQ6IHVuZGVmaW5lZCxcbiAgICAgIGRhdGFzZXRJbmRleDogaW5kZXgsXG4gICAgICBpbmRleCxcbiAgICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICAgIHR5cGU6ICdkYXRhc2V0J1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURhdGFDb250ZXh0KHBhcmVudCwgaW5kZXgsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIHBhcnNlZDogdW5kZWZpbmVkLFxuICAgIHJhdzogdW5kZWZpbmVkLFxuICAgIGVsZW1lbnQsXG4gICAgaW5kZXgsXG4gICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgIHR5cGU6ICdkYXRhJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNsZWFyU3RhY2tzKG1ldGEsIGl0ZW1zKSB7XG4gIGNvbnN0IGRhdGFzZXRJbmRleCA9IG1ldGEuY29udHJvbGxlci5pbmRleDtcbiAgY29uc3QgYXhpcyA9IG1ldGEudlNjYWxlICYmIG1ldGEudlNjYWxlLmF4aXM7XG4gIGlmICghYXhpcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpdGVtcyA9IGl0ZW1zIHx8IG1ldGEuX3BhcnNlZDtcbiAgZm9yIChjb25zdCBwYXJzZWQgb2YgaXRlbXMpIHtcbiAgICBjb25zdCBzdGFja3MgPSBwYXJzZWQuX3N0YWNrcztcbiAgICBpZiAoIXN0YWNrcyB8fCBzdGFja3NbYXhpc10gPT09IHVuZGVmaW5lZCB8fCBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XTtcbiAgfVxufVxuY29uc3QgaXNEaXJlY3RVcGRhdGVNb2RlID0gKG1vZGUpID0+IG1vZGUgPT09ICdyZXNldCcgfHwgbW9kZSA9PT0gJ25vbmUnO1xuY29uc3QgY2xvbmVJZk5vdFNoYXJlZCA9IChjYWNoZWQsIHNoYXJlZCkgPT4gc2hhcmVkID8gY2FjaGVkIDogT2JqZWN0LmFzc2lnbih7fSwgY2FjaGVkKTtcbmNvbnN0IGNyZWF0ZVN0YWNrID0gKGNhblN0YWNrLCBtZXRhLCBjaGFydCkgPT4gY2FuU3RhY2sgJiYgIW1ldGEuaGlkZGVuICYmIG1ldGEuX3N0YWNrZWRcbiAgJiYge2tleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSwgdmFsdWVzOiBudWxsfTtcbmNsYXNzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9jdHggPSBjaGFydC5jdHg7XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICAgIHRoaXMuX2NhY2hlZE1ldGEgPSB0aGlzLmdldE1ldGEoKTtcbiAgICB0aGlzLl90eXBlID0gdGhpcy5fY2FjaGVkTWV0YS50eXBlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wYXJzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vYmplY3REYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NoYXJlZE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSBmYWxzZTtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgIHRoaXMubGlua1NjYWxlcygpO1xuICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIHRoaXMuYWRkRWxlbWVudHMoKTtcbiAgfVxuICB1cGRhdGVJbmRleChkYXRhc2V0SW5kZXgpIHtcbiAgICBpZiAodGhpcy5pbmRleCAhPT0gZGF0YXNldEluZGV4KSB7XG4gICAgICBjbGVhclN0YWNrcyh0aGlzLl9jYWNoZWRNZXRhKTtcbiAgICB9XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgfVxuICBsaW5rU2NhbGVzKCkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgY29uc3QgY2hvb3NlSWQgPSAoYXhpcywgeCwgeSwgcikgPT4gYXhpcyA9PT0gJ3gnID8geCA6IGF4aXMgPT09ICdyJyA/IHIgOiB5O1xuICAgIGNvbnN0IHhpZCA9IG1ldGEueEF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueEF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneCcpKTtcbiAgICBjb25zdCB5aWQgPSBtZXRhLnlBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnlBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3knKSk7XG4gICAgY29uc3QgcmlkID0gbWV0YS5yQXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC5yQXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICdyJykpO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IG1ldGEuaW5kZXhBeGlzO1xuICAgIGNvbnN0IGlpZCA9IG1ldGEuaUF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeGlkLCB5aWQsIHJpZCk7XG4gICAgY29uc3QgdmlkID0gbWV0YS52QXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB5aWQsIHhpZCwgcmlkKTtcbiAgICBtZXRhLnhTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh4aWQpO1xuICAgIG1ldGEueVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHlpZCk7XG4gICAgbWV0YS5yU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQocmlkKTtcbiAgICBtZXRhLmlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChpaWQpO1xuICAgIG1ldGEudlNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHZpZCk7XG4gIH1cbiAgZ2V0RGF0YXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xuICB9XG4gIGdldE1ldGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEodGhpcy5pbmRleCk7XG4gIH1cbiAgZ2V0U2NhbGVGb3JJZChzY2FsZUlEKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuc2NhbGVzW3NjYWxlSURdO1xuICB9XG4gIF9nZXRPdGhlclNjYWxlKHNjYWxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgcmV0dXJuIHNjYWxlID09PSBtZXRhLmlTY2FsZVxuICAgICAgPyBtZXRhLnZTY2FsZVxuICAgICAgOiBtZXRhLmlTY2FsZTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl91cGRhdGUoJ3Jlc2V0Jyk7XG4gIH1cbiAgX2Rlc3Ryb3koKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHVubGlzdGVuQXJyYXlFdmVudHModGhpcy5fZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICB9XG4gIH1cbiAgX2RhdGFDaGVjaygpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuZGF0YSB8fCAoZGF0YXNldC5kYXRhID0gW10pO1xuICAgIGNvbnN0IF9kYXRhID0gdGhpcy5fZGF0YTtcbiAgICBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSk7XG4gICAgfSBlbHNlIGlmIChfZGF0YSAhPT0gZGF0YSkge1xuICAgICAgaWYgKF9kYXRhKSB7XG4gICAgICAgIHVubGlzdGVuQXJyYXlFdmVudHMoX2RhdGEsIHRoaXMpO1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICAgIG1ldGEuX3BhcnNlZCA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShkYXRhKSkge1xuICAgICAgICBsaXN0ZW5BcnJheUV2ZW50cyhkYXRhLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy5fZGF0YUNoZWNrKCk7XG4gICAgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICBtZXRhLmRhdGFzZXQgPSBuZXcgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUoKTtcbiAgICB9XG4gIH1cbiAgYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IHN0YWNrQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuICAgIGNvbnN0IG9sZFN0YWNrZWQgPSBtZXRhLl9zdGFja2VkO1xuICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIGlmIChtZXRhLnN0YWNrICE9PSBkYXRhc2V0LnN0YWNrKSB7XG4gICAgICBzdGFja0NoYW5nZWQgPSB0cnVlO1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICBtZXRhLnN0YWNrID0gZGF0YXNldC5zdGFjaztcbiAgICB9XG4gICAgdGhpcy5fcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cyk7XG4gICAgaWYgKHN0YWNrQ2hhbmdlZCB8fCBvbGRTdGFja2VkICE9PSBtZXRhLl9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3ModGhpcywgbWV0YS5fcGFyc2VkKTtcbiAgICB9XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0U2NvcGVLZXlzKHRoaXMuX3R5cGUpO1xuICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cywgdHJ1ZSk7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMuX3BhcnNpbmcgPSB0aGlzLm9wdGlvbnMucGFyc2luZztcbiAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICB9XG4gIHBhcnNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtfY2FjaGVkTWV0YTogbWV0YSwgX2RhdGE6IGRhdGF9ID0gdGhpcztcbiAgICBjb25zdCB7aVNjYWxlLCBfc3RhY2tlZH0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgbGV0IHNvcnRlZCA9IHN0YXJ0ID09PSAwICYmIGNvdW50ID09PSBkYXRhLmxlbmd0aCA/IHRydWUgOiBtZXRhLl9zb3J0ZWQ7XG4gICAgbGV0IHByZXYgPSBzdGFydCA+IDAgJiYgbWV0YS5fcGFyc2VkW3N0YXJ0IC0gMV07XG4gICAgbGV0IGksIGN1ciwgcGFyc2VkO1xuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICAgIG1ldGEuX3NvcnRlZCA9IHRydWU7XG4gICAgICBwYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcnJheShkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldiA9ICgpID0+IGN1cltpQXhpc10gPT09IG51bGwgfHwgKHByZXYgJiYgY3VyW2lBeGlzXSA8IHByZXZbaUF4aXNdKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIG1ldGEuX3BhcnNlZFtpICsgc3RhcnRdID0gY3VyID0gcGFyc2VkW2ldO1xuICAgICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgICAgaWYgKGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2KCkpIHtcbiAgICAgICAgICAgIHNvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2ID0gY3VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZXRhLl9zb3J0ZWQgPSBzb3J0ZWQ7XG4gICAgfVxuICAgIGlmIChfc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIHBhcnNlZCk7XG4gICAgfVxuICB9XG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICAgIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXg7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgW2lBeGlzXTogc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpbmRleF0sIGluZGV4KSxcbiAgICAgICAgW3ZBeGlzXTogdlNjYWxlLnBhcnNlKGRhdGFbaW5kZXhdLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKGl0ZW1bMF0sIGluZGV4KSxcbiAgICAgICAgeTogeVNjYWxlLnBhcnNlKGl0ZW1bMV0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIHg6IHhTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHhBeGlzS2V5KSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCB5QXhpc0tleSksIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBnZXRQYXJzZWQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkW2luZGV4XTtcbiAgfVxuICBnZXREYXRhRWxlbWVudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFbaW5kZXhdO1xuICB9XG4gIGFwcGx5U3RhY2soc2NhbGUsIHBhcnNlZCwgbW9kZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnNlZFtzY2FsZS5heGlzXTtcbiAgICBjb25zdCBzdGFjayA9IHtcbiAgICAgIGtleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSxcbiAgICAgIHZhbHVlczogcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc11cbiAgICB9O1xuICAgIHJldHVybiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgbWV0YS5pbmRleCwge21vZGV9KTtcbiAgfVxuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkVmFsdWUgPT09IG51bGwgPyBOYU4gOiBwYXJzZWRWYWx1ZTtcbiAgICBjb25zdCB2YWx1ZXMgPSBzdGFjayAmJiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXTtcbiAgICBpZiAoc3RhY2sgJiYgdmFsdWVzKSB7XG4gICAgICBzdGFjay52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICB2YWx1ZSA9IGFwcGx5U3RhY2soc3RhY2ssIHBhcnNlZFZhbHVlLCB0aGlzLl9jYWNoZWRNZXRhLmluZGV4KTtcbiAgICB9XG4gICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCB2YWx1ZSk7XG4gICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCB2YWx1ZSk7XG4gIH1cbiAgZ2V0TWluTWF4KHNjYWxlLCBjYW5TdGFjaykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IF9wYXJzZWQgPSBtZXRhLl9wYXJzZWQ7XG4gICAgY29uc3Qgc29ydGVkID0gbWV0YS5fc29ydGVkICYmIHNjYWxlID09PSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBpbGVuID0gX3BhcnNlZC5sZW5ndGg7XG4gICAgY29uc3Qgb3RoZXJTY2FsZSA9IHRoaXMuX2dldE90aGVyU2NhbGUoc2NhbGUpO1xuICAgIGNvbnN0IHN0YWNrID0gY3JlYXRlU3RhY2soY2FuU3RhY2ssIG1ldGEsIHRoaXMuY2hhcnQpO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG4gICAgY29uc3Qge21pbjogb3RoZXJNaW4sIG1heDogb3RoZXJNYXh9ID0gZ2V0VXNlckJvdW5kcyhvdGhlclNjYWxlKTtcbiAgICBsZXQgaSwgcGFyc2VkO1xuICAgIGZ1bmN0aW9uIF9za2lwKCkge1xuICAgICAgcGFyc2VkID0gX3BhcnNlZFtpXTtcbiAgICAgIGNvbnN0IG90aGVyVmFsdWUgPSBwYXJzZWRbb3RoZXJTY2FsZS5heGlzXTtcbiAgICAgIHJldHVybiAhaXNOdW1iZXJGaW5pdGUocGFyc2VkW3NjYWxlLmF4aXNdKSB8fCBvdGhlck1pbiA+IG90aGVyVmFsdWUgfHwgb3RoZXJNYXggPCBvdGhlclZhbHVlO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc29ydGVkKSB7XG4gICAgICBmb3IgKGkgPSBpbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG4gIGdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZDtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgdmFsdWU7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHBhcnNlZC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VkW2ldW3NjYWxlLmF4aXNdO1xuICAgICAgaWYgKGlzTnVtYmVyRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBpU2NhbGUgPyAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pIDogJycsXG4gICAgICB2YWx1ZTogdlNjYWxlID8gJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKSA6ICcnXG4gICAgfTtcbiAgfVxuICBfdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZShtb2RlIHx8ICdkZWZhdWx0Jyk7XG4gICAgbWV0YS5fY2xpcCA9IHRvQ2xpcCh2YWx1ZU9yRGVmYXVsdCh0aGlzLm9wdGlvbnMuY2xpcCwgZGVmYXVsdENsaXAobWV0YS54U2NhbGUsIG1ldGEueVNjYWxlLCB0aGlzLmdldE1heE92ZXJmbG93KCkpKSk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHt9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fY3R4O1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBjb25zdCBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IGFjdGl2ZSA9IFtdO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fZHJhd1N0YXJ0IHx8IDA7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLl9kcmF3Q291bnQgfHwgKGVsZW1lbnRzLmxlbmd0aCAtIHN0YXJ0KTtcbiAgICBjb25zdCBkcmF3QWN0aXZlRWxlbWVudHNPblRvcCA9IHRoaXMub3B0aW9ucy5kcmF3QWN0aXZlRWxlbWVudHNPblRvcDtcbiAgICBsZXQgaTtcbiAgICBpZiAobWV0YS5kYXRhc2V0KSB7XG4gICAgICBtZXRhLmRhdGFzZXQuZHJhdyhjdHgsIGFyZWEsIHN0YXJ0LCBjb3VudCk7XG4gICAgfVxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoZWxlbWVudC5oaWRkZW4pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5hY3RpdmUgJiYgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3ApIHtcbiAgICAgICAgYWN0aXZlLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmRyYXcoY3R4LCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7ICsraSkge1xuICAgICAgYWN0aXZlW2ldLmRyYXcoY3R4LCBhcmVhKTtcbiAgICB9XG4gIH1cbiAgZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSkge1xuICAgIGNvbnN0IG1vZGUgPSBhY3RpdmUgPyAnYWN0aXZlJyA6ICdkZWZhdWx0JztcbiAgICByZXR1cm4gaW5kZXggPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXRcbiAgICAgID8gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpXG4gICAgICA6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCB8fCAwLCBtb2RlKTtcbiAgfVxuICBnZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIG1vZGUpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IGNvbnRleHQ7XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQgPSBlbGVtZW50LiRjb250ZXh0IHx8XG4gICAgICAgIChlbGVtZW50LiRjb250ZXh0ID0gY3JlYXRlRGF0YUNvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBlbGVtZW50KSk7XG4gICAgICBjb250ZXh0LnBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICAgIGNvbnRleHQucmF3ID0gZGF0YXNldC5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFJbmRleCA9IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gdGhpcy4kY29udGV4dCB8fFxuICAgICAgICAodGhpcy4kY29udGV4dCA9IGNyZWF0ZURhdGFzZXRDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLmluZGV4KSk7XG4gICAgICBjb250ZXh0LmRhdGFzZXQgPSBkYXRhc2V0O1xuICAgICAgY29udGV4dC5pbmRleCA9IGNvbnRleHQuZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB9XG4gICAgY29udGV4dC5hY3RpdmUgPSAhIWFjdGl2ZTtcbiAgICBjb250ZXh0Lm1vZGUgPSBtb2RlO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG4gIHJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhc2V0RWxlbWVudFR5cGUuaWQsIG1vZGUpO1xuICB9XG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YUVsZW1lbnRUeXBlLmlkLCBtb2RlLCBpbmRleCk7XG4gIH1cbiAgX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhlbGVtZW50VHlwZSwgbW9kZSA9ICdkZWZhdWx0JywgaW5kZXgpIHtcbiAgICBjb25zdCBhY3RpdmUgPSBtb2RlID09PSAnYWN0aXZlJztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZWxlbWVudFR5cGUgKyAnLScgKyBtb2RlO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBjb25zdCBzaGFyaW5nID0gdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nICYmIGRlZmluZWQoaW5kZXgpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjbG9uZUlmTm90U2hhcmVkKGNhY2hlZCwgc2hhcmluZyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0RWxlbWVudFNjb3BlS2V5cyh0aGlzLl90eXBlLCBlbGVtZW50VHlwZSk7XG4gICAgY29uc3QgcHJlZml4ZXMgPSBhY3RpdmUgPyBbYCR7ZWxlbWVudFR5cGV9SG92ZXJgLCAnaG92ZXInLCBlbGVtZW50VHlwZSwgJyddIDogW2VsZW1lbnRUeXBlLCAnJ107XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmVsZW1lbnRzW2VsZW1lbnRUeXBlXSk7XG4gICAgY29uc3QgY29udGV4dCA9ICgpID0+IHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBjb25maWcucmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyk7XG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICB2YWx1ZXMuJHNoYXJlZCA9IHNoYXJpbmc7XG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGNsb25lSWZOb3RTaGFyZWQodmFsdWVzLCBzaGFyaW5nKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCB0cmFuc2l0aW9uLCBhY3RpdmUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICBjb25zdCBjYWNoZUtleSA9IGBhbmltYXRpb24tJHt0cmFuc2l0aW9ufWA7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGxldCBvcHRpb25zO1xuICAgIGlmIChjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRBbmltYXRpb25TY29wZUtleXModGhpcy5fdHlwZSwgdHJhbnNpdGlvbik7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgICAgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCB0cmFuc2l0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyhjaGFydCwgb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbnMpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2NhY2hlYWJsZSkge1xuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NoYXJlZE9wdGlvbnMgfHwgKHRoaXMuX3NoYXJlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gIH1cbiAgaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykge1xuICAgIHJldHVybiAhc2hhcmVkT3B0aW9ucyB8fCBpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkgfHwgdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnQoZWxlbWVudCwgaW5kZXgsIHByb3BlcnRpZXMsIG1vZGUpIHtcbiAgICBpZiAoaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgbW9kZSkudXBkYXRlKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIG5ld09wdGlvbnMpIHtcbiAgICBpZiAoc2hhcmVkT3B0aW9ucyAmJiAhaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpLnVwZGF0ZShzaGFyZWRPcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCBtb2RlLCBhY3RpdmUpIHtcbiAgICBlbGVtZW50LmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRTdHlsZShpbmRleCwgYWN0aXZlKTtcbiAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgbW9kZSwgYWN0aXZlKS51cGRhdGUoZWxlbWVudCwge1xuICAgICAgb3B0aW9uczogKCFhY3RpdmUgJiYgdGhpcy5nZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpKSB8fCBvcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlSG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCBmYWxzZSk7XG4gIH1cbiAgc2V0SG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCB0cnVlKTtcbiAgfVxuICBfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldDtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgIH1cbiAgfVxuICBfc2V0RGF0YXNldEhvdmVyU3R5bGUoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldDtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIF9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgZm9yIChjb25zdCBbbWV0aG9kLCBhcmcxLCBhcmcyXSBvZiB0aGlzLl9zeW5jTGlzdCkge1xuICAgICAgdGhpc1ttZXRob2RdKGFyZzEsIGFyZzIpO1xuICAgIH1cbiAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgIGNvbnN0IG51bU1ldGEgPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGNvdW50ID0gTWF0aC5taW4obnVtRGF0YSwgbnVtTWV0YSk7XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICB0aGlzLnBhcnNlKDAsIGNvdW50KTtcbiAgICB9XG4gICAgaWYgKG51bURhdGEgPiBudW1NZXRhKSB7XG4gICAgICB0aGlzLl9pbnNlcnRFbGVtZW50cyhudW1NZXRhLCBudW1EYXRhIC0gbnVtTWV0YSwgcmVzZXROZXdFbGVtZW50cyk7XG4gICAgfSBlbHNlIGlmIChudW1EYXRhIDwgbnVtTWV0YSkge1xuICAgICAgdGhpcy5fcmVtb3ZlRWxlbWVudHMobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgfVxuICBfaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGNvdW50LCByZXNldE5ld0VsZW1lbnRzID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb3VudDtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBtb3ZlID0gKGFycikgPT4ge1xuICAgICAgYXJyLmxlbmd0aCArPSBjb3VudDtcbiAgICAgIGZvciAoaSA9IGFyci5sZW5ndGggLSAxOyBpID49IGVuZDsgaS0tKSB7XG4gICAgICAgIGFycltpXSA9IGFycltpIC0gY291bnRdO1xuICAgICAgfVxuICAgIH07XG4gICAgbW92ZShkYXRhKTtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBkYXRhW2ldID0gbmV3IHRoaXMuZGF0YUVsZW1lbnRUeXBlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBtb3ZlKG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICAgIHRoaXMucGFyc2Uoc3RhcnQsIGNvdW50KTtcbiAgICBpZiAocmVzZXROZXdFbGVtZW50cykge1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50cyhkYXRhLCBzdGFydCwgY291bnQsICdyZXNldCcpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVFbGVtZW50cyhlbGVtZW50LCBzdGFydCwgY291bnQsIG1vZGUpIHt9XG4gIF9yZW1vdmVFbGVtZW50cyhzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IG1ldGEuX3BhcnNlZC5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEsIHJlbW92ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBtZXRhLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgX3N5bmMoYXJncykge1xuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICB0aGlzLl9zeW5jTGlzdC5wdXNoKGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbbWV0aG9kLCBhcmcxLCBhcmcyXSA9IGFyZ3M7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIHRoaXMuY2hhcnQuX2RhdGFDaGFuZ2VzLnB1c2goW3RoaXMuaW5kZXgsIC4uLmFyZ3NdKTtcbiAgfVxuICBfb25EYXRhUHVzaCgpIHtcbiAgICBjb25zdCBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEubGVuZ3RoIC0gY291bnQsIGNvdW50XSk7XG4gIH1cbiAgX29uRGF0YVBvcCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCAtIDEsIDFdKTtcbiAgfVxuICBfb25EYXRhU2hpZnQoKSB7XG4gICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIDAsIDFdKTtcbiAgfVxuICBfb25EYXRhU3BsaWNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGlmIChjb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHN0YXJ0LCBjb3VudF0pO1xuICAgIH1cbiAgICBjb25zdCBuZXdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIGlmIChuZXdDb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHN0YXJ0LCBuZXdDb3VudF0pO1xuICAgIH1cbiAgfVxuICBfb25EYXRhVW5zaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgMCwgYXJndW1lbnRzLmxlbmd0aF0pO1xuICB9XG59XG5EYXRhc2V0Q29udHJvbGxlci5kZWZhdWx0cyA9IHt9O1xuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLmRhdGFzZXRFbGVtZW50VHlwZSA9IG51bGw7XG5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuZGF0YUVsZW1lbnRUeXBlID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIHR5cGUpIHtcbiAgaWYgKCFzY2FsZS5fY2FjaGUuJGJhcikge1xuICAgIGNvbnN0IHZpc2libGVNZXRhcyA9IHNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpO1xuICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHZpc2libGVNZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodmlzaWJsZU1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSk7XG4gICAgfVxuICAgIHNjYWxlLl9jYWNoZS4kYmFyID0gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYikpO1xuICB9XG4gIHJldHVybiBzY2FsZS5fY2FjaGUuJGJhcjtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpIHtcbiAgY29uc3Qgc2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdmFsdWVzID0gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIG1ldGEudHlwZSk7XG4gIGxldCBtaW4gPSBzY2FsZS5fbGVuZ3RoO1xuICBsZXQgaSwgaWxlbiwgY3VyciwgcHJldjtcbiAgY29uc3QgdXBkYXRlTWluQW5kUHJldiA9ICgpID0+IHtcbiAgICBpZiAoY3VyciA9PT0gMzI3NjcgfHwgY3VyciA9PT0gLTMyNzY4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkZWZpbmVkKHByZXYpKSB7XG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguYWJzKGN1cnIgLSBwcmV2KSB8fCBtaW4pO1xuICAgIH1cbiAgICBwcmV2ID0gY3VycjtcbiAgfTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZXNbaV0pO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuICBwcmV2ID0gdW5kZWZpbmVkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gc2NhbGUudGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cbiAgcmV0dXJuIG1pbjtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG4gIGxldCBzaXplLCByYXRpbztcbiAgaWYgKGlzTnVsbE9yVW5kZWYodGhpY2tuZXNzKSkge1xuICAgIHNpemUgPSBydWxlci5taW4gKiBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgICByYXRpbyA9IG9wdGlvbnMuYmFyUGVyY2VudGFnZTtcbiAgfSBlbHNlIHtcbiAgICBzaXplID0gdGhpY2tuZXNzICogc3RhY2tDb3VudDtcbiAgICByYXRpbyA9IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW8sXG4gICAgc3RhcnQ6IHJ1bGVyLnBpeGVsc1tpbmRleF0gLSAoc2l6ZSAvIDIpXG4gIH07XG59XG5mdW5jdGlvbiBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCBwaXhlbHMgPSBydWxlci5waXhlbHM7XG4gIGNvbnN0IGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xuICBsZXQgcHJldiA9IGluZGV4ID4gMCA/IHBpeGVsc1tpbmRleCAtIDFdIDogbnVsbDtcbiAgbGV0IG5leHQgPSBpbmRleCA8IHBpeGVscy5sZW5ndGggLSAxID8gcGl4ZWxzW2luZGV4ICsgMV0gOiBudWxsO1xuICBjb25zdCBwZXJjZW50ID0gb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG4gIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgcHJldiA9IGN1cnIgLSAobmV4dCA9PT0gbnVsbCA/IHJ1bGVyLmVuZCAtIHJ1bGVyLnN0YXJ0IDogbmV4dCAtIGN1cnIpO1xuICB9XG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgbmV4dCA9IGN1cnIgKyBjdXJyIC0gcHJldjtcbiAgfVxuICBjb25zdCBzdGFydCA9IGN1cnIgLSAoY3VyciAtIE1hdGgubWluKHByZXYsIG5leHQpKSAvIDIgKiBwZXJjZW50O1xuICBjb25zdCBzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvOiBvcHRpb25zLmJhclBlcmNlbnRhZ2UsXG4gICAgc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBjb25zdCBzdGFydFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzBdLCBpKTtcbiAgY29uc3QgZW5kVmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMV0sIGkpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgbGV0IGJhclN0YXJ0ID0gbWluO1xuICBsZXQgYmFyRW5kID0gbWF4O1xuICBpZiAoTWF0aC5hYnMobWluKSA+IE1hdGguYWJzKG1heCkpIHtcbiAgICBiYXJTdGFydCA9IG1heDtcbiAgICBiYXJFbmQgPSBtaW47XG4gIH1cbiAgaXRlbVt2U2NhbGUuYXhpc10gPSBiYXJFbmQ7XG4gIGl0ZW0uX2N1c3RvbSA9IHtcbiAgICBiYXJTdGFydCxcbiAgICBiYXJFbmQsXG4gICAgc3RhcnQ6IHN0YXJ0VmFsdWUsXG4gICAgZW5kOiBlbmRWYWx1ZSxcbiAgICBtaW4sXG4gICAgbWF4XG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcbiAgaWYgKGlzQXJyYXkoZW50cnkpKSB7XG4gICAgcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKTtcbiAgfSBlbHNlIHtcbiAgICBpdGVtW3ZTY2FsZS5heGlzXSA9IHZTY2FsZS5wYXJzZShlbnRyeSwgaSk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5mdW5jdGlvbiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICBjb25zdCBzaW5nbGVTY2FsZSA9IGlTY2FsZSA9PT0gdlNjYWxlO1xuICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGl0ZW0sIGVudHJ5O1xuICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBlbnRyeSA9IGRhdGFbaV07XG4gICAgaXRlbSA9IHt9O1xuICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpXSwgaSk7XG4gICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbmZ1bmN0aW9uIGlzRmxvYXRCYXIoY3VzdG9tKSB7XG4gIHJldHVybiBjdXN0b20gJiYgY3VzdG9tLmJhclN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgY3VzdG9tLmJhckVuZCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpIHtcbiAgaWYgKHNpemUgIT09IDApIHtcbiAgICByZXR1cm4gc2lnbihzaXplKTtcbiAgfVxuICByZXR1cm4gKHZTY2FsZS5pc0hvcml6b250YWwoKSA/IDEgOiAtMSkgKiAodlNjYWxlLm1pbiA+PSBhY3R1YWxCYXNlID8gMSA6IC0xKTtcbn1cbmZ1bmN0aW9uIGJvcmRlclByb3BzKHByb3BlcnRpZXMpIHtcbiAgbGV0IHJldmVyc2UsIHN0YXJ0LCBlbmQsIHRvcCwgYm90dG9tO1xuICBpZiAocHJvcGVydGllcy5ob3Jpem9udGFsKSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA+IHByb3BlcnRpZXMueDtcbiAgICBzdGFydCA9ICdsZWZ0JztcbiAgICBlbmQgPSAncmlnaHQnO1xuICB9IGVsc2Uge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPCBwcm9wZXJ0aWVzLnk7XG4gICAgc3RhcnQgPSAnYm90dG9tJztcbiAgICBlbmQgPSAndG9wJztcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHRvcCA9ICdlbmQnO1xuICAgIGJvdHRvbSA9ICdzdGFydCc7XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gJ3N0YXJ0JztcbiAgICBib3R0b20gPSAnZW5kJztcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfTtcbn1cbmZ1bmN0aW9uIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgb3B0aW9ucywgc3RhY2ssIGluZGV4KSB7XG4gIGxldCBlZGdlID0gb3B0aW9ucy5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCByZXMgPSB7fTtcbiAgaWYgKCFlZGdlKSB7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219ID0gYm9yZGVyUHJvcHMocHJvcGVydGllcyk7XG4gIGlmIChlZGdlID09PSAnbWlkZGxlJyAmJiBzdGFjaykge1xuICAgIHByb3BlcnRpZXMuZW5hYmxlQm9yZGVyUmFkaXVzID0gdHJ1ZTtcbiAgICBpZiAoKHN0YWNrLl90b3AgfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH0gZWxzZSBpZiAoKHN0YWNrLl9ib3R0b20gfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbcGFyc2VFZGdlKGJvdHRvbSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfVxuICB9XG4gIHJlc1twYXJzZUVkZ2UoZWRnZSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xufVxuZnVuY3Rpb24gcGFyc2VFZGdlKGVkZ2UsIGEsIGIsIHJldmVyc2UpIHtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBlZGdlID0gc3dhcChlZGdlLCBhLCBiKTtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYiwgYSk7XG4gIH0gZWxzZSB7XG4gICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGEsIGIpO1xuICB9XG4gIHJldHVybiBlZGdlO1xufVxuZnVuY3Rpb24gc3dhcChvcmlnLCB2MSwgdjIpIHtcbiAgcmV0dXJuIG9yaWcgPT09IHYxID8gdjIgOiBvcmlnID09PSB2MiA/IHYxIDogb3JpZztcbn1cbmZ1bmN0aW9uIHN0YXJ0RW5kKHYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHYgPT09ICdzdGFydCcgPyBzdGFydCA6IHYgPT09ICdlbmQnID8gZW5kIDogdjtcbn1cbmZ1bmN0aW9uIHNldEluZmxhdGVBbW91bnQocHJvcGVydGllcywge2luZmxhdGVBbW91bnR9LCByYXRpbykge1xuICBwcm9wZXJ0aWVzLmluZmxhdGVBbW91bnQgPSBpbmZsYXRlQW1vdW50ID09PSAnYXV0bydcbiAgICA/IHJhdGlvID09PSAxID8gMC4zMyA6IDBcbiAgICA6IGluZmxhdGVBbW91bnQ7XG59XG5jbGFzcyBCYXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IGlBeGlzS2V5ID0gaVNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgY29uc3QgdkF4aXNLZXkgPSB2U2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgaXRlbSwgb2JqO1xuICAgIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb2JqID0gZGF0YVtpXTtcbiAgICAgIGl0ZW0gPSB7fTtcbiAgICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gaVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkob2JqLCBpQXhpc0tleSksIGkpO1xuICAgICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShyZXNvbHZlT2JqZWN0S2V5KG9iaiwgdkF4aXNLZXkpLCBpdGVtLCB2U2NhbGUsIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgc3VwZXIudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgaWYgKGN1c3RvbSAmJiBzY2FsZSA9PT0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGUpIHtcbiAgICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgY3VzdG9tLm1pbik7XG4gICAgICByYW5nZS5tYXggPSBNYXRoLm1heChyYW5nZS5tYXgsIGN1c3RvbS5tYXgpO1xuICAgIH1cbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IHZhbHVlID0gaXNGbG9hdEJhcihjdXN0b20pXG4gICAgICA/ICdbJyArIGN1c3RvbS5zdGFydCArICcsICcgKyBjdXN0b20uZW5kICsgJ10nXG4gICAgICA6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5zdGFjayA9IHRoaXMuZ2V0RGF0YXNldCgpLnN0YWNrO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhtZXRhLmRhdGEsIDAsIG1ldGEuZGF0YS5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGJhcnMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aW5kZXgsIF9jYWNoZWRNZXRhOiB7dlNjYWxlfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJhc2UgPSB2U2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHZTY2FsZS5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCBydWxlciA9IHRoaXMuX2dldFJ1bGVyKCk7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpO1xuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCB2cGl4ZWxzID0gcmVzZXQgfHwgaXNOdWxsT3JVbmRlZihwYXJzZWRbdlNjYWxlLmF4aXNdKSA/IHtiYXNlLCBoZWFkOiBiYXNlfSA6IHRoaXMuX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGkpO1xuICAgICAgY29uc3QgaXBpeGVscyA9IHRoaXMuX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGksIHJ1bGVyKTtcbiAgICAgIGNvbnN0IHN0YWNrID0gKHBhcnNlZC5fc3RhY2tzIHx8IHt9KVt2U2NhbGUuYXhpc107XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBob3Jpem9udGFsLFxuICAgICAgICBiYXNlOiB2cGl4ZWxzLmJhc2UsXG4gICAgICAgIGVuYWJsZUJvcmRlclJhZGl1czogIXN0YWNrIHx8IGlzRmxvYXRCYXIocGFyc2VkLl9jdXN0b20pIHx8IChpbmRleCA9PT0gc3RhY2suX3RvcCB8fCBpbmRleCA9PT0gc3RhY2suX2JvdHRvbSksXG4gICAgICAgIHg6IGhvcml6b250YWwgPyB2cGl4ZWxzLmhlYWQgOiBpcGl4ZWxzLmNlbnRlcixcbiAgICAgICAgeTogaG9yaXpvbnRhbCA/IGlwaXhlbHMuY2VudGVyIDogdnBpeGVscy5oZWFkLFxuICAgICAgICBoZWlnaHQ6IGhvcml6b250YWwgPyBpcGl4ZWxzLnNpemUgOiBNYXRoLmFicyh2cGl4ZWxzLnNpemUpLFxuICAgICAgICB3aWR0aDogaG9yaXpvbnRhbCA/IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSkgOiBpcGl4ZWxzLnNpemVcbiAgICAgIH07XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYmFyc1tpXS5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHByb3BlcnRpZXMub3B0aW9ucyB8fCBiYXJzW2ldLm9wdGlvbnM7XG4gICAgICBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCk7XG4gICAgICBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIG9wdGlvbnMsIHJ1bGVyLnJhdGlvKTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChiYXJzW2ldLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbiAgX2dldFN0YWNrcyhsYXN0LCBkYXRhSW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IGlTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0aGlzLl90eXBlKTtcbiAgICBjb25zdCBzdGFja2VkID0gaVNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgICBjb25zdCBpbGVuID0gbWV0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IHN0YWNrcyA9IFtdO1xuICAgIGxldCBpLCBpdGVtO1xuICAgIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBtZXRhc2V0c1tpXTtcbiAgICAgIGlmICghaXRlbS5jb250cm9sbGVyLm9wdGlvbnMuZ3JvdXBlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGF0YUluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCB2YWwgPSBpdGVtLmNvbnRyb2xsZXIuZ2V0UGFyc2VkKGRhdGFJbmRleClbXG4gICAgICAgICAgaXRlbS5jb250cm9sbGVyLl9jYWNoZWRNZXRhLnZTY2FsZS5heGlzXG4gICAgICAgIF07XG4gICAgICAgIGlmIChpc051bGxPclVuZGVmKHZhbCkgfHwgaXNOYU4odmFsKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhY2tlZCA9PT0gZmFsc2UgfHwgc3RhY2tzLmluZGV4T2YoaXRlbS5zdGFjaykgPT09IC0xIHx8XG5cdFx0XHRcdChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgaXRlbS5zdGFjayA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzdGFja3MucHVzaChpdGVtLnN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtLmluZGV4ID09PSBsYXN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN0YWNrcy5sZW5ndGgpIHtcbiAgICAgIHN0YWNrcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiBzdGFja3M7XG4gIH1cbiAgX2dldFN0YWNrQ291bnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3RhY2tzKHVuZGVmaW5lZCwgaW5kZXgpLmxlbmd0aDtcbiAgfVxuICBfZ2V0U3RhY2tJbmRleChkYXRhc2V0SW5kZXgsIG5hbWUsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCk7XG4gICAgY29uc3QgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgPyBzdGFja3MuaW5kZXhPZihuYW1lKVxuICAgICAgOiAtMTtcbiAgICByZXR1cm4gKGluZGV4ID09PSAtMSlcbiAgICAgID8gc3RhY2tzLmxlbmd0aCAtIDFcbiAgICAgIDogaW5kZXg7XG4gIH1cbiAgX2dldFJ1bGVyKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgcGl4ZWxzID0gW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGEuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHBpeGVscy5wdXNoKGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGkpW2lTY2FsZS5heGlzXSwgaSkpO1xuICAgIH1cbiAgICBjb25zdCBiYXJUaGlja25lc3MgPSBvcHRzLmJhclRoaWNrbmVzcztcbiAgICBjb25zdCBtaW4gPSBiYXJUaGlja25lc3MgfHwgY29tcHV0ZU1pblNhbXBsZVNpemUobWV0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbixcbiAgICAgIHBpeGVscyxcbiAgICAgIHN0YXJ0OiBpU2NhbGUuX3N0YXJ0UGl4ZWwsXG4gICAgICBlbmQ6IGlTY2FsZS5fZW5kUGl4ZWwsXG4gICAgICBzdGFja0NvdW50OiB0aGlzLl9nZXRTdGFja0NvdW50KCksXG4gICAgICBzY2FsZTogaVNjYWxlLFxuICAgICAgZ3JvdXBlZDogb3B0cy5ncm91cGVkLFxuICAgICAgcmF0aW86IGJhclRoaWNrbmVzcyA/IDEgOiBvcHRzLmNhdGVnb3J5UGVyY2VudGFnZSAqIG9wdHMuYmFyUGVyY2VudGFnZVxuICAgIH07XG4gIH1cbiAgX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGluZGV4KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiB7dlNjYWxlLCBfc3RhY2tlZH0sIG9wdGlvbnM6IHtiYXNlOiBiYXNlVmFsdWUsIG1pbkJhckxlbmd0aH19ID0gdGhpcztcbiAgICBjb25zdCBhY3R1YWxCYXNlID0gYmFzZVZhbHVlIHx8IDA7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IGZsb2F0aW5nID0gaXNGbG9hdEJhcihjdXN0b20pO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFt2U2NhbGUuYXhpc107XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgbGVuZ3RoID0gX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHZhbHVlO1xuICAgIGxldCBoZWFkLCBzaXplO1xuICAgIGlmIChsZW5ndGggIT09IHZhbHVlKSB7XG4gICAgICBzdGFydCA9IGxlbmd0aCAtIHZhbHVlO1xuICAgICAgbGVuZ3RoID0gdmFsdWU7XG4gICAgfVxuICAgIGlmIChmbG9hdGluZykge1xuICAgICAgdmFsdWUgPSBjdXN0b20uYmFyU3RhcnQ7XG4gICAgICBsZW5ndGggPSBjdXN0b20uYmFyRW5kIC0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHNpZ24odmFsdWUpICE9PSBzaWduKGN1c3RvbS5iYXJFbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFZhbHVlID0gIWlzTnVsbE9yVW5kZWYoYmFzZVZhbHVlKSAmJiAhZmxvYXRpbmcgPyBiYXNlVmFsdWUgOiBzdGFydDtcbiAgICBsZXQgYmFzZSA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0VmFsdWUpO1xuICAgIGlmICh0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgaGVhZCA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0ICsgbGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZCA9IGJhc2U7XG4gICAgfVxuICAgIHNpemUgPSBoZWFkIC0gYmFzZTtcbiAgICBpZiAoTWF0aC5hYnMoc2l6ZSkgPCBtaW5CYXJMZW5ndGgpIHtcbiAgICAgIHNpemUgPSBiYXJTaWduKHNpemUsIHZTY2FsZSwgYWN0dWFsQmFzZSkgKiBtaW5CYXJMZW5ndGg7XG4gICAgICBpZiAodmFsdWUgPT09IGFjdHVhbEJhc2UpIHtcbiAgICAgICAgYmFzZSAtPSBzaXplIC8gMjtcbiAgICAgIH1cbiAgICAgIGhlYWQgPSBiYXNlICsgc2l6ZTtcbiAgICB9XG4gICAgaWYgKGJhc2UgPT09IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKGFjdHVhbEJhc2UpKSB7XG4gICAgICBjb25zdCBoYWxmR3JpZCA9IHNpZ24oc2l6ZSkgKiB2U2NhbGUuZ2V0TGluZVdpZHRoRm9yVmFsdWUoYWN0dWFsQmFzZSkgLyAyO1xuICAgICAgYmFzZSArPSBoYWxmR3JpZDtcbiAgICAgIHNpemUgLT0gaGFsZkdyaWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzaXplLFxuICAgICAgYmFzZSxcbiAgICAgIGhlYWQsXG4gICAgICBjZW50ZXI6IGhlYWQgKyBzaXplIC8gMlxuICAgIH07XG4gIH1cbiAgX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGluZGV4LCBydWxlcikge1xuICAgIGNvbnN0IHNjYWxlID0gcnVsZXIuc2NhbGU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBza2lwTnVsbCA9IG9wdGlvbnMuc2tpcE51bGw7XG4gICAgY29uc3QgbWF4QmFyVGhpY2tuZXNzID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5tYXhCYXJUaGlja25lc3MsIEluZmluaXR5KTtcbiAgICBsZXQgY2VudGVyLCBzaXplO1xuICAgIGlmIChydWxlci5ncm91cGVkKSB7XG4gICAgICBjb25zdCBzdGFja0NvdW50ID0gc2tpcE51bGwgPyB0aGlzLl9nZXRTdGFja0NvdW50KGluZGV4KSA6IHJ1bGVyLnN0YWNrQ291bnQ7XG4gICAgICBjb25zdCByYW5nZSA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzID09PSAnZmxleCdcbiAgICAgICAgPyBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudClcbiAgICAgICAgOiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KTtcbiAgICAgIGNvbnN0IHN0YWNrSW5kZXggPSB0aGlzLl9nZXRTdGFja0luZGV4KHRoaXMuaW5kZXgsIHRoaXMuX2NhY2hlZE1ldGEuc3RhY2ssIHNraXBOdWxsID8gaW5kZXggOiB1bmRlZmluZWQpO1xuICAgICAgY2VudGVyID0gcmFuZ2Uuc3RhcnQgKyAocmFuZ2UuY2h1bmsgKiBzdGFja0luZGV4KSArIChyYW5nZS5jaHVuayAvIDIpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcmFuZ2UuY2h1bmsgKiByYW5nZS5yYXRpbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbnRlciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaW5kZXgpW3NjYWxlLmF4aXNdLCBpbmRleCk7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCBydWxlci5taW4gKiBydWxlci5yYXRpbyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcbiAgICAgIGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuICAgICAgY2VudGVyLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgICBjb25zdCByZWN0cyA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBpbGVuID0gcmVjdHMubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKHRoaXMuZ2V0UGFyc2VkKGkpW3ZTY2FsZS5heGlzXSAhPT0gbnVsbCkge1xuICAgICAgICByZWN0c1tpXS5kcmF3KHRoaXMuX2N0eCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5CYXJDb250cm9sbGVyLmlkID0gJ2Jhcic7XG5CYXJDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdiYXInLFxuICBjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcbiAgYmFyUGVyY2VudGFnZTogMC45LFxuICBncm91cGVkOiB0cnVlLFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddXG4gICAgfVxuICB9XG59O1xuQmFyQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIF9pbmRleF86IHtcbiAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICBvZmZzZXQ6IHRydWUsXG4gICAgICBncmlkOiB7XG4gICAgICAgIG9mZnNldDogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgX3ZhbHVlXzoge1xuICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIEJ1YmJsZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cztcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtWzJdLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbSAmJiBpdGVtLnIgJiYgK2l0ZW0uciwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIGxldCBtYXggPSAwO1xuICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSkpIC8gMik7XG4gICAgfVxuICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IHggPSB4U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueCk7XG4gICAgY29uc3QgeSA9IHlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC55KTtcbiAgICBjb25zdCByID0gcGFyc2VkLl9jdXN0b207XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBtZXRhLmxhYmVsLFxuICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArIChyID8gJywgJyArIHIgOiAnJykgKyAnKSdcbiAgICB9O1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSAhcmVzZXQgJiYgdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IHJlc2V0ID8gaVNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwLjUpIDogaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0ID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCk7XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgIHByb3BlcnRpZXMub3B0aW9ucy5yYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgfVxuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGxldCB2YWx1ZXMgPSBzdXBlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKTtcbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIHZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlcywgeyRzaGFyZWQ6IGZhbHNlfSk7XG4gICAgfVxuICAgIGNvbnN0IHJhZGl1cyA9IHZhbHVlcy5yYWRpdXM7XG4gICAgaWYgKG1vZGUgIT09ICdhY3RpdmUnKSB7XG4gICAgICB2YWx1ZXMucmFkaXVzID0gMDtcbiAgICB9XG4gICAgdmFsdWVzLnJhZGl1cyArPSB2YWx1ZU9yRGVmYXVsdChwYXJzZWQgJiYgcGFyc2VkLl9jdXN0b20sIHJhZGl1cyk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxufVxuQnViYmxlQ29udHJvbGxlci5pZCA9ICdidWJibGUnO1xuQnViYmxlQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnXVxuICAgIH1cbiAgfVxufTtcbkJ1YmJsZUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBzY2FsZXM6IHtcbiAgICB4OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH0sXG4gICAgeToge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9XG4gIH0sXG4gIHBsdWdpbnM6IHtcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KSB7XG4gIGxldCByYXRpb1ggPSAxO1xuICBsZXQgcmF0aW9ZID0gMTtcbiAgbGV0IG9mZnNldFggPSAwO1xuICBsZXQgb2Zmc2V0WSA9IDA7XG4gIGlmIChjaXJjdW1mZXJlbmNlIDwgVEFVKSB7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHJvdGF0aW9uO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG4gICAgY29uc3Qgc3RhcnRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgY29uc3Qgc3RhcnRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgZW5kWCA9IE1hdGguY29zKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBlbmRZID0gTWF0aC5zaW4oZW5kQW5nbGUpO1xuICAgIGNvbnN0IGNhbGNNYXggPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IDEgOiBNYXRoLm1heChhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBjYWxjTWluID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAtMSA6IE1hdGgubWluKGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFggPSBjYWxjTWF4KDAsIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWF4WSA9IGNhbGNNYXgoSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICBjb25zdCBtaW5YID0gY2FsY01pbihQSSwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtaW5ZID0gY2FsY01pbihQSSArIEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgcmF0aW9YID0gKG1heFggLSBtaW5YKSAvIDI7XG4gICAgcmF0aW9ZID0gKG1heFkgLSBtaW5ZKSAvIDI7XG4gICAgb2Zmc2V0WCA9IC0obWF4WCArIG1pblgpIC8gMjtcbiAgICBvZmZzZXRZID0gLShtYXhZICsgbWluWSkgLyAyO1xuICB9XG4gIHJldHVybiB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9O1xufVxuY2xhc3MgRG91Z2hudXRDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WSA9IHVuZGVmaW5lZDtcbiAgfVxuICBsaW5rU2NhbGVzKCkge31cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YXNldCgpLmRhdGE7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZ2V0dGVyID0gKGkpID0+ICtkYXRhW2ldO1xuICAgICAgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBjb25zdCB7a2V5ID0gJ3ZhbHVlJ30gPSB0aGlzLl9wYXJzaW5nO1xuICAgICAgICBnZXR0ZXIgPSAoaSkgPT4gK3Jlc29sdmVPYmplY3RLZXkoZGF0YVtpXSwga2V5KTtcbiAgICAgIH1cbiAgICAgIGxldCBpLCBpbGVuO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIG1ldGEuX3BhcnNlZFtpXSA9IGdldHRlcihpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2dldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLnJvdGF0aW9uIC0gOTApO1xuICB9XG4gIF9nZXRDaXJjdW1mZXJlbmNlKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLmNpcmN1bWZlcmVuY2UpO1xuICB9XG4gIF9nZXRSb3RhdGlvbkV4dGVudHMoKSB7XG4gICAgbGV0IG1pbiA9IFRBVTtcbiAgICBsZXQgbWF4ID0gLVRBVTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyO1xuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGNvbnRyb2xsZXIuX2dldFJvdGF0aW9uKCk7XG4gICAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSBjb250cm9sbGVyLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcm90YXRpb24pO1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJvdGF0aW9uICsgY2lyY3VtZmVyZW5jZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByb3RhdGlvbjogbWluLFxuICAgICAgY2lyY3VtZmVyZW5jZTogbWF4IC0gbWluLFxuICAgIH07XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qge2NoYXJ0QXJlYX0gPSBjaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBhcmNzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IHNwYWNpbmcgPSB0aGlzLmdldE1heEJvcmRlcldpZHRoKCkgKyB0aGlzLmdldE1heE9mZnNldChhcmNzKSArIHRoaXMub3B0aW9ucy5zcGFjaW5nO1xuICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heCgoTWF0aC5taW4oY2hhcnRBcmVhLndpZHRoLCBjaGFydEFyZWEuaGVpZ2h0KSAtIHNwYWNpbmcpIC8gMiwgMCk7XG4gICAgY29uc3QgY3V0b3V0ID0gTWF0aC5taW4odG9QZXJjZW50YWdlKHRoaXMub3B0aW9ucy5jdXRvdXQsIG1heFNpemUpLCAxKTtcbiAgICBjb25zdCBjaGFydFdlaWdodCA9IHRoaXMuX2dldFJpbmdXZWlnaHQodGhpcy5pbmRleCk7XG4gICAgY29uc3Qge2NpcmN1bWZlcmVuY2UsIHJvdGF0aW9ufSA9IHRoaXMuX2dldFJvdGF0aW9uRXh0ZW50cygpO1xuICAgIGNvbnN0IHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX0gPSBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KTtcbiAgICBjb25zdCBtYXhXaWR0aCA9IChjaGFydEFyZWEud2lkdGggLSBzcGFjaW5nKSAvIHJhdGlvWDtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSAoY2hhcnRBcmVhLmhlaWdodCAtIHNwYWNpbmcpIC8gcmF0aW9ZO1xuICAgIGNvbnN0IG1heFJhZGl1cyA9IE1hdGgubWF4KE1hdGgubWluKG1heFdpZHRoLCBtYXhIZWlnaHQpIC8gMiwgMCk7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSB0b0RpbWVuc2lvbih0aGlzLm9wdGlvbnMucmFkaXVzLCBtYXhSYWRpdXMpO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3V0ZXJSYWRpdXMgKiBjdXRvdXQsIDApO1xuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIHRoaXMuX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKTtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYICogb3V0ZXJSYWRpdXM7XG4gICAgdGhpcy5vZmZzZXRZID0gb2Zmc2V0WSAqIG91dGVyUmFkaXVzO1xuICAgIG1ldGEudG90YWwgPSB0aGlzLmNhbGN1bGF0ZVRvdGFsKCk7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gTWF0aC5tYXgodGhpcy5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIGNoYXJ0V2VpZ2h0LCAwKTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICBfY2lyY3VtZmVyZW5jZShpLCByZXNldCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2dldENpcmN1bWZlcmVuY2UoKTtcbiAgICBpZiAoKHJlc2V0ICYmIG9wdHMuYW5pbWF0aW9uLmFuaW1hdGVSb3RhdGUpIHx8ICF0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpIHx8IG1ldGEuX3BhcnNlZFtpXSA9PT0gbnVsbCB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShtZXRhLl9wYXJzZWRbaV0gKiBjaXJjdW1mZXJlbmNlIC8gVEFVKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3QgY2VudGVyWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcbiAgICBjb25zdCBhbmltYXRlU2NhbGUgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLmlubmVyUmFkaXVzO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMub3V0ZXJSYWRpdXM7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpO1xuICAgIGxldCBzdGFydEFuZ2xlID0gdGhpcy5fZ2V0Um90YXRpb24oKTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgc3RhcnRBbmdsZSArPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYICsgdGhpcy5vZmZzZXRYLFxuICAgICAgICB5OiBjZW50ZXJZICsgdGhpcy5vZmZzZXRZLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZTogc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBpbm5lclJhZGl1c1xuICAgICAgfTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBhcmMuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0QW5nbGUgKz0gY2lyY3VtZmVyZW5jZTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgfVxuICBjYWxjdWxhdGVUb3RhbCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhRGF0YSA9IG1ldGEuZGF0YTtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtZXRhRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWUgPSBtZXRhLl9wYXJzZWRbaV07XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgIWlzTmFOKHZhbHVlKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpICYmICFtZXRhRGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgICAgdG90YWwgKz0gTWF0aC5hYnModmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cbiAgY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSh2YWx1ZSkge1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5fY2FjaGVkTWV0YS50b3RhbDtcbiAgICBpZiAodG90YWwgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBUQVUgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0sIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG4gIGdldE1heEJvcmRlcldpZHRoKGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGV0IGksIGlsZW4sIG1ldGEsIGNvbnRyb2xsZXIsIG9wdGlvbnM7XG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbGVuID0gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgICBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICAgICAgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICAgICAgICBjb250cm9sbGVyID0gbWV0YS5jb250cm9sbGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYXJjcykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb3B0aW9ucyA9IGNvbnRyb2xsZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwLCBvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGggfHwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cbiAgZ2V0TWF4T2Zmc2V0KGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLm9mZnNldCB8fCAwLCBvcHRpb25zLmhvdmVyT2Zmc2V0IHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIF9nZXRSaW5nV2VpZ2h0T2Zmc2V0KGRhdGFzZXRJbmRleCkge1xuICAgIGxldCByaW5nV2VpZ2h0T2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgIHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJpbmdXZWlnaHRPZmZzZXQ7XG4gIH1cbiAgX2dldFJpbmdXZWlnaHQoZGF0YXNldEluZGV4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlT3JEZWZhdWx0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLndlaWdodCwgMSksIDApO1xuICB9XG4gIF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHx8IDE7XG4gIH1cbn1cbkRvdWdobnV0Q29udHJvbGxlci5pZCA9ICdkb3VnaG51dCc7XG5Eb3VnaG51dENvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gIGFuaW1hdGlvbjoge1xuICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgYW5pbWF0ZVNjYWxlOiBmYWxzZVxuICB9LFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ2NpcmN1bWZlcmVuY2UnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAnc3RhcnRBbmdsZScsICd4JywgJ3knLCAnb2Zmc2V0JywgJ2JvcmRlcldpZHRoJywgJ3NwYWNpbmcnXVxuICAgIH0sXG4gIH0sXG4gIGN1dG91dDogJzUwJScsXG4gIHJvdGF0aW9uOiAwLFxuICBjaXJjdW1mZXJlbmNlOiAzNjAsXG4gIHJhZGl1czogJzEwMCUnLFxuICBzcGFjaW5nOiAwLFxuICBpbmRleEF4aXM6ICdyJyxcbn07XG5Eb3VnaG51dENvbnRyb2xsZXIuZGVzY3JpcHRvcnMgPSB7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnLFxufTtcbkRvdWdobnV0Q29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBwbHVnaW5zOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZX19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG4gICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgICAgbGV0IGRhdGFMYWJlbCA9IHRvb2x0aXBJdGVtLmxhYmVsO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gJzogJyArIHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgIGlmIChpc0FycmF5KGRhdGFMYWJlbCkpIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbCA9IGRhdGFMYWJlbC5zbGljZSgpO1xuICAgICAgICAgICAgZGF0YUxhYmVsWzBdICs9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhTGFiZWwgKz0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRhTGFiZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIExpbmVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2RhdGFzZXQ6IGxpbmUsIGRhdGE6IHBvaW50cyA9IFtdLCBfZGF0YXNldH0gPSBtZXRhO1xuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcbiAgICBpZiAoc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBsaW5lLl9kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICB9XG4gICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICBvcHRpb25zXG4gICAgfSwgbW9kZSk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZCwgX2RhdGFzZXR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHtzcGFuR2Fwcywgc2VnbWVudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xuICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICB9XG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLmRhdGFzZXQudXBkYXRlQ29udHJvbFBvaW50cyh0aGlzLmNoYXJ0LmNoYXJ0QXJlYSwgbWV0YS5pU2NhbGUuYXhpcyk7XG4gICAgc3VwZXIuZHJhdygpO1xuICB9XG59XG5MaW5lQ29udHJvbGxlci5pZCA9ICdsaW5lJztcbkxpbmVDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBzaG93TGluZTogdHJ1ZSxcbiAgc3BhbkdhcHM6IGZhbHNlLFxufTtcbkxpbmVDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgc2NhbGVzOiB7XG4gICAgX2luZGV4Xzoge1xuICAgICAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgICB9LFxuICAgIF92YWx1ZV86IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgIH0sXG4gIH1cbn07XG5mdW5jdGlvbiBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQgPSBwb2ludENvdW50O1xuICBpZiAobWV0YS5fc29ydGVkKSB7XG4gICAgY29uc3Qge2lTY2FsZSwgX3BhcnNlZH0gPSBtZXRhO1xuICAgIGNvbnN0IGF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgICBpZiAobWluRGVmaW5lZCkge1xuICAgICAgc3RhcnQgPSBfbGltaXRWYWx1ZShNYXRoLm1pbihcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGlTY2FsZS5heGlzLCBtaW4pLmxvLFxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyBwb2ludENvdW50IDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWluKSkubG8pLFxuICAgICAgMCwgcG9pbnRDb3VudCAtIDEpO1xuICAgIH1cbiAgICBpZiAobWF4RGVmaW5lZCkge1xuICAgICAgY291bnQgPSBfbGltaXRWYWx1ZShNYXRoLm1heChcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGlTY2FsZS5heGlzLCBtYXgpLmhpICsgMSxcbiAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gMCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1heCkpLmhpICsgMSksXG4gICAgICBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cbmZ1bmN0aW9uIHNjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSB7XG4gIGNvbnN0IHt4U2NhbGUsIHlTY2FsZSwgX3NjYWxlUmFuZ2VzfSA9IG1ldGE7XG4gIGNvbnN0IG5ld1JhbmdlcyA9IHtcbiAgICB4bWluOiB4U2NhbGUubWluLFxuICAgIHhtYXg6IHhTY2FsZS5tYXgsXG4gICAgeW1pbjogeVNjYWxlLm1pbixcbiAgICB5bWF4OiB5U2NhbGUubWF4XG4gIH07XG4gIGlmICghX3NjYWxlUmFuZ2VzKSB7XG4gICAgbWV0YS5fc2NhbGVSYW5nZXMgPSBuZXdSYW5nZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgY2hhbmdlZCA9IF9zY2FsZVJhbmdlcy54bWluICE9PSB4U2NhbGUubWluXG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnhtYXggIT09IHhTY2FsZS5tYXhcblx0XHR8fCBfc2NhbGVSYW5nZXMueW1pbiAhPT0geVNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy55bWF4ICE9PSB5U2NhbGUubWF4O1xuICBPYmplY3QuYXNzaWduKF9zY2FsZVJhbmdlcywgbmV3UmFuZ2VzKTtcbiAgcmV0dXJuIGNoYW5nZWQ7XG59XG5cbmNsYXNzIFBvbGFyQXJlYUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLnIsIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgYXJjcyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICB0aGlzLl91cGRhdGVSYWRpdXMoKTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICBfdXBkYXRlUmFkaXVzKCkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgbWluU2l6ZSA9IE1hdGgubWluKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChtaW5TaXplIC8gMiwgMCk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvcHRzLmN1dG91dFBlcmNlbnRhZ2UgPyAob3V0ZXJSYWRpdXMgLyAxMDApICogKG9wdHMuY3V0b3V0UGVyY2VudGFnZSkgOiAxLCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyBjaGFydC5nZXRWaXNpYmxlRGF0YXNldENvdW50KCk7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gKHJhZGl1c0xlbmd0aCAqIHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBzY2FsZS55Q2VudGVyO1xuICAgIGNvbnN0IGRhdGFzZXRTdGFydEFuZ2xlID0gc2NhbGUuZ2V0SW5kZXhBbmdsZSgwKSAtIDAuNSAqIFBJO1xuICAgIGxldCBhbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgIGxldCBpO1xuICAgIGNvbnN0IGRlZmF1bHRBbmdsZSA9IDM2MCAvIHRoaXMuY291bnRWaXNpYmxlRWxlbWVudHMoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgYW5nbGUgKz0gdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgfVxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgbGV0IHN0YXJ0QW5nbGUgPSBhbmdsZTtcbiAgICAgIGxldCBlbmRBbmdsZSA9IGFuZ2xlICsgdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgICBsZXQgb3V0ZXJSYWRpdXMgPSBjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSA/IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKGRhdGFzZXQuZGF0YVtpXSkgOiAwO1xuICAgICAgYW5nbGUgPSBlbmRBbmdsZTtcbiAgICAgIGlmIChyZXNldCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUpIHtcbiAgICAgICAgICBvdXRlclJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSkge1xuICAgICAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYLFxuICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICBvcHRpb25zOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSlcbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbiAgY291bnRWaXNpYmxlRWxlbWVudHMoKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIWlzTmFOKGRhdGFzZXQuZGF0YVtpbmRleF0pICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIF9jb21wdXRlQW5nbGUoaW5kZXgsIG1vZGUsIGRlZmF1bHRBbmdsZSkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KVxuICAgICAgPyB0b1JhZGlhbnModGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKS5hbmdsZSB8fCBkZWZhdWx0QW5nbGUpXG4gICAgICA6IDA7XG4gIH1cbn1cblBvbGFyQXJlYUNvbnRyb2xsZXIuaWQgPSAncG9sYXJBcmVhJztcblBvbGFyQXJlYUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gIGFuaW1hdGlvbjoge1xuICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgYW5pbWF0ZVNjYWxlOiB0cnVlXG4gIH0sXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnXVxuICAgIH0sXG4gIH0sXG4gIGluZGV4QXhpczogJ3InLFxuICBzdGFydEFuZ2xlOiAwLFxufTtcblBvbGFyQXJlYUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBhc3BlY3RSYXRpbzogMSxcbiAgcGx1Z2luczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGV9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbChjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuY2hhcnQuZGF0YS5sYWJlbHNbY29udGV4dC5kYXRhSW5kZXhdICsgJzogJyArIGNvbnRleHQuZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNjYWxlczoge1xuICAgIHI6IHtcbiAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgICAgYW5nbGVMaW5lczoge1xuICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgZ3JpZDoge1xuICAgICAgICBjaXJjdWxhcjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgc3RhcnRBbmdsZTogMFxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgUGllQ29udHJvbGxlciBleHRlbmRzIERvdWdobnV0Q29udHJvbGxlciB7XG59XG5QaWVDb250cm9sbGVyLmlkID0gJ3BpZSc7XG5QaWVDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBjdXRvdXQ6IDAsXG4gIHJvdGF0aW9uOiAwLFxuICBjaXJjdW1mZXJlbmNlOiAzNjAsXG4gIHJhZGl1czogJzEwMCUnXG59O1xuXG5jbGFzcyBSYWRhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCB2U2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiB2U2NhbGUuZ2V0TGFiZWxzKClbaW5kZXhdLFxuICAgICAgdmFsdWU6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSlcbiAgICB9O1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgbGFiZWxzID0gbWV0YS5pU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG4gICAgaWYgKG1vZGUgIT09ICdyZXNpemUnKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBfbG9vcDogdHJ1ZSxcbiAgICAgICAgX2Z1bGxMb29wOiBsYWJlbHMubGVuZ3RoID09PSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCBkYXRhc2V0LmRhdGFbaV0pO1xuICAgICAgY29uc3QgeCA9IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueDtcbiAgICAgIGNvbnN0IHkgPSByZXNldCA/IHNjYWxlLnlDZW50ZXIgOiBwb2ludFBvc2l0aW9uLnk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBhbmdsZTogcG9pbnRQb3NpdGlvbi5hbmdsZSxcbiAgICAgICAgc2tpcDogaXNOYU4oeCkgfHwgaXNOYU4oeSksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxufVxuUmFkYXJDb250cm9sbGVyLmlkID0gJ3JhZGFyJztcblJhZGFyQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgaW5kZXhBeGlzOiAncicsXG4gIHNob3dMaW5lOiB0cnVlLFxuICBlbGVtZW50czoge1xuICAgIGxpbmU6IHtcbiAgICAgIGZpbGw6ICdzdGFydCdcbiAgICB9XG4gIH0sXG59O1xuUmFkYXJDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgYXNwZWN0UmF0aW86IDEsXG4gIHNjYWxlczoge1xuICAgIHI6IHtcbiAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgU2NhdHRlckNvbnRyb2xsZXIgZXh0ZW5kcyBMaW5lQ29udHJvbGxlciB7XG59XG5TY2F0dGVyQ29udHJvbGxlci5pZCA9ICdzY2F0dGVyJztcblNjYXR0ZXJDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBzaG93TGluZTogZmFsc2UsXG4gIGZpbGw6IGZhbHNlXG59O1xuU2NhdHRlckNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBpbnRlcmFjdGlvbjoge1xuICAgIG1vZGU6ICdwb2ludCdcbiAgfSxcbiAgcGx1Z2luczoge1xuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gJygnICsgaXRlbS5sYWJlbCArICcsICcgKyBpdGVtLmZvcm1hdHRlZFZhbHVlICsgJyknO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzY2FsZXM6IHtcbiAgICB4OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH0sXG4gICAgeToge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjb250cm9sbGVycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkJhckNvbnRyb2xsZXI6IEJhckNvbnRyb2xsZXIsXG5CdWJibGVDb250cm9sbGVyOiBCdWJibGVDb250cm9sbGVyLFxuRG91Z2hudXRDb250cm9sbGVyOiBEb3VnaG51dENvbnRyb2xsZXIsXG5MaW5lQ29udHJvbGxlcjogTGluZUNvbnRyb2xsZXIsXG5Qb2xhckFyZWFDb250cm9sbGVyOiBQb2xhckFyZWFDb250cm9sbGVyLFxuUGllQ29udHJvbGxlcjogUGllQ29udHJvbGxlcixcblJhZGFyQ29udHJvbGxlcjogUmFkYXJDb250cm9sbGVyLFxuU2NhdHRlckNvbnRyb2xsZXI6IFNjYXR0ZXJDb250cm9sbGVyXG59KTtcblxuZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG4gIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkOiBDaGVjayB0aGF0IGEgY29tcGxldGUgZGF0ZSBhZGFwdGVyIGlzIHByb3ZpZGVkLicpO1xufVxuY2xhc3MgRGF0ZUFkYXB0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgfVxuICBmb3JtYXRzKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIHBhcnNlKHZhbHVlLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBmb3JtYXQodGltZXN0YW1wLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBhZGQodGltZXN0YW1wLCBhbW91bnQsIHVuaXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBkaWZmKGEsIGIsIHVuaXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBzdGFydE9mKHRpbWVzdGFtcCwgdW5pdCwgd2Vla2RheSkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGVuZE9mKHRpbWVzdGFtcCwgdW5pdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG59XG5EYXRlQWRhcHRlci5vdmVycmlkZSA9IGZ1bmN0aW9uKG1lbWJlcnMpIHtcbiAgT2JqZWN0LmFzc2lnbihEYXRlQWRhcHRlci5wcm90b3R5cGUsIG1lbWJlcnMpO1xufTtcbnZhciBhZGFwdGVycyA9IHtcbiAgX2RhdGU6IERhdGVBZGFwdGVyXG59O1xuXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KSB7XG4gIGlmICgnbmF0aXZlJyBpbiBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGUueCxcbiAgICAgIHk6IGUueVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGdldFJlbGF0aXZlUG9zaXRpb24kMShlLCBjaGFydCk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZUFsbFZpc2libGVJdGVtcyhjaGFydCwgaGFuZGxlcikge1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgbGV0IGluZGV4LCBkYXRhLCBlbGVtZW50O1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICh7aW5kZXgsIGRhdGF9ID0gbWV0YXNldHNbaV0pO1xuICAgIGZvciAobGV0IGogPSAwLCBqbGVuID0gZGF0YS5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgIGVsZW1lbnQgPSBkYXRhW2pdO1xuICAgICAgaWYgKCFlbGVtZW50LnNraXApIHtcbiAgICAgICAgaGFuZGxlcihlbGVtZW50LCBpbmRleCwgaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBiaW5hcnlTZWFyY2gobWV0YXNldCwgYXhpcywgdmFsdWUsIGludGVyc2VjdCkge1xuICBjb25zdCB7Y29udHJvbGxlciwgZGF0YSwgX3NvcnRlZH0gPSBtZXRhc2V0O1xuICBjb25zdCBpU2NhbGUgPSBjb250cm9sbGVyLl9jYWNoZWRNZXRhLmlTY2FsZTtcbiAgaWYgKGlTY2FsZSAmJiBheGlzID09PSBpU2NhbGUuYXhpcyAmJiBheGlzICE9PSAncicgJiYgX3NvcnRlZCAmJiBkYXRhLmxlbmd0aCkge1xuICAgIGNvbnN0IGxvb2t1cE1ldGhvZCA9IGlTY2FsZS5fcmV2ZXJzZVBpeGVscyA/IF9ybG9va3VwQnlLZXkgOiBfbG9va3VwQnlLZXk7XG4gICAgaWYgKCFpbnRlcnNlY3QpIHtcbiAgICAgIHJldHVybiBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlci5fc2hhcmVkT3B0aW9ucykge1xuICAgICAgY29uc3QgZWwgPSBkYXRhWzBdO1xuICAgICAgY29uc3QgcmFuZ2UgPSB0eXBlb2YgZWwuZ2V0UmFuZ2UgPT09ICdmdW5jdGlvbicgJiYgZWwuZ2V0UmFuZ2UoYXhpcyk7XG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgLSByYW5nZSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSArIHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHtsbzogc3RhcnQubG8sIGhpOiBlbmQuaGl9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge2xvOiAwLCBoaTogZGF0YS5sZW5ndGggLSAxfTtcbn1cbmZ1bmN0aW9uIG9wdGltaXplZEV2YWx1YXRlSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBoYW5kbGVyLCBpbnRlcnNlY3QpIHtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bYXhpc107XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY29uc3Qge2luZGV4LCBkYXRhfSA9IG1ldGFzZXRzW2ldO1xuICAgIGNvbnN0IHtsbywgaGl9ID0gYmluYXJ5U2VhcmNoKG1ldGFzZXRzW2ldLCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KTtcbiAgICBmb3IgKGxldCBqID0gbG87IGogPD0gaGk7ICsraikge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGRhdGFbal07XG4gICAgICBpZiAoIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICBoYW5kbGVyKGVsZW1lbnQsIGluZGV4LCBqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKSB7XG4gIGNvbnN0IHVzZVggPSBheGlzLmluZGV4T2YoJ3gnKSAhPT0gLTE7XG4gIGNvbnN0IHVzZVkgPSBheGlzLmluZGV4T2YoJ3knKSAhPT0gLTE7XG4gIHJldHVybiBmdW5jdGlvbihwdDEsIHB0Mikge1xuICAgIGNvbnN0IGRlbHRhWCA9IHVzZVggPyBNYXRoLmFicyhwdDEueCAtIHB0Mi54KSA6IDA7XG4gICAgY29uc3QgZGVsdGFZID0gdXNlWSA/IE1hdGguYWJzKHB0MS55IC0gcHQyLnkpIDogMDtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGRlbHRhWCwgMikgKyBNYXRoLnBvdyhkZWx0YVksIDIpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBpZiAoIV9pc1BvaW50SW5BcmVhKHBvc2l0aW9uLCBjaGFydC5jaGFydEFyZWEsIGNoYXJ0Ll9taW5QYWRkaW5nKSkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICBjb25zdCBldmFsdWF0aW9uRnVuYyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9O1xuICBvcHRpbWl6ZWRFdmFsdWF0ZUl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMsIHRydWUpO1xuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0UmFkaWFsSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGxldCBpdGVtcyA9IFtdO1xuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3Qge3N0YXJ0QW5nbGUsIGVuZEFuZ2xlfSA9IGVsZW1lbnQuZ2V0UHJvcHMoWydzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZX0gPSBnZXRBbmdsZUZyb21Qb2ludChlbGVtZW50LCB7eDogcG9zaXRpb24ueCwgeTogcG9zaXRpb24ueX0pO1xuICAgIGlmIChfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH1cbiAgb3B0aW1pemVkRXZhbHVhdGVJdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGxldCBpdGVtcyA9IFtdO1xuICBjb25zdCBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKTtcbiAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3QgaW5SYW5nZSA9IGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBpZiAoaW50ZXJzZWN0ICYmICFpblJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNlbnRlciA9IGVsZW1lbnQuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgcG9pbnRJbkFyZWEgPSBfaXNQb2ludEluQXJlYShjZW50ZXIsIGNoYXJ0LmNoYXJ0QXJlYSwgY2hhcnQuX21pblBhZGRpbmcpO1xuICAgIGlmICghcG9pbnRJbkFyZWEgJiYgIWluUmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGlzdGFuY2UgPSBkaXN0YW5jZU1ldHJpYyhwb3NpdGlvbiwgY2VudGVyKTtcbiAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgaXRlbXMgPSBbe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9XTtcbiAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH1cbiAgb3B0aW1pemVkRXZhbHVhdGVJdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGlmICghX2lzUG9pbnRJbkFyZWEocG9zaXRpb24sIGNoYXJ0LmNoYXJ0QXJlYSwgY2hhcnQuX21pblBhZGRpbmcpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBheGlzID09PSAncicgJiYgIWludGVyc2VjdFxuICAgID8gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbilcbiAgICA6IGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbik7XG59XG5mdW5jdGlvbiBnZXRBeGlzSXRlbXMoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcztcbiAgY29uc3QgcmFuZ2VNZXRob2QgPSBheGlzID09PSAneCcgPyAnaW5YUmFuZ2UnIDogJ2luWVJhbmdlJztcbiAgbGV0IGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG4gIGV2YWx1YXRlQWxsVmlzaWJsZUl0ZW1zKGNoYXJ0LCAoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkgPT4ge1xuICAgIGlmIChlbGVtZW50W3JhbmdlTWV0aG9kXShwb3NpdGlvbltheGlzXSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaW50ZXJzZWN0c0l0ZW0gPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIGlmIChvcHRpb25zLmludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxudmFyIEludGVyYWN0aW9uID0ge1xuICBtb2Rlczoge1xuICAgIGluZGV4KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneCc7XG4gICAgICBjb25zdCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKVxuICAgICAgICA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkuZm9yRWFjaCgobWV0YSkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGl0ZW1zWzBdLmluZGV4O1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gbWV0YS5kYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleCwgaW5kZXh9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcbiAgICBkYXRhc2V0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgbGV0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pIDpcbiAgICAgICAgZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZGF0YXNldEluZGV4ID0gaXRlbXNbMF0uZGF0YXNldEluZGV4O1xuICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5kYXRhO1xuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKHtlbGVtZW50OiBkYXRhW2ldLCBkYXRhc2V0SW5kZXgsIGluZGV4OiBpfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LFxuICAgIHBvaW50KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgcmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfSxcbiAgICBuZWFyZXN0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgcmV0dXJuIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9LFxuICAgIHgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIGUsIHtheGlzOiAneCcsIGludGVyc2VjdDogb3B0aW9ucy5pbnRlcnNlY3R9LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9LFxuICAgIHkoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIGUsIHtheGlzOiAneScsIGludGVyc2VjdDogb3B0aW9ucy5pbnRlcnNlY3R9LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IFNUQVRJQ19QT1NJVElPTlMgPSBbJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddO1xuZnVuY3Rpb24gZmlsdGVyQnlQb3NpdGlvbihhcnJheSwgcG9zaXRpb24pIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IHYucG9zID09PSBwb3NpdGlvbik7XG59XG5mdW5jdGlvbiBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMoYXJyYXksIGF4aXMpIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IFNUQVRJQ19QT1NJVElPTlMuaW5kZXhPZih2LnBvcykgPT09IC0xICYmIHYuYm94LmF4aXMgPT09IGF4aXMpO1xufVxuZnVuY3Rpb24gc29ydEJ5V2VpZ2h0KGFycmF5LCByZXZlcnNlKSB7XG4gIHJldHVybiBhcnJheS5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgdjAgPSByZXZlcnNlID8gYiA6IGE7XG4gICAgY29uc3QgdjEgPSByZXZlcnNlID8gYSA6IGI7XG4gICAgcmV0dXJuIHYwLndlaWdodCA9PT0gdjEud2VpZ2h0ID9cbiAgICAgIHYwLmluZGV4IC0gdjEuaW5kZXggOlxuICAgICAgdjAud2VpZ2h0IC0gdjEud2VpZ2h0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHdyYXBCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgYm94LCBwb3MsIHN0YWNrLCBzdGFja1dlaWdodDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IChib3hlcyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgYm94ID0gYm94ZXNbaV07XG4gICAgKHtwb3NpdGlvbjogcG9zLCBvcHRpb25zOiB7c3RhY2ssIHN0YWNrV2VpZ2h0ID0gMX19ID0gYm94KTtcbiAgICBsYXlvdXRCb3hlcy5wdXNoKHtcbiAgICAgIGluZGV4OiBpLFxuICAgICAgYm94LFxuICAgICAgcG9zLFxuICAgICAgaG9yaXpvbnRhbDogYm94LmlzSG9yaXpvbnRhbCgpLFxuICAgICAgd2VpZ2h0OiBib3gud2VpZ2h0LFxuICAgICAgc3RhY2s6IHN0YWNrICYmIChwb3MgKyBzdGFjayksXG4gICAgICBzdGFja1dlaWdodFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBsYXlvdXRCb3hlcztcbn1cbmZ1bmN0aW9uIGJ1aWxkU3RhY2tzKGxheW91dHMpIHtcbiAgY29uc3Qgc3RhY2tzID0ge307XG4gIGZvciAoY29uc3Qgd3JhcCBvZiBsYXlvdXRzKSB7XG4gICAgY29uc3Qge3N0YWNrLCBwb3MsIHN0YWNrV2VpZ2h0fSA9IHdyYXA7XG4gICAgaWYgKCFzdGFjayB8fCAhU1RBVElDX1BPU0lUSU9OUy5pbmNsdWRlcyhwb3MpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgX3N0YWNrID0gc3RhY2tzW3N0YWNrXSB8fCAoc3RhY2tzW3N0YWNrXSA9IHtjb3VudDogMCwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDAsIHNpemU6IDB9KTtcbiAgICBfc3RhY2suY291bnQrKztcbiAgICBfc3RhY2sud2VpZ2h0ICs9IHN0YWNrV2VpZ2h0O1xuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5mdW5jdGlvbiBzZXRMYXlvdXREaW1zKGxheW91dHMsIHBhcmFtcykge1xuICBjb25zdCBzdGFja3MgPSBidWlsZFN0YWNrcyhsYXlvdXRzKTtcbiAgY29uc3Qge3ZCb3hNYXhXaWR0aCwgaEJveE1heEhlaWdodH0gPSBwYXJhbXM7XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBsYXlvdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGxheW91dCA9IGxheW91dHNbaV07XG4gICAgY29uc3Qge2Z1bGxTaXplfSA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXTtcbiAgICBjb25zdCBmYWN0b3IgPSBzdGFjayAmJiBsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQ7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBsYXlvdXQud2lkdGggPSBmYWN0b3IgPyBmYWN0b3IgKiB2Qm94TWF4V2lkdGggOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlV2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gaEJveE1heEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5b3V0LndpZHRoID0gdkJveE1heFdpZHRoO1xuICAgICAgbGF5b3V0LmhlaWdodCA9IGZhY3RvciA/IGZhY3RvciAqIGhCb3hNYXhIZWlnaHQgOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlSGVpZ2h0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuZnVuY3Rpb24gYnVpbGRMYXlvdXRCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IHdyYXBCb3hlcyhib3hlcyk7XG4gIGNvbnN0IGZ1bGxTaXplID0gc29ydEJ5V2VpZ2h0KGxheW91dEJveGVzLmZpbHRlcih3cmFwID0+IHdyYXAuYm94LmZ1bGxTaXplKSwgdHJ1ZSk7XG4gIGNvbnN0IGxlZnQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2xlZnQnKSwgdHJ1ZSk7XG4gIGNvbnN0IHJpZ2h0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdyaWdodCcpKTtcbiAgY29uc3QgdG9wID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICd0b3AnKSwgdHJ1ZSk7XG4gIGNvbnN0IGJvdHRvbSA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnYm90dG9tJykpO1xuICBjb25zdCBjZW50ZXJIb3Jpem9udGFsID0gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGxheW91dEJveGVzLCAneCcpO1xuICBjb25zdCBjZW50ZXJWZXJ0aWNhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3knKTtcbiAgcmV0dXJuIHtcbiAgICBmdWxsU2l6ZSxcbiAgICBsZWZ0QW5kVG9wOiBsZWZ0LmNvbmNhdCh0b3ApLFxuICAgIHJpZ2h0QW5kQm90dG9tOiByaWdodC5jb25jYXQoY2VudGVyVmVydGljYWwpLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKSxcbiAgICBjaGFydEFyZWE6IGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdjaGFydEFyZWEnKSxcbiAgICB2ZXJ0aWNhbDogbGVmdC5jb25jYXQocmlnaHQpLmNvbmNhdChjZW50ZXJWZXJ0aWNhbCksXG4gICAgaG9yaXpvbnRhbDogdG9wLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCBhLCBiKSB7XG4gIHJldHVybiBNYXRoLm1heChtYXhQYWRkaW5nW2FdLCBjaGFydEFyZWFbYV0pICsgTWF0aC5tYXgobWF4UGFkZGluZ1tiXSwgY2hhcnRBcmVhW2JdKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgYm94UGFkZGluZykge1xuICBtYXhQYWRkaW5nLnRvcCA9IE1hdGgubWF4KG1heFBhZGRpbmcudG9wLCBib3hQYWRkaW5nLnRvcCk7XG4gIG1heFBhZGRpbmcubGVmdCA9IE1hdGgubWF4KG1heFBhZGRpbmcubGVmdCwgYm94UGFkZGluZy5sZWZ0KTtcbiAgbWF4UGFkZGluZy5ib3R0b20gPSBNYXRoLm1heChtYXhQYWRkaW5nLmJvdHRvbSwgYm94UGFkZGluZy5ib3R0b20pO1xuICBtYXhQYWRkaW5nLnJpZ2h0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5yaWdodCwgYm94UGFkZGluZy5yaWdodCk7XG59XG5mdW5jdGlvbiB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcykge1xuICBjb25zdCB7cG9zLCBib3h9ID0gbGF5b3V0O1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG4gIGlmICghaXNPYmplY3QocG9zKSkge1xuICAgIGlmIChsYXlvdXQuc2l6ZSkge1xuICAgICAgY2hhcnRBcmVhW3Bvc10gLT0gbGF5b3V0LnNpemU7XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge3NpemU6IDAsIGNvdW50OiAxfTtcbiAgICBzdGFjay5zaXplID0gTWF0aC5tYXgoc3RhY2suc2l6ZSwgbGF5b3V0Lmhvcml6b250YWwgPyBib3guaGVpZ2h0IDogYm94LndpZHRoKTtcbiAgICBsYXlvdXQuc2l6ZSA9IHN0YWNrLnNpemUgLyBzdGFjay5jb3VudDtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBsYXlvdXQuc2l6ZTtcbiAgfVxuICBpZiAoYm94LmdldFBhZGRpbmcpIHtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveC5nZXRQYWRkaW5nKCkpO1xuICB9XG4gIGNvbnN0IG5ld1dpZHRoID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVyV2lkdGggLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICdsZWZ0JywgJ3JpZ2h0JykpO1xuICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICd0b3AnLCAnYm90dG9tJykpO1xuICBjb25zdCB3aWR0aENoYW5nZWQgPSBuZXdXaWR0aCAhPT0gY2hhcnRBcmVhLnc7XG4gIGNvbnN0IGhlaWdodENoYW5nZWQgPSBuZXdIZWlnaHQgIT09IGNoYXJ0QXJlYS5oO1xuICBjaGFydEFyZWEudyA9IG5ld1dpZHRoO1xuICBjaGFydEFyZWEuaCA9IG5ld0hlaWdodDtcbiAgcmV0dXJuIGxheW91dC5ob3Jpem9udGFsXG4gICAgPyB7c2FtZTogd2lkdGhDaGFuZ2VkLCBvdGhlcjogaGVpZ2h0Q2hhbmdlZH1cbiAgICA6IHtzYW1lOiBoZWlnaHRDaGFuZ2VkLCBvdGhlcjogd2lkdGhDaGFuZ2VkfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcbiAgZnVuY3Rpb24gdXBkYXRlUG9zKHBvcykge1xuICAgIGNvbnN0IGNoYW5nZSA9IE1hdGgubWF4KG1heFBhZGRpbmdbcG9zXSAtIGNoYXJ0QXJlYVtwb3NdLCAwKTtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBjaGFuZ2U7XG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfVxuICBjaGFydEFyZWEueSArPSB1cGRhdGVQb3MoJ3RvcCcpO1xuICBjaGFydEFyZWEueCArPSB1cGRhdGVQb3MoJ2xlZnQnKTtcbiAgdXBkYXRlUG9zKCdyaWdodCcpO1xuICB1cGRhdGVQb3MoJ2JvdHRvbScpO1xufVxuZnVuY3Rpb24gZ2V0TWFyZ2lucyhob3Jpem9udGFsLCBjaGFydEFyZWEpIHtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuICBmdW5jdGlvbiBtYXJnaW5Gb3JQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgY29uc3QgbWFyZ2luID0ge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH07XG4gICAgcG9zaXRpb25zLmZvckVhY2goKHBvcykgPT4ge1xuICAgICAgbWFyZ2luW3Bvc10gPSBNYXRoLm1heChjaGFydEFyZWFbcG9zXSwgbWF4UGFkZGluZ1twb3NdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFyZ2luO1xuICB9XG4gIHJldHVybiBob3Jpem9udGFsXG4gICAgPyBtYXJnaW5Gb3JQb3NpdGlvbnMoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgOiBtYXJnaW5Gb3JQb3NpdGlvbnMoWyd0b3AnLCAnYm90dG9tJ10pO1xufVxuZnVuY3Rpb24gZml0Qm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgcmVmaXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgbGF5b3V0LCBib3gsIHJlZml0LCBjaGFuZ2VkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gYm94ZXMubGVuZ3RoLCByZWZpdCA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBib3hlc1tpXTtcbiAgICBib3ggPSBsYXlvdXQuYm94O1xuICAgIGJveC51cGRhdGUoXG4gICAgICBsYXlvdXQud2lkdGggfHwgY2hhcnRBcmVhLncsXG4gICAgICBsYXlvdXQuaGVpZ2h0IHx8IGNoYXJ0QXJlYS5oLFxuICAgICAgZ2V0TWFyZ2lucyhsYXlvdXQuaG9yaXpvbnRhbCwgY2hhcnRBcmVhKVxuICAgICk7XG4gICAgY29uc3Qge3NhbWUsIG90aGVyfSA9IHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKTtcbiAgICByZWZpdCB8PSBzYW1lICYmIHJlZml0Qm94ZXMubGVuZ3RoO1xuICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IG90aGVyO1xuICAgIGlmICghYm94LmZ1bGxTaXplKSB7XG4gICAgICByZWZpdEJveGVzLnB1c2gobGF5b3V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZml0ICYmIGZpdEJveGVzKHJlZml0Qm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHx8IGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBzZXRCb3hEaW1zKGJveCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGJveC50b3AgPSB0b3A7XG4gIGJveC5sZWZ0ID0gbGVmdDtcbiAgYm94LnJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICBib3guYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICBib3gud2lkdGggPSB3aWR0aDtcbiAgYm94LmhlaWdodCA9IGhlaWdodDtcbn1cbmZ1bmN0aW9uIHBsYWNlQm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgdXNlclBhZGRpbmcgPSBwYXJhbXMucGFkZGluZztcbiAgbGV0IHt4LCB5fSA9IGNoYXJ0QXJlYTtcbiAgZm9yIChjb25zdCBsYXlvdXQgb2YgYm94ZXMpIHtcbiAgICBjb25zdCBib3ggPSBsYXlvdXQuYm94O1xuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge2NvdW50OiAxLCBwbGFjZWQ6IDAsIHdlaWdodDogMX07XG4gICAgY29uc3Qgd2VpZ2h0ID0gKGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodCkgfHwgMTtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gY2hhcnRBcmVhLncgKiB3ZWlnaHQ7XG4gICAgICBjb25zdCBoZWlnaHQgPSBzdGFjay5zaXplIHx8IGJveC5oZWlnaHQ7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeSA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgdXNlclBhZGRpbmcubGVmdCwgeSwgcGFyYW1zLm91dGVyV2lkdGggLSB1c2VyUGFkZGluZy5yaWdodCAtIHVzZXJQYWRkaW5nLmxlZnQsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgY2hhcnRBcmVhLmxlZnQgKyBzdGFjay5wbGFjZWQsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgc3RhY2suc3RhcnQgPSB5O1xuICAgICAgc3RhY2sucGxhY2VkICs9IHdpZHRoO1xuICAgICAgeSA9IGJveC5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGNoYXJ0QXJlYS5oICogd2VpZ2h0O1xuICAgICAgY29uc3Qgd2lkdGggPSBzdGFjay5zaXplIHx8IGJveC53aWR0aDtcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICB4ID0gc3RhY2suc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCB1c2VyUGFkZGluZy50b3AsIHdpZHRoLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSB1c2VyUGFkZGluZy5ib3R0b20gLSB1c2VyUGFkZGluZy50b3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIGNoYXJ0QXJlYS50b3AgKyBzdGFjay5wbGFjZWQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgc3RhY2suc3RhcnQgPSB4O1xuICAgICAgc3RhY2sucGxhY2VkICs9IGhlaWdodDtcbiAgICAgIHggPSBib3gucmlnaHQ7XG4gICAgfVxuICB9XG4gIGNoYXJ0QXJlYS54ID0geDtcbiAgY2hhcnRBcmVhLnkgPSB5O1xufVxuZGVmYXVsdHMuc2V0KCdsYXlvdXQnLCB7XG4gIGF1dG9QYWRkaW5nOiB0cnVlLFxuICBwYWRkaW5nOiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH1cbn0pO1xudmFyIGxheW91dHMgPSB7XG4gIGFkZEJveChjaGFydCwgaXRlbSkge1xuICAgIGlmICghY2hhcnQuYm94ZXMpIHtcbiAgICAgIGNoYXJ0LmJveGVzID0gW107XG4gICAgfVxuICAgIGl0ZW0uZnVsbFNpemUgPSBpdGVtLmZ1bGxTaXplIHx8IGZhbHNlO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8ICd0b3AnO1xuICAgIGl0ZW0ud2VpZ2h0ID0gaXRlbS53ZWlnaHQgfHwgMDtcbiAgICBpdGVtLl9sYXllcnMgPSBpdGVtLl9sYXllcnMgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogMCxcbiAgICAgICAgZHJhdyhjaGFydEFyZWEpIHtcbiAgICAgICAgICBpdGVtLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfTtcbiAgICBjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuICB9LFxuICByZW1vdmVCb3goY2hhcnQsIGxheW91dEl0ZW0pIHtcbiAgICBjb25zdCBpbmRleCA9IGNoYXJ0LmJveGVzID8gY2hhcnQuYm94ZXMuaW5kZXhPZihsYXlvdXRJdGVtKSA6IC0xO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNoYXJ0LmJveGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9LFxuICBjb25maWd1cmUoY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICBpdGVtLmZ1bGxTaXplID0gb3B0aW9ucy5mdWxsU2l6ZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgICBpdGVtLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0O1xuICB9LFxuICB1cGRhdGUoY2hhcnQsIHdpZHRoLCBoZWlnaHQsIG1pblBhZGRpbmcpIHtcbiAgICBpZiAoIWNoYXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcoY2hhcnQub3B0aW9ucy5sYXlvdXQucGFkZGluZyk7XG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBNYXRoLm1heCh3aWR0aCAtIHBhZGRpbmcud2lkdGgsIDApO1xuICAgIGNvbnN0IGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWF4KGhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0LCAwKTtcbiAgICBjb25zdCBib3hlcyA9IGJ1aWxkTGF5b3V0Qm94ZXMoY2hhcnQuYm94ZXMpO1xuICAgIGNvbnN0IHZlcnRpY2FsQm94ZXMgPSBib3hlcy52ZXJ0aWNhbDtcbiAgICBjb25zdCBob3Jpem9udGFsQm94ZXMgPSBib3hlcy5ob3Jpem9udGFsO1xuICAgIGVhY2goY2hhcnQuYm94ZXMsIGJveCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJveC5iZWZvcmVMYXlvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYm94LmJlZm9yZUxheW91dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHZpc2libGVWZXJ0aWNhbEJveENvdW50ID0gdmVydGljYWxCb3hlcy5yZWR1Y2UoKHRvdGFsLCB3cmFwKSA9PlxuICAgICAgd3JhcC5ib3gub3B0aW9ucyAmJiB3cmFwLmJveC5vcHRpb25zLmRpc3BsYXkgPT09IGZhbHNlID8gdG90YWwgOiB0b3RhbCArIDEsIDApIHx8IDE7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBvdXRlcldpZHRoOiB3aWR0aCxcbiAgICAgIG91dGVySGVpZ2h0OiBoZWlnaHQsXG4gICAgICBwYWRkaW5nLFxuICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICBhdmFpbGFibGVIZWlnaHQsXG4gICAgICB2Qm94TWF4V2lkdGg6IGF2YWlsYWJsZVdpZHRoIC8gMiAvIHZpc2libGVWZXJ0aWNhbEJveENvdW50LFxuICAgICAgaEJveE1heEhlaWdodDogYXZhaWxhYmxlSGVpZ2h0IC8gMlxuICAgIH0pO1xuICAgIGNvbnN0IG1heFBhZGRpbmcgPSBPYmplY3QuYXNzaWduKHt9LCBwYWRkaW5nKTtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIHRvUGFkZGluZyhtaW5QYWRkaW5nKSk7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBtYXhQYWRkaW5nLFxuICAgICAgdzogYXZhaWxhYmxlV2lkdGgsXG4gICAgICBoOiBhdmFpbGFibGVIZWlnaHQsXG4gICAgICB4OiBwYWRkaW5nLmxlZnQsXG4gICAgICB5OiBwYWRkaW5nLnRvcFxuICAgIH0sIHBhZGRpbmcpO1xuICAgIGNvbnN0IHN0YWNrcyA9IHNldExheW91dERpbXModmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKSwgcGFyYW1zKTtcbiAgICBmaXRCb3hlcyhib3hlcy5mdWxsU2l6ZSwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgaWYgKGZpdEJveGVzKGhvcml6b250YWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykpIHtcbiAgICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIH1cbiAgICBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSk7XG4gICAgcGxhY2VCb3hlcyhib3hlcy5sZWZ0QW5kVG9wLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBjaGFydEFyZWEueCArPSBjaGFydEFyZWEudztcbiAgICBjaGFydEFyZWEueSArPSBjaGFydEFyZWEuaDtcbiAgICBwbGFjZUJveGVzKGJveGVzLnJpZ2h0QW5kQm90dG9tLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBjaGFydC5jaGFydEFyZWEgPSB7XG4gICAgICBsZWZ0OiBjaGFydEFyZWEubGVmdCxcbiAgICAgIHRvcDogY2hhcnRBcmVhLnRvcCxcbiAgICAgIHJpZ2h0OiBjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS53LFxuICAgICAgYm90dG9tOiBjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmgsXG4gICAgICBoZWlnaHQ6IGNoYXJ0QXJlYS5oLFxuICAgICAgd2lkdGg6IGNoYXJ0QXJlYS53LFxuICAgIH07XG4gICAgZWFjaChib3hlcy5jaGFydEFyZWEsIChsYXlvdXQpID0+IHtcbiAgICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgICBPYmplY3QuYXNzaWduKGJveCwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIGJveC51cGRhdGUoY2hhcnRBcmVhLncsIGNoYXJ0QXJlYS5oLCB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbmNsYXNzIEJhc2VQbGF0Zm9ybSB7XG4gIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHt9XG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHt9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fVxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGdldE1heGltdW1TaXplKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCB8fCBlbGVtZW50LndpZHRoKTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgZWxlbWVudC5oZWlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IE1hdGguZmxvb3Iod2lkdGggLyBhc3BlY3RSYXRpbykgOiBoZWlnaHQpXG4gICAgfTtcbiAgfVxuICBpc0F0dGFjaGVkKGNhbnZhcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgfVxufVxuXG5jbGFzcyBCYXNpY1BsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoaXRlbSkge1xuICAgIHJldHVybiBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCAmJiBpdGVtLmdldENvbnRleHQoJzJkJykgfHwgbnVsbDtcbiAgfVxuICB1cGRhdGVDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnLm9wdGlvbnMuYW5pbWF0aW9uID0gZmFsc2U7XG4gIH1cbn1cblxuY29uc3QgRVhQQU5ET19LRVkgPSAnJGNoYXJ0anMnO1xuY29uc3QgRVZFTlRfVFlQRVMgPSB7XG4gIHRvdWNoc3RhcnQ6ICdtb3VzZWRvd24nLFxuICB0b3VjaG1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3VjaGVuZDogJ21vdXNldXAnLFxuICBwb2ludGVyZW50ZXI6ICdtb3VzZWVudGVyJyxcbiAgcG9pbnRlcmRvd246ICdtb3VzZWRvd24nLFxuICBwb2ludGVybW92ZTogJ21vdXNlbW92ZScsXG4gIHBvaW50ZXJ1cDogJ21vdXNldXAnLFxuICBwb2ludGVybGVhdmU6ICdtb3VzZW91dCcsXG4gIHBvaW50ZXJvdXQ6ICdtb3VzZW91dCdcbn07XG5jb25zdCBpc051bGxPckVtcHR5ID0gdmFsdWUgPT4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnO1xuZnVuY3Rpb24gaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHN0eWxlID0gY2FudmFzLnN0eWxlO1xuICBjb25zdCByZW5kZXJIZWlnaHQgPSBjYW52YXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTtcbiAgY29uc3QgcmVuZGVyV2lkdGggPSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuICBjYW52YXNbRVhQQU5ET19LRVldID0ge1xuICAgIGluaXRpYWw6IHtcbiAgICAgIGhlaWdodDogcmVuZGVySGVpZ2h0LFxuICAgICAgd2lkdGg6IHJlbmRlcldpZHRoLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogc3R5bGUuZGlzcGxheSxcbiAgICAgICAgaGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBzdHlsZS53aWR0aFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3R5bGUuZGlzcGxheSA9IHN0eWxlLmRpc3BsYXkgfHwgJ2Jsb2NrJztcbiAgc3R5bGUuYm94U2l6aW5nID0gc3R5bGUuYm94U2l6aW5nIHx8ICdib3JkZXItYm94JztcbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVyV2lkdGgpKSB7XG4gICAgY29uc3QgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG4gICAgaWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG4gICAgfVxuICB9XG4gIGlmIChpc051bGxPckVtcHR5KHJlbmRlckhlaWdodCkpIHtcbiAgICBpZiAoY2FudmFzLnN0eWxlLmhlaWdodCA9PT0gJycpIHtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggLyAoYXNwZWN0UmF0aW8gfHwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG4gICAgICBpZiAoZGlzcGxheUhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FudmFzO1xufVxuY29uc3QgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihub2RlLCB0eXBlLCBsaXN0ZW5lcikge1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjaGFydC5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkge1xuICBjb25zdCB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcbiAgY29uc3Qge3gsIHl9ID0gZ2V0UmVsYXRpdmVQb3NpdGlvbiQxKGV2ZW50LCBjaGFydCk7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICBjaGFydCxcbiAgICBuYXRpdmU6IGV2ZW50LFxuICAgIHg6IHggIT09IHVuZGVmaW5lZCA/IHggOiBudWxsLFxuICAgIHk6IHkgIT09IHVuZGVmaW5lZCA/IHkgOiBudWxsLFxuICB9O1xufVxuZnVuY3Rpb24gbm9kZUxpc3RDb250YWlucyhub2RlTGlzdCwgY2FudmFzKSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTGlzdCkge1xuICAgIGlmIChub2RlID09PSBjYW52YXMgfHwgbm9kZS5jb250YWlucyhjYW52YXMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUF0dGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVEZXRhY2hPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGxldCB0cmlnZ2VyID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciB8fCBub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LmFkZGVkTm9kZXMsIGNhbnZhcyk7XG4gICAgfVxuICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWV9KTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuY29uc3QgZHJwTGlzdGVuaW5nQ2hhcnRzID0gbmV3IE1hcCgpO1xubGV0IG9sZERldmljZVBpeGVsUmF0aW8gPSAwO1xuZnVuY3Rpb24gb25XaW5kb3dSZXNpemUoKSB7XG4gIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICBpZiAoZHByID09PSBvbGREZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9sZERldmljZVBpeGVsUmF0aW8gPSBkcHI7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5mb3JFYWNoKChyZXNpemUsIGNoYXJ0KSA9PiB7XG4gICAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBkcHIpIHtcbiAgICAgIHJlc2l6ZSgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCwgcmVzaXplKSB7XG4gIGlmICghZHJwTGlzdGVuaW5nQ2hhcnRzLnNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25XaW5kb3dSZXNpemUpO1xuICB9XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5zZXQoY2hhcnQsIHJlc2l6ZSk7XG59XG5mdW5jdGlvbiB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KSB7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUmVzaXplT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlc2l6ZSA9IHRocm90dGxlZCgod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHcgPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgbGlzdGVuZXIod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHcgPCBjb250YWluZXIuY2xpZW50V2lkdGgpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9LCB3aW5kb3cpO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbMF07XG4gICAgY29uc3Qgd2lkdGggPSBlbnRyeS5jb250ZW50UmVjdC53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBlbnRyeS5jb250ZW50UmVjdC5oZWlnaHQ7XG4gICAgaWYgKHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXNpemUod2lkdGgsIGhlaWdodCk7XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lcik7XG4gIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5mdW5jdGlvbiByZWxlYXNlT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIG9ic2VydmVyKSB7XG4gIGlmIChvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJveHlBbmRMaXN0ZW4oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgcHJveHkgPSB0aHJvdHRsZWQoKGV2ZW50KSA9PiB7XG4gICAgaWYgKGNoYXJ0LmN0eCAhPT0gbnVsbCkge1xuICAgICAgbGlzdGVuZXIoZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkpO1xuICAgIH1cbiAgfSwgY2hhcnQsIChhcmdzKSA9PiB7XG4gICAgY29uc3QgZXZlbnQgPSBhcmdzWzBdO1xuICAgIHJldHVybiBbZXZlbnQsIGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFldO1xuICB9KTtcbiAgYWRkTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XG4gIHJldHVybiBwcm94eTtcbn1cbmNsYXNzIERvbVBsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQgJiYgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5jYW52YXMgPT09IGNhbnZhcykge1xuICAgICAgaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKTtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZWxlYXNlQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgaWYgKCFjYW52YXNbRVhQQU5ET19LRVldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG4gICAgWydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHN0eWxlID0gaW5pdGlhbC5zdHlsZSB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjYW52YXMuc3R5bGVba2V5XSA9IHN0eWxlW2tleV07XG4gICAgfSk7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIGRlbGV0ZSBjYW52YXNbRVhQQU5ET19LRVldO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlKTtcbiAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiBjcmVhdGVBdHRhY2hPYnNlcnZlcixcbiAgICAgIGRldGFjaDogY3JlYXRlRGV0YWNoT2JzZXJ2ZXIsXG4gICAgICByZXNpemU6IGNyZWF0ZVJlc2l6ZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgY3JlYXRlUHJveHlBbmRMaXN0ZW47XG4gICAgcHJveGllc1t0eXBlXSA9IGhhbmRsZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlKSB7XG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBwcm94eSA9IHByb3hpZXNbdHlwZV07XG4gICAgaWYgKCFwcm94eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogcmVsZWFzZU9ic2VydmVyLFxuICAgICAgZGV0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICByZXNpemU6IHJlbGVhc2VPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IHJlbW92ZUxpc3RlbmVyO1xuICAgIGhhbmRsZXIoY2hhcnQsIHR5cGUsIHByb3h5KTtcbiAgICBwcm94aWVzW3R5cGVdID0gdW5kZWZpbmVkO1xuICB9XG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICB9XG4gIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgICByZXR1cm4gZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbyk7XG4gIH1cbiAgaXNBdHRhY2hlZChjYW52YXMpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIHJldHVybiAhIShjb250YWluZXIgJiYgY29udGFpbmVyLmlzQ29ubmVjdGVkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGV0ZWN0UGxhdGZvcm0oY2FudmFzKSB7XG4gIGlmICghX2lzRG9tU3VwcG9ydGVkKCkgfHwgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykpIHtcbiAgICByZXR1cm4gQmFzaWNQbGF0Zm9ybTtcbiAgfVxuICByZXR1cm4gRG9tUGxhdGZvcm07XG59XG5cbmNsYXNzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX07XG4gIH1cbiAgaGFzVmFsdWUoKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHRoaXMueCkgJiYgaXNOdW1iZXIodGhpcy55KTtcbiAgfVxuICBnZXRQcm9wcyhwcm9wcywgZmluYWwpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgaWYgKCFmaW5hbCB8fCAhYW5pbXMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBwcm9wcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgcmV0W3Byb3BdID0gYW5pbXNbcHJvcF0gJiYgYW5pbXNbcHJvcF0uYWN0aXZlKCkgPyBhbmltc1twcm9wXS5fdG8gOiB0aGlzW3Byb3BdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cbkVsZW1lbnQuZGVmYXVsdHMgPSB7fTtcbkVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHVuZGVmaW5lZDtcblxuY29uc3QgZm9ybWF0dGVycyA9IHtcbiAgdmFsdWVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiAnJyArIHZhbHVlO1xuICB9LFxuICBudW1lcmljKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG4gICAgaWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcwJztcbiAgICB9XG4gICAgY29uc3QgbG9jYWxlID0gdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZTtcbiAgICBsZXQgbm90YXRpb247XG4gICAgbGV0IGRlbHRhID0gdGlja1ZhbHVlO1xuICAgIGlmICh0aWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBtYXhUaWNrID0gTWF0aC5tYXgoTWF0aC5hYnModGlja3NbMF0udmFsdWUpLCBNYXRoLmFicyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSkpO1xuICAgICAgaWYgKG1heFRpY2sgPCAxZS00IHx8IG1heFRpY2sgPiAxZSsxNSkge1xuICAgICAgICBub3RhdGlvbiA9ICdzY2llbnRpZmljJztcbiAgICAgIH1cbiAgICAgIGRlbHRhID0gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcyk7XG4gICAgfVxuICAgIGNvbnN0IGxvZ0RlbHRhID0gbG9nMTAoTWF0aC5hYnMoZGVsdGEpKTtcbiAgICBjb25zdCBudW1EZWNpbWFsID0gTWF0aC5tYXgoTWF0aC5taW4oLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKSwgMjApLCAwKTtcbiAgICBjb25zdCBvcHRpb25zID0ge25vdGF0aW9uLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IG51bURlY2ltYWwsIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbH07XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHRpY2tWYWx1ZSwgbG9jYWxlLCBvcHRpb25zKTtcbiAgfSxcbiAgbG9nYXJpdGhtaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnO1xuICAgIH1cbiAgICBjb25zdCByZW1haW4gPSB0aWNrVmFsdWUgLyAoTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAodGlja1ZhbHVlKSkpKTtcbiAgICBpZiAocmVtYWluID09PSAxIHx8IHJlbWFpbiA9PT0gMiB8fCByZW1haW4gPT09IDUpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLm51bWVyaWMuY2FsbCh0aGlzLCB0aWNrVmFsdWUsIGluZGV4LCB0aWNrcyk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxufTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpIHtcbiAgbGV0IGRlbHRhID0gdGlja3MubGVuZ3RoID4gMyA/IHRpY2tzWzJdLnZhbHVlIC0gdGlja3NbMV0udmFsdWUgOiB0aWNrc1sxXS52YWx1ZSAtIHRpY2tzWzBdLnZhbHVlO1xuICBpZiAoTWF0aC5hYnMoZGVsdGEpID49IDEgJiYgdGlja1ZhbHVlICE9PSBNYXRoLmZsb29yKHRpY2tWYWx1ZSkpIHtcbiAgICBkZWx0YSA9IHRpY2tWYWx1ZSAtIE1hdGguZmxvb3IodGlja1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG52YXIgVGlja3MgPSB7Zm9ybWF0dGVyc307XG5cbmRlZmF1bHRzLnNldCgnc2NhbGUnLCB7XG4gIGRpc3BsYXk6IHRydWUsXG4gIG9mZnNldDogZmFsc2UsXG4gIHJldmVyc2U6IGZhbHNlLFxuICBiZWdpbkF0WmVybzogZmFsc2UsXG4gIGJvdW5kczogJ3RpY2tzJyxcbiAgZ3JhY2U6IDAsXG4gIGdyaWQ6IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGxpbmVXaWR0aDogMSxcbiAgICBkcmF3Qm9yZGVyOiB0cnVlLFxuICAgIGRyYXdPbkNoYXJ0QXJlYTogdHJ1ZSxcbiAgICBkcmF3VGlja3M6IHRydWUsXG4gICAgdGlja0xlbmd0aDogOCxcbiAgICB0aWNrV2lkdGg6IChfY3R4LCBvcHRpb25zKSA9PiBvcHRpb25zLmxpbmVXaWR0aCxcbiAgICB0aWNrQ29sb3I6IChfY3R4LCBvcHRpb25zKSA9PiBvcHRpb25zLmNvbG9yLFxuICAgIG9mZnNldDogZmFsc2UsXG4gICAgYm9yZGVyRGFzaDogW10sXG4gICAgYm9yZGVyRGFzaE9mZnNldDogMC4wLFxuICAgIGJvcmRlcldpZHRoOiAxXG4gIH0sXG4gIHRpdGxlOiB7XG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgdGV4dDogJycsXG4gICAgcGFkZGluZzoge1xuICAgICAgdG9wOiA0LFxuICAgICAgYm90dG9tOiA0XG4gICAgfVxuICB9LFxuICB0aWNrczoge1xuICAgIG1pblJvdGF0aW9uOiAwLFxuICAgIG1heFJvdGF0aW9uOiA1MCxcbiAgICBtaXJyb3I6IGZhbHNlLFxuICAgIHRleHRTdHJva2VXaWR0aDogMCxcbiAgICB0ZXh0U3Ryb2tlQ29sb3I6ICcnLFxuICAgIHBhZGRpbmc6IDMsXG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBhdXRvU2tpcDogdHJ1ZSxcbiAgICBhdXRvU2tpcFBhZGRpbmc6IDMsXG4gICAgbGFiZWxPZmZzZXQ6IDAsXG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMudmFsdWVzLFxuICAgIG1pbm9yOiB7fSxcbiAgICBtYWpvcjoge30sXG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGNyb3NzQWxpZ246ICduZWFyJyxcbiAgICBzaG93TGFiZWxCYWNrZHJvcDogZmFsc2UsXG4gICAgYmFja2Ryb3BDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSknLFxuICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgfVxufSk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGlja3MnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUuZ3JpZCcsICdjb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ncmlkJywgJ2JvcmRlckNvbG9yJywgJycsICdib3JkZXJDb2xvcicpO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLnRpdGxlJywgJ2NvbG9yJywgJycsICdjb2xvcicpO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlJywge1xuICBfZmFsbGJhY2s6IGZhbHNlLFxuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ2JlZm9yZScpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2FmdGVyJykgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyAmJiBuYW1lICE9PSAncGFyc2VyJyxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAndGlja0JvcmRlckRhc2gnLFxufSk7XG5kZWZhdWx0cy5kZXNjcmliZSgnc2NhbGVzJywge1xuICBfZmFsbGJhY2s6ICdzY2FsZScsXG59KTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZS50aWNrcycsIHtcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyAmJiBuYW1lICE9PSAnY2FsbGJhY2snLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycsXG59KTtcblxuZnVuY3Rpb24gYXV0b1NraXAoc2NhbGUsIHRpY2tzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gc2NhbGUub3B0aW9ucy50aWNrcztcbiAgY29uc3QgdGlja3NMaW1pdCA9IHRpY2tPcHRzLm1heFRpY2tzTGltaXQgfHwgZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpO1xuICBjb25zdCBtYWpvckluZGljZXMgPSB0aWNrT3B0cy5tYWpvci5lbmFibGVkID8gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSA6IFtdO1xuICBjb25zdCBudW1NYWpvckluZGljZXMgPSBtYWpvckluZGljZXMubGVuZ3RoO1xuICBjb25zdCBmaXJzdCA9IG1ham9ySW5kaWNlc1swXTtcbiAgY29uc3QgbGFzdCA9IG1ham9ySW5kaWNlc1tudW1NYWpvckluZGljZXMgLSAxXTtcbiAgY29uc3QgbmV3VGlja3MgPSBbXTtcbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IHRpY2tzTGltaXQpIHtcbiAgICBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBudW1NYWpvckluZGljZXMgLyB0aWNrc0xpbWl0KTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cbiAgY29uc3Qgc3BhY2luZyA9IGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCk7XG4gIGlmIChudW1NYWpvckluZGljZXMgPiAwKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgY29uc3QgYXZnTWFqb3JTcGFjaW5nID0gbnVtTWFqb3JJbmRpY2VzID4gMSA/IE1hdGgucm91bmQoKGxhc3QgLSBmaXJzdCkgLyAobnVtTWFqb3JJbmRpY2VzIC0gMSkpIDogbnVsbDtcbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gMCA6IGZpcnN0IC0gYXZnTWFqb3JTcGFjaW5nLCBmaXJzdCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG51bU1ham9ySW5kaWNlcyAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvckluZGljZXNbaV0sIG1ham9ySW5kaWNlc1tpICsgMV0pO1xuICAgIH1cbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbGFzdCwgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gdGlja3MubGVuZ3RoIDogbGFzdCArIGF2Z01ham9yU3BhY2luZyk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG4gIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nKTtcbiAgcmV0dXJuIG5ld1RpY2tzO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpIHtcbiAgY29uc3Qgb2Zmc2V0ID0gc2NhbGUub3B0aW9ucy5vZmZzZXQ7XG4gIGNvbnN0IHRpY2tMZW5ndGggPSBzY2FsZS5fdGlja1NpemUoKTtcbiAgY29uc3QgbWF4U2NhbGUgPSBzY2FsZS5fbGVuZ3RoIC8gdGlja0xlbmd0aCArIChvZmZzZXQgPyAwIDogMSk7XG4gIGNvbnN0IG1heENoYXJ0ID0gc2NhbGUuX21heExlbmd0aCAvIHRpY2tMZW5ndGg7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWluKG1heFNjYWxlLCBtYXhDaGFydCkpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KSB7XG4gIGNvbnN0IGV2ZW5NYWpvclNwYWNpbmcgPSBnZXRFdmVuU3BhY2luZyhtYWpvckluZGljZXMpO1xuICBjb25zdCBzcGFjaW5nID0gdGlja3MubGVuZ3RoIC8gdGlja3NMaW1pdDtcbiAgaWYgKCFldmVuTWFqb3JTcGFjaW5nKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xuICB9XG4gIGNvbnN0IGZhY3RvcnMgPSBfZmFjdG9yaXplKGV2ZW5NYWpvclNwYWNpbmcpO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGZhY3RvcnMubGVuZ3RoIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgIGNvbnN0IGZhY3RvciA9IGZhY3RvcnNbaV07XG4gICAgaWYgKGZhY3RvciA+IHNwYWNpbmcpIHtcbiAgICAgIHJldHVybiBmYWN0b3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbn1cbmZ1bmN0aW9uIGdldE1ham9ySW5kaWNlcyh0aWNrcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBpZiAodGlja3NbaV0ubWFqb3IpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgc3BhY2luZykge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgbmV4dCA9IG1ham9ySW5kaWNlc1swXTtcbiAgbGV0IGk7XG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gbWFqb3JJbmRpY2VzW2NvdW50ICogc3BhY2luZ107XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JTdGFydCwgbWFqb3JFbmQpIHtcbiAgY29uc3Qgc3RhcnQgPSB2YWx1ZU9yRGVmYXVsdChtYWpvclN0YXJ0LCAwKTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4odmFsdWVPckRlZmF1bHQobWFqb3JFbmQsIHRpY2tzLmxlbmd0aCksIHRpY2tzLmxlbmd0aCk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBsZW5ndGgsIGksIG5leHQ7XG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGlmIChtYWpvckVuZCkge1xuICAgIGxlbmd0aCA9IG1ham9yRW5kIC0gbWFqb3JTdGFydDtcbiAgICBzcGFjaW5nID0gbGVuZ3RoIC8gTWF0aC5mbG9vcihsZW5ndGggLyBzcGFjaW5nKTtcbiAgfVxuICBuZXh0ID0gc3RhcnQ7XG4gIHdoaWxlIChuZXh0IDwgMCkge1xuICAgIGNvdW50Kys7XG4gICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICB9XG4gIGZvciAoaSA9IE1hdGgubWF4KHN0YXJ0LCAwKTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEV2ZW5TcGFjaW5nKGFycikge1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSwgZGlmZjtcbiAgaWYgKGxlbiA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChkaWZmID0gYXJyWzBdLCBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFycltpXSAtIGFycltpIC0gMV0gIT09IGRpZmYpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmY7XG59XG5cbmNvbnN0IHJldmVyc2VBbGlnbiA9IChhbGlnbikgPT4gYWxpZ24gPT09ICdsZWZ0JyA/ICdyaWdodCcgOiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6IGFsaWduO1xuY29uc3Qgb2Zmc2V0RnJvbUVkZ2UgPSAoc2NhbGUsIGVkZ2UsIG9mZnNldCkgPT4gZWRnZSA9PT0gJ3RvcCcgfHwgZWRnZSA9PT0gJ2xlZnQnID8gc2NhbGVbZWRnZV0gKyBvZmZzZXQgOiBzY2FsZVtlZGdlXSAtIG9mZnNldDtcbmZ1bmN0aW9uIHNhbXBsZShhcnIsIG51bUl0ZW1zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBpbmNyZW1lbnQgPSBhcnIubGVuZ3RoIC8gbnVtSXRlbXM7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGxldCBpID0gMDtcbiAgZm9yICg7IGkgPCBsZW47IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgcmVzdWx0LnB1c2goYXJyW01hdGguZmxvb3IoaSldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0UGl4ZWxGb3JHcmlkTGluZShzY2FsZSwgaW5kZXgsIG9mZnNldEdyaWRMaW5lcykge1xuICBjb25zdCBsZW5ndGggPSBzY2FsZS50aWNrcy5sZW5ndGg7XG4gIGNvbnN0IHZhbGlkSW5kZXggPSBNYXRoLm1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gIGNvbnN0IHN0YXJ0ID0gc2NhbGUuX3N0YXJ0UGl4ZWw7XG4gIGNvbnN0IGVuZCA9IHNjYWxlLl9lbmRQaXhlbDtcbiAgY29uc3QgZXBzaWxvbiA9IDFlLTY7XG4gIGxldCBsaW5lVmFsdWUgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCk7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChvZmZzZXRHcmlkTGluZXMpIHtcbiAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICBvZmZzZXQgPSBNYXRoLm1heChsaW5lVmFsdWUgLSBzdGFydCwgZW5kIC0gbGluZVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBvZmZzZXQgPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCAtIDEpKSAvIDI7XG4gICAgfVxuICAgIGxpbmVWYWx1ZSArPSB2YWxpZEluZGV4IDwgaW5kZXggPyBvZmZzZXQgOiAtb2Zmc2V0O1xuICAgIGlmIChsaW5lVmFsdWUgPCBzdGFydCAtIGVwc2lsb24gfHwgbGluZVZhbHVlID4gZW5kICsgZXBzaWxvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGluZVZhbHVlO1xufVxuZnVuY3Rpb24gZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpIHtcbiAgZWFjaChjYWNoZXMsIChjYWNoZSkgPT4ge1xuICAgIGNvbnN0IGdjID0gY2FjaGUuZ2M7XG4gICAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICAgIGxldCBpO1xuICAgIGlmIChnY0xlbiA+IGxlbmd0aCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyArK2kpIHtcbiAgICAgICAgZGVsZXRlIGNhY2hlLmRhdGFbZ2NbaV1dO1xuICAgICAgfVxuICAgICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5kcmF3VGlja3MgPyBvcHRpb25zLnRpY2tMZW5ndGggOiAwO1xufVxuZnVuY3Rpb24gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucywgZmFsbGJhY2spIHtcbiAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBmb250ID0gdG9Gb250KG9wdGlvbnMuZm9udCwgZmFsbGJhY2spO1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIGNvbnN0IGxpbmVzID0gaXNBcnJheShvcHRpb25zLnRleHQpID8gb3B0aW9ucy50ZXh0Lmxlbmd0aCA6IDE7XG4gIHJldHVybiAobGluZXMgKiBmb250LmxpbmVIZWlnaHQpICsgcGFkZGluZy5oZWlnaHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVTY2FsZUNvbnRleHQocGFyZW50LCBzY2FsZSkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBzY2FsZSxcbiAgICB0eXBlOiAnc2NhbGUnXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVGlja0NvbnRleHQocGFyZW50LCBpbmRleCwgdGljaykge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICB0aWNrLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICd0aWNrJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSB7XG4gIGxldCByZXQgPSBfdG9MZWZ0UmlnaHRDZW50ZXIoYWxpZ24pO1xuICBpZiAoKHJldmVyc2UgJiYgcG9zaXRpb24gIT09ICdyaWdodCcpIHx8ICghcmV2ZXJzZSAmJiBwb3NpdGlvbiA9PT0gJ3JpZ2h0JykpIHtcbiAgICByZXQgPSByZXZlcnNlQWxpZ24ocmV0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gdGl0bGVBcmdzKHNjYWxlLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbikge1xuICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBjaGFydH0gPSBzY2FsZTtcbiAgY29uc3Qge2NoYXJ0QXJlYSwgc2NhbGVzfSA9IGNoYXJ0O1xuICBsZXQgcm90YXRpb24gPSAwO1xuICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICBpZiAoc2NhbGUuaXNIb3Jpem9udGFsKCkpIHtcbiAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICB0aXRsZVkgPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpICsgaGVpZ2h0IC0gb2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICB0aXRsZVkgPSAoY2hhcnRBcmVhLmJvdHRvbSArIGNoYXJ0QXJlYS50b3ApIC8gMiArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVZID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVYID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSAtIHdpZHRoICsgb2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICB0aXRsZVggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMiAtIHdpZHRoICsgb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZVggPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgfVxuICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBib3R0b20sIHRvcCk7XG4gICAgcm90YXRpb24gPSBwb3NpdGlvbiA9PT0gJ2xlZnQnID8gLUhBTEZfUEkgOiBIQUxGX1BJO1xuICB9XG4gIHJldHVybiB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn07XG59XG5jbGFzcyBTY2FsZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaWQgPSBjZmcuaWQ7XG4gICAgdGhpcy50eXBlID0gY2ZnLnR5cGU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY3R4ID0gY2ZnLmN0eDtcbiAgICB0aGlzLmNoYXJ0ID0gY2ZnLmNoYXJ0O1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH07XG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdUb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nQm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ0xlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nUmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yYW5nZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpY2tzID0gW107XG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSAwO1xuICAgIHRoaXMuX2xvbmdlc3RUZXh0Q2FjaGUgPSB7fTtcbiAgICB0aGlzLl9zdGFydFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2VuZFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VyTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3VzZXJNaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IDA7XG4gICAgdGhpcy5fYm9yZGVyVmFsdWUgPSAwO1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICB0aGlzLmF4aXMgPSBvcHRpb25zLmF4aXM7XG4gICAgdGhpcy5fdXNlck1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5taW4pO1xuICAgIHRoaXMuX3VzZXJNYXggPSB0aGlzLnBhcnNlKG9wdGlvbnMubWF4KTtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWluKTtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWF4KTtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgcmV0dXJuIHJhdztcbiAgfVxuICBnZXRVc2VyQm91bmRzKCkge1xuICAgIGxldCB7X3VzZXJNaW4sIF91c2VyTWF4LCBfc3VnZ2VzdGVkTWluLCBfc3VnZ2VzdGVkTWF4fSA9IHRoaXM7XG4gICAgX3VzZXJNaW4gPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3VzZXJNYXggPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1pbiA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWluLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIF9zdWdnZXN0ZWRNYXggPSBmaW5pdGVPckRlZmF1bHQoX3N1Z2dlc3RlZE1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIF9zdWdnZXN0ZWRNaW4pLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIF9zdWdnZXN0ZWRNYXgpLFxuICAgICAgbWluRGVmaW5lZDogaXNOdW1iZXJGaW5pdGUoX3VzZXJNaW4pLFxuICAgICAgbWF4RGVmaW5lZDogaXNOdW1iZXJGaW5pdGUoX3VzZXJNYXgpXG4gICAgfTtcbiAgfVxuICBnZXRNaW5NYXgoY2FuU3RhY2spIHtcbiAgICBsZXQge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCByYW5nZTtcbiAgICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkKSB7XG4gICAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgICB9XG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHJhbmdlID0gbWV0YXNbaV0uY29udHJvbGxlci5nZXRNaW5NYXgodGhpcywgY2FuU3RhY2spO1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcmFuZ2UubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJhbmdlLm1heCk7XG4gICAgICB9XG4gICAgfVxuICAgIG1pbiA9IG1heERlZmluZWQgJiYgbWluID4gbWF4ID8gbWF4IDogbWluO1xuICAgIG1heCA9IG1pbkRlZmluZWQgJiYgbWluID4gbWF4ID8gbWluIDogbWF4O1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChtaW4sIGZpbml0ZU9yRGVmYXVsdChtYXgsIG1pbikpLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQobWF4LCBmaW5pdGVPckRlZmF1bHQobWluLCBtYXgpKVxuICAgIH07XG4gIH1cbiAgZ2V0UGFkZGluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5wYWRkaW5nTGVmdCB8fCAwLFxuICAgICAgdG9wOiB0aGlzLnBhZGRpbmdUb3AgfHwgMCxcbiAgICAgIHJpZ2h0OiB0aGlzLnBhZGRpbmdSaWdodCB8fCAwLFxuICAgICAgYm90dG9tOiB0aGlzLnBhZGRpbmdCb3R0b20gfHwgMFxuICAgIH07XG4gIH1cbiAgZ2V0VGlja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlja3M7XG4gIH1cbiAgZ2V0TGFiZWxzKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sYWJlbHMgfHwgKHRoaXMuaXNIb3Jpem9udGFsKCkgPyBkYXRhLnhMYWJlbHMgOiBkYXRhLnlMYWJlbHMpIHx8IGRhdGEubGFiZWxzIHx8IFtdO1xuICB9XG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSBmYWxzZTtcbiAgfVxuICBiZWZvcmVVcGRhdGUoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuICAgIGNvbnN0IHtiZWdpbkF0WmVybywgZ3JhY2UsIHRpY2tzOiB0aWNrT3B0c30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRpY2tPcHRzLnNhbXBsZVNpemU7XG4gICAgdGhpcy5iZWZvcmVVcGRhdGUoKTtcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IG1hcmdpbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH0sIG1hcmdpbnMpO1xuICAgIHRoaXMudGlja3MgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgIHRoaXMuX2dyaWRMaW5lSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgPyB0aGlzLndpZHRoICsgbWFyZ2lucy5sZWZ0ICsgbWFyZ2lucy5yaWdodFxuICAgICAgOiB0aGlzLmhlaWdodCArIG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b207XG4gICAgaWYgKCF0aGlzLl9kYXRhTGltaXRzQ2FjaGVkKSB7XG4gICAgICB0aGlzLmJlZm9yZURhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuZGV0ZXJtaW5lRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5hZnRlckRhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuX3JhbmdlID0gX2FkZEdyYWNlKHRoaXMsIGdyYWNlLCBiZWdpbkF0WmVybyk7XG4gICAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5iZWZvcmVCdWlsZFRpY2tzKCk7XG4gICAgdGhpcy50aWNrcyA9IHRoaXMuYnVpbGRUaWNrcygpIHx8IFtdO1xuICAgIHRoaXMuYWZ0ZXJCdWlsZFRpY2tzKCk7XG4gICAgY29uc3Qgc2FtcGxpbmdFbmFibGVkID0gc2FtcGxlU2l6ZSA8IHRoaXMudGlja3MubGVuZ3RoO1xuICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHNhbXBsaW5nRW5hYmxlZCA/IHNhbXBsZSh0aGlzLnRpY2tzLCBzYW1wbGVTaXplKSA6IHRoaXMudGlja3MpO1xuICAgIHRoaXMuY29uZmlndXJlKCk7XG4gICAgdGhpcy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgdGhpcy5jYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgdGhpcy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiAodGlja09wdHMuYXV0b1NraXAgfHwgdGlja09wdHMuc291cmNlID09PSAnYXV0bycpKSB7XG4gICAgICB0aGlzLnRpY2tzID0gYXV0b1NraXAodGhpcywgdGhpcy50aWNrcyk7XG4gICAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHNhbXBsaW5nRW5hYmxlZCkge1xuICAgICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHModGhpcy50aWNrcyk7XG4gICAgfVxuICAgIHRoaXMuYmVmb3JlRml0KCk7XG4gICAgdGhpcy5maXQoKTtcbiAgICB0aGlzLmFmdGVyRml0KCk7XG4gICAgdGhpcy5hZnRlclVwZGF0ZSgpO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBsZXQgcmV2ZXJzZVBpeGVscyA9IHRoaXMub3B0aW9ucy5yZXZlcnNlO1xuICAgIGxldCBzdGFydFBpeGVsLCBlbmRQaXhlbDtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgc3RhcnRQaXhlbCA9IHRoaXMubGVmdDtcbiAgICAgIGVuZFBpeGVsID0gdGhpcy5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQaXhlbCA9IHRoaXMudG9wO1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLmJvdHRvbTtcbiAgICAgIHJldmVyc2VQaXhlbHMgPSAhcmV2ZXJzZVBpeGVscztcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRQaXhlbCA9IHN0YXJ0UGl4ZWw7XG4gICAgdGhpcy5fZW5kUGl4ZWwgPSBlbmRQaXhlbDtcbiAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gcmV2ZXJzZVBpeGVscztcbiAgICB0aGlzLl9sZW5ndGggPSBlbmRQaXhlbCAtIHN0YXJ0UGl4ZWw7XG4gICAgdGhpcy5fYWxpZ25Ub1BpeGVscyA9IHRoaXMub3B0aW9ucy5hbGlnblRvUGl4ZWxzO1xuICB9XG4gIGFmdGVyVXBkYXRlKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuICBiZWZvcmVTZXREaW1lbnNpb25zKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gMDtcbiAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgdGhpcy50b3AgPSAwO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nVG9wID0gMDtcbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nQm90dG9tID0gMDtcbiAgfVxuICBhZnRlclNldERpbWVuc2lvbnMoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuICBfY2FsbEhvb2tzKG5hbWUpIHtcbiAgICB0aGlzLmNoYXJ0Lm5vdGlmeVBsdWdpbnMobmFtZSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9uc1tuYW1lXSwgW3RoaXNdKTtcbiAgfVxuICBiZWZvcmVEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlRGF0YUxpbWl0cycpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7fVxuICBhZnRlckRhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckRhdGFMaW1pdHMnKTtcbiAgfVxuICBiZWZvcmVCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlQnVpbGRUaWNrcycpO1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGFmdGVyQnVpbGRUaWNrcygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyQnVpbGRUaWNrcycpO1xuICB9XG4gIGJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSBjYWxsYmFjayh0aWNrT3B0cy5jYWxsYmFjaywgW3RpY2sudmFsdWUsIGksIHRpY2tzXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcbiAgfVxuICBiZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xuICB9XG4gIGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgbnVtVGlja3MgPSB0aGlzLnRpY2tzLmxlbmd0aDtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDA7XG4gICAgY29uc3QgbWF4Um90YXRpb24gPSB0aWNrT3B0cy5tYXhSb3RhdGlvbjtcbiAgICBsZXQgbGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgIGxldCB0aWNrV2lkdGgsIG1heEhlaWdodCwgbWF4TGFiZWxEaWFnb25hbDtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICF0aWNrT3B0cy5kaXNwbGF5IHx8IG1pblJvdGF0aW9uID49IG1heFJvdGF0aW9uIHx8IG51bVRpY2tzIDw9IDEgfHwgIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IG1heExhYmVsV2lkdGggPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcbiAgICBjb25zdCBtYXhMYWJlbEhlaWdodCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQ7XG4gICAgY29uc3QgbWF4V2lkdGggPSBfbGltaXRWYWx1ZSh0aGlzLmNoYXJ0LndpZHRoIC0gbWF4TGFiZWxXaWR0aCwgMCwgdGhpcy5tYXhXaWR0aCk7XG4gICAgdGlja1dpZHRoID0gb3B0aW9ucy5vZmZzZXQgPyB0aGlzLm1heFdpZHRoIC8gbnVtVGlja3MgOiBtYXhXaWR0aCAvIChudW1UaWNrcyAtIDEpO1xuICAgIGlmIChtYXhMYWJlbFdpZHRoICsgNiA+IHRpY2tXaWR0aCkge1xuICAgICAgdGlja1dpZHRoID0gbWF4V2lkdGggLyAobnVtVGlja3MgLSAob3B0aW9ucy5vZmZzZXQgPyAwLjUgOiAxKSk7XG4gICAgICBtYXhIZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZClcblx0XHRcdFx0LSB0aWNrT3B0cy5wYWRkaW5nIC0gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucy50aXRsZSwgdGhpcy5jaGFydC5vcHRpb25zLmZvbnQpO1xuICAgICAgbWF4TGFiZWxEaWFnb25hbCA9IE1hdGguc3FydChtYXhMYWJlbFdpZHRoICogbWF4TGFiZWxXaWR0aCArIG1heExhYmVsSGVpZ2h0ICogbWF4TGFiZWxIZWlnaHQpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IHRvRGVncmVlcyhNYXRoLm1pbihcbiAgICAgICAgTWF0aC5hc2luKF9saW1pdFZhbHVlKChsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgNikgLyB0aWNrV2lkdGgsIC0xLCAxKSksXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpIC0gTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heExhYmVsSGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKVxuICAgICAgKSk7XG4gICAgICBsYWJlbFJvdGF0aW9uID0gTWF0aC5tYXgobWluUm90YXRpb24sIE1hdGgubWluKG1heFJvdGF0aW9uLCBsYWJlbFJvdGF0aW9uKSk7XG4gICAgfVxuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XG4gIH1cbiAgYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgYmVmb3JlRml0KCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFt0aGlzXSk7XG4gIH1cbiAgZml0KCkge1xuICAgIGNvbnN0IG1pblNpemUgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgY29uc3Qge2NoYXJ0LCBvcHRpb25zOiB7dGlja3M6IHRpY2tPcHRzLCB0aXRsZTogdGl0bGVPcHRzLCBncmlkOiBncmlkT3B0c319ID0gdGhpcztcbiAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5faXNWaXNpYmxlKCk7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBpZiAoZGlzcGxheSkge1xuICAgICAgY29uc3QgdGl0bGVIZWlnaHQgPSBnZXRUaXRsZUhlaWdodCh0aXRsZU9wdHMsIGNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIG1pblNpemUud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgdGhpcy50aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qge2ZpcnN0LCBsYXN0LCB3aWRlc3QsIGhpZ2hlc3R9ID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgICAgICBjb25zdCB0aWNrUGFkZGluZyA9IHRpY2tPcHRzLnBhZGRpbmcgKiAyO1xuICAgICAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gdGlja09wdHMubWlycm9yID8gMCA6IHNpbiAqIHdpZGVzdC53aWR0aCArIGNvcyAqIGhpZ2hlc3QuaGVpZ2h0O1xuICAgICAgICAgIG1pblNpemUuaGVpZ2h0ID0gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIG1pblNpemUuaGVpZ2h0ICsgbGFiZWxIZWlnaHQgKyB0aWNrUGFkZGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBjb3MgKiB3aWRlc3Qud2lkdGggKyBzaW4gKiBoaWdoZXN0LmhlaWdodDtcbiAgICAgICAgICBtaW5TaXplLndpZHRoID0gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhYmVsV2lkdGggKyB0aWNrUGFkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlUGFkZGluZyhmaXJzdCwgbGFzdCwgc2luLCBjb3MpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9oYW5kbGVNYXJnaW5zKCk7XG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LndpZHRoIC0gdGhpcy5fbWFyZ2lucy5sZWZ0IC0gdGhpcy5fbWFyZ2lucy5yaWdodDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSBtaW5TaXplLndpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLl9sZW5ndGggPSBjaGFydC5oZWlnaHQgLSB0aGlzLl9tYXJnaW5zLnRvcCAtIHRoaXMuX21hcmdpbnMuYm90dG9tO1xuICAgIH1cbiAgfVxuICBfY2FsY3VsYXRlUGFkZGluZyhmaXJzdCwgbGFzdCwgc2luLCBjb3MpIHtcbiAgICBjb25zdCB7dGlja3M6IHthbGlnbiwgcGFkZGluZ30sIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBpc1JvdGF0ZWQgPSB0aGlzLmxhYmVsUm90YXRpb24gIT09IDA7XG4gICAgY29uc3QgbGFiZWxzQmVsb3dUaWNrcyA9IHBvc2l0aW9uICE9PSAndG9wJyAmJiB0aGlzLmF4aXMgPT09ICd4JztcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgY29uc3Qgb2Zmc2V0TGVmdCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKDApIC0gdGhpcy5sZWZ0O1xuICAgICAgY29uc3Qgb2Zmc2V0UmlnaHQgPSB0aGlzLnJpZ2h0IC0gdGhpcy5nZXRQaXhlbEZvclRpY2sodGhpcy50aWNrcy5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBwYWRkaW5nTGVmdCA9IDA7XG4gICAgICBsZXQgcGFkZGluZ1JpZ2h0ID0gMDtcbiAgICAgIGlmIChpc1JvdGF0ZWQpIHtcbiAgICAgICAgaWYgKGxhYmVsc0JlbG93VGlja3MpIHtcbiAgICAgICAgICBwYWRkaW5nTGVmdCA9IGNvcyAqIGZpcnN0LndpZHRoO1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IHNpbiAqIGxhc3QuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gc2luICogZmlyc3QuaGVpZ2h0O1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IGNvcyAqIGxhc3Qud2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWRkaW5nTGVmdCA9IGZpcnN0LndpZHRoIC8gMjtcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aCAvIDI7XG4gICAgICB9XG4gICAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgoKHBhZGRpbmdMZWZ0IC0gb2Zmc2V0TGVmdCArIHBhZGRpbmcpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gb2Zmc2V0TGVmdCksIDApO1xuICAgICAgdGhpcy5wYWRkaW5nUmlnaHQgPSBNYXRoLm1heCgocGFkZGluZ1JpZ2h0IC0gb2Zmc2V0UmlnaHQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldFJpZ2h0KSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQgLyAyO1xuICAgICAgbGV0IHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQgLyAyO1xuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdUb3AgPSAwO1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0O1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3AgKyBwYWRkaW5nO1xuICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gcGFkZGluZ0JvdHRvbSArIHBhZGRpbmc7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVNYXJnaW5zKCkge1xuICAgIGlmICh0aGlzLl9tYXJnaW5zKSB7XG4gICAgICB0aGlzLl9tYXJnaW5zLmxlZnQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdMZWZ0LCB0aGlzLl9tYXJnaW5zLmxlZnQpO1xuICAgICAgdGhpcy5fbWFyZ2lucy50b3AgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdUb3AsIHRoaXMuX21hcmdpbnMudG9wKTtcbiAgICAgIHRoaXMuX21hcmdpbnMucmlnaHQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdSaWdodCwgdGhpcy5fbWFyZ2lucy5yaWdodCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLmJvdHRvbSA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0JvdHRvbSwgdGhpcy5fbWFyZ2lucy5ib3R0b20pO1xuICAgIH1cbiAgfVxuICBhZnRlckZpdCgpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJGaXQsIFt0aGlzXSk7XG4gIH1cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHtheGlzLCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgYXhpcyA9PT0gJ3gnO1xuICB9XG4gIGlzRnVsbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mdWxsU2l6ZTtcbiAgfVxuICBfY29udmVydFRpY2tzVG9MYWJlbHModGlja3MpIHtcbiAgICB0aGlzLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuICAgIHRoaXMuZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih0aWNrc1tpXS5sYWJlbCkpIHtcbiAgICAgICAgdGlja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBpbGVuLS07XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuICB9XG4gIF9nZXRMYWJlbFNpemVzKCkge1xuICAgIGxldCBsYWJlbFNpemVzID0gdGhpcy5fbGFiZWxTaXplcztcbiAgICBpZiAoIWxhYmVsU2l6ZXMpIHtcbiAgICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlja3Muc2FtcGxlU2l6ZTtcbiAgICAgIGxldCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgICBpZiAoc2FtcGxlU2l6ZSA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgICB0aWNrcyA9IHNhbXBsZSh0aWNrcywgc2FtcGxlU2l6ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYWJlbFNpemVzID0gbGFiZWxTaXplcyA9IHRoaXMuX2NvbXB1dGVMYWJlbFNpemVzKHRpY2tzLCB0aWNrcy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gbGFiZWxTaXplcztcbiAgfVxuICBfY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIGxlbmd0aCkge1xuICAgIGNvbnN0IHtjdHgsIF9sb25nZXN0VGV4dENhY2hlOiBjYWNoZXN9ID0gdGhpcztcbiAgICBjb25zdCB3aWR0aHMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHRzID0gW107XG4gICAgbGV0IHdpZGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGhpZ2hlc3RMYWJlbFNpemUgPSAwO1xuICAgIGxldCBpLCBqLCBqbGVuLCBsYWJlbCwgdGlja0ZvbnQsIGZvbnRTdHJpbmcsIGNhY2hlLCBsaW5lSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBuZXN0ZWRMYWJlbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIGxhYmVsID0gdGlja3NbaV0ubGFiZWw7XG4gICAgICB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBjdHguZm9udCA9IGZvbnRTdHJpbmcgPSB0aWNrRm9udC5zdHJpbmc7XG4gICAgICBjYWNoZSA9IGNhY2hlc1tmb250U3RyaW5nXSA9IGNhY2hlc1tmb250U3RyaW5nXSB8fCB7ZGF0YToge30sIGdjOiBbXX07XG4gICAgICBsaW5lSGVpZ2h0ID0gdGlja0ZvbnQubGluZUhlaWdodDtcbiAgICAgIHdpZHRoID0gaGVpZ2h0ID0gMDtcbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihsYWJlbCkgJiYgIWlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBsYWJlbCk7XG4gICAgICAgIGhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsYWJlbC5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgICBuZXN0ZWRMYWJlbCA9IGxhYmVsW2pdO1xuICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihuZXN0ZWRMYWJlbCkgJiYgIWlzQXJyYXkobmVzdGVkTGFiZWwpKSB7XG4gICAgICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbmVzdGVkTGFiZWwpO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aWR0aHMucHVzaCh3aWR0aCk7XG4gICAgICBoZWlnaHRzLnB1c2goaGVpZ2h0KTtcbiAgICAgIHdpZGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KHdpZHRoLCB3aWRlc3RMYWJlbFNpemUpO1xuICAgICAgaGlnaGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KGhlaWdodCwgaGlnaGVzdExhYmVsU2l6ZSk7XG4gICAgfVxuICAgIGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKTtcbiAgICBjb25zdCB3aWRlc3QgPSB3aWR0aHMuaW5kZXhPZih3aWRlc3RMYWJlbFNpemUpO1xuICAgIGNvbnN0IGhpZ2hlc3QgPSBoZWlnaHRzLmluZGV4T2YoaGlnaGVzdExhYmVsU2l6ZSk7XG4gICAgY29uc3QgdmFsdWVBdCA9IChpZHgpID0+ICh7d2lkdGg6IHdpZHRoc1tpZHhdIHx8IDAsIGhlaWdodDogaGVpZ2h0c1tpZHhdIHx8IDB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZmlyc3Q6IHZhbHVlQXQoMCksXG4gICAgICBsYXN0OiB2YWx1ZUF0KGxlbmd0aCAtIDEpLFxuICAgICAgd2lkZXN0OiB2YWx1ZUF0KHdpZGVzdCksXG4gICAgICBoaWdoZXN0OiB2YWx1ZUF0KGhpZ2hlc3QpLFxuICAgICAgd2lkdGhzLFxuICAgICAgaGVpZ2h0cyxcbiAgICB9O1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHt9XG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuICBnZXRQaXhlbEZvckRlY2ltYWwoZGVjaW1hbCkge1xuICAgIGlmICh0aGlzLl9yZXZlcnNlUGl4ZWxzKSB7XG4gICAgICBkZWNpbWFsID0gMSAtIGRlY2ltYWw7XG4gICAgfVxuICAgIGNvbnN0IHBpeGVsID0gdGhpcy5fc3RhcnRQaXhlbCArIGRlY2ltYWwgKiB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIF9pbnQxNlJhbmdlKHRoaXMuX2FsaWduVG9QaXhlbHMgPyBfYWxpZ25QaXhlbCh0aGlzLmNoYXJ0LCBwaXhlbCwgMCkgOiBwaXhlbCk7XG4gIH1cbiAgZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IChwaXhlbCAtIHRoaXMuX3N0YXJ0UGl4ZWwpIC8gdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9yZXZlcnNlUGl4ZWxzID8gMSAtIGRlY2ltYWwgOiBkZWNpbWFsO1xuICB9XG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG4gIGdldEJhc2VWYWx1ZSgpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICByZXR1cm4gbWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDpcbiAgICAgIG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XG4gICAgICAwO1xuICB9XG4gIGdldENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3MgfHwgW107XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpbmRleF07XG4gICAgICByZXR1cm4gdGljay4kY29udGV4dCB8fFxuXHRcdFx0XHQodGljay4kY29udGV4dCA9IGNyZWF0ZVRpY2tDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgdGljaykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fFxuXHRcdFx0KHRoaXMuJGNvbnRleHQgPSBjcmVhdGVTY2FsZUNvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMpKTtcbiAgfVxuICBfdGlja1NpemUoKSB7XG4gICAgY29uc3Qgb3B0aW9uVGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgY29uc3Qgcm90ID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3Mocm90KSk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCBwYWRkaW5nID0gb3B0aW9uVGlja3MuYXV0b1NraXBQYWRkaW5nIHx8IDA7XG4gICAgY29uc3QgdyA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLndpZGVzdC53aWR0aCArIHBhZGRpbmcgOiAwO1xuICAgIGNvbnN0IGggPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIHBhZGRpbmcgOiAwO1xuICAgIHJldHVybiB0aGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICA/IGggKiBjb3MgPiB3ICogc2luID8gdyAvIGNvcyA6IGggLyBzaW5cbiAgICAgIDogaCAqIHNpbiA8IHcgKiBjb3MgPyBoIC8gY29zIDogdyAvIHNpbjtcbiAgfVxuICBfaXNWaXNpYmxlKCkge1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLm9wdGlvbnMuZGlzcGxheTtcbiAgICBpZiAoZGlzcGxheSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gISFkaXNwbGF5O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpLmxlbmd0aCA+IDA7XG4gIH1cbiAgX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge2dyaWQsIHBvc2l0aW9ufSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gZ3JpZC5vZmZzZXQ7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3QgdGlja3NMZW5ndGggPSB0aWNrcy5sZW5ndGggKyAob2Zmc2V0ID8gMSA6IDApO1xuICAgIGNvbnN0IHRsID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZCk7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCBib3JkZXJPcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBheGlzV2lkdGggPSBib3JkZXJPcHRzLmRyYXdCb3JkZXIgPyBib3JkZXJPcHRzLmJvcmRlcldpZHRoIDogMDtcbiAgICBjb25zdCBheGlzSGFsZldpZHRoID0gYXhpc1dpZHRoIC8gMjtcbiAgICBjb25zdCBhbGlnbkJvcmRlclZhbHVlID0gZnVuY3Rpb24ocGl4ZWwpIHtcbiAgICAgIHJldHVybiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIGF4aXNXaWR0aCk7XG4gICAgfTtcbiAgICBsZXQgYm9yZGVyVmFsdWUsIGksIGxpbmVWYWx1ZSwgYWxpZ25lZExpbmVWYWx1ZTtcbiAgICBsZXQgdHgxLCB0eTEsIHR4MiwgdHkyLCB4MSwgeTEsIHgyLCB5MjtcbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5ib3R0b20pO1xuICAgICAgdHkxID0gdGhpcy5ib3R0b20gLSB0bDtcbiAgICAgIHR5MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHkxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEudG9wKSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLnRvcCk7XG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmJvdHRvbSkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHkyID0gdGhpcy50b3AgKyB0bDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLnJpZ2h0KTtcbiAgICAgIHR4MSA9IHRoaXMucmlnaHQgLSB0bDtcbiAgICAgIHR4MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEubGVmdCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMubGVmdCk7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5yaWdodCkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdGhpcy5sZWZ0ICsgdGw7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyICsgMC41KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0eTEgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IHR4MSAtIHRsO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBsaW1pdCA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCwgdGlja3NMZW5ndGgpO1xuICAgIGNvbnN0IHN0ZXAgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwodGlja3NMZW5ndGggLyBsaW1pdCkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aWNrc0xlbmd0aDsgaSArPSBzdGVwKSB7XG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaSkpO1xuICAgICAgY29uc3QgbGluZVdpZHRoID0gb3B0c0F0SW5kZXgubGluZVdpZHRoO1xuICAgICAgY29uc3QgbGluZUNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBib3JkZXJEYXNoID0gZ3JpZC5ib3JkZXJEYXNoIHx8IFtdO1xuICAgICAgY29uc3QgYm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2hPZmZzZXQ7XG4gICAgICBjb25zdCB0aWNrV2lkdGggPSBvcHRzQXRJbmRleC50aWNrV2lkdGg7XG4gICAgICBjb25zdCB0aWNrQ29sb3IgPSBvcHRzQXRJbmRleC50aWNrQ29sb3I7XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoIHx8IFtdO1xuICAgICAgY29uc3QgdGlja0JvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaE9mZnNldDtcbiAgICAgIGxpbmVWYWx1ZSA9IGdldFBpeGVsRm9yR3JpZExpbmUodGhpcywgaSwgb2Zmc2V0KTtcbiAgICAgIGlmIChsaW5lVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGFsaWduZWRMaW5lVmFsdWUgPSBfYWxpZ25QaXhlbChjaGFydCwgbGluZVZhbHVlLCBsaW5lV2lkdGgpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB0eDEgPSB0eDIgPSB4MSA9IHgyID0gYWxpZ25lZExpbmVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5MSA9IHR5MiA9IHkxID0geTIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfVxuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIHR4MSxcbiAgICAgICAgdHkxLFxuICAgICAgICB0eDIsXG4gICAgICAgIHR5MixcbiAgICAgICAgeDEsXG4gICAgICAgIHkxLFxuICAgICAgICB4MixcbiAgICAgICAgeTIsXG4gICAgICAgIHdpZHRoOiBsaW5lV2lkdGgsXG4gICAgICAgIGNvbG9yOiBsaW5lQ29sb3IsXG4gICAgICAgIGJvcmRlckRhc2gsXG4gICAgICAgIGJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgIHRpY2tXaWR0aCxcbiAgICAgICAgdGlja0NvbG9yLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgdGlja0JvcmRlckRhc2hPZmZzZXQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fdGlja3NMZW5ndGggPSB0aWNrc0xlbmd0aDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IGJvcmRlclZhbHVlO1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICBfY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IG9wdGlvblRpY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3Qge2FsaWduLCBjcm9zc0FsaWduLCBwYWRkaW5nLCBtaXJyb3J9ID0gb3B0aW9uVGlja3M7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IGhUaWNrQW5kUGFkZGluZyA9IG1pcnJvciA/IC1wYWRkaW5nIDogdGlja0FuZFBhZGRpbmc7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgdGljaywgbGFiZWwsIHgsIHksIHRleHRBbGlnbiwgcGl4ZWwsIGZvbnQsIGxpbmVIZWlnaHQsIGxpbmVDb3VudCwgdGV4dE9mZnNldDtcbiAgICBsZXQgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgeSA9IHRoaXMuYm90dG9tIC0gaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICB5ID0gdGhpcy50b3AgKyBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XG4gICAgICB0ZXh0QWxpZ24gPSByZXQudGV4dEFsaWduO1xuICAgICAgeCA9IHJldC54O1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHkgPSAoKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIpICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHkgPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH1cbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICB4ID0gKChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyKSAtIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICB4ID0gdGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkudGV4dEFsaWduO1xuICAgIH1cbiAgICBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICBsYWJlbCA9IHRpY2subGFiZWw7XG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IG9wdGlvblRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGkpKTtcbiAgICAgIHBpeGVsID0gdGhpcy5nZXRQaXhlbEZvclRpY2soaSkgKyBvcHRpb25UaWNrcy5sYWJlbE9mZnNldDtcbiAgICAgIGZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgbGluZUhlaWdodCA9IGZvbnQubGluZUhlaWdodDtcbiAgICAgIGxpbmVDb3VudCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwubGVuZ3RoIDogMTtcbiAgICAgIGNvbnN0IGhhbGZDb3VudCA9IGxpbmVDb3VudCAvIDI7XG4gICAgICBjb25zdCBjb2xvciA9IG9wdHNBdEluZGV4LmNvbG9yO1xuICAgICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlQ29sb3I7XG4gICAgICBjb25zdCBzdHJva2VXaWR0aCA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VXaWR0aDtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgeCA9IHBpeGVsO1xuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1saW5lQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC0gbGluZUNvdW50ICogbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICAgIHRleHRPZmZzZXQgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkgPSBwaXhlbDtcbiAgICAgICAgdGV4dE9mZnNldCA9ICgxIC0gbGluZUNvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgfVxuICAgICAgbGV0IGJhY2tkcm9wO1xuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsUGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBsYWJlbFNpemVzLmhlaWdodHNbaV07XG4gICAgICAgIGNvbnN0IHdpZHRoID0gbGFiZWxTaXplcy53aWR0aHNbaV07XG4gICAgICAgIGxldCB0b3AgPSB5ICsgdGV4dE9mZnNldCAtIGxhYmVsUGFkZGluZy50b3A7XG4gICAgICAgIGxldCBsZWZ0ID0geCAtIGxhYmVsUGFkZGluZy5sZWZ0O1xuICAgICAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xuICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQgLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYmFja2Ryb3AgPSB7XG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoICsgbGFiZWxQYWRkaW5nLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICsgbGFiZWxQYWRkaW5nLmhlaWdodCxcbiAgICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvcixcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGZvbnQsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzdHJva2VDb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIHRleHRPZmZzZXQsXG4gICAgICAgIHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgICB0cmFuc2xhdGlvbjogW3gsIHldLFxuICAgICAgICBiYWNrZHJvcCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKSB7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrc30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9XG4gICAgbGV0IGFsaWduID0gJ2NlbnRlcic7XG4gICAgaWYgKHRpY2tzLmFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnZW5kJykge1xuICAgICAgYWxpZ24gPSAncmlnaHQnO1xuICAgIH1cbiAgICByZXR1cm4gYWxpZ247XG4gIH1cbiAgX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiB7Y3Jvc3NBbGlnbiwgbWlycm9yLCBwYWRkaW5nfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCB3aWRlc3QgPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcbiAgICBsZXQgdGV4dEFsaWduO1xuICAgIGxldCB4O1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggKz0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCArPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0IC0gdGlja0FuZFBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCAtPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIHggPSB0aGlzLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyBwYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggLT0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICB4IC09IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSB3aWRlc3QgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCA9IHRoaXMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuIHt0ZXh0QWxpZ24sIHh9O1xuICB9XG4gIF9jb21wdXRlTGFiZWxBcmVhKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGlja3MubWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgcmV0dXJuIHt0b3A6IDAsIGxlZnQ6IHRoaXMubGVmdCwgYm90dG9tOiBjaGFydC5oZWlnaHQsIHJpZ2h0OiB0aGlzLnJpZ2h0fTtcbiAgICB9IGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICByZXR1cm4ge3RvcDogdGhpcy50b3AsIGxlZnQ6IDAsIGJvdHRvbTogdGhpcy5ib3R0b20sIHJpZ2h0OiBjaGFydC53aWR0aH07XG4gICAgfVxuICB9XG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtiYWNrZ3JvdW5kQ29sb3J9LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHR9ID0gdGhpcztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0TGluZVdpZHRoRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhZ3JpZC5kaXNwbGF5KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IGluZGV4ID0gdGlja3MuZmluZEluZGV4KHQgPT4gdC52YWx1ZSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBjb25zdCBvcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgcmV0dXJuIG9wdHMubGluZVdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBkcmF3R3JpZChjaGFydEFyZWEpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9ncmlkTGluZUl0ZW1zIHx8ICh0aGlzLl9ncmlkTGluZUl0ZW1zID0gdGhpcy5fY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgY29uc3QgZHJhd0xpbmUgPSAocDEsIHAyLCBzdHlsZSkgPT4ge1xuICAgICAgaWYgKCFzdHlsZS53aWR0aCB8fCAhc3R5bGUuY29sb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgY3R4LnNldExpbmVEYXNoKHN0eWxlLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gc3R5bGUuYm9yZGVyRGFzaE9mZnNldDtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueSk7XG4gICAgICBjdHgubGluZVRvKHAyLngsIHAyLnkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoZ3JpZC5kcmF3T25DaGFydEFyZWEpIHtcbiAgICAgICAgICBkcmF3TGluZShcbiAgICAgICAgICAgIHt4OiBpdGVtLngxLCB5OiBpdGVtLnkxfSxcbiAgICAgICAgICAgIHt4OiBpdGVtLngyLCB5OiBpdGVtLnkyfSxcbiAgICAgICAgICAgIGl0ZW1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncmlkLmRyYXdUaWNrcykge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0udHgxLCB5OiBpdGVtLnR5MX0sXG4gICAgICAgICAgICB7eDogaXRlbS50eDIsIHk6IGl0ZW0udHkyfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29sb3I6IGl0ZW0udGlja0NvbG9yLFxuICAgICAgICAgICAgICB3aWR0aDogaXRlbS50aWNrV2lkdGgsXG4gICAgICAgICAgICAgIGJvcmRlckRhc2g6IGl0ZW0udGlja0JvcmRlckRhc2gsXG4gICAgICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IGl0ZW0udGlja0JvcmRlckRhc2hPZmZzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyYXdCb3JkZXIoKSB7XG4gICAgY29uc3Qge2NoYXJ0LCBjdHgsIG9wdGlvbnM6IHtncmlkfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGdyaWQuZHJhd0JvcmRlciA/IGJvcmRlck9wdHMuYm9yZGVyV2lkdGggOiAwO1xuICAgIGlmICghYXhpc1dpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3RMaW5lV2lkdGggPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KDApKS5saW5lV2lkdGg7XG4gICAgY29uc3QgYm9yZGVyVmFsdWUgPSB0aGlzLl9ib3JkZXJWYWx1ZTtcbiAgICBsZXQgeDEsIHgyLCB5MSwgeTI7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHgxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMubGVmdCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB4MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnJpZ2h0LCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeTEgPSB5MiA9IGJvcmRlclZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB5MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnRvcCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB5MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmJvdHRvbSwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHgxID0geDIgPSBib3JkZXJWYWx1ZTtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyT3B0cy5ib3JkZXJXaWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJPcHRzLmJvcmRlckNvbG9yO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGRyYXdMYWJlbHMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9uVGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgaWYgKCFvcHRpb25UaWNrcy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLl9jb21wdXRlTGFiZWxBcmVhKCk7XG4gICAgaWYgKGFyZWEpIHtcbiAgICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGFiZWxJdGVtcyB8fCAodGhpcy5fbGFiZWxJdGVtcyA9IHRoaXMuX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gaXRlbS5mb250O1xuICAgICAgY29uc3QgbGFiZWwgPSBpdGVtLmxhYmVsO1xuICAgICAgaWYgKGl0ZW0uYmFja2Ryb3ApIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGl0ZW0uYmFja2Ryb3AuY29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChpdGVtLmJhY2tkcm9wLmxlZnQsIGl0ZW0uYmFja2Ryb3AudG9wLCBpdGVtLmJhY2tkcm9wLndpZHRoLCBpdGVtLmJhY2tkcm9wLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBsZXQgeSA9IGl0ZW0udGV4dE9mZnNldDtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsYWJlbCwgMCwgeSwgdGlja0ZvbnQsIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAoYXJlYSkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge3Bvc2l0aW9uLCB0aXRsZSwgcmV2ZXJzZX19ID0gdGhpcztcbiAgICBpZiAoIXRpdGxlLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZm9udCA9IHRvRm9udCh0aXRsZS5mb250KTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlLnBhZGRpbmcpO1xuICAgIGNvbnN0IGFsaWduID0gdGl0bGUuYWxpZ247XG4gICAgbGV0IG9mZnNldCA9IGZvbnQubGluZUhlaWdodCAvIDI7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBwb3NpdGlvbiA9PT0gJ2NlbnRlcicgfHwgaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy5ib3R0b207XG4gICAgICBpZiAoaXNBcnJheSh0aXRsZS50ZXh0KSkge1xuICAgICAgICBvZmZzZXQgKz0gZm9udC5saW5lSGVpZ2h0ICogKHRpdGxlLnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLnRvcDtcbiAgICB9XG4gICAgY29uc3Qge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259ID0gdGl0bGVBcmdzKHRoaXMsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKTtcbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGUudGV4dCwgMCwgMCwgZm9udCwge1xuICAgICAgY29sb3I6IHRpdGxlLmNvbG9yLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbjogdGl0bGVBbGlnbihhbGlnbiwgcG9zaXRpb24sIHJldmVyc2UpLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxuICAgIH0pO1xuICB9XG4gIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgdGhpcy5kcmF3R3JpZChjaGFydEFyZWEpO1xuICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgdGhpcy5kcmF3TGFiZWxzKGNoYXJ0QXJlYSk7XG4gIH1cbiAgX2xheWVycygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHR6ID0gb3B0cy50aWNrcyAmJiBvcHRzLnRpY2tzLnogfHwgMDtcbiAgICBjb25zdCBneiA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuZ3JpZCAmJiBvcHRzLmdyaWQueiwgLTEpO1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgdGhpcy5kcmF3ICE9PSBTY2FsZS5wcm90b3R5cGUuZHJhdykge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IHR6LFxuICAgICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgICAgdGhpcy5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gW3tcbiAgICAgIHo6IGd6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICAgICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB6OiBneiArIDEsXG4gICAgICBkcmF3OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IHR6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XTtcbiAgfVxuICBnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKSB7XG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBjb25zdCBheGlzSUQgPSB0aGlzLmF4aXMgKyAnQXhpc0lEJztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgICBpZiAobWV0YVtheGlzSURdID09PSB0aGlzLmlkICYmICghdHlwZSB8fCBtZXRhLnR5cGUgPT09IHR5cGUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIF9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGluZGV4KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgIHJldHVybiB0b0ZvbnQob3B0cy5mb250KTtcbiAgfVxuICBfbWF4RGlnaXRzKCkge1xuICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5saW5lSGVpZ2h0O1xuICAgIHJldHVybiAodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodCkgLyBmb250U2l6ZTtcbiAgfVxufVxuXG5jbGFzcyBUeXBlZFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IodHlwZSwgc2NvcGUsIG92ZXJyaWRlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgIHRoaXMuaXRlbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGlzRm9yVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKHRoaXMudHlwZS5wcm90b3R5cGUsIHR5cGUucHJvdG90eXBlKTtcbiAgfVxuICByZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaXRlbSk7XG4gICAgbGV0IHBhcmVudFNjb3BlO1xuICAgIGlmIChpc0lDaGFydENvbXBvbmVudChwcm90bykpIHtcbiAgICAgIHBhcmVudFNjb3BlID0gdGhpcy5yZWdpc3Rlcihwcm90byk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlICsgJy4nICsgaWQ7XG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGFzcyBkb2VzIG5vdCBoYXZlIGlkOiAnICsgaXRlbSk7XG4gICAgfVxuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH1cbiAgICBpdGVtc1tpZF0gPSBpdGVtO1xuICAgIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgICBpZiAodGhpcy5vdmVycmlkZSkge1xuICAgICAgZGVmYXVsdHMub3ZlcnJpZGUoaXRlbS5pZCwgaXRlbS5vdmVycmlkZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGU7XG4gIH1cbiAgZ2V0KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNbaWRdO1xuICB9XG4gIHVucmVnaXN0ZXIoaXRlbSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlO1xuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgZGVsZXRlIGl0ZW1zW2lkXTtcbiAgICB9XG4gICAgaWYgKHNjb3BlICYmIGlkIGluIGRlZmF1bHRzW3Njb3BlXSkge1xuICAgICAgZGVsZXRlIGRlZmF1bHRzW3Njb3BlXVtpZF07XG4gICAgICBpZiAodGhpcy5vdmVycmlkZSkge1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gIGNvbnN0IGl0ZW1EZWZhdWx0cyA9IG1lcmdlKE9iamVjdC5jcmVhdGUobnVsbCksIFtcbiAgICBwYXJlbnRTY29wZSA/IGRlZmF1bHRzLmdldChwYXJlbnRTY29wZSkgOiB7fSxcbiAgICBkZWZhdWx0cy5nZXQoc2NvcGUpLFxuICAgIGl0ZW0uZGVmYXVsdHNcbiAgXSk7XG4gIGRlZmF1bHRzLnNldChzY29wZSwgaXRlbURlZmF1bHRzKTtcbiAgaWYgKGl0ZW0uZGVmYXVsdFJvdXRlcykge1xuICAgIHJvdXRlRGVmYXVsdHMoc2NvcGUsIGl0ZW0uZGVmYXVsdFJvdXRlcyk7XG4gIH1cbiAgaWYgKGl0ZW0uZGVzY3JpcHRvcnMpIHtcbiAgICBkZWZhdWx0cy5kZXNjcmliZShzY29wZSwgaXRlbS5kZXNjcmlwdG9ycyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJvdXRlRGVmYXVsdHMoc2NvcGUsIHJvdXRlcykge1xuICBPYmplY3Qua2V5cyhyb3V0ZXMpLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgIGNvbnN0IHByb3BlcnR5UGFydHMgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBwcm9wZXJ0eVBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHNvdXJjZVNjb3BlID0gW3Njb3BlXS5jb25jYXQocHJvcGVydHlQYXJ0cykuam9pbignLicpO1xuICAgIGNvbnN0IHBhcnRzID0gcm91dGVzW3Byb3BlcnR5XS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHRhcmdldE5hbWUgPSBwYXJ0cy5wb3AoKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZSA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICBkZWZhdWx0cy5yb3V0ZShzb3VyY2VTY29wZSwgc291cmNlTmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSB7XG4gIHJldHVybiAnaWQnIGluIHByb3RvICYmICdkZWZhdWx0cycgaW4gcHJvdG87XG59XG5cbmNsYXNzIFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb250cm9sbGVycyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KERhdGFzZXRDb250cm9sbGVyLCAnZGF0YXNldHMnLCB0cnVlKTtcbiAgICB0aGlzLmVsZW1lbnRzID0gbmV3IFR5cGVkUmVnaXN0cnkoRWxlbWVudCwgJ2VsZW1lbnRzJyk7XG4gICAgdGhpcy5wbHVnaW5zID0gbmV3IFR5cGVkUmVnaXN0cnkoT2JqZWN0LCAncGx1Z2lucycpO1xuICAgIHRoaXMuc2NhbGVzID0gbmV3IFR5cGVkUmVnaXN0cnkoU2NhbGUsICdzY2FsZXMnKTtcbiAgICB0aGlzLl90eXBlZFJlZ2lzdHJpZXMgPSBbdGhpcy5jb250cm9sbGVycywgdGhpcy5zY2FsZXMsIHRoaXMuZWxlbWVudHNdO1xuICB9XG4gIGFkZCguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuICByZW1vdmUoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuICBhZGRDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmNvbnRyb2xsZXJzKTtcbiAgfVxuICBhZGRFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuICBhZGRQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cbiAgYWRkU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcbiAgfVxuICBnZXRDb250cm9sbGVyKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5jb250cm9sbGVycywgJ2NvbnRyb2xsZXInKTtcbiAgfVxuICBnZXRFbGVtZW50KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5lbGVtZW50cywgJ2VsZW1lbnQnKTtcbiAgfVxuICBnZXRQbHVnaW4oaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnBsdWdpbnMsICdwbHVnaW4nKTtcbiAgfVxuICBnZXRTY2FsZShpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuc2NhbGVzLCAnc2NhbGUnKTtcbiAgfVxuICByZW1vdmVDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG4gIHJlbW92ZUVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5lbGVtZW50cyk7XG4gIH1cbiAgcmVtb3ZlUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cbiAgcmVtb3ZlU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5zY2FsZXMpO1xuICB9XG4gIF9lYWNoKG1ldGhvZCwgYXJncywgdHlwZWRSZWdpc3RyeSkge1xuICAgIFsuLi5hcmdzXS5mb3JFYWNoKGFyZyA9PiB7XG4gICAgICBjb25zdCByZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShhcmcpO1xuICAgICAgaWYgKHR5cGVkUmVnaXN0cnkgfHwgcmVnLmlzRm9yVHlwZShhcmcpIHx8IChyZWcgPT09IHRoaXMucGx1Z2lucyAmJiBhcmcuaWQpKSB7XG4gICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCByZWcsIGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlYWNoKGFyZywgaXRlbSA9PiB7XG4gICAgICAgICAgY29uc3QgaXRlbVJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGl0ZW0pO1xuICAgICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCBpdGVtUmVnLCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2V4ZWMobWV0aG9kLCByZWdpc3RyeSwgY29tcG9uZW50KSB7XG4gICAgY29uc3QgY2FtZWxNZXRob2QgPSBfY2FwaXRhbGl6ZShtZXRob2QpO1xuICAgIGNhbGxiYWNrKGNvbXBvbmVudFsnYmVmb3JlJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7XG4gICAgcmVnaXN0cnlbbWV0aG9kXShjb21wb25lbnQpO1xuICAgIGNhbGxiYWNrKGNvbXBvbmVudFsnYWZ0ZXInICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTtcbiAgfVxuICBfZ2V0UmVnaXN0cnlGb3JUeXBlKHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3R5cGVkUmVnaXN0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVnID0gdGhpcy5fdHlwZWRSZWdpc3RyaWVzW2ldO1xuICAgICAgaWYgKHJlZy5pc0ZvclR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGx1Z2lucztcbiAgfVxuICBfZ2V0KGlkLCB0eXBlZFJlZ2lzdHJ5LCB0eXBlKSB7XG4gICAgY29uc3QgaXRlbSA9IHR5cGVkUmVnaXN0cnkuZ2V0KGlkKTtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGlkICsgJ1wiIGlzIG5vdCBhIHJlZ2lzdGVyZWQgJyArIHR5cGUgKyAnLicpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxufVxudmFyIHJlZ2lzdHJ5ID0gbmV3IFJlZ2lzdHJ5KCk7XG5cbmNsYXNzIFBsdWdpblNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pbml0ID0gW107XG4gIH1cbiAgbm90aWZ5KGNoYXJ0LCBob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICBpZiAoaG9vayA9PT0gJ2JlZm9yZUluaXQnKSB7XG4gICAgICB0aGlzLl9pbml0ID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHRydWUpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAnaW5zdGFsbCcpO1xuICAgIH1cbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IGZpbHRlciA/IHRoaXMuX2Rlc2NyaXB0b3JzKGNoYXJ0KS5maWx0ZXIoZmlsdGVyKSA6IHRoaXMuX2Rlc2NyaXB0b3JzKGNoYXJ0KTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKTtcbiAgICBpZiAoaG9vayA9PT0gJ2FmdGVyRGVzdHJveScpIHtcbiAgICAgIHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsICdzdG9wJyk7XG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICd1bmluc3RhbGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncykge1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgIGZvciAoY29uc3QgZGVzY3JpcHRvciBvZiBkZXNjcmlwdG9ycykge1xuICAgICAgY29uc3QgcGx1Z2luID0gZGVzY3JpcHRvci5wbHVnaW47XG4gICAgICBjb25zdCBtZXRob2QgPSBwbHVnaW5baG9va107XG4gICAgICBjb25zdCBwYXJhbXMgPSBbY2hhcnQsIGFyZ3MsIGRlc2NyaXB0b3Iub3B0aW9uc107XG4gICAgICBpZiAoY2FsbGJhY2sobWV0aG9kLCBwYXJhbXMsIHBsdWdpbikgPT09IGZhbHNlICYmIGFyZ3MuY2FuY2VsYWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGludmFsaWRhdGUoKSB7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKHRoaXMuX2NhY2hlKSkge1xuICAgICAgdGhpcy5fb2xkQ2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICAgIHRoaXMuX2NhY2hlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBfZGVzY3JpcHRvcnMoY2hhcnQpIHtcbiAgICBpZiAodGhpcy5fY2FjaGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZTtcbiAgICB9XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZSA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0KTtcbiAgICB0aGlzLl9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpO1xuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfVxuICBfY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIGFsbCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGNoYXJ0ICYmIGNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBvcHRpb25zID0gdmFsdWVPckRlZmF1bHQoY29uZmlnLm9wdGlvbnMgJiYgY29uZmlnLm9wdGlvbnMucGx1Z2lucywge30pO1xuICAgIGNvbnN0IHBsdWdpbnMgPSBhbGxQbHVnaW5zKGNvbmZpZyk7XG4gICAgcmV0dXJuIG9wdGlvbnMgPT09IGZhbHNlICYmICFhbGwgPyBbXSA6IGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBwbHVnaW5zLCBvcHRpb25zLCBhbGwpO1xuICB9XG4gIF9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpIHtcbiAgICBjb25zdCBwcmV2aW91c0Rlc2NyaXB0b3JzID0gdGhpcy5fb2xkQ2FjaGUgfHwgW107XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZTtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHgucGx1Z2luLmlkID09PSB5LnBsdWdpbi5pZCkpO1xuICAgIHRoaXMuX25vdGlmeShkaWZmKHByZXZpb3VzRGVzY3JpcHRvcnMsIGRlc2NyaXB0b3JzKSwgY2hhcnQsICdzdG9wJyk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYoZGVzY3JpcHRvcnMsIHByZXZpb3VzRGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0YXJ0Jyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFsbFBsdWdpbnMoY29uZmlnKSB7XG4gIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnBsdWdpbnMuaXRlbXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBwbHVnaW5zLnB1c2gocmVnaXN0cnkuZ2V0UGx1Z2luKGtleXNbaV0pKTtcbiAgfVxuICBjb25zdCBsb2NhbCA9IGNvbmZpZy5wbHVnaW5zIHx8IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGx1Z2luID0gbG9jYWxbaV07XG4gICAgaWYgKHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBwbHVnaW5zO1xufVxuZnVuY3Rpb24gZ2V0T3B0cyhvcHRpb25zLCBhbGwpIHtcbiAgaWYgKCFhbGwgJiYgb3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBwbHVnaW5zLCBvcHRpb25zLCBhbGwpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSBjaGFydC5nZXRDb250ZXh0KCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3Qgb3B0cyA9IGdldE9wdHMob3B0aW9uc1tpZF0sIGFsbCk7XG4gICAgaWYgKG9wdHMgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh7XG4gICAgICBwbHVnaW4sXG4gICAgICBvcHRpb25zOiBwbHVnaW5PcHRzKGNoYXJ0LmNvbmZpZywgcGx1Z2luLCBvcHRzLCBjb250ZXh0KVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwbHVnaW5PcHRzKGNvbmZpZywgcGx1Z2luLCBvcHRzLCBjb250ZXh0KSB7XG4gIGNvbnN0IGtleXMgPSBjb25maWcucGx1Z2luU2NvcGVLZXlzKHBsdWdpbik7XG4gIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXMob3B0cywga2V5cyk7XG4gIHJldHVybiBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBbJyddLCB7c2NyaXB0YWJsZTogZmFsc2UsIGluZGV4YWJsZTogZmFsc2UsIGFsbEtleXM6IHRydWV9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhBeGlzKHR5cGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge307XG4gIGNvbnN0IGRhdGFzZXRPcHRpb25zID0gKG9wdGlvbnMuZGF0YXNldHMgfHwge30pW3R5cGVdIHx8IHt9O1xuICByZXR1cm4gZGF0YXNldE9wdGlvbnMuaW5kZXhBeGlzIHx8IG9wdGlvbnMuaW5kZXhBeGlzIHx8IGRhdGFzZXREZWZhdWx0cy5pbmRleEF4aXMgfHwgJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChpZCwgaW5kZXhBeGlzKSB7XG4gIGxldCBheGlzID0gaWQ7XG4gIGlmIChpZCA9PT0gJ19pbmRleF8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcztcbiAgfSBlbHNlIGlmIChpZCA9PT0gJ192YWx1ZV8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICB9XG4gIHJldHVybiBheGlzO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBpbmRleEF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09IGluZGV4QXhpcyA/ICdfaW5kZXhfJyA6ICdfdmFsdWVfJztcbn1cbmZ1bmN0aW9uIGF4aXNGcm9tUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICByZXR1cm4gJ3gnO1xuICB9XG4gIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgcmV0dXJuICd5JztcbiAgfVxufVxuZnVuY3Rpb24gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKSB7XG4gIGlmIChpZCA9PT0gJ3gnIHx8IGlkID09PSAneScpIHtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgcmV0dXJuIHNjYWxlT3B0aW9ucy5heGlzIHx8IGF4aXNGcm9tUG9zaXRpb24oc2NhbGVPcHRpb25zLnBvc2l0aW9uKSB8fCBpZC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0RGVmYXVsdHMgPSBvdmVycmlkZXNbY29uZmlnLnR5cGVdIHx8IHtzY2FsZXM6IHt9fTtcbiAgY29uc3QgY29uZmlnU2NhbGVzID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG4gIGNvbnN0IGNoYXJ0SW5kZXhBeGlzID0gZ2V0SW5kZXhBeGlzKGNvbmZpZy50eXBlLCBvcHRpb25zKTtcbiAgY29uc3QgZmlyc3RJRHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBzY2FsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBPYmplY3Qua2V5cyhjb25maWdTY2FsZXMpLmZvckVhY2goaWQgPT4ge1xuICAgIGNvbnN0IHNjYWxlQ29uZiA9IGNvbmZpZ1NjYWxlc1tpZF07XG4gICAgaWYgKCFpc09iamVjdChzY2FsZUNvbmYpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgSW52YWxpZCBzY2FsZSBjb25maWd1cmF0aW9uIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgaWYgKHNjYWxlQ29uZi5fcHJveHkpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oYElnbm9yaW5nIHJlc29sdmVyIHBhc3NlZCBhcyBvcHRpb25zIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlQ29uZik7XG4gICAgY29uc3QgZGVmYXVsdElkID0gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBjaGFydEluZGV4QXhpcyk7XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGNoYXJ0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIGZpcnN0SURzW2F4aXNdID0gZmlyc3RJRHNbYXhpc10gfHwgaWQ7XG4gICAgc2NhbGVzW2lkXSA9IG1lcmdlSWYoT2JqZWN0LmNyZWF0ZShudWxsKSwgW3theGlzfSwgc2NhbGVDb25mLCBkZWZhdWx0U2NhbGVPcHRpb25zW2F4aXNdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJZF1dKTtcbiAgfSk7XG4gIGNvbmZpZy5kYXRhLmRhdGFzZXRzLmZvckVhY2goZGF0YXNldCA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBjb25maWcudHlwZTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gb3ZlcnJpZGVzW3R5cGVdIHx8IHt9O1xuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBkYXRhc2V0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKGRlZmF1bHRTY2FsZU9wdGlvbnMpLmZvckVhY2goZGVmYXVsdElEID0+IHtcbiAgICAgIGNvbnN0IGF4aXMgPSBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGRlZmF1bHRJRCwgaW5kZXhBeGlzKTtcbiAgICAgIGNvbnN0IGlkID0gZGF0YXNldFtheGlzICsgJ0F4aXNJRCddIHx8IGZpcnN0SURzW2F4aXNdIHx8IGF4aXM7XG4gICAgICBzY2FsZXNbaWRdID0gc2NhbGVzW2lkXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgbWVyZ2VJZihzY2FsZXNbaWRdLCBbe2F4aXN9LCBjb25maWdTY2FsZXNbaWRdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJRF1dKTtcbiAgICB9KTtcbiAgfSk7XG4gIE9iamVjdC5rZXlzKHNjYWxlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGNvbnN0IHNjYWxlID0gc2NhbGVzW2tleV07XG4gICAgbWVyZ2VJZihzY2FsZSwgW2RlZmF1bHRzLnNjYWxlc1tzY2FsZS50eXBlXSwgZGVmYXVsdHMuc2NhbGVdKTtcbiAgfSk7XG4gIHJldHVybiBzY2FsZXM7XG59XG5mdW5jdGlvbiBpbml0T3B0aW9ucyhjb25maWcpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zIHx8IChjb25maWcub3B0aW9ucyA9IHt9KTtcbiAgb3B0aW9ucy5wbHVnaW5zID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gIG9wdGlvbnMuc2NhbGVzID0gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaW5pdERhdGEoZGF0YSkge1xuICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgZGF0YS5kYXRhc2V0cyA9IGRhdGEuZGF0YXNldHMgfHwgW107XG4gIGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XG4gIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBjb25maWcuZGF0YSA9IGluaXREYXRhKGNvbmZpZy5kYXRhKTtcbiAgaW5pdE9wdGlvbnMoY29uZmlnKTtcbiAgcmV0dXJuIGNvbmZpZztcbn1cbmNvbnN0IGtleUNhY2hlID0gbmV3IE1hcCgpO1xuY29uc3Qga2V5c0NhY2hlZCA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGNhY2hlZEtleXMoY2FjaGVLZXksIGdlbmVyYXRlKSB7XG4gIGxldCBrZXlzID0ga2V5Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IGdlbmVyYXRlKCk7XG4gICAga2V5Q2FjaGUuc2V0KGNhY2hlS2V5LCBrZXlzKTtcbiAgICBrZXlzQ2FjaGVkLmFkZChrZXlzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmNvbnN0IGFkZElmRm91bmQgPSAoc2V0LCBvYmosIGtleSkgPT4ge1xuICBjb25zdCBvcHRzID0gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSk7XG4gIGlmIChvcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXQuYWRkKG9wdHMpO1xuICB9XG59O1xuY2xhc3MgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gaW5pdENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgcGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbGF0Zm9ybTtcbiAgfVxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnR5cGU7XG4gIH1cbiAgc2V0IHR5cGUodHlwZSkge1xuICAgIHRoaXMuX2NvbmZpZy50eXBlID0gdHlwZTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmRhdGE7XG4gIH1cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuX2NvbmZpZy5kYXRhID0gaW5pdERhdGEoZGF0YSk7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5vcHRpb25zO1xuICB9XG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbHVnaW5zO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLl9jb25maWc7XG4gICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgaW5pdE9wdGlvbnMoY29uZmlnKTtcbiAgfVxuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlLmNsZWFyKCk7XG4gIH1cbiAgZGF0YXNldFNjb3BlS2V5cyhkYXRhc2V0VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGRhdGFzZXRUeXBlLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuICBkYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzKGRhdGFzZXRUeXBlLCB0cmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb24uJHt0cmFuc2l0aW9ufWAsXG4gICAgICAoKSA9PiBbXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgICAgYHRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgICAnJ1xuICAgICAgICBdXG4gICAgICBdKTtcbiAgfVxuICBkYXRhc2V0RWxlbWVudFNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgZWxlbWVudFR5cGUpIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0tJHtlbGVtZW50VHlwZX1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LmVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgYGVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuICBwbHVnaW5TY29wZUtleXMocGx1Z2luKSB7XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZTtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHt0eXBlfS1wbHVnaW4tJHtpZH1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYHBsdWdpbnMuJHtpZH1gLFxuICAgICAgICAuLi5wbHVnaW4uYWRkaXRpb25hbE9wdGlvblNjb3BlcyB8fCBbXSxcbiAgICAgIF1dKTtcbiAgfVxuICBfY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IF9zY29wZUNhY2hlID0gdGhpcy5fc2NvcGVDYWNoZTtcbiAgICBsZXQgY2FjaGUgPSBfc2NvcGVDYWNoZS5nZXQobWFpblNjb3BlKTtcbiAgICBpZiAoIWNhY2hlIHx8IHJlc2V0Q2FjaGUpIHtcbiAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgX3Njb3BlQ2FjaGUuc2V0KG1haW5TY29wZSwgY2FjaGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cbiAgZ2V0T3B0aW9uU2NvcGVzKG1haW5TY29wZSwga2V5TGlzdHMsIHJlc2V0Q2FjaGUpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSk7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleUxpc3RzKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBjb25zdCBzY29wZXMgPSBuZXcgU2V0KCk7XG4gICAga2V5TGlzdHMuZm9yRWFjaChrZXlzID0+IHtcbiAgICAgIGlmIChtYWluU2NvcGUpIHtcbiAgICAgICAgc2NvcGVzLmFkZChtYWluU2NvcGUpO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBtYWluU2NvcGUsIGtleSkpO1xuICAgICAgfVxuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3B0aW9ucywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvdmVycmlkZXNbdHlwZV0gfHwge30sIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVmYXVsdHMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVzY3JpcHRvcnMsIGtleSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGFycmF5ID0gQXJyYXkuZnJvbShzY29wZXMpO1xuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIGFycmF5LnB1c2goT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgfVxuICAgIGlmIChrZXlzQ2FjaGVkLmhhcyhrZXlMaXN0cykpIHtcbiAgICAgIGNhY2hlLnNldChrZXlMaXN0cywgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgY2hhcnRPcHRpb25TY29wZXMoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIHR5cGV9ID0gdGhpcztcbiAgICByZXR1cm4gW1xuICAgICAgb3B0aW9ucyxcbiAgICAgIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSxcbiAgICAgIGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9LFxuICAgICAge3R5cGV9LFxuICAgICAgZGVmYXVsdHMsXG4gICAgICBkZXNjcmlwdG9yc1xuICAgIF07XG4gIH1cbiAgcmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyA9IFsnJ10pIHtcbiAgICBjb25zdCByZXN1bHQgPSB7JHNoYXJlZDogdHJ1ZX07XG4gICAgY29uc3Qge3Jlc29sdmVyLCBzdWJQcmVmaXhlc30gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICBsZXQgb3B0aW9ucyA9IHJlc29sdmVyO1xuICAgIGlmIChuZWVkQ29udGV4dChyZXNvbHZlciwgbmFtZXMpKSB7XG4gICAgICByZXN1bHQuJHNoYXJlZCA9IGZhbHNlO1xuICAgICAgY29udGV4dCA9IGlzRnVuY3Rpb24oY29udGV4dCkgPyBjb250ZXh0KCkgOiBjb250ZXh0O1xuICAgICAgY29uc3Qgc3ViUmVzb2x2ZXIgPSB0aGlzLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgc3ViUHJlZml4ZXMpO1xuICAgICAgb3B0aW9ucyA9IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCBzdWJSZXNvbHZlcik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgICAgcmVzdWx0W3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSwgZGVzY3JpcHRvckRlZmF1bHRzKSB7XG4gICAgY29uc3Qge3Jlc29sdmVyfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIHJldHVybiBpc09iamVjdChjb250ZXh0KVxuICAgICAgPyBfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgY29udGV4dCwgdW5kZWZpbmVkLCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gICAgICA6IHJlc29sdmVyO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZXNvbHZlcihyZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKSB7XG4gIGxldCBjYWNoZSA9IHJlc29sdmVyQ2FjaGUuZ2V0KHNjb3Blcyk7XG4gIGlmICghY2FjaGUpIHtcbiAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICByZXNvbHZlckNhY2hlLnNldChzY29wZXMsIGNhY2hlKTtcbiAgfVxuICBjb25zdCBjYWNoZUtleSA9IHByZWZpeGVzLmpvaW4oKTtcbiAgbGV0IGNhY2hlZCA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghY2FjaGVkKSB7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBfY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgY2FjaGVkID0ge1xuICAgICAgcmVzb2x2ZXIsXG4gICAgICBzdWJQcmVmaXhlczogcHJlZml4ZXMuZmlsdGVyKHAgPT4gIXAudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnaG92ZXInKSlcbiAgICB9O1xuICAgIGNhY2hlLnNldChjYWNoZUtleSwgY2FjaGVkKTtcbiAgfVxuICByZXR1cm4gY2FjaGVkO1xufVxuY29uc3QgaGFzRnVuY3Rpb24gPSB2YWx1ZSA9PiBpc09iamVjdCh2YWx1ZSlcbiAgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjYyB8fCBpc0Z1bmN0aW9uKHZhbHVlW2tleV0pLCBmYWxzZSk7XG5mdW5jdGlvbiBuZWVkQ29udGV4dChwcm94eSwgbmFtZXMpIHtcbiAgY29uc3Qge2lzU2NyaXB0YWJsZSwgaXNJbmRleGFibGV9ID0gX2Rlc2NyaXB0b3JzKHByb3h5KTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgY29uc3Qgc2NyaXB0YWJsZSA9IGlzU2NyaXB0YWJsZShwcm9wKTtcbiAgICBjb25zdCBpbmRleGFibGUgPSBpc0luZGV4YWJsZShwcm9wKTtcbiAgICBjb25zdCB2YWx1ZSA9IChpbmRleGFibGUgfHwgc2NyaXB0YWJsZSkgJiYgcHJveHlbcHJvcF07XG4gICAgaWYgKChzY3JpcHRhYmxlICYmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBoYXNGdW5jdGlvbih2YWx1ZSkpKVxuICAgICAgfHwgKGluZGV4YWJsZSAmJiBpc0FycmF5KHZhbHVlKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciB2ZXJzaW9uID0gXCIzLjcuMFwiO1xuXG5jb25zdCBLTk9XTl9QT1NJVElPTlMgPSBbJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCcsICdjaGFydEFyZWEnXTtcbmZ1bmN0aW9uIHBvc2l0aW9uSXNIb3Jpem9udGFsKHBvc2l0aW9uLCBheGlzKSB7XG4gIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nIHx8IChLTk9XTl9QT1NJVElPTlMuaW5kZXhPZihwb3NpdGlvbikgPT09IC0xICYmIGF4aXMgPT09ICd4Jyk7XG59XG5mdW5jdGlvbiBjb21wYXJlMkxldmVsKGwxLCBsMikge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhW2wxXSA9PT0gYltsMV1cbiAgICAgID8gYVtsMl0gLSBiW2wyXVxuICAgICAgOiBhW2wxXSAtIGJbbDFdO1xuICB9O1xufVxuZnVuY3Rpb24gb25BbmltYXRpb25zQ29tcGxldGUoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJSZW5kZXInKTtcbiAgY2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uQ29tcGxldGUsIFtjb250ZXh0XSwgY2hhcnQpO1xufVxuZnVuY3Rpb24gb25BbmltYXRpb25Qcm9ncmVzcyhjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICBjYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Qcm9ncmVzcywgW2NvbnRleHRdLCBjaGFydCk7XG59XG5mdW5jdGlvbiBnZXRDYW52YXMoaXRlbSkge1xuICBpZiAoX2lzRG9tU3VwcG9ydGVkKCkgJiYgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaXRlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGl0ZW0pO1xuICB9IGVsc2UgaWYgKGl0ZW0gJiYgaXRlbS5sZW5ndGgpIHtcbiAgICBpdGVtID0gaXRlbVswXTtcbiAgfVxuICBpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuICAgIGl0ZW0gPSBpdGVtLmNhbnZhcztcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cbmNvbnN0IGluc3RhbmNlcyA9IHt9O1xuY29uc3QgZ2V0Q2hhcnQgPSAoa2V5KSA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IGdldENhbnZhcyhrZXkpO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpbnN0YW5jZXMpLmZpbHRlcigoYykgPT4gYy5jYW52YXMgPT09IGNhbnZhcykucG9wKCk7XG59O1xuZnVuY3Rpb24gbW92ZU51bWVyaWNLZXlzKG9iaiwgc3RhcnQsIG1vdmUpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBpbnRLZXkgPSAra2V5O1xuICAgIGlmIChpbnRLZXkgPj0gc3RhcnQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICBpZiAobW92ZSA+IDAgfHwgaW50S2V5ID4gc3RhcnQpIHtcbiAgICAgICAgb2JqW2ludEtleSArIG1vdmVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljaykge1xuICBpZiAoIWluQ2hhcnRBcmVhIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0NsaWNrKSB7XG4gICAgcmV0dXJuIGxhc3RFdmVudDtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmNsYXNzIENoYXJ0IHtcbiAgY29uc3RydWN0b3IoaXRlbSwgdXNlckNvbmZpZykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnID0gbmV3IENvbmZpZyh1c2VyQ29uZmlnKTtcbiAgICBjb25zdCBpbml0aWFsQ2FudmFzID0gZ2V0Q2FudmFzKGl0ZW0pO1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hhcnQgPSBnZXRDaGFydChpbml0aWFsQ2FudmFzKTtcbiAgICBpZiAoZXhpc3RpbmdDaGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2FudmFzIGlzIGFscmVhZHkgaW4gdXNlLiBDaGFydCB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmlkICsgJ1xcJycgK1xuXHRcdFx0XHQnIG11c3QgYmUgZGVzdHJveWVkIGJlZm9yZSB0aGUgY2FudmFzIGNhbiBiZSByZXVzZWQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMucGxhdGZvcm0gPSBuZXcgKGNvbmZpZy5wbGF0Zm9ybSB8fCBfZGV0ZWN0UGxhdGZvcm0oaW5pdGlhbENhbnZhcykpKCk7XG4gICAgdGhpcy5wbGF0Zm9ybS51cGRhdGVDb25maWcoY29uZmlnKTtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5wbGF0Zm9ybS5hY3F1aXJlQ29udGV4dChpbml0aWFsQ2FudmFzLCBvcHRpb25zLmFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzO1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcyAmJiBjYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gY2FudmFzICYmIGNhbnZhcy53aWR0aDtcbiAgICB0aGlzLmlkID0gdWlkKCk7XG4gICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW87XG4gICAgdGhpcy5fbGF5ZXJzID0gW107XG4gICAgdGhpcy5fbWV0YXNldHMgPSBbXTtcbiAgICB0aGlzLl9zdGFja3MgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3hlcyA9IFtdO1xuICAgIHRoaXMuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFydEFyZWEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fYWN0aXZlID0gW107XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBbXTtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuX3BsdWdpbnMgPSBuZXcgUGx1Z2luU2VydmljZSgpO1xuICAgIHRoaXMuJHByb3hpZXMgPSB7fTtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzID0ge307XG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RvUmVzaXplID0gZGVib3VuY2UobW9kZSA9PiB0aGlzLnVwZGF0ZShtb2RlKSwgb3B0aW9ucy5yZXNpemVEZWxheSB8fCAwKTtcbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuICAgIGluc3RhbmNlc1t0aGlzLmlkXSA9IHRoaXM7XG4gICAgaWYgKCFjb250ZXh0IHx8ICFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNoYXJ0OiBjYW4ndCBhY3F1aXJlIGNvbnRleHQgZnJvbSB0aGUgZ2l2ZW4gaXRlbVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdjb21wbGV0ZScsIG9uQW5pbWF0aW9uc0NvbXBsZXRlKTtcbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ3Byb2dyZXNzJywgb25BbmltYXRpb25Qcm9ncmVzcyk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBnZXQgYXNwZWN0UmF0aW8oKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IHthc3BlY3RSYXRpbywgbWFpbnRhaW5Bc3BlY3RSYXRpb30sIHdpZHRoLCBoZWlnaHQsIF9hc3BlY3RSYXRpb30gPSB0aGlzO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZihhc3BlY3RSYXRpbykpIHtcbiAgICAgIHJldHVybiBhc3BlY3RSYXRpbztcbiAgICB9XG4gICAgaWYgKG1haW50YWluQXNwZWN0UmF0aW8gJiYgX2FzcGVjdFJhdGlvKSB7XG4gICAgICByZXR1cm4gX2FzcGVjdFJhdGlvO1xuICAgIH1cbiAgICByZXR1cm4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhO1xuICB9XG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLmNvbmZpZy5kYXRhID0gZGF0YTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVJbml0Jyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRpbmFTY2FsZSh0aGlzLCB0aGlzLm9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgfVxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJJbml0Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgY2xlYXJDYW52YXModGhpcy5jYW52YXMsIHRoaXMuY3R4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdG9wKCkge1xuICAgIGFuaW1hdG9yLnN0b3AodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWFuaW1hdG9yLnJ1bm5pbmcodGhpcykpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IHt3aWR0aCwgaGVpZ2h0fTtcbiAgICB9XG4gIH1cbiAgX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IG9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLnBsYXRmb3JtLmdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICAgIGNvbnN0IG5ld1JhdGlvID0gb3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvIHx8IHRoaXMucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIGNvbnN0IG1vZGUgPSB0aGlzLndpZHRoID8gJ3Jlc2l6ZScgOiAnYXR0YWNoJztcbiAgICB0aGlzLndpZHRoID0gbmV3U2l6ZS53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG5ld1NpemUuaGVpZ2h0O1xuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICBpZiAoIXJldGluYVNjYWxlKHRoaXMsIG5ld1JhdGlvLCB0cnVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2l6ZScsIHtzaXplOiBuZXdTaXplfSk7XG4gICAgY2FsbGJhY2sob3B0aW9ucy5vblJlc2l6ZSwgW3RoaXMsIG5ld1NpemVdLCB0aGlzKTtcbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgaWYgKHRoaXMuX2RvUmVzaXplKG1vZGUpKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVuc3VyZVNjYWxlc0hhdmVJRHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZXNPcHRpb25zID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG4gICAgZWFjaChzY2FsZXNPcHRpb25zLCAoYXhpc09wdGlvbnMsIGF4aXNJRCkgPT4ge1xuICAgICAgYXhpc09wdGlvbnMuaWQgPSBheGlzSUQ7XG4gICAgfSk7XG4gIH1cbiAgYnVpbGRPclVwZGF0ZVNjYWxlcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNjYWxlT3B0cyA9IG9wdGlvbnMuc2NhbGVzO1xuICAgIGNvbnN0IHNjYWxlcyA9IHRoaXMuc2NhbGVzO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3Qua2V5cyhzY2FsZXMpLnJlZHVjZSgob2JqLCBpZCkgPT4ge1xuICAgICAgb2JqW2lkXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG4gICAgbGV0IGl0ZW1zID0gW107XG4gICAgaWYgKHNjYWxlT3B0cykge1xuICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoXG4gICAgICAgIE9iamVjdC5rZXlzKHNjYWxlT3B0cykubWFwKChpZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IHNjYWxlT3B0c1tpZF07XG4gICAgICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICAgICAgY29uc3QgaXNSYWRpYWwgPSBheGlzID09PSAncic7XG4gICAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gYXhpcyA9PT0gJ3gnO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb25zOiBzY2FsZU9wdGlvbnMsXG4gICAgICAgICAgICBkcG9zaXRpb246IGlzUmFkaWFsID8gJ2NoYXJ0QXJlYScgOiBpc0hvcml6b250YWwgPyAnYm90dG9tJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgIGR0eXBlOiBpc1JhZGlhbCA/ICdyYWRpYWxMaW5lYXInIDogaXNIb3Jpem9udGFsID8gJ2NhdGVnb3J5JyA6ICdsaW5lYXInXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGVhY2goaXRlbXMsIChpdGVtKSA9PiB7XG4gICAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSBpdGVtLm9wdGlvbnM7XG4gICAgICBjb25zdCBpZCA9IHNjYWxlT3B0aW9ucy5pZDtcbiAgICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpO1xuICAgICAgY29uc3Qgc2NhbGVUeXBlID0gdmFsdWVPckRlZmF1bHQoc2NhbGVPcHRpb25zLnR5cGUsIGl0ZW0uZHR5cGUpO1xuICAgICAgaWYgKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uSXNIb3Jpem9udGFsKHNjYWxlT3B0aW9ucy5wb3NpdGlvbiwgYXhpcykgIT09IHBvc2l0aW9uSXNIb3Jpem9udGFsKGl0ZW0uZHBvc2l0aW9uKSkge1xuICAgICAgICBzY2FsZU9wdGlvbnMucG9zaXRpb24gPSBpdGVtLmRwb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZWRbaWRdID0gdHJ1ZTtcbiAgICAgIGxldCBzY2FsZSA9IG51bGw7XG4gICAgICBpZiAoaWQgaW4gc2NhbGVzICYmIHNjYWxlc1tpZF0udHlwZSA9PT0gc2NhbGVUeXBlKSB7XG4gICAgICAgIHNjYWxlID0gc2NhbGVzW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNjYWxlQ2xhc3MgPSByZWdpc3RyeS5nZXRTY2FsZShzY2FsZVR5cGUpO1xuICAgICAgICBzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB0eXBlOiBzY2FsZVR5cGUsXG4gICAgICAgICAgY3R4OiB0aGlzLmN0eCxcbiAgICAgICAgICBjaGFydDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgc2NhbGVzW3NjYWxlLmlkXSA9IHNjYWxlO1xuICAgICAgfVxuICAgICAgc2NhbGUuaW5pdChzY2FsZU9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIGVhY2godXBkYXRlZCwgKGhhc1VwZGF0ZWQsIGlkKSA9PiB7XG4gICAgICBpZiAoIWhhc1VwZGF0ZWQpIHtcbiAgICAgICAgZGVsZXRlIHNjYWxlc1tpZF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgZWFjaChzY2FsZXMsIChzY2FsZSkgPT4ge1xuICAgICAgbGF5b3V0cy5jb25maWd1cmUodGhpcywgc2NhbGUsIHNjYWxlLm9wdGlvbnMpO1xuICAgICAgbGF5b3V0cy5hZGRCb3godGhpcywgc2NhbGUpO1xuICAgIH0pO1xuICB9XG4gIF91cGRhdGVNZXRhc2V0cygpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGNvbnN0IG51bURhdGEgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bU1ldGEgPSBtZXRhc2V0cy5sZW5ndGg7XG4gICAgbWV0YXNldHMuc29ydCgoYSwgYikgPT4gYS5pbmRleCAtIGIuaW5kZXgpO1xuICAgIGlmIChudW1NZXRhID4gbnVtRGF0YSkge1xuICAgICAgZm9yIChsZXQgaSA9IG51bURhdGE7IGkgPCBudW1NZXRhOyArK2kpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgfVxuICAgICAgbWV0YXNldHMuc3BsaWNlKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcbiAgICB9XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBtZXRhc2V0cy5zbGljZSgwKS5zb3J0KGNvbXBhcmUyTGV2ZWwoJ29yZGVyJywgJ2luZGV4JykpO1xuICB9XG4gIF9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpIHtcbiAgICBjb25zdCB7X21ldGFzZXRzOiBtZXRhc2V0cywgZGF0YToge2RhdGFzZXRzfX0gPSB0aGlzO1xuICAgIGlmIChtZXRhc2V0cy5sZW5ndGggPiBkYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdGFja3M7XG4gICAgfVxuICAgIG1ldGFzZXRzLmZvckVhY2goKG1ldGEsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZGF0YXNldHMuZmlsdGVyKHggPT4geCA9PT0gbWV0YS5fZGF0YXNldCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCkge1xuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gW107XG4gICAgY29uc3QgZGF0YXNldHMgPSB0aGlzLmRhdGEuZGF0YXNldHM7XG4gICAgbGV0IGksIGlsZW47XG4gICAgdGhpcy5fcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldHNbaV07XG4gICAgICBsZXQgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IHRoaXMuY29uZmlnLnR5cGU7XG4gICAgICBpZiAobWV0YS50eXBlICYmIG1ldGEudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgfVxuICAgICAgbWV0YS50eXBlID0gdHlwZTtcbiAgICAgIG1ldGEuaW5kZXhBeGlzID0gZGF0YXNldC5pbmRleEF4aXMgfHwgZ2V0SW5kZXhBeGlzKHR5cGUsIHRoaXMub3B0aW9ucyk7XG4gICAgICBtZXRhLm9yZGVyID0gZGF0YXNldC5vcmRlciB8fCAwO1xuICAgICAgbWV0YS5pbmRleCA9IGk7XG4gICAgICBtZXRhLmxhYmVsID0gJycgKyBkYXRhc2V0LmxhYmVsO1xuICAgICAgbWV0YS52aXNpYmxlID0gdGhpcy5pc0RhdGFzZXRWaXNpYmxlKGkpO1xuICAgICAgaWYgKG1ldGEuY29udHJvbGxlcikge1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoaSk7XG4gICAgICAgIG1ldGEuY29udHJvbGxlci5saW5rU2NhbGVzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBDb250cm9sbGVyQ2xhc3MgPSByZWdpc3RyeS5nZXRDb250cm9sbGVyKHR5cGUpO1xuICAgICAgICBjb25zdCB7ZGF0YXNldEVsZW1lbnRUeXBlLCBkYXRhRWxlbWVudFR5cGV9ID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oQ29udHJvbGxlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICAgIGRhdGFFbGVtZW50VHlwZTogcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhRWxlbWVudFR5cGUpLFxuICAgICAgICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZGF0YXNldEVsZW1lbnRUeXBlICYmIHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YXNldEVsZW1lbnRUeXBlKVxuICAgICAgICB9KTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzLCBpKTtcbiAgICAgICAgbmV3Q29udHJvbGxlcnMucHVzaChtZXRhLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl91cGRhdGVNZXRhc2V0cygpO1xuICAgIHJldHVybiBuZXdDb250cm9sbGVycztcbiAgfVxuICBfcmVzZXRFbGVtZW50cygpIHtcbiAgICBlYWNoKHRoaXMuZGF0YS5kYXRhc2V0cywgKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkgPT4ge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRzKCk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdyZXNldCcpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uZmlnLnVwZGF0ZSgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYW5pbXNEaXNhYmxlZCA9IHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9ICFvcHRpb25zLmFuaW1hdGlvbjtcbiAgICB0aGlzLl91cGRhdGVTY2FsZXMoKTtcbiAgICB0aGlzLl9jaGVja0V2ZW50QmluZGluZ3MoKTtcbiAgICB0aGlzLl91cGRhdGVIaWRkZW5JbmRpY2VzKCk7XG4gICAgdGhpcy5fcGx1Z2lucy5pbnZhbGlkYXRlKCk7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlVXBkYXRlJywge21vZGUsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSB0aGlzLmJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRWxlbWVudHNVcGRhdGUnKTtcbiAgICBsZXQgbWluUGFkZGluZyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCB7Y29udHJvbGxlcn0gPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgcmVzZXQgPSAhYW5pbXNEaXNhYmxlZCAmJiBuZXdDb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpID09PSAtMTtcbiAgICAgIGNvbnRyb2xsZXIuYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0KTtcbiAgICAgIG1pblBhZGRpbmcgPSBNYXRoLm1heCgrY29udHJvbGxlci5nZXRNYXhPdmVyZmxvdygpLCBtaW5QYWRkaW5nKTtcbiAgICB9XG4gICAgbWluUGFkZGluZyA9IHRoaXMuX21pblBhZGRpbmcgPSBvcHRpb25zLmxheW91dC5hdXRvUGFkZGluZyA/IG1pblBhZGRpbmcgOiAwO1xuICAgIHRoaXMuX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKTtcbiAgICBpZiAoIWFuaW1zRGlzYWJsZWQpIHtcbiAgICAgIGVhY2gobmV3Q29udHJvbGxlcnMsIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVEYXRhc2V0cyhtb2RlKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyVXBkYXRlJywge21vZGV9KTtcbiAgICB0aGlzLl9sYXllcnMuc29ydChjb21wYXJlMkxldmVsKCd6JywgJ19pZHgnKSk7XG4gICAgY29uc3Qge19hY3RpdmUsIF9sYXN0RXZlbnR9ID0gdGhpcztcbiAgICBpZiAoX2xhc3RFdmVudCkge1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKF9sYXN0RXZlbnQsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoX2FjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKF9hY3RpdmUsIF9hY3RpdmUsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG4gIF91cGRhdGVTY2FsZXMoKSB7XG4gICAgZWFjaCh0aGlzLnNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLnJlbW92ZUJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG4gICAgdGhpcy5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG4gICAgdGhpcy5idWlsZE9yVXBkYXRlU2NhbGVzKCk7XG4gIH1cbiAgX2NoZWNrRXZlbnRCaW5kaW5ncygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGV4aXN0aW5nRXZlbnRzID0gbmV3IFNldChPYmplY3Qua2V5cyh0aGlzLl9saXN0ZW5lcnMpKTtcbiAgICBjb25zdCBuZXdFdmVudHMgPSBuZXcgU2V0KG9wdGlvbnMuZXZlbnRzKTtcbiAgICBpZiAoIXNldHNFcXVhbChleGlzdGluZ0V2ZW50cywgbmV3RXZlbnRzKSB8fCAhIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgIT09IG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlSGlkZGVuSW5kaWNlcygpIHtcbiAgICBjb25zdCB7X2hpZGRlbkluZGljZXN9ID0gdGhpcztcbiAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkgfHwgW107XG4gICAgZm9yIChjb25zdCB7bWV0aG9kLCBzdGFydCwgY291bnR9IG9mIGNoYW5nZXMpIHtcbiAgICAgIGNvbnN0IG1vdmUgPSBtZXRob2QgPT09ICdfcmVtb3ZlRWxlbWVudHMnID8gLWNvdW50IDogY291bnQ7XG4gICAgICBtb3ZlTnVtZXJpY0tleXMoX2hpZGRlbkluZGljZXMsIHN0YXJ0LCBtb3ZlKTtcbiAgICB9XG4gIH1cbiAgX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHtcbiAgICBjb25zdCBfZGF0YUNoYW5nZXMgPSB0aGlzLl9kYXRhQ2hhbmdlcztcbiAgICBpZiAoIV9kYXRhQ2hhbmdlcyB8fCAhX2RhdGFDaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRDb3VudCA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgbWFrZVNldCA9IChpZHgpID0+IG5ldyBTZXQoXG4gICAgICBfZGF0YUNoYW5nZXNcbiAgICAgICAgLmZpbHRlcihjID0+IGNbMF0gPT09IGlkeClcbiAgICAgICAgLm1hcCgoYywgaSkgPT4gaSArICcsJyArIGMuc3BsaWNlKDEpLmpvaW4oJywnKSlcbiAgICApO1xuICAgIGNvbnN0IGNoYW5nZVNldCA9IG1ha2VTZXQoMCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkYXRhc2V0Q291bnQ7IGkrKykge1xuICAgICAgaWYgKCFzZXRzRXF1YWwoY2hhbmdlU2V0LCBtYWtlU2V0KGkpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGNoYW5nZVNldClcbiAgICAgIC5tYXAoYyA9PiBjLnNwbGl0KCcsJykpXG4gICAgICAubWFwKGEgPT4gKHttZXRob2Q6IGFbMV0sIHN0YXJ0OiArYVsyXSwgY291bnQ6ICthWzNdfSkpO1xuICB9XG4gIF91cGRhdGVMYXlvdXQobWluUGFkZGluZykge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUxheW91dCcsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxheW91dHMudXBkYXRlKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBtaW5QYWRkaW5nKTtcbiAgICBjb25zdCBhcmVhID0gdGhpcy5jaGFydEFyZWE7XG4gICAgY29uc3Qgbm9BcmVhID0gYXJlYS53aWR0aCA8PSAwIHx8IGFyZWEuaGVpZ2h0IDw9IDA7XG4gICAgdGhpcy5fbGF5ZXJzID0gW107XG4gICAgZWFjaCh0aGlzLmJveGVzLCAoYm94KSA9PiB7XG4gICAgICBpZiAobm9BcmVhICYmIGJveC5wb3NpdGlvbiA9PT0gJ2NoYXJ0QXJlYScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGJveC5jb25maWd1cmUpIHtcbiAgICAgICAgYm94LmNvbmZpZ3VyZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGF5ZXJzLnB1c2goLi4uYm94Ll9sYXllcnMoKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fbGF5ZXJzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBpdGVtLl9pZHggPSBpbmRleDtcbiAgICB9KTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyTGF5b3V0Jyk7XG4gIH1cbiAgX3VwZGF0ZURhdGFzZXRzKG1vZGUpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c1VwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyLmNvbmZpZ3VyZSgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURhdGFzZXQoaSwgaXNGdW5jdGlvbihtb2RlKSA/IG1vZGUoe2RhdGFzZXRJbmRleDogaX0pIDogbW9kZSk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c1VwZGF0ZScsIHttb2RlfSk7XG4gIH1cbiAgX3VwZGF0ZURhdGFzZXQoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gICAgY29uc3QgYXJncyA9IHttZXRhLCBpbmRleCwgbW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX07XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldFVwZGF0ZScsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtZXRhLmNvbnRyb2xsZXIuX3VwZGF0ZShtb2RlKTtcbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldFVwZGF0ZScsIGFyZ3MpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVSZW5kZXInLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0b3IuaGFzKHRoaXMpKSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgICBhbmltYXRvci5zdGFydCh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICBvbkFuaW1hdGlvbnNDb21wbGV0ZSh7Y2hhcnQ6IHRoaXN9KTtcbiAgICB9XG4gIH1cbiAgZHJhdygpIHtcbiAgICBsZXQgaTtcbiAgICBpZiAodGhpcy5fcmVzaXplQmVmb3JlRHJhdykge1xuICAgICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5fcmVzaXplQmVmb3JlRHJhdztcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURyYXcnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gICAgZm9yIChpID0gMDsgaSA8IGxheWVycy5sZW5ndGggJiYgbGF5ZXJzW2ldLnogPD0gMDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuICAgIHRoaXMuX2RyYXdEYXRhc2V0cygpO1xuICAgIGZvciAoOyBpIDwgbGF5ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEcmF3Jyk7XG4gIH1cbiAgX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9zb3J0ZWRNZXRhc2V0cztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNldHNbaV07XG4gICAgICBpZiAoIWZpbHRlclZpc2libGUgfHwgbWV0YS52aXNpYmxlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0cnVlKTtcbiAgfVxuICBfZHJhd0RhdGFzZXRzKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0aGlzLl9kcmF3RGF0YXNldChtZXRhc2V0c1tpXSk7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0c0RyYXcnKTtcbiAgfVxuICBfZHJhd0RhdGFzZXQobWV0YSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGNsaXAgPSBtZXRhLl9jbGlwO1xuICAgIGNvbnN0IHVzZUNsaXAgPSAhY2xpcC5kaXNhYmxlZDtcbiAgICBjb25zdCBhcmVhID0gdGhpcy5jaGFydEFyZWE7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIG1ldGEsXG4gICAgICBpbmRleDogbWV0YS5pbmRleCxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9O1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXREcmF3JywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIHtcbiAgICAgICAgbGVmdDogY2xpcC5sZWZ0ID09PSBmYWxzZSA/IDAgOiBhcmVhLmxlZnQgLSBjbGlwLmxlZnQsXG4gICAgICAgIHJpZ2h0OiBjbGlwLnJpZ2h0ID09PSBmYWxzZSA/IHRoaXMud2lkdGggOiBhcmVhLnJpZ2h0ICsgY2xpcC5yaWdodCxcbiAgICAgICAgdG9wOiBjbGlwLnRvcCA9PT0gZmFsc2UgPyAwIDogYXJlYS50b3AgLSBjbGlwLnRvcCxcbiAgICAgICAgYm90dG9tOiBjbGlwLmJvdHRvbSA9PT0gZmFsc2UgPyB0aGlzLmhlaWdodCA6IGFyZWEuYm90dG9tICsgY2xpcC5ib3R0b21cbiAgICAgIH0pO1xuICAgIH1cbiAgICBtZXRhLmNvbnRyb2xsZXIuZHJhdygpO1xuICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0RHJhdycsIGFyZ3MpO1xuICB9XG4gIGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgbW9kZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IG1ldGhvZCA9IEludGVyYWN0aW9uLm1vZGVzW21vZGVdO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbWV0aG9kKHRoaXMsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgbGV0IG1ldGEgPSBtZXRhc2V0cy5maWx0ZXIoeCA9PiB4ICYmIHguX2RhdGFzZXQgPT09IGRhdGFzZXQpLnBvcCgpO1xuICAgIGlmICghbWV0YSkge1xuICAgICAgbWV0YSA9IHtcbiAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGRhdGFzZXQ6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgIGhpZGRlbjogbnVsbCxcbiAgICAgICAgeEF4aXNJRDogbnVsbCxcbiAgICAgICAgeUF4aXNJRDogbnVsbCxcbiAgICAgICAgb3JkZXI6IGRhdGFzZXQgJiYgZGF0YXNldC5vcmRlciB8fCAwLFxuICAgICAgICBpbmRleDogZGF0YXNldEluZGV4LFxuICAgICAgICBfZGF0YXNldDogZGF0YXNldCxcbiAgICAgICAgX3BhcnNlZDogW10sXG4gICAgICAgIF9zb3J0ZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgbWV0YXNldHMucHVzaChtZXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGE7XG4gIH1cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fCAodGhpcy4kY29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCwge2NoYXJ0OiB0aGlzLCB0eXBlOiAnY2hhcnQnfSkpO1xuICB9XG4gIGdldFZpc2libGVEYXRhc2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmxlbmd0aDtcbiAgfVxuICBpc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICByZXR1cm4gdHlwZW9mIG1ldGEuaGlkZGVuID09PSAnYm9vbGVhbicgPyAhbWV0YS5oaWRkZW4gOiAhZGF0YXNldC5oaWRkZW47XG4gIH1cbiAgc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBtZXRhLmhpZGRlbiA9ICF2aXNpYmxlO1xuICB9XG4gIHRvZ2dsZURhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF0gPSAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cbiAgZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICByZXR1cm4gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG4gIF91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbW9kZSA9IHZpc2libGUgPyAnc2hvdycgOiAnaGlkZSc7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBhbmltcyA9IG1ldGEuY29udHJvbGxlci5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKTtcbiAgICBpZiAoZGVmaW5lZChkYXRhSW5kZXgpKSB7XG4gICAgICBtZXRhLmRhdGFbZGF0YUluZGV4XS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKTtcbiAgICAgIGFuaW1zLnVwZGF0ZShtZXRhLCB7dmlzaWJsZX0pO1xuICAgICAgdGhpcy51cGRhdGUoKGN0eCkgPT4gY3R4LmRhdGFzZXRJbmRleCA9PT0gZGF0YXNldEluZGV4ID8gbW9kZSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9XG4gIGhpZGUoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCBmYWxzZSk7XG4gIH1cbiAgc2hvdyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHRydWUpO1xuICB9XG4gIF9kZXN0cm95RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKG1ldGEgJiYgbWV0YS5jb250cm9sbGVyKSB7XG4gICAgICBtZXRhLmNvbnRyb2xsZXIuX2Rlc3Ryb3koKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gIH1cbiAgX3N0b3AoKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgYW5pbWF0b3IucmVtb3ZlKHRoaXMpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEZXN0cm95Jyk7XG4gICAgY29uc3Qge2NhbnZhcywgY3R4fSA9IHRoaXM7XG4gICAgdGhpcy5fc3RvcCgpO1xuICAgIHRoaXMuY29uZmlnLmNsZWFyQ2FjaGUoKTtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpO1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZWxlYXNlQ29udGV4dChjdHgpO1xuICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2Rlc3Ryb3knKTtcbiAgICBkZWxldGUgaW5zdGFuY2VzW3RoaXMuaWRdO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEZXN0cm95Jyk7XG4gIH1cbiAgdG9CYXNlNjRJbWFnZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTCguLi5hcmdzKTtcbiAgfVxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuYmluZFVzZXJFdmVudHMoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMuYmluZFJlc3BvbnNpdmVFdmVudHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGJpbmRVc2VyRXZlbnRzKCkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG4gICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgcGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKGUsIHgsIHkpID0+IHtcbiAgICAgIGUub2Zmc2V0WCA9IHg7XG4gICAgICBlLm9mZnNldFkgPSB5O1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKGUpO1xuICAgIH07XG4gICAgZWFjaCh0aGlzLm9wdGlvbnMuZXZlbnRzLCAodHlwZSkgPT4gX2FkZCh0eXBlLCBsaXN0ZW5lcikpO1xuICB9XG4gIGJpbmRSZXNwb25zaXZlRXZlbnRzKCkge1xuICAgIGlmICghdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG4gICAgY29uc3QgX3JlbW92ZSA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICBwbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1t0eXBlXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBkZXRhY2hlZDtcbiAgICBjb25zdCBhdHRhY2hlZCA9ICgpID0+IHtcbiAgICAgIF9yZW1vdmUoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgIF9hZGQoJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcbiAgICAgIF9hZGQoJ2RldGFjaCcsIGRldGFjaGVkKTtcbiAgICB9O1xuICAgIGRldGFjaGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgX3JlbW92ZSgncmVzaXplJywgbGlzdGVuZXIpO1xuICAgICAgdGhpcy5fc3RvcCgpO1xuICAgICAgdGhpcy5fcmVzaXplKDAsIDApO1xuICAgICAgX2FkZCgnYXR0YWNoJywgYXR0YWNoZWQpO1xuICAgIH07XG4gICAgaWYgKHBsYXRmb3JtLmlzQXR0YWNoZWQodGhpcy5jYW52YXMpKSB7XG4gICAgICBhdHRhY2hlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhY2hlZCgpO1xuICAgIH1cbiAgfVxuICB1bmJpbmRFdmVudHMoKSB7XG4gICAgZWFjaCh0aGlzLl9saXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICBlYWNoKHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICB9XG4gIHVwZGF0ZUhvdmVyU3R5bGUoaXRlbXMsIG1vZGUsIGVuYWJsZWQpIHtcbiAgICBjb25zdCBwcmVmaXggPSBlbmFibGVkID8gJ3NldCcgOiAncmVtb3ZlJztcbiAgICBsZXQgbWV0YSwgaXRlbSwgaSwgaWxlbjtcbiAgICBpZiAobW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtc1swXS5kYXRhc2V0SW5kZXgpO1xuICAgICAgbWV0YS5jb250cm9sbGVyWydfJyArIHByZWZpeCArICdEYXRhc2V0SG92ZXJTdHlsZSddKCk7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBpdGVtICYmIHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbS5kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyW3ByZWZpeCArICdIb3ZlclN0eWxlJ10oaXRlbS5lbGVtZW50LCBpdGVtLmRhdGFzZXRJbmRleCwgaXRlbS5pbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMpIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YXNldCBmb3VuZCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgfVxuICB9XG4gIG5vdGlmeVBsdWdpbnMoaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdWdpbnMubm90aWZ5KHRoaXMsIGhvb2ssIGFyZ3MsIGZpbHRlcik7XG4gIH1cbiAgX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgaG92ZXJPcHRpb25zID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5kYXRhc2V0SW5kZXggPT09IHkuZGF0YXNldEluZGV4ICYmIHguaW5kZXggPT09IHkuaW5kZXgpKTtcbiAgICBjb25zdCBkZWFjdGl2YXRlZCA9IGRpZmYobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBhY3RpdmF0ZWQgPSByZXBsYXkgPyBhY3RpdmUgOiBkaWZmKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGRlYWN0aXZhdGVkLmxlbmd0aCkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGRlYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAoYWN0aXZhdGVkLmxlbmd0aCAmJiBob3Zlck9wdGlvbnMubW9kZSkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGFjdGl2YXRlZCwgaG92ZXJPcHRpb25zLm1vZGUsIHRydWUpO1xuICAgIH1cbiAgfVxuICBfZXZlbnRIYW5kbGVyKGUsIHJlcGxheSkge1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBldmVudDogZSxcbiAgICAgIHJlcGxheSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBpbkNoYXJ0QXJlYTogX2lzUG9pbnRJbkFyZWEoZSwgdGhpcy5jaGFydEFyZWEsIHRoaXMuX21pblBhZGRpbmcpXG4gICAgfTtcbiAgICBjb25zdCBldmVudEZpbHRlciA9IChwbHVnaW4pID0+IChwbHVnaW4ub3B0aW9ucy5ldmVudHMgfHwgdGhpcy5vcHRpb25zLmV2ZW50cykuaW5jbHVkZXMoZS5uYXRpdmUudHlwZSk7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRXZlbnQnLCBhcmdzLCBldmVudEZpbHRlcikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLl9oYW5kbGVFdmVudChlLCByZXBsYXksIGFyZ3MuaW5DaGFydEFyZWEpO1xuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKTtcbiAgICBpZiAoY2hhbmdlZCB8fCBhcmdzLmNoYW5nZWQpIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9oYW5kbGVFdmVudChlLCByZXBsYXksIGluQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qge19hY3RpdmU6IGxhc3RBY3RpdmUgPSBbXSwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSByZXBsYXk7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgaW5DaGFydEFyZWEsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IGlzQ2xpY2sgPSBfaXNDbGlja0V2ZW50KGUpO1xuICAgIGNvbnN0IGxhc3RFdmVudCA9IGRldGVybWluZUxhc3RFdmVudChlLCB0aGlzLl9sYXN0RXZlbnQsIGluQ2hhcnRBcmVhLCBpc0NsaWNrKTtcbiAgICBpZiAoaW5DaGFydEFyZWEpIHtcbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG4gICAgICBjYWxsYmFjayhvcHRpb25zLm9uSG92ZXIsIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcbiAgICAgIGlmIChpc0NsaWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG9wdGlvbnMub25DbGljaywgW2UsIGFjdGl2ZSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGNoYW5nZWQgfHwgcmVwbGF5KSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSk7XG4gICAgfVxuICAgIHRoaXMuX2xhc3RFdmVudCA9IGxhc3RFdmVudDtcbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgaW5DaGFydEFyZWEsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgIHJldHVybiBsYXN0QWN0aXZlO1xuICAgIH1cbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaG92ZXI7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBob3Zlck9wdGlvbnMubW9kZSwgaG92ZXJPcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxufVxuY29uc3QgaW52YWxpZGF0ZVBsdWdpbnMgPSAoKSA9PiBlYWNoKENoYXJ0Lmluc3RhbmNlcywgKGNoYXJ0KSA9PiBjaGFydC5fcGx1Z2lucy5pbnZhbGlkYXRlKCkpO1xuY29uc3QgZW51bWVyYWJsZSA9IHRydWU7XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaGFydCwge1xuICBkZWZhdWx0czoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IGRlZmF1bHRzXG4gIH0sXG4gIGluc3RhbmNlczoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IGluc3RhbmNlc1xuICB9LFxuICBvdmVycmlkZXM6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiBvdmVycmlkZXNcbiAgfSxcbiAgcmVnaXN0cnk6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiByZWdpc3RyeVxuICB9LFxuICB2ZXJzaW9uOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogdmVyc2lvblxuICB9LFxuICBnZXRDaGFydDoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IGdldENoYXJ0XG4gIH0sXG4gIHJlZ2lzdGVyOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogKC4uLml0ZW1zKSA9PiB7XG4gICAgICByZWdpc3RyeS5hZGQoLi4uaXRlbXMpO1xuICAgICAgaW52YWxpZGF0ZVBsdWdpbnMoKTtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXI6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiAoLi4uaXRlbXMpID0+IHtcbiAgICAgIHJlZ2lzdHJ5LnJlbW92ZSguLi5pdGVtcyk7XG4gICAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSkge1xuICBjb25zdCB7c3RhcnRBbmdsZSwgcGl4ZWxNYXJnaW4sIHgsIHksIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1c30gPSBlbGVtZW50O1xuICBsZXQgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIG91dGVyUmFkaXVzO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbik7XG4gIGlmIChpbm5lclJhZGl1cyA+IHBpeGVsTWFyZ2luKSB7XG4gICAgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIGlubmVyUmFkaXVzO1xuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4sIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmFyYyh4LCB5LCBwaXhlbE1hcmdpbiwgZW5kQW5nbGUgKyBIQUxGX1BJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gIH1cbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguY2xpcCgpO1xufVxuZnVuY3Rpb24gdG9SYWRpdXNDb3JuZXJzKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWydvdXRlclN0YXJ0JywgJ291dGVyRW5kJywgJ2lubmVyU3RhcnQnLCAnaW5uZXJFbmQnXSk7XG59XG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyQxKGFyYywgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBhbmdsZURlbHRhKSB7XG4gIGNvbnN0IG8gPSB0b1JhZGl1c0Nvcm5lcnMoYXJjLm9wdGlvbnMuYm9yZGVyUmFkaXVzKTtcbiAgY29uc3QgaGFsZlRoaWNrbmVzcyA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIDI7XG4gIGNvbnN0IGlubmVyTGltaXQgPSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBhbmdsZURlbHRhICogaW5uZXJSYWRpdXMgLyAyKTtcbiAgY29uc3QgY29tcHV0ZU91dGVyTGltaXQgPSAodmFsKSA9PiB7XG4gICAgY29uc3Qgb3V0ZXJBcmNMaW1pdCA9IChvdXRlclJhZGl1cyAtIE1hdGgubWluKGhhbGZUaGlja25lc3MsIHZhbCkpICogYW5nbGVEZWx0YSAvIDI7XG4gICAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbCwgMCwgTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgb3V0ZXJBcmNMaW1pdCkpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG91dGVyU3RhcnQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJTdGFydCksXG4gICAgb3V0ZXJFbmQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJFbmQpLFxuICAgIGlubmVyU3RhcnQ6IF9saW1pdFZhbHVlKG8uaW5uZXJTdGFydCwgMCwgaW5uZXJMaW1pdCksXG4gICAgaW5uZXJFbmQ6IF9saW1pdFZhbHVlKG8uaW5uZXJFbmQsIDAsIGlubmVyTGltaXQpLFxuICB9O1xufVxuZnVuY3Rpb24gclRoZXRhVG9YWShyLCB0aGV0YSwgeCwgeSkge1xuICByZXR1cm4ge1xuICAgIHg6IHggKyByICogTWF0aC5jb3ModGhldGEpLFxuICAgIHk6IHkgKyByICogTWF0aC5zaW4odGhldGEpLFxuICB9O1xufVxuZnVuY3Rpb24gcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kKSB7XG4gIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlOiBzdGFydCwgcGl4ZWxNYXJnaW4sIGlubmVyUmFkaXVzOiBpbm5lclJ9ID0gZWxlbWVudDtcbiAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChlbGVtZW50Lm91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCAtIHBpeGVsTWFyZ2luLCAwKTtcbiAgY29uc3QgaW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSICsgc3BhY2luZyArIG9mZnNldCArIHBpeGVsTWFyZ2luIDogMDtcbiAgbGV0IHNwYWNpbmdPZmZzZXQgPSAwO1xuICBjb25zdCBhbHBoYSA9IGVuZCAtIHN0YXJ0O1xuICBpZiAoc3BhY2luZykge1xuICAgIGNvbnN0IG5vU3BhY2luZ0lubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IG5vU3BhY2luZ091dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgPiAwID8gb3V0ZXJSYWRpdXMgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBhdk5vZ1NwYWNpbmdSYWRpdXMgPSAobm9TcGFjaW5nSW5uZXJSYWRpdXMgKyBub1NwYWNpbmdPdXRlclJhZGl1cykgLyAyO1xuICAgIGNvbnN0IGFkanVzdGVkQW5nbGUgPSBhdk5vZ1NwYWNpbmdSYWRpdXMgIT09IDAgPyAoYWxwaGEgKiBhdk5vZ1NwYWNpbmdSYWRpdXMpIC8gKGF2Tm9nU3BhY2luZ1JhZGl1cyArIHNwYWNpbmcpIDogYWxwaGE7XG4gICAgc3BhY2luZ09mZnNldCA9IChhbHBoYSAtIGFkanVzdGVkQW5nbGUpIC8gMjtcbiAgfVxuICBjb25zdCBiZXRhID0gTWF0aC5tYXgoMC4wMDEsIGFscGhhICogb3V0ZXJSYWRpdXMgLSBvZmZzZXQgLyBQSSkgLyBvdXRlclJhZGl1cztcbiAgY29uc3QgYW5nbGVPZmZzZXQgPSAoYWxwaGEgLSBiZXRhKSAvIDI7XG4gIGNvbnN0IHN0YXJ0QW5nbGUgPSBzdGFydCArIGFuZ2xlT2Zmc2V0ICsgc3BhY2luZ09mZnNldDtcbiAgY29uc3QgZW5kQW5nbGUgPSBlbmQgLSBhbmdsZU9mZnNldCAtIHNwYWNpbmdPZmZzZXQ7XG4gIGNvbnN0IHtvdXRlclN0YXJ0LCBvdXRlckVuZCwgaW5uZXJTdGFydCwgaW5uZXJFbmR9ID0gcGFyc2VCb3JkZXJSYWRpdXMkMShlbGVtZW50LCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJTdGFydDtcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJFbmQ7XG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIG91dGVyU3RhcnQgLyBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gb3V0ZXJFbmQgLyBvdXRlckVuZEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyU3RhcnQ7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyRW5kO1xuICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBpbm5lclN0YXJ0IC8gaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBpbm5lckVuZEFkanVzdGVkQW5nbGUgPSBlbmRBbmdsZSAtIGlubmVyRW5kIC8gaW5uZXJFbmRBZGp1c3RlZFJhZGl1cztcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKTtcbiAgaWYgKG91dGVyRW5kID4gMCkge1xuICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJFbmQsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgZW5kQW5nbGUgKyBIQUxGX1BJKTtcbiAgfVxuICBjb25zdCBwNCA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgZW5kQW5nbGUsIHgsIHkpO1xuICBjdHgubGluZVRvKHA0LngsIHA0LnkpO1xuICBpZiAoaW5uZXJFbmQgPiAwKSB7XG4gICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lckVuZCwgZW5kQW5nbGUgKyBIQUxGX1BJLCBpbm5lckVuZEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJKTtcbiAgfVxuICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSAtIChpbm5lckVuZCAvIGlubmVyUmFkaXVzKSwgc3RhcnRBbmdsZSArIChpbm5lclN0YXJ0IC8gaW5uZXJSYWRpdXMpLCB0cnVlKTtcbiAgaWYgKGlubmVyU3RhcnQgPiAwKSB7XG4gICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzLCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJTdGFydCwgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gIH1cbiAgY29uc3QgcDggPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgc3RhcnRBbmdsZSwgeCwgeSk7XG4gIGN0eC5saW5lVG8ocDgueCwgcDgueSk7XG4gIGlmIChvdXRlclN0YXJ0ID4gMCkge1xuICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyU3RhcnQsIHN0YXJ0QW5nbGUgLSBIQUxGX1BJLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSk7XG4gIH1cbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuZnVuY3Rpb24gZHJhd0FyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZykge1xuICBjb25zdCB7ZnVsbENpcmNsZXMsIHN0YXJ0QW5nbGUsIGNpcmN1bWZlcmVuY2V9ID0gZWxlbWVudDtcbiAgbGV0IGVuZEFuZ2xlID0gZWxlbWVudC5lbmRBbmdsZTtcbiAgaWYgKGZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgc3RhcnRBbmdsZSArIFRBVSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlICUgVEFVO1xuICAgICAgaWYgKGNpcmN1bWZlcmVuY2UgJSBUQVUgPT09IDApIHtcbiAgICAgICAgZW5kQW5nbGUgKz0gVEFVO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSk7XG4gIGN0eC5maWxsKCk7XG4gIHJldHVybiBlbmRBbmdsZTtcbn1cbmZ1bmN0aW9uIGRyYXdGdWxsQ2lyY2xlQm9yZGVycyhjdHgsIGVsZW1lbnQsIGlubmVyKSB7XG4gIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlLCBwaXhlbE1hcmdpbiwgZnVsbENpcmNsZXN9ID0gZWxlbWVudDtcbiAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChlbGVtZW50Lm91dGVyUmFkaXVzIC0gcGl4ZWxNYXJnaW4sIDApO1xuICBjb25zdCBpbm5lclJhZGl1cyA9IGVsZW1lbnQuaW5uZXJSYWRpdXMgKyBwaXhlbE1hcmdpbjtcbiAgbGV0IGk7XG4gIGlmIChpbm5lcikge1xuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBzdGFydEFuZ2xlICsgVEFVKTtcbiAgfVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIHN0YXJ0QW5nbGUgKyBUQVUsIHN0YXJ0QW5nbGUsIHRydWUpO1xuICBmb3IgKGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUsIHN0YXJ0QW5nbGUgKyBUQVUpO1xuICBmb3IgKGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gZHJhd0JvcmRlcihjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUpIHtcbiAgY29uc3Qge29wdGlvbnN9ID0gZWxlbWVudDtcbiAgY29uc3Qge2JvcmRlcldpZHRoLCBib3JkZXJKb2luU3R5bGV9ID0gb3B0aW9ucztcbiAgY29uc3QgaW5uZXIgPSBvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInO1xuICBpZiAoIWJvcmRlcldpZHRoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbm5lcikge1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aCAqIDI7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdyb3VuZCc7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgIGN0eC5saW5lSm9pbiA9IGJvcmRlckpvaW5TdHlsZSB8fCAnYmV2ZWwnO1xuICB9XG4gIGlmIChlbGVtZW50LmZ1bGxDaXJjbGVzKSB7XG4gICAgZHJhd0Z1bGxDaXJjbGVCb3JkZXJzKGN0eCwgZWxlbWVudCwgaW5uZXIpO1xuICB9XG4gIGlmIChpbm5lcikge1xuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSk7XG4gIH1cbiAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUpO1xuICBjdHguc3Ryb2tlKCk7XG59XG5jbGFzcyBBcmNFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2lyY3VtZmVyZW5jZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IDA7XG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IDA7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICBpblJhbmdlKGNoYXJ0WCwgY2hhcnRZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZSwgZGlzdGFuY2V9ID0gZ2V0QW5nbGVGcm9tUG9pbnQocG9pbnQsIHt4OiBjaGFydFgsIHk6IGNoYXJ0WX0pO1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgckFkanVzdCA9IHRoaXMub3B0aW9ucy5zcGFjaW5nIC8gMjtcbiAgICBjb25zdCBfY2lyY3VtZmVyZW5jZSA9IHZhbHVlT3JEZWZhdWx0KGNpcmN1bWZlcmVuY2UsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgYmV0d2VlbkFuZ2xlcyA9IF9jaXJjdW1mZXJlbmNlID49IFRBVSB8fCBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgY29uc3Qgd2l0aGluUmFkaXVzID0gX2lzQmV0d2VlbihkaXN0YW5jZSwgaW5uZXJSYWRpdXMgKyByQWRqdXN0LCBvdXRlclJhZGl1cyArIHJBZGp1c3QpO1xuICAgIHJldHVybiAoYmV0d2VlbkFuZ2xlcyAmJiB3aXRoaW5SYWRpdXMpO1xuICB9XG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1c30gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICd4JyxcbiAgICAgICd5JyxcbiAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICdlbmRBbmdsZScsXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJyxcbiAgICAgICdjaXJjdW1mZXJlbmNlJyxcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7b2Zmc2V0LCBzcGFjaW5nfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBoYWxmQW5nbGUgPSAoc3RhcnRBbmdsZSArIGVuZEFuZ2xlKSAvIDI7XG4gICAgY29uc3QgaGFsZlJhZGl1cyA9IChpbm5lclJhZGl1cyArIG91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCkgLyAyO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICsgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcbiAgICB9O1xuICB9XG4gIHRvb2x0aXBQb3NpdGlvbih1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgY2lyY3VtZmVyZW5jZX0gPSB0aGlzO1xuICAgIGNvbnN0IG9mZnNldCA9IChvcHRpb25zLm9mZnNldCB8fCAwKSAvIDI7XG4gICAgY29uc3Qgc3BhY2luZyA9IChvcHRpb25zLnNwYWNpbmcgfHwgMCkgLyAyO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAob3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykgPyAwLjMzIDogMDtcbiAgICB0aGlzLmZ1bGxDaXJjbGVzID0gY2lyY3VtZmVyZW5jZSA+IFRBVSA/IE1hdGguZmxvb3IoY2lyY3VtZmVyZW5jZSAvIFRBVSkgOiAwO1xuICAgIGlmIChjaXJjdW1mZXJlbmNlID09PSAwIHx8IHRoaXMuaW5uZXJSYWRpdXMgPCAwIHx8IHRoaXMub3V0ZXJSYWRpdXMgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgbGV0IHJhZGl1c09mZnNldCA9IDA7XG4gICAgaWYgKG9mZnNldCkge1xuICAgICAgcmFkaXVzT2Zmc2V0ID0gb2Zmc2V0IC8gMjtcbiAgICAgIGNvbnN0IGhhbGZBbmdsZSA9ICh0aGlzLnN0YXJ0QW5nbGUgKyB0aGlzLmVuZEFuZ2xlKSAvIDI7XG4gICAgICBjdHgudHJhbnNsYXRlKE1hdGguY29zKGhhbGZBbmdsZSkgKiByYWRpdXNPZmZzZXQsIE1hdGguc2luKGhhbGZBbmdsZSkgKiByYWRpdXNPZmZzZXQpO1xuICAgICAgaWYgKHRoaXMuY2lyY3VtZmVyZW5jZSA+PSBQSSkge1xuICAgICAgICByYWRpdXNPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gZHJhd0FyYyhjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZyk7XG4gICAgZHJhd0JvcmRlcihjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgZW5kQW5nbGUpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn1cbkFyY0VsZW1lbnQuaWQgPSAnYXJjJztcbkFyY0VsZW1lbnQuZGVmYXVsdHMgPSB7XG4gIGJvcmRlckFsaWduOiAnY2VudGVyJyxcbiAgYm9yZGVyQ29sb3I6ICcjZmZmJyxcbiAgYm9yZGVySm9pblN0eWxlOiB1bmRlZmluZWQsXG4gIGJvcmRlclJhZGl1czogMCxcbiAgYm9yZGVyV2lkdGg6IDIsXG4gIG9mZnNldDogMCxcbiAgc3BhY2luZzogMCxcbiAgYW5nbGU6IHVuZGVmaW5lZCxcbn07XG5BcmNFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcidcbn07XG5cbmZ1bmN0aW9uIHNldFN0eWxlKGN0eCwgb3B0aW9ucywgc3R5bGUgPSBvcHRpb25zKSB7XG4gIGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ2FwU3R5bGUsIG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUpO1xuICBjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaCwgb3B0aW9ucy5ib3JkZXJEYXNoKSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsIG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCk7XG4gIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckpvaW5TdHlsZSwgb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUpO1xuICBjdHgubGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDb2xvciwgb3B0aW9ucy5ib3JkZXJDb2xvcik7XG59XG5mdW5jdGlvbiBsaW5lVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0KSB7XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cbmZ1bmN0aW9uIGdldExpbmVNZXRob2Qob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgcmV0dXJuIF9zdGVwcGVkTGluZVRvO1xuICB9XG4gIGlmIChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgcmV0dXJuIF9iZXppZXJDdXJ2ZVRvO1xuICB9XG4gIHJldHVybiBsaW5lVG87XG59XG5mdW5jdGlvbiBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyA9IHt9KSB7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge3N0YXJ0OiBwYXJhbXNTdGFydCA9IDAsIGVuZDogcGFyYW1zRW5kID0gY291bnQgLSAxfSA9IHBhcmFtcztcbiAgY29uc3Qge3N0YXJ0OiBzZWdtZW50U3RhcnQsIGVuZDogc2VnbWVudEVuZH0gPSBzZWdtZW50O1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHBhcmFtc1N0YXJ0LCBzZWdtZW50U3RhcnQpO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbihwYXJhbXNFbmQsIHNlZ21lbnRFbmQpO1xuICBjb25zdCBvdXRzaWRlID0gcGFyYW1zU3RhcnQgPCBzZWdtZW50U3RhcnQgJiYgcGFyYW1zRW5kIDwgc2VnbWVudFN0YXJ0IHx8IHBhcmFtc1N0YXJ0ID4gc2VnbWVudEVuZCAmJiBwYXJhbXNFbmQgPiBzZWdtZW50RW5kO1xuICByZXR1cm4ge1xuICAgIGNvdW50LFxuICAgIHN0YXJ0LFxuICAgIGxvb3A6IHNlZ21lbnQubG9vcCxcbiAgICBpbGVuOiBlbmQgPCBzdGFydCAmJiAhb3V0c2lkZSA/IGNvdW50ICsgZW5kIC0gc3RhcnQgOiBlbmQgLSBzdGFydFxuICB9O1xufVxuZnVuY3Rpb24gcGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3Qge3BvaW50cywgb3B0aW9uc30gPSBsaW5lO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBsb29wLCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3QgbGluZU1ldGhvZCA9IGdldExpbmVNZXRob2Qob3B0aW9ucyk7XG4gIGxldCB7bW92ZSA9IHRydWUsIHJldmVyc2V9ID0gcGFyYW1zIHx8IHt9O1xuICBsZXQgaSwgcG9pbnQsIHByZXY7XG4gIGZvciAoaSA9IDA7IGkgPD0gaWxlbjsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaSA6IGkpKSAlIGNvdW50XTtcbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChtb3ZlKSB7XG4gICAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgbW92ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgfVxuICAgIHByZXYgPSBwb2ludDtcbiAgfVxuICBpZiAobG9vcCkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiA6IDApKSAlIGNvdW50XTtcbiAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gIH1cbiAgcmV0dXJuICEhbG9vcDtcbn1cbmZ1bmN0aW9uIGZhc3RQYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3Qge2NvdW50LCBzdGFydCwgaWxlbn0gPSBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIGNvbnN0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgcHJldlgsIG1pblksIG1heFksIGxhc3RZO1xuICBjb25zdCBwb2ludEluZGV4ID0gKGluZGV4KSA9PiAoc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpbmRleCA6IGluZGV4KSkgJSBjb3VudDtcbiAgY29uc3QgZHJhd1ggPSAoKSA9PiB7XG4gICAgaWYgKG1pblkgIT09IG1heFkpIHtcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWF4WSk7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1pblkpO1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBsYXN0WSk7XG4gICAgfVxuICB9O1xuICBpZiAobW92ZSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoMCldO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8PSBpbGVuOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1twb2ludEluZGV4KGkpXTtcbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHggPSBwb2ludC54O1xuICAgIGNvbnN0IHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwO1xuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgIG1heFkgPSB5O1xuICAgICAgfVxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgeCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhd1goKTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgfVxuICAgIGxhc3RZID0geTtcbiAgfVxuICBkcmF3WCgpO1xufVxuZnVuY3Rpb24gX2dldFNlZ21lbnRNZXRob2QobGluZSkge1xuICBjb25zdCBvcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBib3JkZXJEYXNoID0gb3B0cy5ib3JkZXJEYXNoICYmIG9wdHMuYm9yZGVyRGFzaC5sZW5ndGg7XG4gIGNvbnN0IHVzZUZhc3RQYXRoID0gIWxpbmUuX2RlY2ltYXRlZCAmJiAhbGluZS5fbG9vcCAmJiAhb3B0cy50ZW5zaW9uICYmIG9wdHMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSAhPT0gJ21vbm90b25lJyAmJiAhb3B0cy5zdGVwcGVkICYmICFib3JkZXJEYXNoO1xuICByZXR1cm4gdXNlRmFzdFBhdGggPyBmYXN0UGF0aFNlZ21lbnQgOiBwYXRoU2VnbWVudDtcbn1cbmZ1bmN0aW9uIF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xuICAgIHJldHVybiBfc3RlcHBlZEludGVycG9sYXRpb247XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckludGVycG9sYXRpb247XG4gIH1cbiAgcmV0dXJuIF9wb2ludEluTGluZTtcbn1cbmZ1bmN0aW9uIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgbGV0IHBhdGggPSBsaW5lLl9wYXRoO1xuICBpZiAoIXBhdGgpIHtcbiAgICBwYXRoID0gbGluZS5fcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICBpZiAobGluZS5wYXRoKHBhdGgsIHN0YXJ0LCBjb3VudCkpIHtcbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9XG4gIHNldFN0eWxlKGN0eCwgbGluZS5vcHRpb25zKTtcbiAgY3R4LnN0cm9rZShwYXRoKTtcbn1cbmZ1bmN0aW9uIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3Qge3NlZ21lbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzZWdtZW50LnN0eWxlKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgaWYgKHNlZ21lbnRNZXRob2QoY3R4LCBsaW5lLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KSkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cbmNvbnN0IHVzZVBhdGgyRCA9IHR5cGVvZiBQYXRoMkQgPT09ICdmdW5jdGlvbic7XG5mdW5jdGlvbiBkcmF3KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGlmICh1c2VQYXRoMkQgJiYgIWxpbmUub3B0aW9ucy5zZWdtZW50KSB7XG4gICAgc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH0gZWxzZSB7XG4gICAgc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbn1cbmNsYXNzIExpbmVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5hbmltYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NoYXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2xvb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnVsbExvb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2VnbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZGVjaW1hdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGFzZXRJbmRleCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUNvbnRyb2xQb2ludHMoY2hhcnRBcmVhLCBpbmRleEF4aXMpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICgob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykgJiYgIW9wdGlvbnMuc3RlcHBlZCAmJiAhdGhpcy5fcG9pbnRzVXBkYXRlZCkge1xuICAgICAgY29uc3QgbG9vcCA9IG9wdGlvbnMuc3BhbkdhcHMgPyB0aGlzLl9sb29wIDogdGhpcy5fZnVsbExvb3A7XG4gICAgICBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyh0aGlzLl9wb2ludHMsIG9wdGlvbnMsIGNoYXJ0QXJlYSwgbG9vcCwgaW5kZXhBeGlzKTtcbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBzZXQgcG9pbnRzKHBvaW50cykge1xuICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgICBkZWxldGUgdGhpcy5fc2VnbWVudHM7XG4gICAgZGVsZXRlIHRoaXMuX3BhdGg7XG4gICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICB9XG4gIGdldCBwb2ludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cztcbiAgfVxuICBnZXQgc2VnbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRzIHx8ICh0aGlzLl9zZWdtZW50cyA9IF9jb21wdXRlU2VnbWVudHModGhpcywgdGhpcy5vcHRpb25zLnNlZ21lbnQpKTtcbiAgfVxuICBmaXJzdCgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCAmJiBwb2ludHNbc2VnbWVudHNbMF0uc3RhcnRdO1xuICB9XG4gIGxhc3QoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGNvbnN0IGNvdW50ID0gc2VnbWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBjb3VudCAmJiBwb2ludHNbc2VnbWVudHNbY291bnQgLSAxXS5lbmRdO1xuICB9XG4gIGludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0aGlzLCB7cHJvcGVydHksIHN0YXJ0OiB2YWx1ZSwgZW5kOiB2YWx1ZX0pO1xuICAgIGlmICghc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IF9pbnRlcnBvbGF0ZSA9IF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnRzW2ldO1xuICAgICAgY29uc3QgcDEgPSBwb2ludHNbc3RhcnRdO1xuICAgICAgY29uc3QgcDIgPSBwb2ludHNbZW5kXTtcbiAgICAgIGlmIChwMSA9PT0gcDIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHQgPSBNYXRoLmFicygodmFsdWUgLSBwMVtwcm9wZXJ0eV0pIC8gKHAyW3Byb3BlcnR5XSAtIHAxW3Byb3BlcnR5XSkpO1xuICAgICAgY29uc3QgaW50ZXJwb2xhdGVkID0gX2ludGVycG9sYXRlKHAxLCBwMiwgdCwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICAgIGludGVycG9sYXRlZFtwcm9wZXJ0eV0gPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgICByZXN1bHQucHVzaChpbnRlcnBvbGF0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgfVxuICBwYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHBhcmFtcykge1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICByZXR1cm4gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIH1cbiAgcGF0aChjdHgsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QodGhpcyk7XG4gICAgbGV0IGxvb3AgPSB0aGlzLl9sb29wO1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICBjb3VudCA9IGNvdW50IHx8ICh0aGlzLnBvaW50cy5sZW5ndGggLSBzdGFydCk7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICBsb29wICY9IHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KTtcbiAgICB9XG4gICAgcmV0dXJuICEhbG9vcDtcbiAgfVxuICBkcmF3KGN0eCwgY2hhcnRBcmVhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzIHx8IFtdO1xuICAgIGlmIChwb2ludHMubGVuZ3RoICYmIG9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBkcmF3KGN0eCwgdGhpcywgc3RhcnQsIGNvdW50KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmFuaW1hdGVkKSB7XG4gICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuTGluZUVsZW1lbnQuaWQgPSAnbGluZSc7XG5MaW5lRWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyQ2FwU3R5bGU6ICdidXR0JyxcbiAgYm9yZGVyRGFzaDogW10sXG4gIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gIGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcbiAgYm9yZGVyV2lkdGg6IDMsXG4gIGNhcEJlemllclBvaW50czogdHJ1ZSxcbiAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ2RlZmF1bHQnLFxuICBmaWxsOiBmYWxzZSxcbiAgc3BhbkdhcHM6IGZhbHNlLFxuICBzdGVwcGVkOiBmYWxzZSxcbiAgdGVuc2lvbjogMCxcbn07XG5MaW5lRWxlbWVudC5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xufTtcbkxpbmVFbGVtZW50LmRlc2NyaXB0b3JzID0ge1xuICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAnZmlsbCcsXG59O1xuXG5mdW5jdGlvbiBpblJhbmdlJDEoZWwsIHBvcywgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBvcHRpb25zID0gZWwub3B0aW9ucztcbiAgY29uc3Qge1theGlzXTogdmFsdWV9ID0gZWwuZ2V0UHJvcHMoW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgcmV0dXJuIChNYXRoLmFicyhwb3MgLSB2YWx1ZSkgPCBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzKTtcbn1cbmNsYXNzIFBvaW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhcnNlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNraXAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdG9wID0gdW5kZWZpbmVkO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4gKChNYXRoLnBvdyhtb3VzZVggLSB4LCAyKSArIE1hdGgucG93KG1vdXNlWSAtIHksIDIpKSA8IE1hdGgucG93KG9wdGlvbnMuaGl0UmFkaXVzICsgb3B0aW9ucy5yYWRpdXMsIDIpKTtcbiAgfVxuICBpblhSYW5nZShtb3VzZVgsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSQxKHRoaXMsIG1vdXNlWCwgJ3gnLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBpbllSYW5nZShtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSQxKHRoaXMsIG1vdXNlWSwgJ3knLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge3gsIHl9O1xuICB9XG4gIHNpemUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgMDtcbiAgICByYWRpdXMgPSBNYXRoLm1heChyYWRpdXMsIHJhZGl1cyAmJiBvcHRpb25zLmhvdmVyUmFkaXVzIHx8IDApO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gcmFkaXVzICYmIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICByZXR1cm4gKHJhZGl1cyArIGJvcmRlcldpZHRoKSAqIDI7XG4gIH1cbiAgZHJhdyhjdHgsIGFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICh0aGlzLnNraXAgfHwgb3B0aW9ucy5yYWRpdXMgPCAwLjEgfHwgIV9pc1BvaW50SW5BcmVhKHRoaXMsIGFyZWEsIHRoaXMuc2l6ZShvcHRpb25zKSAvIDIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGRyYXdQb2ludChjdHgsIG9wdGlvbnMsIHRoaXMueCwgdGhpcy55KTtcbiAgfVxuICBnZXRSYW5nZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzO1xuICB9XG59XG5Qb2ludEVsZW1lbnQuaWQgPSAncG9pbnQnO1xuUG9pbnRFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJXaWR0aDogMSxcbiAgaGl0UmFkaXVzOiAxLFxuICBob3ZlckJvcmRlcldpZHRoOiAxLFxuICBob3ZlclJhZGl1czogNCxcbiAgcG9pbnRTdHlsZTogJ2NpcmNsZScsXG4gIHJhZGl1czogMyxcbiAgcm90YXRpb246IDBcbn07XG5Qb2ludEVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbn07XG5cbmZ1bmN0aW9uIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qge3gsIHksIGJhc2UsIHdpZHRoLCBoZWlnaHR9ID0gYmFyLmdldFByb3BzKFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICBsZXQgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBoYWxmO1xuICBpZiAoYmFyLmhvcml6b250YWwpIHtcbiAgICBoYWxmID0gaGVpZ2h0IC8gMjtcbiAgICBsZWZ0ID0gTWF0aC5taW4oeCwgYmFzZSk7XG4gICAgcmlnaHQgPSBNYXRoLm1heCh4LCBiYXNlKTtcbiAgICB0b3AgPSB5IC0gaGFsZjtcbiAgICBib3R0b20gPSB5ICsgaGFsZjtcbiAgfSBlbHNlIHtcbiAgICBoYWxmID0gd2lkdGggLyAyO1xuICAgIGxlZnQgPSB4IC0gaGFsZjtcbiAgICByaWdodCA9IHggKyBoYWxmO1xuICAgIHRvcCA9IE1hdGgubWluKHksIGJhc2UpO1xuICAgIGJvdHRvbSA9IE1hdGgubWF4KHksIGJhc2UpO1xuICB9XG4gIHJldHVybiB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfTtcbn1cbmZ1bmN0aW9uIHNraXBPckxpbWl0KHNraXAsIHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gc2tpcCA/IDAgOiBfbGltaXRWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpO1xufVxuZnVuY3Rpb24gcGFyc2VCb3JkZXJXaWR0aChiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCBvID0gdG9UUkJMKHZhbHVlKTtcbiAgcmV0dXJuIHtcbiAgICB0OiBza2lwT3JMaW1pdChza2lwLnRvcCwgby50b3AsIDAsIG1heEgpLFxuICAgIHI6IHNraXBPckxpbWl0KHNraXAucmlnaHQsIG8ucmlnaHQsIDAsIG1heFcpLFxuICAgIGI6IHNraXBPckxpbWl0KHNraXAuYm90dG9tLCBvLmJvdHRvbSwgMCwgbWF4SCksXG4gICAgbDogc2tpcE9yTGltaXQoc2tpcC5sZWZ0LCBvLmxlZnQsIDAsIG1heFcpXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3Qge2VuYWJsZUJvcmRlclJhZGl1c30gPSBiYXIuZ2V0UHJvcHMoWydlbmFibGVCb3JkZXJSYWRpdXMnXSk7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyUmFkaXVzO1xuICBjb25zdCBvID0gdG9UUkJMQ29ybmVycyh2YWx1ZSk7XG4gIGNvbnN0IG1heFIgPSBNYXRoLm1pbihtYXhXLCBtYXhIKTtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCBlbmFibGVCb3JkZXIgPSBlbmFibGVCb3JkZXJSYWRpdXMgfHwgaXNPYmplY3QodmFsdWUpO1xuICByZXR1cm4ge1xuICAgIHRvcExlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5sZWZ0LCBvLnRvcExlZnQsIDAsIG1heFIpLFxuICAgIHRvcFJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAucmlnaHQsIG8udG9wUmlnaHQsIDAsIG1heFIpLFxuICAgIGJvdHRvbUxlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5sZWZ0LCBvLmJvdHRvbUxlZnQsIDAsIG1heFIpLFxuICAgIGJvdHRvbVJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAucmlnaHQsIG8uYm90dG9tUmlnaHQsIDAsIG1heFIpXG4gIH07XG59XG5mdW5jdGlvbiBib3VuZGluZ1JlY3RzKGJhcikge1xuICBjb25zdCBib3VuZHMgPSBnZXRCYXJCb3VuZHMoYmFyKTtcbiAgY29uc3Qgd2lkdGggPSBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdDtcbiAgY29uc3QgaGVpZ2h0ID0gYm91bmRzLmJvdHRvbSAtIGJvdW5kcy50b3A7XG4gIGNvbnN0IGJvcmRlciA9IHBhcnNlQm9yZGVyV2lkdGgoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICBjb25zdCByYWRpdXMgPSBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gIHJldHVybiB7XG4gICAgb3V0ZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0LFxuICAgICAgeTogYm91bmRzLnRvcCxcbiAgICAgIHc6IHdpZHRoLFxuICAgICAgaDogaGVpZ2h0LFxuICAgICAgcmFkaXVzXG4gICAgfSxcbiAgICBpbm5lcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQgKyBib3JkZXIubCxcbiAgICAgIHk6IGJvdW5kcy50b3AgKyBib3JkZXIudCxcbiAgICAgIHc6IHdpZHRoIC0gYm9yZGVyLmwgLSBib3JkZXIucixcbiAgICAgIGg6IGhlaWdodCAtIGJvcmRlci50IC0gYm9yZGVyLmIsXG4gICAgICByYWRpdXM6IHtcbiAgICAgICAgdG9wTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcExlZnQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLmwpKSxcbiAgICAgICAgdG9wUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BSaWdodCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIucikpLFxuICAgICAgICBib3R0b21MZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tTGVmdCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIubCkpLFxuICAgICAgICBib3R0b21SaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbVJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5yKSksXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaW5SYW5nZShiYXIsIHgsIHksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qgc2tpcFggPSB4ID09PSBudWxsO1xuICBjb25zdCBza2lwWSA9IHkgPT09IG51bGw7XG4gIGNvbnN0IHNraXBCb3RoID0gc2tpcFggJiYgc2tpcFk7XG4gIGNvbnN0IGJvdW5kcyA9IGJhciAmJiAhc2tpcEJvdGggJiYgZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbik7XG4gIHJldHVybiBib3VuZHNcblx0XHQmJiAoc2tpcFggfHwgX2lzQmV0d2Vlbih4LCBib3VuZHMubGVmdCwgYm91bmRzLnJpZ2h0KSlcblx0XHQmJiAoc2tpcFkgfHwgX2lzQmV0d2Vlbih5LCBib3VuZHMudG9wLCBib3VuZHMuYm90dG9tKSk7XG59XG5mdW5jdGlvbiBoYXNSYWRpdXMocmFkaXVzKSB7XG4gIHJldHVybiByYWRpdXMudG9wTGVmdCB8fCByYWRpdXMudG9wUmlnaHQgfHwgcmFkaXVzLmJvdHRvbUxlZnQgfHwgcmFkaXVzLmJvdHRvbVJpZ2h0O1xufVxuZnVuY3Rpb24gYWRkTm9ybWFsUmVjdFBhdGgoY3R4LCByZWN0KSB7XG4gIGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LncsIHJlY3QuaCk7XG59XG5mdW5jdGlvbiBpbmZsYXRlUmVjdChyZWN0LCBhbW91bnQsIHJlZlJlY3QgPSB7fSkge1xuICBjb25zdCB4ID0gcmVjdC54ICE9PSByZWZSZWN0LnggPyAtYW1vdW50IDogMDtcbiAgY29uc3QgeSA9IHJlY3QueSAhPT0gcmVmUmVjdC55ID8gLWFtb3VudCA6IDA7XG4gIGNvbnN0IHcgPSAocmVjdC54ICsgcmVjdC53ICE9PSByZWZSZWN0LnggKyByZWZSZWN0LncgPyBhbW91bnQgOiAwKSAtIHg7XG4gIGNvbnN0IGggPSAocmVjdC55ICsgcmVjdC5oICE9PSByZWZSZWN0LnkgKyByZWZSZWN0LmggPyBhbW91bnQgOiAwKSAtIHk7XG4gIHJldHVybiB7XG4gICAgeDogcmVjdC54ICsgeCxcbiAgICB5OiByZWN0LnkgKyB5LFxuICAgIHc6IHJlY3QudyArIHcsXG4gICAgaDogcmVjdC5oICsgaCxcbiAgICByYWRpdXM6IHJlY3QucmFkaXVzXG4gIH07XG59XG5jbGFzcyBCYXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaG9yaXpvbnRhbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJhc2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluZmxhdGVBbW91bnQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IHtpbmZsYXRlQW1vdW50LCBvcHRpb25zOiB7Ym9yZGVyQ29sb3IsIGJhY2tncm91bmRDb2xvcn19ID0gdGhpcztcbiAgICBjb25zdCB7aW5uZXIsIG91dGVyfSA9IGJvdW5kaW5nUmVjdHModGhpcyk7XG4gICAgY29uc3QgYWRkUmVjdFBhdGggPSBoYXNSYWRpdXMob3V0ZXIucmFkaXVzKSA/IGFkZFJvdW5kZWRSZWN0UGF0aCA6IGFkZE5vcm1hbFJlY3RQYXRoO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgaWYgKG91dGVyLncgIT09IGlubmVyLncgfHwgb3V0ZXIuaCAhPT0gaW5uZXIuaCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChvdXRlciwgaW5mbGF0ZUFtb3VudCwgaW5uZXIpKTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCAtaW5mbGF0ZUFtb3VudCwgb3V0ZXIpKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsKCdldmVub2RkJyk7XG4gICAgfVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCBpbmZsYXRlQW1vdW50KSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguZmlsbCgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBpblhSYW5nZShtb3VzZVgsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG51bGwsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG51bGwsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5LCBiYXNlLCBob3Jpem9udGFsfSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICdob3Jpem9udGFsJ10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBob3Jpem9udGFsID8gKHggKyBiYXNlKSAvIDIgOiB4LFxuICAgICAgeTogaG9yaXpvbnRhbCA/IHkgOiAoeSArIGJhc2UpIC8gMlxuICAgIH07XG4gIH1cbiAgZ2V0UmFuZ2UoYXhpcykge1xuICAgIHJldHVybiBheGlzID09PSAneCcgPyB0aGlzLndpZHRoIC8gMiA6IHRoaXMuaGVpZ2h0IC8gMjtcbiAgfVxufVxuQmFyRWxlbWVudC5pZCA9ICdiYXInO1xuQmFyRWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyU2tpcHBlZDogJ3N0YXJ0JyxcbiAgYm9yZGVyV2lkdGg6IDAsXG4gIGJvcmRlclJhZGl1czogMCxcbiAgaW5mbGF0ZUFtb3VudDogJ2F1dG8nLFxuICBwb2ludFN0eWxlOiB1bmRlZmluZWRcbn07XG5CYXJFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG59O1xuXG52YXIgZWxlbWVudHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5BcmNFbGVtZW50OiBBcmNFbGVtZW50LFxuTGluZUVsZW1lbnQ6IExpbmVFbGVtZW50LFxuUG9pbnRFbGVtZW50OiBQb2ludEVsZW1lbnQsXG5CYXJFbGVtZW50OiBCYXJFbGVtZW50XG59KTtcblxuZnVuY3Rpb24gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucykge1xuICBjb25zdCBzYW1wbGVzID0gb3B0aW9ucy5zYW1wbGVzIHx8IGF2YWlsYWJsZVdpZHRoO1xuICBpZiAoc2FtcGxlcyA+PSBjb3VudCkge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKHN0YXJ0LCBzdGFydCArIGNvdW50KTtcbiAgfVxuICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcbiAgY29uc3QgYnVja2V0V2lkdGggPSAoY291bnQgLSAyKSAvIChzYW1wbGVzIC0gMik7XG4gIGxldCBzYW1wbGVkSW5kZXggPSAwO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuICBsZXQgYSA9IHN0YXJ0O1xuICBsZXQgaSwgbWF4QXJlYVBvaW50LCBtYXhBcmVhLCBhcmVhLCBuZXh0QTtcbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbYV07XG4gIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzIC0gMjsgaSsrKSB7XG4gICAgbGV0IGF2Z1ggPSAwO1xuICAgIGxldCBhdmdZID0gMDtcbiAgICBsZXQgajtcbiAgICBjb25zdCBhdmdSYW5nZVN0YXJ0ID0gTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSArIHN0YXJ0O1xuICAgIGNvbnN0IGF2Z1JhbmdlRW5kID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDIpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VMZW5ndGggPSBhdmdSYW5nZUVuZCAtIGF2Z1JhbmdlU3RhcnQ7XG4gICAgZm9yIChqID0gYXZnUmFuZ2VTdGFydDsgaiA8IGF2Z1JhbmdlRW5kOyBqKyspIHtcbiAgICAgIGF2Z1ggKz0gZGF0YVtqXS54O1xuICAgICAgYXZnWSArPSBkYXRhW2pdLnk7XG4gICAgfVxuICAgIGF2Z1ggLz0gYXZnUmFuZ2VMZW5ndGg7XG4gICAgYXZnWSAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICBjb25zdCByYW5nZU9mZnMgPSBNYXRoLmZsb29yKGkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgcmFuZ2VUbyA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IHt4OiBwb2ludEF4LCB5OiBwb2ludEF5fSA9IGRhdGFbYV07XG4gICAgbWF4QXJlYSA9IGFyZWEgPSAtMTtcbiAgICBmb3IgKGogPSByYW5nZU9mZnM7IGogPCByYW5nZVRvOyBqKyspIHtcbiAgICAgIGFyZWEgPSAwLjUgKiBNYXRoLmFicyhcbiAgICAgICAgKHBvaW50QXggLSBhdmdYKSAqIChkYXRhW2pdLnkgLSBwb2ludEF5KSAtXG4gICAgICAgIChwb2ludEF4IC0gZGF0YVtqXS54KSAqIChhdmdZIC0gcG9pbnRBeSlcbiAgICAgICk7XG4gICAgICBpZiAoYXJlYSA+IG1heEFyZWEpIHtcbiAgICAgICAgbWF4QXJlYSA9IGFyZWE7XG4gICAgICAgIG1heEFyZWFQb2ludCA9IGRhdGFbal07XG4gICAgICAgIG5leHRBID0gajtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IG1heEFyZWFQb2ludDtcbiAgICBhID0gbmV4dEE7XG4gIH1cbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbZW5kSW5kZXhdO1xuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuZnVuY3Rpb24gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKSB7XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgeCwgeSwgcHJldlgsIG1pbkluZGV4LCBtYXhJbmRleCwgc3RhcnRJbmRleCwgbWluWSwgbWF4WTtcbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG4gIGNvbnN0IHhNaW4gPSBkYXRhW3N0YXJ0XS54O1xuICBjb25zdCB4TWF4ID0gZGF0YVtlbmRJbmRleF0ueDtcbiAgY29uc3QgZHggPSB4TWF4IC0geE1pbjtcbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICBwb2ludCA9IGRhdGFbaV07XG4gICAgeCA9IChwb2ludC54IC0geE1pbikgLyBkeCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgIHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwO1xuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICAgIG1pbkluZGV4ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgIG1heEluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIGF2Z1ggPSAoY291bnRYICogYXZnWCArIHBvaW50LngpIC8gKytjb3VudFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGkgLSAxO1xuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG1pbkluZGV4KSAmJiAhaXNOdWxsT3JVbmRlZihtYXhJbmRleCkpIHtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgxID0gTWF0aC5taW4obWluSW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgyID0gTWF0aC5tYXgobWluSW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MSAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDEgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgxXSxcbiAgICAgICAgICAgIHg6IGF2Z1gsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MiAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDIgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgyXSxcbiAgICAgICAgICAgIHg6IGF2Z1hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPiAwICYmIGxhc3RJbmRleCAhPT0gc3RhcnRJbmRleCkge1xuICAgICAgICBkZWNpbWF0ZWQucHVzaChkYXRhW2xhc3RJbmRleF0pO1xuICAgICAgfVxuICAgICAgZGVjaW1hdGVkLnB1c2gocG9pbnQpO1xuICAgICAgcHJldlggPSB0cnVuY1g7XG4gICAgICBjb3VudFggPSAwO1xuICAgICAgbWluWSA9IG1heFkgPSB5O1xuICAgICAgbWluSW5kZXggPSBtYXhJbmRleCA9IHN0YXJ0SW5kZXggPSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpIHtcbiAgaWYgKGRhdGFzZXQuX2RlY2ltYXRlZCkge1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0Ll9kYXRhO1xuICAgIGRlbGV0ZSBkYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RhdGE7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge3ZhbHVlOiBkYXRhfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCkge1xuICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQpID0+IHtcbiAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgcG9pbnRzKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQ7XG4gIGNvbnN0IHtpU2NhbGV9ID0gbWV0YTtcbiAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IGlTY2FsZS5nZXRVc2VyQm91bmRzKCk7XG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWluKS5sbywgMCwgcG9pbnRDb3VudCAtIDEpO1xuICB9XG4gIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgY291bnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWF4KS5oaSArIDEsIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cbnZhciBwbHVnaW5fZGVjaW1hdGlvbiA9IHtcbiAgaWQ6ICdkZWNpbWF0aW9uJyxcbiAgZGVmYXVsdHM6IHtcbiAgICBhbGdvcml0aG06ICdtaW4tbWF4JyxcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgfSxcbiAgYmVmb3JlRWxlbWVudHNVcGRhdGU6IChjaGFydCwgYXJncywgb3B0aW9ucykgPT4ge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IGNoYXJ0LndpZHRoO1xuICAgIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7X2RhdGEsIGluZGV4QXhpc30gPSBkYXRhc2V0O1xuICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBjb25zdCBkYXRhID0gX2RhdGEgfHwgZGF0YXNldC5kYXRhO1xuICAgICAgaWYgKHJlc29sdmUoW2luZGV4QXhpcywgY2hhcnQub3B0aW9ucy5pbmRleEF4aXNdKSA9PT0gJ3knKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhLnR5cGUgIT09ICdsaW5lJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB4QXhpcyA9IGNoYXJ0LnNjYWxlc1ttZXRhLnhBeGlzSURdO1xuICAgICAgaWYgKHhBeGlzLnR5cGUgIT09ICdsaW5lYXInICYmIHhBeGlzLnR5cGUgIT09ICd0aW1lJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2hhcnQub3B0aW9ucy5wYXJzaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIGRhdGEpO1xuICAgICAgY29uc3QgdGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQgfHwgNCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKGNvdW50IDw9IHRocmVzaG9sZCkge1xuICAgICAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc051bGxPclVuZGVmKF9kYXRhKSkge1xuICAgICAgICBkYXRhc2V0Ll9kYXRhID0gZGF0YTtcbiAgICAgICAgZGVsZXRlIGRhdGFzZXQuZGF0YTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjaW1hdGVkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGV0IGRlY2ltYXRlZDtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgICAgIGNhc2UgJ2x0dGInOlxuICAgICAgICBkZWNpbWF0ZWQgPSBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaW4tbWF4JzpcbiAgICAgICAgZGVjaW1hdGVkID0gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlY2ltYXRpb24gYWxnb3JpdGhtICcke29wdGlvbnMuYWxnb3JpdGhtfSdgKTtcbiAgICAgIH1cbiAgICAgIGRhdGFzZXQuX2RlY2ltYXRlZCA9IGRlY2ltYXRlZDtcbiAgICB9KTtcbiAgfSxcbiAgZGVzdHJveShjaGFydCkge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldExpbmVCeUluZGV4KGNoYXJ0LCBpbmRleCkge1xuICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICBjb25zdCB2aXNpYmxlID0gbWV0YSAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KTtcbiAgcmV0dXJuIHZpc2libGUgPyBtZXRhLmRhdGFzZXQgOiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VGaWxsT3B0aW9uKGxpbmUpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IG9wdGlvbnMuZmlsbDtcbiAgbGV0IGZpbGwgPSB2YWx1ZU9yRGVmYXVsdChmaWxsT3B0aW9uICYmIGZpbGxPcHRpb24udGFyZ2V0LCBmaWxsT3B0aW9uKTtcbiAgaWYgKGZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIGZpbGwgPSAhIW9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICB9XG4gIGlmIChmaWxsID09PSBmYWxzZSB8fCBmaWxsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmaWxsID09PSB0cnVlKSB7XG4gICAgcmV0dXJuICdvcmlnaW4nO1xuICB9XG4gIHJldHVybiBmaWxsO1xufVxuZnVuY3Rpb24gZGVjb2RlRmlsbChsaW5lLCBpbmRleCwgY291bnQpIHtcbiAgY29uc3QgZmlsbCA9IHBhcnNlRmlsbE9wdGlvbihsaW5lKTtcbiAgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgcmV0dXJuIGlzTmFOKGZpbGwudmFsdWUpID8gZmFsc2UgOiBmaWxsO1xuICB9XG4gIGxldCB0YXJnZXQgPSBwYXJzZUZsb2F0KGZpbGwpO1xuICBpZiAoaXNOdW1iZXJGaW5pdGUodGFyZ2V0KSAmJiBNYXRoLmZsb29yKHRhcmdldCkgPT09IHRhcmdldCkge1xuICAgIGlmIChmaWxsWzBdID09PSAnLScgfHwgZmlsbFswXSA9PT0gJysnKSB7XG4gICAgICB0YXJnZXQgPSBpbmRleCArIHRhcmdldDtcbiAgICB9XG4gICAgaWYgKHRhcmdldCA9PT0gaW5kZXggfHwgdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPj0gY291bnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gWydvcmlnaW4nLCAnc3RhcnQnLCAnZW5kJywgJ3N0YWNrJywgJ3NoYXBlJ10uaW5kZXhPZihmaWxsKSA+PSAwICYmIGZpbGw7XG59XG5mdW5jdGlvbiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSA9IHt9LCBmaWxsfSA9IHNvdXJjZTtcbiAgbGV0IHRhcmdldCA9IG51bGw7XG4gIGxldCBob3Jpem9udGFsO1xuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHRhcmdldCA9IHNjYWxlLmJvdHRvbTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHRhcmdldCA9IHNjYWxlLnRvcDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHRhcmdldCA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUoZmlsbC52YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG4gICAgdGFyZ2V0ID0gc2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyRmluaXRlKHRhcmdldCkpIHtcbiAgICBob3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyB0YXJnZXQgOiBudWxsLFxuICAgICAgeTogaG9yaXpvbnRhbCA/IG51bGwgOiB0YXJnZXRcbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuY2xhc3Mgc2ltcGxlQXJjIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMueCA9IG9wdHMueDtcbiAgICB0aGlzLnkgPSBvcHRzLnk7XG4gICAgdGhpcy5yYWRpdXMgPSBvcHRzLnJhZGl1cztcbiAgfVxuICBwYXRoU2VnbWVudChjdHgsIGJvdW5kcywgb3B0cykge1xuICAgIGNvbnN0IHt4LCB5LCByYWRpdXN9ID0gdGhpcztcbiAgICBib3VuZHMgPSBib3VuZHMgfHwge3N0YXJ0OiAwLCBlbmQ6IFRBVX07XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIGJvdW5kcy5lbmQsIGJvdW5kcy5zdGFydCwgdHJ1ZSk7XG4gICAgcmV0dXJuICFvcHRzLmJvdW5kcztcbiAgfVxuICBpbnRlcnBvbGF0ZShwb2ludCkge1xuICAgIGNvbnN0IHt4LCB5LCByYWRpdXN9ID0gdGhpcztcbiAgICBjb25zdCBhbmdsZSA9IHBvaW50LmFuZ2xlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzLFxuICAgICAgeTogeSArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIGFuZ2xlXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgZmlsbH0gPSBzb3VyY2U7XG4gIGNvbnN0IG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCBsZW5ndGggPSBzY2FsZS5nZXRMYWJlbHMoKS5sZW5ndGg7XG4gIGNvbnN0IHRhcmdldCA9IFtdO1xuICBjb25zdCBzdGFydCA9IG9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1heCA6IHNjYWxlLm1pbjtcbiAgY29uc3QgZW5kID0gb3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4O1xuICBsZXQgaSwgY2VudGVyLCB2YWx1ZTtcbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICB2YWx1ZSA9IHN0YXJ0O1xuICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG4gICAgdmFsdWUgPSBlbmQ7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICB2YWx1ZSA9IGZpbGwudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBzY2FsZS5nZXRCYXNlVmFsdWUoKTtcbiAgfVxuICBpZiAob3B0aW9ucy5ncmlkLmNpcmN1bGFyKSB7XG4gICAgY2VudGVyID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsIHN0YXJ0KTtcbiAgICByZXR1cm4gbmV3IHNpbXBsZUFyYyh7XG4gICAgICB4OiBjZW50ZXIueCxcbiAgICAgIHk6IGNlbnRlci55LFxuICAgICAgcmFkaXVzOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSlcbiAgICB9KTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB0YXJnZXQucHVzaChzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaSwgdmFsdWUpKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCBzY2FsZSA9IHNvdXJjZS5zY2FsZSB8fCB7fTtcbiAgaWYgKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSkge1xuICAgIHJldHVybiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpO1xuICB9XG4gIHJldHVybiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKTtcbn1cbmZ1bmN0aW9uIGZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cykge1xuICBmb3IgKDtlbmQgPiBzdGFydDsgZW5kLS0pIHtcbiAgICBjb25zdCBwb2ludCA9IHBvaW50c1tlbmRdO1xuICAgIGlmICghaXNOYU4ocG9pbnQueCkgJiYgIWlzTmFOKHBvaW50LnkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuZDtcbn1cbmZ1bmN0aW9uIHBvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSkge1xuICBjb25zdCB7eCA9IG51bGwsIHkgPSBudWxsfSA9IGJvdW5kYXJ5IHx8IHt9O1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBsaW5lLnNlZ21lbnRzLmZvckVhY2goKHtzdGFydCwgZW5kfSkgPT4ge1xuICAgIGVuZCA9IGZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIGxpbmVQb2ludHMpO1xuICAgIGNvbnN0IGZpcnN0ID0gbGluZVBvaW50c1tzdGFydF07XG4gICAgY29uc3QgbGFzdCA9IGxpbmVQb2ludHNbZW5kXTtcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGZpcnN0LngsIHl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBsYXN0LngsIHl9KTtcbiAgICB9IGVsc2UgaWYgKHggIT09IG51bGwpIHtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBmaXJzdC55fSk7XG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogbGFzdC55fSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBvaW50cztcbn1cbmZ1bmN0aW9uIGJ1aWxkU3RhY2tMaW5lKHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGluZGV4LCBsaW5lfSA9IHNvdXJjZTtcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3Qgc291cmNlUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IGxpbmVzQmVsb3cgPSBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCk7XG4gIGxpbmVzQmVsb3cucHVzaChjcmVhdGVCb3VuZGFyeUxpbmUoe3g6IG51bGwsIHk6IHNjYWxlLmJvdHRvbX0sIGxpbmUpKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBmb3IgKGxldCBqID0gc2VnbWVudC5zdGFydDsgaiA8PSBzZWdtZW50LmVuZDsgaisrKSB7XG4gICAgICBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50c1tqXSwgbGluZXNCZWxvdyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgTGluZUVsZW1lbnQoe3BvaW50cywgb3B0aW9uczoge319KTtcbn1cbmZ1bmN0aW9uIGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KSB7XG4gIGNvbnN0IGJlbG93ID0gW107XG4gIGNvbnN0IG1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoJ2xpbmUnKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRhcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICBpZiAobWV0YS5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIW1ldGEuaGlkZGVuKSB7XG4gICAgICBiZWxvdy51bnNoaWZ0KG1ldGEuZGF0YXNldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiZWxvdztcbn1cbmZ1bmN0aW9uIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnQsIGxpbmVzQmVsb3cpIHtcbiAgY29uc3QgcG9zdHBvbmVkID0gW107XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbGluZXNCZWxvdy5sZW5ndGg7IGorKykge1xuICAgIGNvbnN0IGxpbmUgPSBsaW5lc0JlbG93W2pdO1xuICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgcG9pbnR9ID0gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCAneCcpO1xuICAgIGlmICghcG9pbnQgfHwgKGZpcnN0ICYmIGxhc3QpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBwb3N0cG9uZWQudW5zaGlmdChwb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIGlmICghbGFzdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcG9pbnRzLnB1c2goLi4ucG9zdHBvbmVkKTtcbn1cbmZ1bmN0aW9uIGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgcG9pbnQgPSBsaW5lLmludGVycG9sYXRlKHNvdXJjZVBvaW50LCBwcm9wZXJ0eSk7XG4gIGlmICghcG9pbnQpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgcG9pbnRWYWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGxldCBmaXJzdCA9IGZhbHNlO1xuICBsZXQgbGFzdCA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuc3RhcnRdW3Byb3BlcnR5XTtcbiAgICBjb25zdCBsYXN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuZW5kXVtwcm9wZXJ0eV07XG4gICAgaWYgKF9pc0JldHdlZW4ocG9pbnRWYWx1ZSwgZmlyc3RWYWx1ZSwgbGFzdFZhbHVlKSkge1xuICAgICAgZmlyc3QgPSBwb2ludFZhbHVlID09PSBmaXJzdFZhbHVlO1xuICAgICAgbGFzdCA9IHBvaW50VmFsdWUgPT09IGxhc3RWYWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2ZpcnN0LCBsYXN0LCBwb2ludH07XG59XG5mdW5jdGlvbiBnZXRUYXJnZXQoc291cmNlKSB7XG4gIGNvbnN0IHtjaGFydCwgZmlsbCwgbGluZX0gPSBzb3VyY2U7XG4gIGlmIChpc051bWJlckZpbml0ZShmaWxsKSkge1xuICAgIHJldHVybiBnZXRMaW5lQnlJbmRleChjaGFydCwgZmlsbCk7XG4gIH1cbiAgaWYgKGZpbGwgPT09ICdzdGFjaycpIHtcbiAgICByZXR1cm4gYnVpbGRTdGFja0xpbmUoc291cmNlKTtcbiAgfVxuICBpZiAoZmlsbCA9PT0gJ3NoYXBlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGJvdW5kYXJ5ID0gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSk7XG4gIGlmIChib3VuZGFyeSBpbnN0YW5jZW9mIHNpbXBsZUFyYykge1xuICAgIHJldHVybiBib3VuZGFyeTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSkge1xuICBsZXQgcG9pbnRzID0gW107XG4gIGxldCBfbG9vcCA9IGZhbHNlO1xuICBpZiAoaXNBcnJheShib3VuZGFyeSkpIHtcbiAgICBfbG9vcCA9IHRydWU7XG4gICAgcG9pbnRzID0gYm91bmRhcnk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKTtcbiAgfVxuICByZXR1cm4gcG9pbnRzLmxlbmd0aCA/IG5ldyBMaW5lRWxlbWVudCh7XG4gICAgcG9pbnRzLFxuICAgIG9wdGlvbnM6IHt0ZW5zaW9uOiAwfSxcbiAgICBfbG9vcCxcbiAgICBfZnVsbExvb3A6IF9sb29wXG4gIH0pIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUYXJnZXQoc291cmNlcywgaW5kZXgsIHByb3BhZ2F0ZSkge1xuICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgbGV0IGZpbGwgPSBzb3VyY2UuZmlsbDtcbiAgY29uc3QgdmlzaXRlZCA9IFtpbmRleF07XG4gIGxldCB0YXJnZXQ7XG4gIGlmICghcHJvcGFnYXRlKSB7XG4gICAgcmV0dXJuIGZpbGw7XG4gIH1cbiAgd2hpbGUgKGZpbGwgIT09IGZhbHNlICYmIHZpc2l0ZWQuaW5kZXhPZihmaWxsKSA9PT0gLTEpIHtcbiAgICBpZiAoIWlzTnVtYmVyRmluaXRlKGZpbGwpKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG4gICAgdGFyZ2V0ID0gc291cmNlc1tmaWxsXTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LnZpc2libGUpIHtcbiAgICAgIHJldHVybiBmaWxsO1xuICAgIH1cbiAgICB2aXNpdGVkLnB1c2goZmlsbCk7XG4gICAgZmlsbCA9IHRhcmdldC5maWxsO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIF9jbGlwKGN0eCwgdGFyZ2V0LCBjbGlwWSkge1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIHRhcmdldC5wYXRoKGN0eCk7XG4gIGN0eC5saW5lVG8odGFyZ2V0Lmxhc3QoKS54LCBjbGlwWSk7XG4gIGN0eC5saW5lVG8odGFyZ2V0LmZpcnN0KCkueCwgY2xpcFkpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiBnZXRCb3VuZHMocHJvcGVydHksIGZpcnN0LCBsYXN0LCBsb29wKSB7XG4gIGlmIChsb29wKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGFydCA9IGZpcnN0W3Byb3BlcnR5XTtcbiAgbGV0IGVuZCA9IGxhc3RbcHJvcGVydHldO1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICBzdGFydCA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gICAgZW5kID0gX25vcm1hbGl6ZUFuZ2xlKGVuZCk7XG4gIH1cbiAgcmV0dXJuIHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH07XG59XG5mdW5jdGlvbiBfZ2V0RWRnZShhLCBiLCBwcm9wLCBmbikge1xuICBpZiAoYSAmJiBiKSB7XG4gICAgcmV0dXJuIGZuKGFbcHJvcF0sIGJbcHJvcF0pO1xuICB9XG4gIHJldHVybiBhID8gYVtwcm9wXSA6IGIgPyBiW3Byb3BdIDogMDtcbn1cbmZ1bmN0aW9uIF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHRwb2ludHMgPSB0YXJnZXQucG9pbnRzO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBsZXQge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBlbmQgPSBmaW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpO1xuICAgIGNvbnN0IGJvdW5kcyA9IGdldEJvdW5kcyhwcm9wZXJ0eSwgcG9pbnRzW3N0YXJ0XSwgcG9pbnRzW2VuZF0sIHNlZ21lbnQubG9vcCk7XG4gICAgaWYgKCF0YXJnZXQuc2VnbWVudHMpIHtcbiAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICBzb3VyY2U6IHNlZ21lbnQsXG4gICAgICAgIHRhcmdldDogYm91bmRzLFxuICAgICAgICBzdGFydDogcG9pbnRzW3N0YXJ0XSxcbiAgICAgICAgZW5kOiBwb2ludHNbZW5kXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0U2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0YXJnZXQsIGJvdW5kcyk7XG4gICAgZm9yIChjb25zdCB0Z3Qgb2YgdGFyZ2V0U2VnbWVudHMpIHtcbiAgICAgIGNvbnN0IHN1YkJvdW5kcyA9IGdldEJvdW5kcyhwcm9wZXJ0eSwgdHBvaW50c1t0Z3Quc3RhcnRdLCB0cG9pbnRzW3RndC5lbmRdLCB0Z3QubG9vcCk7XG4gICAgICBjb25zdCBmaWxsU291cmNlcyA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBzdWJCb3VuZHMpO1xuICAgICAgZm9yIChjb25zdCBmaWxsU291cmNlIG9mIGZpbGxTb3VyY2VzKSB7XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZTogZmlsbFNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQ6IHRndCxcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdzdGFydCcsIE1hdGgubWF4KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ2VuZCcsIE1hdGgubWluKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cbmZ1bmN0aW9uIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgYm91bmRzKSB7XG4gIGNvbnN0IHt0b3AsIGJvdHRvbX0gPSBzY2FsZS5jaGFydC5jaGFydEFyZWE7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH0gPSBib3VuZHMgfHwge307XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5yZWN0KHN0YXJ0LCB0b3AsIGVuZCAtIHN0YXJ0LCBib3R0b20gLSB0b3ApO1xuICAgIGN0eC5jbGlwKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgcG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGludGVycG9sYXRlZFBvaW50ID0gdGFyZ2V0LmludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSk7XG4gIGlmIChpbnRlcnBvbGF0ZWRQb2ludCkge1xuICAgIGN0eC5saW5lVG8oaW50ZXJwb2xhdGVkUG9pbnQueCwgaW50ZXJwb2xhdGVkUG9pbnQueSk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9maWxsKGN0eCwgY2ZnKSB7XG4gIGNvbnN0IHtsaW5lLCB0YXJnZXQsIHByb3BlcnR5LCBjb2xvciwgc2NhbGV9ID0gY2ZnO1xuICBjb25zdCBzZWdtZW50cyA9IF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KTtcbiAgZm9yIChjb25zdCB7c291cmNlOiBzcmMsIHRhcmdldDogdGd0LCBzdGFydCwgZW5kfSBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IHtzdHlsZToge2JhY2tncm91bmRDb2xvciA9IGNvbG9yfSA9IHt9fSA9IHNyYztcbiAgICBjb25zdCBub3RTaGFwZSA9IHRhcmdldCAhPT0gdHJ1ZTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgY2xpcEJvdW5kcyhjdHgsIHNjYWxlLCBub3RTaGFwZSAmJiBnZXRCb3VuZHMocHJvcGVydHksIHN0YXJ0LCBlbmQpKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY29uc3QgbGluZUxvb3AgPSAhIWxpbmUucGF0aFNlZ21lbnQoY3R4LCBzcmMpO1xuICAgIGxldCBsb29wO1xuICAgIGlmIChub3RTaGFwZSkge1xuICAgICAgaWYgKGxpbmVMb29wKSB7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgZW5kLCBwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCB0Z3QsIHttb3ZlOiBsaW5lTG9vcCwgcmV2ZXJzZTogdHJ1ZX0pO1xuICAgICAgbG9vcCA9IGxpbmVMb29wICYmIHRhcmdldExvb3A7XG4gICAgICBpZiAoIWxvb3ApIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBzdGFydCwgcHJvcGVydHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwobG9vcCA/ICdldmVub2RkJyA6ICdub256ZXJvJyk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuZnVuY3Rpb24gZG9GaWxsKGN0eCwgY2ZnKSB7XG4gIGNvbnN0IHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGV9ID0gY2ZnO1xuICBjb25zdCBwcm9wZXJ0eSA9IGxpbmUuX2xvb3AgPyAnYW5nbGUnIDogY2ZnLmF4aXM7XG4gIGN0eC5zYXZlKCk7XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnICYmIGJlbG93ICE9PSBhYm92ZSkge1xuICAgIF9jbGlwKGN0eCwgdGFyZ2V0LCBhcmVhLnRvcCk7XG4gICAgX2ZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYWJvdmUsIHNjYWxlLCBwcm9wZXJ0eX0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBfY2xpcChjdHgsIHRhcmdldCwgYXJlYS5ib3R0b20pO1xuICB9XG4gIF9maWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGJlbG93LCBzY2FsZSwgcHJvcGVydHl9KTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGRyYXdmaWxsKGN0eCwgc291cmNlLCBhcmVhKSB7XG4gIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChzb3VyY2UpO1xuICBjb25zdCB7bGluZSwgc2NhbGUsIGF4aXN9ID0gc291cmNlO1xuICBjb25zdCBsaW5lT3B0cyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IGxpbmVPcHRzLmZpbGw7XG4gIGNvbnN0IGNvbG9yID0gbGluZU9wdHMuYmFja2dyb3VuZENvbG9yO1xuICBjb25zdCB7YWJvdmUgPSBjb2xvciwgYmVsb3cgPSBjb2xvcn0gPSBmaWxsT3B0aW9uIHx8IHt9O1xuICBpZiAodGFyZ2V0ICYmIGxpbmUucG9pbnRzLmxlbmd0aCkge1xuICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgZG9GaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZSwgYXhpc30pO1xuICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgfVxufVxudmFyIHBsdWdpbl9maWxsZXIgPSB7XG4gIGlkOiAnZmlsbGVyJyxcbiAgYWZ0ZXJEYXRhc2V0c1VwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb3VudCA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7XG4gICAgY29uc3Qgc291cmNlcyA9IFtdO1xuICAgIGxldCBtZXRhLCBpLCBsaW5lLCBzb3VyY2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgICBzb3VyY2UgPSBudWxsO1xuICAgICAgaWYgKGxpbmUgJiYgbGluZS5vcHRpb25zICYmIGxpbmUgaW5zdGFuY2VvZiBMaW5lRWxlbWVudCkge1xuICAgICAgICBzb3VyY2UgPSB7XG4gICAgICAgICAgdmlzaWJsZTogY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBmaWxsOiBkZWNvZGVGaWxsKGxpbmUsIGksIGNvdW50KSxcbiAgICAgICAgICBjaGFydCxcbiAgICAgICAgICBheGlzOiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5pbmRleEF4aXMsXG4gICAgICAgICAgc2NhbGU6IG1ldGEudlNjYWxlLFxuICAgICAgICAgIGxpbmUsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBtZXRhLiRmaWxsZXIgPSBzb3VyY2U7XG4gICAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICBpZiAoIXNvdXJjZSB8fCBzb3VyY2UuZmlsbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb3VyY2UuZmlsbCA9IHJlc29sdmVUYXJnZXQoc291cmNlcywgaSwgb3B0aW9ucy5wcm9wYWdhdGUpO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkcmF3ID0gb3B0aW9ucy5kcmF3VGltZSA9PT0gJ2JlZm9yZURyYXcnO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb3VyY2UubGluZS51cGRhdGVDb250cm9sUG9pbnRzKGFyZWEsIHNvdXJjZS5heGlzKTtcbiAgICAgIGlmIChkcmF3KSB7XG4gICAgICAgIGRyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJlZm9yZURhdGFzZXRzRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXRzRHJhdycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBkcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJlZm9yZURhdGFzZXREcmF3KGNoYXJ0LCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc291cmNlID0gYXJncy5tZXRhLiRmaWxsZXI7XG4gICAgaWYgKCFzb3VyY2UgfHwgc291cmNlLmZpbGwgPT09IGZhbHNlIHx8IG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0RHJhdycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgIGRyYXdUaW1lOiAnYmVmb3JlRGF0YXNldERyYXcnXG4gIH1cbn07XG5cbmNvbnN0IGdldEJveFNpemUgPSAobGFiZWxPcHRzLCBmb250U2l6ZSkgPT4ge1xuICBsZXQge2JveEhlaWdodCA9IGZvbnRTaXplLCBib3hXaWR0aCA9IGZvbnRTaXplfSA9IGxhYmVsT3B0cztcbiAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgYm94SGVpZ2h0ID0gTWF0aC5taW4oYm94SGVpZ2h0LCBmb250U2l6ZSk7XG4gICAgYm94V2lkdGggPSBNYXRoLm1pbihib3hXaWR0aCwgZm9udFNpemUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgYm94V2lkdGgsXG4gICAgYm94SGVpZ2h0LFxuICAgIGl0ZW1IZWlnaHQ6IE1hdGgubWF4KGZvbnRTaXplLCBib3hIZWlnaHQpXG4gIH07XG59O1xuY29uc3QgaXRlbXNFcXVhbCA9IChhLCBiKSA9PiBhICE9PSBudWxsICYmIGIgIT09IG51bGwgJiYgYS5kYXRhc2V0SW5kZXggPT09IGIuZGF0YXNldEluZGV4ICYmIGEuaW5kZXggPT09IGIuaW5kZXg7XG5jbGFzcyBMZWdlbmQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9hZGRlZCA9IGZhbHNlO1xuICAgIHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IG51bGw7XG4gICAgdGhpcy5kb3VnaG51dE1vZGUgPSBmYWxzZTtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29sdW1uU2l6ZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5saW5lV2lkdGhzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucztcbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmJ1aWxkTGFiZWxzKCk7XG4gICAgdGhpcy5maXQoKTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IHRoaXMuX21hcmdpbnMubGVmdDtcbiAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgdGhpcy50b3AgPSB0aGlzLl9tYXJnaW5zLnRvcDtcbiAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuICB9XG4gIGJ1aWxkTGFiZWxzKCkge1xuICAgIGNvbnN0IGxhYmVsT3B0cyA9IHRoaXMub3B0aW9ucy5sYWJlbHMgfHwge307XG4gICAgbGV0IGxlZ2VuZEl0ZW1zID0gY2FsbGJhY2sobGFiZWxPcHRzLmdlbmVyYXRlTGFiZWxzLCBbdGhpcy5jaGFydF0sIHRoaXMpIHx8IFtdO1xuICAgIGlmIChsYWJlbE9wdHMuZmlsdGVyKSB7XG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gbGFiZWxPcHRzLmZpbHRlcihpdGVtLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG4gICAgaWYgKGxhYmVsT3B0cy5zb3J0KSB7XG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLnNvcnQoKGEsIGIpID0+IGxhYmVsT3B0cy5zb3J0KGEsIGIsIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zLnJldmVyc2UoKTtcbiAgICB9XG4gICAgdGhpcy5sZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zO1xuICB9XG4gIGZpdCgpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgY3R4fSA9IHRoaXM7XG4gICAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsT3B0cyA9IG9wdGlvbnMubGFiZWxzO1xuICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XG4gICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGNvbnN0IHtib3hXaWR0aCwgaXRlbUhlaWdodH0gPSBnZXRCb3hTaXplKGxhYmVsT3B0cywgZm9udFNpemUpO1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgd2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgaGVpZ2h0ID0gdGhpcy5fZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgIHdpZHRoID0gdGhpcy5fZml0Q29scyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH1cbiAgICB0aGlzLndpZHRoID0gTWF0aC5taW4od2lkdGgsIG9wdGlvbnMubWF4V2lkdGggfHwgdGhpcy5tYXhXaWR0aCk7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1pbihoZWlnaHQsIG9wdGlvbnMubWF4SGVpZ2h0IHx8IHRoaXMubWF4SGVpZ2h0KTtcbiAgfVxuICBfZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSB7XG4gICAgY29uc3Qge2N0eCwgbWF4V2lkdGgsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCBsaW5lV2lkdGhzID0gdGhpcy5saW5lV2lkdGhzID0gWzBdO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICBsZXQgdG90YWxIZWlnaHQgPSB0aXRsZUhlaWdodDtcbiAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBsZXQgcm93ID0gLTE7XG4gICAgbGV0IHRvcCA9IC1saW5lSGVpZ2h0O1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgaWYgKGkgPT09IDAgfHwgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICsgaXRlbVdpZHRoICsgMiAqIHBhZGRpbmcgPiBtYXhXaWR0aCkge1xuICAgICAgICB0b3RhbEhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gKGkgPiAwID8gMCA6IDEpXSA9IDA7XG4gICAgICAgIHRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICByb3crKztcbiAgICAgIH1cbiAgICAgIGhpdGJveGVzW2ldID0ge2xlZnQ6IDAsIHRvcCwgcm93LCB3aWR0aDogaXRlbVdpZHRoLCBoZWlnaHQ6IGl0ZW1IZWlnaHR9O1xuICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICs9IGl0ZW1XaWR0aCArIHBhZGRpbmc7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvdGFsSGVpZ2h0O1xuICB9XG4gIF9maXRDb2xzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhIZWlnaHQsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCBjb2x1bW5TaXplcyA9IHRoaXMuY29sdW1uU2l6ZXMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHRMaW1pdCA9IG1heEhlaWdodCAtIHRpdGxlSGVpZ2h0O1xuICAgIGxldCB0b3RhbFdpZHRoID0gcGFkZGluZztcbiAgICBsZXQgY3VycmVudENvbFdpZHRoID0gMDtcbiAgICBsZXQgY3VycmVudENvbEhlaWdodCA9IDA7XG4gICAgbGV0IGxlZnQgPSAwO1xuICAgIGxldCBjb2wgPSAwO1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgaWYgKGkgPiAwICYmIGN1cnJlbnRDb2xIZWlnaHQgKyBpdGVtSGVpZ2h0ICsgMiAqIHBhZGRpbmcgPiBoZWlnaHRMaW1pdCkge1xuICAgICAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pO1xuICAgICAgICBsZWZ0ICs9IGN1cnJlbnRDb2xXaWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGNvbCsrO1xuICAgICAgICBjdXJyZW50Q29sV2lkdGggPSBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICAgIGhpdGJveGVzW2ldID0ge2xlZnQsIHRvcDogY3VycmVudENvbEhlaWdodCwgY29sLCB3aWR0aDogaXRlbVdpZHRoLCBoZWlnaHQ6IGl0ZW1IZWlnaHR9O1xuICAgICAgY3VycmVudENvbFdpZHRoID0gTWF0aC5tYXgoY3VycmVudENvbFdpZHRoLCBpdGVtV2lkdGgpO1xuICAgICAgY3VycmVudENvbEhlaWdodCArPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB9KTtcbiAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aDtcbiAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTtcbiAgICByZXR1cm4gdG90YWxXaWR0aDtcbiAgfVxuICBhZGp1c3RIaXRCb3hlcygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2xlZ2VuZEhpdEJveGVzOiBoaXRib3hlcywgb3B0aW9uczoge2FsaWduLCBsYWJlbHM6IHtwYWRkaW5nfSwgcnRsfX0gPSB0aGlzO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIocnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBsZXQgcm93ID0gMDtcbiAgICAgIGxldCBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAocm93ICE9PSBoaXRib3gucm93KSB7XG4gICAgICAgICAgcm93ID0gaGl0Ym94LnJvdztcbiAgICAgICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCArPSB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChsZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgbGVmdCArPSBoaXRib3gud2lkdGggKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY29sID0gMDtcbiAgICAgIGxldCB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAoaGl0Ym94LmNvbCAhPT0gY29sKSB7XG4gICAgICAgICAgY29sID0gaGl0Ym94LmNvbDtcbiAgICAgICAgICB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCA9IHRvcDtcbiAgICAgICAgaGl0Ym94LmxlZnQgKz0gdGhpcy5sZWZ0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChoaXRib3gubGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIHRvcCArPSBoaXRib3guaGVpZ2h0ICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gIH1cbiAgZHJhdygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgY2xpcEFyZWEoY3R4LCB0aGlzKTtcbiAgICAgIHRoaXMuX2RyYXcoKTtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gIH1cbiAgX2RyYXcoKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IG9wdHMsIGNvbHVtblNpemVzLCBsaW5lV2lkdGhzLCBjdHh9ID0gdGhpcztcbiAgICBjb25zdCB7YWxpZ24sIGxhYmVsczogbGFiZWxPcHRzfSA9IG9wdHM7XG4gICAgY29uc3QgZGVmYXVsdENvbG9yID0gZGVmYXVsdHMuY29sb3I7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHtjb2xvcjogZm9udENvbG9yLCBwYWRkaW5nfSA9IGxhYmVsT3B0cztcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IGhhbGZGb250U2l6ZSA9IGZvbnRTaXplIC8gMjtcbiAgICBsZXQgY3Vyc29yO1xuICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oJ2xlZnQnKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDAuNTtcbiAgICBjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG4gICAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHQsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcbiAgICBjb25zdCBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgaWYgKGlzTmFOKGJveFdpZHRoKSB8fCBib3hXaWR0aCA8PSAwIHx8IGlzTmFOKGJveEhlaWdodCkgfHwgYm94SGVpZ2h0IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lV2lkdGgsIDEpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uZmlsbFN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuICAgICAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVDYXAsICdidXR0Jyk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoT2Zmc2V0LCAwKTtcbiAgICAgIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUpvaW4sICdtaXRlcicpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uc3Ryb2tlU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICBjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lRGFzaCwgW10pKTtcbiAgICAgIGlmIChsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgICByYWRpdXM6IGJveFdpZHRoICogTWF0aC5TUVJUMiAvIDIsXG4gICAgICAgICAgcG9pbnRTdHlsZTogbGVnZW5kSXRlbS5wb2ludFN0eWxlLFxuICAgICAgICAgIHJvdGF0aW9uOiBsZWdlbmRJdGVtLnJvdGF0aW9uLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiBsaW5lV2lkdGhcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci54UGx1cyh4LCBib3hXaWR0aCAvIDIpO1xuICAgICAgICBjb25zdCBjZW50ZXJZID0geSArIGhhbGZGb250U2l6ZTtcbiAgICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeUJveFRvcCA9IHkgKyBNYXRoLm1heCgoZm9udFNpemUgLSBib3hIZWlnaHQpIC8gMiwgMCk7XG4gICAgICAgIGNvbnN0IHhCb3hMZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIoeCwgYm94V2lkdGgpO1xuICAgICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxlZ2VuZEl0ZW0uYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICAgIHg6IHhCb3hMZWZ0LFxuICAgICAgICAgICAgeTogeUJveFRvcCxcbiAgICAgICAgICAgIHc6IGJveFdpZHRoLFxuICAgICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LnJlY3QoeEJveExlZnQsIHlCb3hUb3AsIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggIT09IDApIHtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcbiAgICBjb25zdCBmaWxsVGV4dCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsZWdlbmRJdGVtLnRleHQsIHgsIHkgKyAoaXRlbUhlaWdodCAvIDIpLCBsYWJlbEZvbnQsIHtcbiAgICAgICAgc3RyaWtldGhyb3VnaDogbGVnZW5kSXRlbS5oaWRkZW4sXG4gICAgICAgIHRleHRBbGlnbjogcnRsSGVscGVyLnRleHRBbGlnbihsZWdlbmRJdGVtLnRleHRBbGlnbilcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgeDogX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSBsaW5lV2lkdGhzWzBdKSxcbiAgICAgICAgeTogdGhpcy50b3AgKyBwYWRkaW5nICsgdGl0bGVIZWlnaHQsXG4gICAgICAgIGxpbmU6IDBcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgeDogdGhpcy5sZWZ0ICsgcGFkZGluZyxcbiAgICAgICAgeTogX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIGNvbHVtblNpemVzWzBdLmhlaWdodCksXG4gICAgICAgIGxpbmU6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvciB8fCBmb250Q29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gbGVnZW5kSXRlbS5mb250Q29sb3IgfHwgZm9udENvbG9yO1xuICAgICAgY29uc3QgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICBjb25zdCB0ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduIHx8IChsZWdlbmRJdGVtLnRleHRBbGlnbiA9IGxhYmVsT3B0cy50ZXh0QWxpZ24pKTtcbiAgICAgIGNvbnN0IHdpZHRoID0gYm94V2lkdGggKyBoYWxmRm9udFNpemUgKyB0ZXh0V2lkdGg7XG4gICAgICBsZXQgeCA9IGN1cnNvci54O1xuICAgICAgbGV0IHkgPSBjdXJzb3IueTtcbiAgICAgIHJ0bEhlbHBlci5zZXRXaWR0aCh0aGlzLndpZHRoKTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGkgPiAwICYmIHggKyB3aWR0aCArIHBhZGRpbmcgPiB0aGlzLnJpZ2h0KSB7XG4gICAgICAgICAgeSA9IGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgY3Vyc29yLmxpbmUrKztcbiAgICAgICAgICB4ID0gY3Vyc29yLnggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpID4gMCAmJiB5ICsgbGluZUhlaWdodCA+IHRoaXMuYm90dG9tKSB7XG4gICAgICAgIHggPSBjdXJzb3IueCA9IHggKyBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0ud2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICB5ID0gY3Vyc29yLnkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWFsWCA9IHJ0bEhlbHBlci54KHgpO1xuICAgICAgZHJhd0xlZ2VuZEJveChyZWFsWCwgeSwgbGVnZW5kSXRlbSk7XG4gICAgICB4ID0gX3RleHRYKHRleHRBbGlnbiwgeCArIGJveFdpZHRoICsgaGFsZkZvbnRTaXplLCBpc0hvcml6b250YWwgPyB4ICsgd2lkdGggOiB0aGlzLnJpZ2h0LCBvcHRzLnJ0bCk7XG4gICAgICBmaWxsVGV4dChydGxIZWxwZXIueCh4KSwgeSwgbGVnZW5kSXRlbSk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGN1cnNvci54ICs9IHdpZHRoICsgcGFkZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdG9yZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG4gIH1cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gb3B0cy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG4gICAgaWYgKCF0aXRsZU9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdHMucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGl0bGVPcHRzLnBvc2l0aW9uO1xuICAgIGNvbnN0IGhhbGZGb250U2l6ZSA9IHRpdGxlRm9udC5zaXplIC8gMjtcbiAgICBjb25zdCB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSA9IHRpdGxlUGFkZGluZy50b3AgKyBoYWxmRm9udFNpemU7XG4gICAgbGV0IHk7XG4gICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgbGV0IG1heFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgbWF4V2lkdGggPSBNYXRoLm1heCguLi50aGlzLmxpbmVXaWR0aHMpO1xuICAgICAgeSA9IHRoaXMudG9wICsgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemU7XG4gICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgbGVmdCwgdGhpcy5yaWdodCAtIG1heFdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gdGhpcy5jb2x1bW5TaXplcy5yZWR1Y2UoKGFjYywgc2l6ZSkgPT4gTWF0aC5tYXgoYWNjLCBzaXplLmhlaWdodCksIDApO1xuICAgICAgeSA9IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplICsgX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgdGhpcy50b3AsIHRoaXMuYm90dG9tIC0gbWF4SGVpZ2h0IC0gb3B0cy5sYWJlbHMucGFkZGluZyAtIHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpKTtcbiAgICB9XG4gICAgY29uc3QgeCA9IF9hbGlnblN0YXJ0RW5kKHBvc2l0aW9uLCBsZWZ0LCBsZWZ0ICsgbWF4V2lkdGgpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKF90b0xlZnRSaWdodENlbnRlcihwb3NpdGlvbikpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlT3B0cy50ZXh0LCB4LCB5LCB0aXRsZUZvbnQpO1xuICB9XG4gIF9jb21wdXRlVGl0bGVIZWlnaHQoKSB7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcbiAgICByZXR1cm4gdGl0bGVPcHRzLmRpc3BsYXkgPyB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlUGFkZGluZy5oZWlnaHQgOiAwO1xuICB9XG4gIF9nZXRMZWdlbmRJdGVtQXQoeCwgeSkge1xuICAgIGxldCBpLCBoaXRCb3gsIGxoO1xuICAgIGlmIChfaXNCZXR3ZWVuKHgsIHRoaXMubGVmdCwgdGhpcy5yaWdodClcbiAgICAgICYmIF9pc0JldHdlZW4oeSwgdGhpcy50b3AsIHRoaXMuYm90dG9tKSkge1xuICAgICAgbGggPSB0aGlzLmxlZ2VuZEhpdEJveGVzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGhpdEJveCA9IGxoW2ldO1xuICAgICAgICBpZiAoX2lzQmV0d2Vlbih4LCBoaXRCb3gubGVmdCwgaGl0Qm94LmxlZnQgKyBoaXRCb3gud2lkdGgpXG4gICAgICAgICAgJiYgX2lzQmV0d2Vlbih5LCBoaXRCb3gudG9wLCBoaXRCb3gudG9wICsgaGl0Qm94LmhlaWdodCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sZWdlbmRJdGVtc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBoYW5kbGVFdmVudChlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIWlzTGlzdGVuZWQoZS50eXBlLCBvcHRzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBob3ZlcmVkSXRlbSA9IHRoaXMuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5faG92ZXJlZEl0ZW07XG4gICAgICBjb25zdCBzYW1lSXRlbSA9IGl0ZW1zRXF1YWwocHJldmlvdXMsIGhvdmVyZWRJdGVtKTtcbiAgICAgIGlmIChwcmV2aW91cyAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbGJhY2sob3B0cy5vbkxlYXZlLCBbZSwgcHJldmlvdXMsIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gaG92ZXJlZEl0ZW07XG4gICAgICBpZiAoaG92ZXJlZEl0ZW0gJiYgIXNhbWVJdGVtKSB7XG4gICAgICAgIGNhbGxiYWNrKG9wdHMub25Ib3ZlciwgW2UsIGhvdmVyZWRJdGVtLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChob3ZlcmVkSXRlbSkge1xuICAgICAgY2FsbGJhY2sob3B0cy5vbkNsaWNrLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTGlzdGVuZWQodHlwZSwgb3B0cykge1xuICBpZiAodHlwZSA9PT0gJ21vdXNlbW92ZScgJiYgKG9wdHMub25Ib3ZlciB8fCBvcHRzLm9uTGVhdmUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9wdHMub25DbGljayAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAnbW91c2V1cCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIHBsdWdpbl9sZWdlbmQgPSB7XG4gIGlkOiAnbGVnZW5kJyxcbiAgX2VsZW1lbnQ6IExlZ2VuZCxcbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kID0gbmV3IExlZ2VuZCh7Y3R4OiBjaGFydC5jdHgsIG9wdGlvbnMsIGNoYXJ0fSk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIGxlZ2VuZCk7XG4gIH0sXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgY2hhcnQubGVnZW5kKTtcbiAgICBkZWxldGUgY2hhcnQubGVnZW5kO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxlZ2VuZC5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcbiAgYWZ0ZXJVcGRhdGUoY2hhcnQpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGVnZW5kLmJ1aWxkTGFiZWxzKCk7XG4gICAgbGVnZW5kLmFkanVzdEhpdEJveGVzKCk7XG4gIH0sXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MucmVwbGF5KSB7XG4gICAgICBjaGFydC5sZWdlbmQuaGFuZGxlRXZlbnQoYXJncy5ldmVudCk7XG4gICAgfVxuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICB3ZWlnaHQ6IDEwMDAsXG4gICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGVnZW5kSXRlbS5kYXRhc2V0SW5kZXg7XG4gICAgICBjb25zdCBjaSA9IGxlZ2VuZC5jaGFydDtcbiAgICAgIGlmIChjaS5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KSkge1xuICAgICAgICBjaS5oaWRlKGluZGV4KTtcbiAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2kuc2hvdyhpbmRleCk7XG4gICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkhvdmVyOiBudWxsLFxuICAgIG9uTGVhdmU6IG51bGwsXG4gICAgbGFiZWxzOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBib3hXaWR0aDogNDAsXG4gICAgICBwYWRkaW5nOiAxMCxcbiAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcbiAgICAgICAgY29uc3Qge2xhYmVsczoge3VzZVBvaW50U3R5bGUsIHBvaW50U3R5bGUsIHRleHRBbGlnbiwgY29sb3J9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICByZXR1cm4gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcygpLm1hcCgobWV0YSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHVzZVBvaW50U3R5bGUgPyAwIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICBjb25zdCBib3JkZXJXaWR0aCA9IHRvUGFkZGluZyhzdHlsZS5ib3JkZXJXaWR0aCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGRhdGFzZXRzW21ldGEuaW5kZXhdLmxhYmVsLFxuICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgaGlkZGVuOiAhbWV0YS52aXNpYmxlLFxuICAgICAgICAgICAgbGluZUNhcDogc3R5bGUuYm9yZGVyQ2FwU3R5bGUsXG4gICAgICAgICAgICBsaW5lRGFzaDogc3R5bGUuYm9yZGVyRGFzaCxcbiAgICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgbGluZUpvaW46IHN0eWxlLmJvcmRlckpvaW5TdHlsZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogKGJvcmRlcldpZHRoLndpZHRoICsgYm9yZGVyV2lkdGguaGVpZ2h0KSAvIDQsXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlIHx8IHN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgICAgICByb3RhdGlvbjogc3R5bGUucm90YXRpb24sXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbiB8fCBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRpdGxlOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAgICAgIHRleHQ6ICcnLFxuICAgIH1cbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gICAgbGFiZWxzOiB7XG4gICAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFbJ2dlbmVyYXRlTGFiZWxzJywgJ2ZpbHRlcicsICdzb3J0J10uaW5jbHVkZXMobmFtZSksXG4gICAgfVxuICB9LFxufTtcblxuY2xhc3MgVGl0bGUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLl9wYWRkaW5nID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICB0aGlzLmxlZnQgPSAwO1xuICAgIHRoaXMudG9wID0gMDtcbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5yaWdodCA9IHRoaXMuYm90dG9tID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy53aWR0aCA9IHRoaXMucmlnaHQgPSBtYXhXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuYm90dG9tID0gbWF4SGVpZ2h0O1xuICAgIGNvbnN0IGxpbmVDb3VudCA9IGlzQXJyYXkob3B0cy50ZXh0KSA/IG9wdHMudGV4dC5sZW5ndGggOiAxO1xuICAgIHRoaXMuX3BhZGRpbmcgPSB0b1BhZGRpbmcob3B0cy5wYWRkaW5nKTtcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IGxpbmVDb3VudCAqIHRvRm9udChvcHRzLmZvbnQpLmxpbmVIZWlnaHQgKyB0aGlzLl9wYWRkaW5nLmhlaWdodDtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0ZXh0U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHRleHRTaXplO1xuICAgIH1cbiAgfVxuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgIHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XG4gIH1cbiAgX2RyYXdBcmdzKG9mZnNldCkge1xuICAgIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBhbGlnbiA9IG9wdGlvbnMuYWxpZ247XG4gICAgbGV0IHJvdGF0aW9uID0gMDtcbiAgICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuICAgICAgdGl0bGVZID0gdG9wICsgb2Zmc2V0O1xuICAgICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgdGl0bGVYID0gbGVmdCArIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIC0wLjU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aXRsZVggPSByaWdodCAtIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRvcCwgYm90dG9tKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIDAuNTtcbiAgICAgIH1cbiAgICAgIG1heFdpZHRoID0gYm90dG9tIC0gdG9wO1xuICAgIH1cbiAgICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xuICB9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmb250T3B0cyA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBmb250T3B0cy5saW5lSGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldCA9IGxpbmVIZWlnaHQgLyAyICsgdGhpcy5fcGFkZGluZy50b3A7XG4gICAgY29uc3Qge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259ID0gdGhpcy5fZHJhd0FyZ3Mob2Zmc2V0KTtcbiAgICByZW5kZXJUZXh0KGN0eCwgb3B0cy50ZXh0LCAwLCAwLCBmb250T3B0cywge1xuICAgICAgY29sb3I6IG9wdHMuY29sb3IsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduOiBfdG9MZWZ0UmlnaHRDZW50ZXIob3B0cy5hbGlnbiksXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgdHJhbnNsYXRpb246IFt0aXRsZVgsIHRpdGxlWV0sXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVRpdGxlKGNoYXJ0LCB0aXRsZU9wdHMpIHtcbiAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgIGN0eDogY2hhcnQuY3R4LFxuICAgIG9wdGlvbnM6IHRpdGxlT3B0cyxcbiAgICBjaGFydFxuICB9KTtcbiAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCB0aXRsZU9wdHMpO1xuICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICBjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XG59XG52YXIgcGx1Z2luX3RpdGxlID0ge1xuICBpZDogJ3RpdGxlJyxcbiAgX2VsZW1lbnQ6IFRpdGxlLFxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjcmVhdGVUaXRsZShjaGFydCwgb3B0aW9ucyk7XG4gIH0sXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCB0aXRsZUJsb2NrID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgdGl0bGVCbG9jayk7XG4gICAgZGVsZXRlIGNoYXJ0LnRpdGxlQmxvY2s7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAxMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAyMDAwXG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcblxuY29uc3QgbWFwID0gbmV3IFdlYWtNYXAoKTtcbnZhciBwbHVnaW5fc3VidGl0bGUgPSB7XG4gIGlkOiAnc3VidGl0bGUnLFxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgICBjdHg6IGNoYXJ0LmN0eCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBjaGFydFxuICAgIH0pO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcbiAgICBtYXAuc2V0KGNoYXJ0LCB0aXRsZSk7XG4gIH0sXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgbWFwLmdldChjaGFydCkpO1xuICAgIG1hcC5kZWxldGUoY2hhcnQpO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBtYXAuZ2V0KGNoYXJ0KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdub3JtYWwnLFxuICAgIH0sXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcGFkZGluZzogMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAxNTAwXG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcblxuY29uc3QgcG9zaXRpb25lcnMgPSB7XG4gIGF2ZXJhZ2UoaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaSwgbGVuO1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgZWwgPSBpdGVtc1tpXS5lbGVtZW50O1xuICAgICAgaWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY29uc3QgcG9zID0gZWwudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICAgIHggKz0gcG9zLng7XG4gICAgICAgIHkgKz0gcG9zLnk7XG4gICAgICAgICsrY291bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4OiB4IC8gY291bnQsXG4gICAgICB5OiB5IC8gY291bnRcbiAgICB9O1xuICB9LFxuICBuZWFyZXN0KGl0ZW1zLCBldmVudFBvc2l0aW9uKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHggPSBldmVudFBvc2l0aW9uLng7XG4gICAgbGV0IHkgPSBldmVudFBvc2l0aW9uLnk7XG4gICAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBpLCBsZW4sIG5lYXJlc3RFbGVtZW50O1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBlbC5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgICBjb25zdCBkID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGV2ZW50UG9zaXRpb24sIGNlbnRlcik7XG4gICAgICAgIGlmIChkIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGQ7XG4gICAgICAgICAgbmVhcmVzdEVsZW1lbnQgPSBlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVhcmVzdEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHRwID0gbmVhcmVzdEVsZW1lbnQudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICB4ID0gdHAueDtcbiAgICAgIHkgPSB0cC55O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gcHVzaE9yQ29uY2F0KGJhc2UsIHRvUHVzaCkge1xuICBpZiAodG9QdXNoKSB7XG4gICAgaWYgKGlzQXJyYXkodG9QdXNoKSkge1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYmFzZSwgdG9QdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZS5wdXNoKHRvUHVzaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiYXNlO1xufVxuZnVuY3Rpb24gc3BsaXROZXdsaW5lcyhzdHIpIHtcbiAgaWYgKCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpICYmIHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnXFxuJyk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGNoYXJ0LCBpdGVtKSB7XG4gIGNvbnN0IHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSA9IGl0ZW07XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gIGNvbnN0IHtsYWJlbCwgdmFsdWV9ID0gY29udHJvbGxlci5nZXRMYWJlbEFuZFZhbHVlKGluZGV4KTtcbiAgcmV0dXJuIHtcbiAgICBjaGFydCxcbiAgICBsYWJlbCxcbiAgICBwYXJzZWQ6IGNvbnRyb2xsZXIuZ2V0UGFyc2VkKGluZGV4KSxcbiAgICByYXc6IGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSxcbiAgICBmb3JtYXR0ZWRWYWx1ZTogdmFsdWUsXG4gICAgZGF0YXNldDogY29udHJvbGxlci5nZXREYXRhc2V0KCksXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBkYXRhc2V0SW5kZXgsXG4gICAgZWxlbWVudFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VG9vbHRpcFNpemUodG9vbHRpcCwgb3B0aW9ucykge1xuICBjb25zdCBjdHggPSB0b29sdGlwLmNoYXJ0LmN0eDtcbiAgY29uc3Qge2JvZHksIGZvb3RlciwgdGl0bGV9ID0gdG9vbHRpcDtcbiAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHR9ID0gb3B0aW9ucztcbiAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gIGNvbnN0IGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcbiAgY29uc3QgdGl0bGVMaW5lQ291bnQgPSB0aXRsZS5sZW5ndGg7XG4gIGNvbnN0IGZvb3RlckxpbmVDb3VudCA9IGZvb3Rlci5sZW5ndGg7XG4gIGNvbnN0IGJvZHlMaW5lSXRlbUNvdW50ID0gYm9keS5sZW5ndGg7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgbGV0IGhlaWdodCA9IHBhZGRpbmcuaGVpZ2h0O1xuICBsZXQgd2lkdGggPSAwO1xuICBsZXQgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoKGNvdW50LCBib2R5SXRlbSkgPT4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoLCAwKTtcbiAgY29tYmluZWRCb2R5TGVuZ3RoICs9IHRvb2x0aXAuYmVmb3JlQm9keS5sZW5ndGggKyB0b29sdGlwLmFmdGVyQm9keS5sZW5ndGg7XG4gIGlmICh0aXRsZUxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCAqIHRpdGxlRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrICh0aXRsZUxpbmVDb3VudCAtIDEpICogb3B0aW9ucy50aXRsZVNwYWNpbmdcblx0XHRcdCsgb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbTtcbiAgfVxuICBpZiAoY29tYmluZWRCb2R5TGVuZ3RoKSB7XG4gICAgY29uc3QgYm9keUxpbmVIZWlnaHQgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyBNYXRoLm1heChib3hIZWlnaHQsIGJvZHlGb250LmxpbmVIZWlnaHQpIDogYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBoZWlnaHQgKz0gYm9keUxpbmVJdGVtQ291bnQgKiBib2R5TGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gYm9keUxpbmVJdGVtQ291bnQpICogYm9keUZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBvcHRpb25zLmJvZHlTcGFjaW5nO1xuICB9XG4gIGlmIChmb290ZXJMaW5lQ291bnQpIHtcbiAgICBoZWlnaHQgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3Bcblx0XHRcdCsgZm9vdGVyTGluZUNvdW50ICogZm9vdGVyRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgfVxuICBsZXQgd2lkdGhQYWRkaW5nID0gMDtcbiAgY29uc3QgbWF4TGluZVdpZHRoID0gZnVuY3Rpb24obGluZSkge1xuICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aCArIHdpZHRoUGFkZGluZyk7XG4gIH07XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmJlZm9yZUJvZHkuY29uY2F0KHRvb2x0aXAuYWZ0ZXJCb2R5KSwgbWF4TGluZVdpZHRoKTtcbiAgd2lkdGhQYWRkaW5nID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gKGJveFdpZHRoICsgMiArIG9wdGlvbnMuYm94UGFkZGluZykgOiAwO1xuICBlYWNoKGJvZHksIChib2R5SXRlbSkgPT4ge1xuICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5hZnRlciwgbWF4TGluZVdpZHRoKTtcbiAgfSk7XG4gIHdpZHRoUGFkZGluZyA9IDA7XG4gIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5mb290ZXIsIG1heExpbmVXaWR0aCk7XG4gIGN0eC5yZXN0b3JlKCk7XG4gIHdpZHRoICs9IHBhZGRpbmcud2lkdGg7XG4gIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpIHtcbiAgY29uc3Qge3ksIGhlaWdodH0gPSBzaXplO1xuICBpZiAoeSA8IGhlaWdodCAvIDIpIHtcbiAgICByZXR1cm4gJ3RvcCc7XG4gIH0gZWxzZSBpZiAoeSA+IChjaGFydC5oZWlnaHQgLSBoZWlnaHQgLyAyKSkge1xuICAgIHJldHVybiAnYm90dG9tJztcbiAgfVxuICByZXR1cm4gJ2NlbnRlcic7XG59XG5mdW5jdGlvbiBkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IGNhcmV0ID0gb3B0aW9ucy5jYXJldFNpemUgKyBvcHRpb25zLmNhcmV0UGFkZGluZztcbiAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnICYmIHggKyB3aWR0aCArIGNhcmV0ID4gY2hhcnQud2lkdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoeEFsaWduID09PSAncmlnaHQnICYmIHggLSB3aWR0aCAtIGNhcmV0IDwgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbikge1xuICBjb25zdCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgY29uc3Qge3dpZHRoOiBjaGFydFdpZHRoLCBjaGFydEFyZWE6IHtsZWZ0LCByaWdodH19ID0gY2hhcnQ7XG4gIGxldCB4QWxpZ24gPSAnY2VudGVyJztcbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4QWxpZ24gPSB4IDw9IChsZWZ0ICsgcmlnaHQpIC8gMiA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH0gZWxzZSBpZiAoeCA8PSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoeCA+PSBjaGFydFdpZHRoIC0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ3JpZ2h0JztcbiAgfVxuICBpZiAoZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSkge1xuICAgIHhBbGlnbiA9ICdjZW50ZXInO1xuICB9XG4gIHJldHVybiB4QWxpZ247XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3QgeUFsaWduID0gc2l6ZS55QWxpZ24gfHwgb3B0aW9ucy55QWxpZ24gfHwgZGV0ZXJtaW5lWUFsaWduKGNoYXJ0LCBzaXplKTtcbiAgcmV0dXJuIHtcbiAgICB4QWxpZ246IHNpemUueEFsaWduIHx8IG9wdGlvbnMueEFsaWduIHx8IGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSxcbiAgICB5QWxpZ25cbiAgfTtcbn1cbmZ1bmN0aW9uIGFsaWduWChzaXplLCB4QWxpZ24pIHtcbiAgbGV0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3aWR0aDtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAod2lkdGggLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKSB7XG4gIGxldCB7eSwgaGVpZ2h0fSA9IHNpemU7XG4gIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgeSArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSAtPSBoZWlnaHQgKyBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICB5IC09IChoZWlnaHQgLyAyKTtcbiAgfVxuICByZXR1cm4geTtcbn1cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBzaXplLCBhbGlnbm1lbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHtjYXJldFNpemUsIGNhcmV0UGFkZGluZywgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSBhbGlnbm1lbnQ7XG4gIGNvbnN0IHBhZGRpbmdBbmRTaXplID0gY2FyZXRTaXplICsgY2FyZXRQYWRkaW5nO1xuICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcbiAgbGV0IHggPSBhbGlnblgoc2l6ZSwgeEFsaWduKTtcbiAgY29uc3QgeSA9IGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKTtcbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHggKz0gcGFkZGluZ0FuZFNpemU7XG4gICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHggLT0gcGFkZGluZ0FuZFNpemU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgeCAtPSBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIGNhcmV0U2l6ZTtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4ICs9IE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgKyBjYXJldFNpemU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBfbGltaXRWYWx1ZSh4LCAwLCBjaGFydC53aWR0aCAtIHNpemUud2lkdGgpLFxuICAgIHk6IF9saW1pdFZhbHVlKHksIDAsIGNoYXJ0LmhlaWdodCAtIHNpemUuaGVpZ2h0KVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25lZFgodG9vbHRpcCwgYWxpZ24sIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICByZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInXG4gICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC8gMlxuICAgIDogYWxpZ24gPT09ICdyaWdodCdcbiAgICAgID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAtIHBhZGRpbmcucmlnaHRcbiAgICAgIDogdG9vbHRpcC54ICsgcGFkZGluZy5sZWZ0O1xufVxuZnVuY3Rpb24gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHB1c2hPckNvbmNhdChbXSwgc3BsaXROZXdsaW5lcyhjYWxsYmFjaykpO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcENvbnRleHQocGFyZW50LCB0b29sdGlwLCB0b29sdGlwSXRlbXMpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgdG9vbHRpcCxcbiAgICB0b29sdGlwSXRlbXMsXG4gICAgdHlwZTogJ3Rvb2x0aXAnXG4gIH0pO1xufVxuZnVuY3Rpb24gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KSB7XG4gIGNvbnN0IG92ZXJyaWRlID0gY29udGV4dCAmJiBjb250ZXh0LmRhdGFzZXQgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAuY2FsbGJhY2tzO1xuICByZXR1cm4gb3ZlcnJpZGUgPyBjYWxsYmFja3Mub3ZlcnJpZGUob3ZlcnJpZGUpIDogY2FsbGJhY2tzO1xufVxuY2xhc3MgVG9vbHRpcCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3BhY2l0eSA9IDA7XG4gICAgdGhpcy5fYWN0aXZlID0gW107XG4gICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zaXplID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdG9vbHRpcEl0ZW1zID0gW107XG4gICAgdGhpcy4kYW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQgfHwgY29uZmlnLl9jaGFydDtcbiAgICB0aGlzLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5kYXRhUG9pbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGl0bGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iZWZvcmVCb2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFmdGVyQm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvb3RlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnhBbGlnbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnlBbGlnbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jYXJldFggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jYXJldFkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdGlhbGl6ZShvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgX3Jlc29sdmVBbmltYXRpb25zKCkge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX2NhY2hlZEFuaW1hdGlvbnM7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMuZW5hYmxlZCAmJiBjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAmJiBvcHRpb25zLmFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKHRoaXMuY2hhcnQsIG9wdHMpO1xuICAgIGlmIChvcHRzLl9jYWNoZWFibGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVRvb2x0aXBDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLCB0aGlzLl90b29sdGlwSXRlbXMpKTtcbiAgfVxuICBnZXRUaXRsZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJlZm9yZVRpdGxlID0gY2FsbGJhY2tzLmJlZm9yZVRpdGxlLmFwcGx5KHRoaXMsIFtjb250ZXh0XSk7XG4gICAgY29uc3QgdGl0bGUgPSBjYWxsYmFja3MudGl0bGUuYXBwbHkodGhpcywgW2NvbnRleHRdKTtcbiAgICBjb25zdCBhZnRlclRpdGxlID0gY2FsbGJhY2tzLmFmdGVyVGl0bGUuYXBwbHkodGhpcywgW2NvbnRleHRdKTtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVUaXRsZSkpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKHRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJUaXRsZSkpO1xuICAgIHJldHVybiBsaW5lcztcbiAgfVxuICBnZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhvcHRpb25zLmNhbGxiYWNrcy5iZWZvcmVCb2R5LmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKSk7XG4gIH1cbiAgZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUl0ZW1zID0gW107XG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBib2R5SXRlbSA9IHtcbiAgICAgICAgYmVmb3JlOiBbXSxcbiAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICBhZnRlcjogW11cbiAgICAgIH07XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmJlZm9yZSwgc3BsaXROZXdsaW5lcyhzY29wZWQuYmVmb3JlTGFiZWwuY2FsbCh0aGlzLCBjb250ZXh0KSkpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmxpbmVzLCBzY29wZWQubGFiZWwuY2FsbCh0aGlzLCBjb250ZXh0KSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoc2NvcGVkLmFmdGVyTGFiZWwuY2FsbCh0aGlzLCBjb250ZXh0KSkpO1xuICAgICAgYm9keUl0ZW1zLnB1c2goYm9keUl0ZW0pO1xuICAgIH0pO1xuICAgIHJldHVybiBib2R5SXRlbXM7XG4gIH1cbiAgZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhvcHRpb25zLmNhbGxiYWNrcy5hZnRlckJvZHkuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pKTtcbiAgfVxuICBnZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJlZm9yZUZvb3RlciA9IGNhbGxiYWNrcy5iZWZvcmVGb290ZXIuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pO1xuICAgIGNvbnN0IGZvb3RlciA9IGNhbGxiYWNrcy5mb290ZXIuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pO1xuICAgIGNvbnN0IGFmdGVyRm9vdGVyID0gY2FsbGJhY2tzLmFmdGVyRm9vdGVyLmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKTtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVGb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhmb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlckZvb3RlcikpO1xuICAgIHJldHVybiBsaW5lcztcbiAgfVxuICBfY3JlYXRlSXRlbXMob3B0aW9ucykge1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gW107XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlcyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgbGVuO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdG9vbHRpcEl0ZW1zLnB1c2goY3JlYXRlVG9vbHRpcEl0ZW0odGhpcy5jaGFydCwgYWN0aXZlW2ldKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZpbHRlcikge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLmZpbHRlcigoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBvcHRpb25zLmZpbHRlcihlbGVtZW50LCBpbmRleCwgYXJyYXksIGRhdGEpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaXRlbVNvcnQpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5zb3J0KChhLCBiKSA9PiBvcHRpb25zLml0ZW1Tb3J0KGEsIGIsIGRhdGEpKTtcbiAgICB9XG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhvcHRpb25zLmNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBsYWJlbENvbG9ycy5wdXNoKHNjb3BlZC5sYWJlbENvbG9yLmNhbGwodGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxQb2ludFN0eWxlcy5wdXNoKHNjb3BlZC5sYWJlbFBvaW50U3R5bGUuY2FsbCh0aGlzLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFRleHRDb2xvcnMucHVzaChzY29wZWQubGFiZWxUZXh0Q29sb3IuY2FsbCh0aGlzLCBjb250ZXh0KSk7XG4gICAgfSk7XG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IGxhYmVsUG9pbnRTdHlsZXM7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSBsYWJlbFRleHRDb2xvcnM7XG4gICAgdGhpcy5kYXRhUG9pbnRzID0gdG9vbHRpcEl0ZW1zO1xuICAgIHJldHVybiB0b29sdGlwSXRlbXM7XG4gIH1cbiAgdXBkYXRlKGNoYW5nZWQsIHJlcGxheSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGxldCBwcm9wZXJ0aWVzO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICBpZiAoIWFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLm9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdGhpcy5fY3JlYXRlSXRlbXMob3B0aW9ucyk7XG4gICAgICB0aGlzLnRpdGxlID0gdGhpcy5nZXRUaXRsZSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5iZWZvcmVCb2R5ID0gdGhpcy5nZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJvZHkgPSB0aGlzLmdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdGhpcy5nZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZm9vdGVyID0gdGhpcy5nZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQodGhpcy5jaGFydCwgb3B0aW9ucywgcG9zaXRpb25BbmRTaXplKTtcbiAgICAgIGNvbnN0IGJhY2tncm91bmRQb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgdGhpcy5jaGFydCk7XG4gICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICB4OiBiYWNrZ3JvdW5kUG9pbnQueCxcbiAgICAgICAgeTogYmFja2dyb3VuZFBvaW50LnksXG4gICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgICAgICBjYXJldFg6IHBvc2l0aW9uLngsXG4gICAgICAgIGNhcmV0WTogcG9zaXRpb24ueVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5fdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlZCAmJiBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICBvcHRpb25zLmV4dGVybmFsLmNhbGwodGhpcywge2NoYXJ0OiB0aGlzLmNoYXJ0LCB0b29sdGlwOiB0aGlzLCByZXBsYXl9KTtcbiAgICB9XG4gIH1cbiAgZHJhd0NhcmV0KHRvb2x0aXBQb2ludCwgY3R4LCBzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2FyZXRQb3NpdGlvbiA9IHRoaXMuZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MSwgY2FyZXRQb3NpdGlvbi55MSk7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngyLCBjYXJldFBvc2l0aW9uLnkyKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDMsIGNhcmV0UG9zaXRpb24ueTMpO1xuICB9XG4gIGdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge2NhcmV0U2l6ZSwgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG4gICAgY29uc3Qge3g6IHB0WCwgeTogcHRZfSA9IHRvb2x0aXBQb2ludDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzaXplO1xuICAgIGxldCB4MSwgeDIsIHgzLCB5MSwgeTIsIHkzO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICB5MiA9IHB0WSArIChoZWlnaHQgLyAyKTtcbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MSA9IHB0WDtcbiAgICAgICAgeDIgPSB4MSAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeTEgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgxID0gcHRYICsgd2lkdGg7XG4gICAgICAgIHgyID0geDEgKyBjYXJldFNpemU7XG4gICAgICAgIHkxID0geTIgLSBjYXJldFNpemU7XG4gICAgICAgIHkzID0geTIgKyBjYXJldFNpemU7XG4gICAgICB9XG4gICAgICB4MyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDIgPSBwdFggKyBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIChjYXJldFNpemUpO1xuICAgICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeDIgPSBwdFggKyB3aWR0aCAtIE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgLSBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MiA9IHRoaXMuY2FyZXRYO1xuICAgICAgfVxuICAgICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgeTEgPSBwdFk7XG4gICAgICAgIHkyID0geTEgLSBjYXJldFNpemU7XG4gICAgICAgIHgxID0geDIgLSBjYXJldFNpemU7XG4gICAgICAgIHgzID0geDIgKyBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5MSA9IHB0WSArIGhlaWdodDtcbiAgICAgICAgeTIgPSB5MSArIGNhcmV0U2l6ZTtcbiAgICAgICAgeDEgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH1cbiAgICAgIHkzID0geTE7XG4gICAgfVxuICAgIHJldHVybiB7eDEsIHgyLCB4MywgeTEsIHkyLCB5M307XG4gIH1cbiAgZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMudGl0bGU7XG4gICAgY29uc3QgbGVuZ3RoID0gdGl0bGUubGVuZ3RoO1xuICAgIGxldCB0aXRsZUZvbnQsIHRpdGxlU3BhY2luZywgaTtcbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMudGl0bGVBbGlnbiwgb3B0aW9ucyk7XG4gICAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihvcHRpb25zLnRpdGxlQWxpZ24pO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgICAgIHRpdGxlU3BhY2luZyA9IG9wdGlvbnMudGl0bGVTcGFjaW5nO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMudGl0bGVDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjdHguZmlsbFRleHQodGl0bGVbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgdGl0bGVGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlU3BhY2luZztcbiAgICAgICAgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBwdC55ICs9IG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b20gLSB0aXRsZVNwYWNpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsYWJlbENvbG9ycyA9IHRoaXMubGFiZWxDb2xvcnNbaV07XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlID0gdGhpcy5sYWJlbFBvaW50U3R5bGVzW2ldO1xuICAgIGNvbnN0IHtib3hIZWlnaHQsIGJveFdpZHRoLCBib3hQYWRkaW5nfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgY29uc3QgY29sb3JYID0gZ2V0QWxpZ25lZFgodGhpcywgJ2xlZnQnLCBvcHRpb25zKTtcbiAgICBjb25zdCBydGxDb2xvclggPSBydGxIZWxwZXIueChjb2xvclgpO1xuICAgIGNvbnN0IHlPZmZTZXQgPSBib3hIZWlnaHQgPCBib2R5Rm9udC5saW5lSGVpZ2h0ID8gKGJvZHlGb250LmxpbmVIZWlnaHQgLSBib3hIZWlnaHQpIC8gMiA6IDA7XG4gICAgY29uc3QgY29sb3JZID0gcHQueSArIHlPZmZTZXQ7XG4gICAgaWYgKG9wdGlvbnMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgIHJhZGl1czogTWF0aC5taW4oYm94V2lkdGgsIGJveEhlaWdodCkgLyAyLFxuICAgICAgICBwb2ludFN0eWxlOiBsYWJlbFBvaW50U3R5bGUucG9pbnRTdHlsZSxcbiAgICAgICAgcm90YXRpb246IGxhYmVsUG9pbnRTdHlsZS5yb3RhdGlvbixcbiAgICAgICAgYm9yZGVyV2lkdGg6IDFcbiAgICAgIH07XG4gICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCkgKyBib3hXaWR0aCAvIDI7XG4gICAgICBjb25zdCBjZW50ZXJZID0gY29sb3JZICsgYm94SGVpZ2h0IC8gMjtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvcnMuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gbGFiZWxDb2xvcnMuYm9yZGVyV2lkdGggfHwgMTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3JzLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LnNldExpbmVEYXNoKGxhYmVsQ29sb3JzLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGFiZWxDb2xvcnMuYm9yZGVyRGFzaE9mZnNldCB8fCAwO1xuICAgICAgY29uc3Qgb3V0ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCAtIGJveFBhZGRpbmcpO1xuICAgICAgY29uc3QgaW5uZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLnhQbHVzKHJ0bENvbG9yWCwgMSksIGJveFdpZHRoIC0gYm94UGFkZGluZyAtIDIpO1xuICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsYWJlbENvbG9ycy5ib3JkZXJSYWRpdXMpO1xuICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICB4OiBvdXRlclgsXG4gICAgICAgICAgeTogY29sb3JZLFxuICAgICAgICAgIHc6IGJveFdpZHRoLFxuICAgICAgICAgIGg6IGJveEhlaWdodCxcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogaW5uZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSArIDEsXG4gICAgICAgICAgdzogYm94V2lkdGggLSAyLFxuICAgICAgICAgIGg6IGJveEhlaWdodCAtIDIsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBjdHguZmlsbFJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICBjdHguc3Ryb2tlUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9ycy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChpbm5lclgsIGNvbG9yWSArIDEsIGJveFdpZHRoIC0gMiwgYm94SGVpZ2h0IC0gMik7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcbiAgfVxuICBkcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2JvZHl9ID0gdGhpcztcbiAgICBjb25zdCB7Ym9keVNwYWNpbmcsIGJvZHlBbGlnbiwgZGlzcGxheUNvbG9ycywgYm94SGVpZ2h0LCBib3hXaWR0aCwgYm94UGFkZGluZ30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGxldCBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgbGV0IHhMaW5lUGFkZGluZyA9IDA7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBmaWxsTGluZU9mVGV4dCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGN0eC5maWxsVGV4dChsaW5lLCBydGxIZWxwZXIueChwdC54ICsgeExpbmVQYWRkaW5nKSwgcHQueSArIGJvZHlMaW5lSGVpZ2h0IC8gMik7XG4gICAgICBwdC55ICs9IGJvZHlMaW5lSGVpZ2h0ICsgYm9keVNwYWNpbmc7XG4gICAgfTtcbiAgICBjb25zdCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oYm9keUFsaWduKTtcbiAgICBsZXQgYm9keUl0ZW0sIHRleHRDb2xvciwgbGluZXMsIGksIGosIGlsZW4sIGpsZW47XG4gICAgY3R4LnRleHRBbGlnbiA9IGJvZHlBbGlnbjtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG4gICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uLCBvcHRpb25zKTtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5ib2R5Q29sb3I7XG4gICAgZWFjaCh0aGlzLmJlZm9yZUJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICB4TGluZVBhZGRpbmcgPSBkaXNwbGF5Q29sb3JzICYmIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uICE9PSAncmlnaHQnXG4gICAgICA/IGJvZHlBbGlnbiA9PT0gJ2NlbnRlcicgPyAoYm94V2lkdGggLyAyICsgYm94UGFkZGluZykgOiAoYm94V2lkdGggKyAyICsgYm94UGFkZGluZylcbiAgICAgIDogMDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gYm9keS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGJvZHlJdGVtID0gYm9keVtpXTtcbiAgICAgIHRleHRDb2xvciA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW2ldO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcbiAgICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBmaWxsTGluZU9mVGV4dCk7XG4gICAgICBsaW5lcyA9IGJvZHlJdGVtLmxpbmVzO1xuICAgICAgaWYgKGRpc3BsYXlDb2xvcnMgJiYgbGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpO1xuICAgICAgICBib2R5TGluZUhlaWdodCA9IE1hdGgubWF4KGJvZHlGb250LmxpbmVIZWlnaHQsIGJveEhlaWdodCk7XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGluZXMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgIGZpbGxMaW5lT2ZUZXh0KGxpbmVzW2pdKTtcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgICAgfVxuICAgICAgZWFjaChib2R5SXRlbS5hZnRlciwgZmlsbExpbmVPZlRleHQpO1xuICAgIH1cbiAgICB4TGluZVBhZGRpbmcgPSAwO1xuICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBlYWNoKHRoaXMuYWZ0ZXJCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG4gICAgcHQueSAtPSBib2R5U3BhY2luZztcbiAgfVxuICBkcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmb290ZXIgPSB0aGlzLmZvb3RlcjtcbiAgICBjb25zdCBsZW5ndGggPSBmb290ZXIubGVuZ3RoO1xuICAgIGxldCBmb290ZXJGb250LCBpO1xuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy5mb290ZXJBbGlnbiwgb3B0aW9ucyk7XG4gICAgICBwdC55ICs9IG9wdGlvbnMuZm9vdGVyTWFyZ2luVG9wO1xuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy5mb290ZXJBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5mb290ZXJDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGZvb3RlcltpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyBmb290ZXJGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSBmb290ZXJGb250LmxpbmVIZWlnaHQgKyBvcHRpb25zLmZvb3RlclNwYWNpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge3gsIHl9ID0gcHQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdG9vbHRpcFNpemU7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKG9wdGlvbnMuY29ybmVyUmFkaXVzKTtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgdG9wTGVmdCwgeSk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSB0b3BSaWdodCwgeSk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyB0b3BSaWdodCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gYm90dG9tUmlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gYm90dG9tUmlnaHQsIHkgKyBoZWlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIGJvdHRvbUxlZnQsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSBib3R0b21MZWZ0KTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHgsIHkgKyB0b3BMZWZ0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgdG9wTGVmdCwgeSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKCk7XG4gICAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9XG4gIF91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucykge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbVggPSBhbmltcyAmJiBhbmltcy54O1xuICAgIGNvbnN0IGFuaW1ZID0gYW5pbXMgJiYgYW5pbXMueTtcbiAgICBpZiAoYW5pbVggfHwgYW5pbVkpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCB0aGlzLl9hY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHRoaXMuX3NpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgcG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIGNoYXJ0KTtcbiAgICAgIGlmIChhbmltWC5fdG8gIT09IHBvaW50LnggfHwgYW5pbVkuX3RvICE9PSBwb2ludC55KSB7XG4gICAgICAgIHRoaXMueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcbiAgICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuICAgICAgICB0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgdGhpcy5jYXJldFggPSBwb3NpdGlvbi54O1xuICAgICAgICB0aGlzLmNhcmV0WSA9IHBvc2l0aW9uLnk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGxldCBvcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgIGlmICghb3BhY2l0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucyk7XG4gICAgY29uc3QgdG9vbHRpcFNpemUgPSB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHB0ID0ge1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55XG4gICAgfTtcbiAgICBvcGFjaXR5ID0gTWF0aC5hYnMob3BhY2l0eSkgPCAxZS0zID8gMCA6IG9wYWNpdHk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICAgIGNvbnN0IGhhc1Rvb2x0aXBDb250ZW50ID0gdGhpcy50aXRsZS5sZW5ndGggfHwgdGhpcy5iZWZvcmVCb2R5Lmxlbmd0aCB8fCB0aGlzLmJvZHkubGVuZ3RoIHx8IHRoaXMuYWZ0ZXJCb2R5Lmxlbmd0aCB8fCB0aGlzLmZvb3Rlci5sZW5ndGg7XG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAmJiBoYXNUb29sdGlwQ29udGVudCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG4gICAgICBwdC55ICs9IHBhZGRpbmcudG9wO1xuICAgICAgdGhpcy5kcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5kcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpO1xuICAgICAgcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuICBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cywgZXZlbnRQb3NpdGlvbikge1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7ZGF0YXNldEluZGV4LCBpbmRleH0pID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBhIGRhdGFzZXQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZXZlbnRQb3NpdGlvbik7XG4gICAgaWYgKGNoYW5nZWQgfHwgcG9zaXRpb25DaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gZXZlbnRQb3NpdGlvbjtcbiAgICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9IHRydWU7XG4gICAgICB0aGlzLnVwZGF0ZSh0cnVlKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSA9IHRydWUpIHtcbiAgICBpZiAocmVwbGF5ICYmIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSBmYWxzZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSk7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSk7XG4gICAgY29uc3QgY2hhbmdlZCA9IHJlcGxheSB8fCAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKSB8fCBwb3NpdGlvbkNoYW5nZWQ7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5leHRlcm5hbCkge1xuICAgICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IGUueCxcbiAgICAgICAgICB5OiBlLnlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGUodHJ1ZSwgcmVwbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cbiAgX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKCFpbkNoYXJ0QXJlYSkge1xuICAgICAgcmV0dXJuIGxhc3RBY3RpdmU7XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuY2hhcnQuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBvcHRpb25zLm1vZGUsIG9wdGlvbnMsIHJlcGxheSk7XG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgYWN0aXZlLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZTtcbiAgfVxuICBfcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSkge1xuICAgIGNvbnN0IHtjYXJldFgsIGNhcmV0WSwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIGUpO1xuICAgIHJldHVybiBwb3NpdGlvbiAhPT0gZmFsc2UgJiYgKGNhcmV0WCAhPT0gcG9zaXRpb24ueCB8fCBjYXJldFkgIT09IHBvc2l0aW9uLnkpO1xuICB9XG59XG5Ub29sdGlwLnBvc2l0aW9uZXJzID0gcG9zaXRpb25lcnM7XG52YXIgcGx1Z2luX3Rvb2x0aXAgPSB7XG4gIGlkOiAndG9vbHRpcCcsXG4gIF9lbGVtZW50OiBUb29sdGlwLFxuICBwb3NpdGlvbmVycyxcbiAgYWZ0ZXJJbml0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjaGFydC50b29sdGlwID0gbmV3IFRvb2x0aXAoe2NoYXJ0LCBvcHRpb25zfSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG4gIHJlc2V0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICBjaGFydC50b29sdGlwLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuICBhZnRlckRyYXcoY2hhcnQpIHtcbiAgICBjb25zdCB0b29sdGlwID0gY2hhcnQudG9vbHRpcDtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgdG9vbHRpcFxuICAgIH07XG4gICAgaWYgKGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVRvb2x0aXBEcmF3JywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0b29sdGlwKSB7XG4gICAgICB0b29sdGlwLmRyYXcoY2hhcnQuY3R4KTtcbiAgICB9XG4gICAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJUb29sdGlwRHJhdycsIGFyZ3MpO1xuICB9LFxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSBhcmdzLnJlcGxheTtcbiAgICAgIGlmIChjaGFydC50b29sdGlwLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQsIHVzZUZpbmFsUG9zaXRpb24sIGFyZ3MuaW5DaGFydEFyZWEpKSB7XG4gICAgICAgIGFyZ3MuY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZXh0ZXJuYWw6IG51bGwsXG4gICAgcG9zaXRpb246ICdhdmVyYWdlJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuICAgIHRpdGxlQ29sb3I6ICcjZmZmJyxcbiAgICB0aXRsZUZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgdGl0bGVTcGFjaW5nOiAyLFxuICAgIHRpdGxlTWFyZ2luQm90dG9tOiA2LFxuICAgIHRpdGxlQWxpZ246ICdsZWZ0JyxcbiAgICBib2R5Q29sb3I6ICcjZmZmJyxcbiAgICBib2R5U3BhY2luZzogMixcbiAgICBib2R5Rm9udDoge1xuICAgIH0sXG4gICAgYm9keUFsaWduOiAnbGVmdCcsXG4gICAgZm9vdGVyQ29sb3I6ICcjZmZmJyxcbiAgICBmb290ZXJTcGFjaW5nOiAyLFxuICAgIGZvb3Rlck1hcmdpblRvcDogNixcbiAgICBmb290ZXJGb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZvb3RlckFsaWduOiAnbGVmdCcsXG4gICAgcGFkZGluZzogNixcbiAgICBjYXJldFBhZGRpbmc6IDIsXG4gICAgY2FyZXRTaXplOiA1LFxuICAgIGNvcm5lclJhZGl1czogNixcbiAgICBib3hIZWlnaHQ6IChjdHgsIG9wdHMpID0+IG9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICBib3hXaWR0aDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIG11bHRpS2V5QmFja2dyb3VuZDogJyNmZmYnLFxuICAgIGRpc3BsYXlDb2xvcnM6IHRydWUsXG4gICAgYm94UGFkZGluZzogMCxcbiAgICBib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMCxcbiAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnLCAnY2FyZXRYJywgJ2NhcmV0WSddLFxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgZHVyYXRpb246IDIwMFxuICAgICAgfVxuICAgIH0sXG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBiZWZvcmVUaXRsZTogbm9vcCxcbiAgICAgIHRpdGxlKHRvb2x0aXBJdGVtcykge1xuICAgICAgICBpZiAodG9vbHRpcEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gdG9vbHRpcEl0ZW1zWzBdO1xuICAgICAgICAgIGNvbnN0IGxhYmVscyA9IGl0ZW0uY2hhcnQuZGF0YS5sYWJlbHM7XG4gICAgICAgICAgY29uc3QgbGFiZWxDb3VudCA9IGxhYmVscyA/IGxhYmVscy5sZW5ndGggOiAwO1xuICAgICAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5sYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubGFiZWw7XG4gICAgICAgICAgfSBlbHNlIGlmIChsYWJlbENvdW50ID4gMCAmJiBpdGVtLmRhdGFJbmRleCA8IGxhYmVsQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbHNbaXRlbS5kYXRhSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9LFxuICAgICAgYWZ0ZXJUaXRsZTogbm9vcCxcbiAgICAgIGJlZm9yZUJvZHk6IG5vb3AsXG4gICAgICBiZWZvcmVMYWJlbDogbm9vcCxcbiAgICAgIGxhYmVsKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgICAgcmV0dXJuIHRvb2x0aXBJdGVtLmxhYmVsICsgJzogJyArIHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlIHx8IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYWJlbCA9IHRvb2x0aXBJdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgIGxhYmVsICs9ICc6ICc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgICAgIGxhYmVsICs9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgIH0sXG4gICAgICBsYWJlbENvbG9yKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0b29sdGlwSXRlbS5jaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICAgICAgICBib3JkZXJEYXNoOiBvcHRpb25zLmJvcmRlckRhc2gsXG4gICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBsYWJlbFRleHRDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ib2R5Q29sb3I7XG4gICAgICB9LFxuICAgICAgbGFiZWxQb2ludFN0eWxlKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0b29sdGlwSXRlbS5jaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcG9pbnRTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxuICAgICAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGFmdGVyTGFiZWw6IG5vb3AsXG4gICAgICBhZnRlckJvZHk6IG5vb3AsXG4gICAgICBiZWZvcmVGb290ZXI6IG5vb3AsXG4gICAgICBmb290ZXI6IG5vb3AsXG4gICAgICBhZnRlckZvb3Rlcjogbm9vcFxuICAgIH1cbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGJvZHlGb250OiAnZm9udCcsXG4gICAgZm9vdGVyRm9udDogJ2ZvbnQnLFxuICAgIHRpdGxlRm9udDogJ2ZvbnQnXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZmlsdGVyJyAmJiBuYW1lICE9PSAnaXRlbVNvcnQnICYmIG5hbWUgIT09ICdleHRlcm5hbCcsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgX2ZhbGxiYWNrOiBmYWxzZVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJ1xuICAgIH1cbiAgfSxcbiAgYWRkaXRpb25hbE9wdGlvblNjb3BlczogWydpbnRlcmFjdGlvbiddXG59O1xuXG52YXIgcGx1Z2lucyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkRlY2ltYXRpb246IHBsdWdpbl9kZWNpbWF0aW9uLFxuRmlsbGVyOiBwbHVnaW5fZmlsbGVyLFxuTGVnZW5kOiBwbHVnaW5fbGVnZW5kLFxuU3ViVGl0bGU6IHBsdWdpbl9zdWJ0aXRsZSxcblRpdGxlOiBwbHVnaW5fdGl0bGUsXG5Ub29sdGlwOiBwbHVnaW5fdG9vbHRpcFxufSk7XG5cbmNvbnN0IGFkZElmU3RyaW5nID0gKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpID0+IHtcbiAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgaW5kZXggPSBsYWJlbHMucHVzaChyYXcpIC0gMTtcbiAgICBhZGRlZExhYmVscy51bnNoaWZ0KHtpbmRleCwgbGFiZWw6IHJhd30pO1xuICB9IGVsc2UgaWYgKGlzTmFOKHJhdykpIHtcbiAgICBpbmRleCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufTtcbmZ1bmN0aW9uIGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpIHtcbiAgY29uc3QgZmlyc3QgPSBsYWJlbHMuaW5kZXhPZihyYXcpO1xuICBpZiAoZmlyc3QgPT09IC0xKSB7XG4gICAgcmV0dXJuIGFkZElmU3RyaW5nKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpO1xuICB9XG4gIGNvbnN0IGxhc3QgPSBsYWJlbHMubGFzdEluZGV4T2YocmF3KTtcbiAgcmV0dXJuIGZpcnN0ICE9PSBsYXN0ID8gaW5kZXggOiBmaXJzdDtcbn1cbmNvbnN0IHZhbGlkSW5kZXggPSAoaW5kZXgsIG1heCkgPT4gaW5kZXggPT09IG51bGwgPyBudWxsIDogX2xpbWl0VmFsdWUoTWF0aC5yb3VuZChpbmRleCksIDAsIG1heCk7XG5jbGFzcyBDYXRlZ29yeVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgfVxuICBpbml0KHNjYWxlT3B0aW9ucykge1xuICAgIGNvbnN0IGFkZGVkID0gdGhpcy5fYWRkZWRMYWJlbHM7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCkge1xuICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICAgIGZvciAoY29uc3Qge2luZGV4LCBsYWJlbH0gb2YgYWRkZWQpIHtcbiAgICAgICAgaWYgKGxhYmVsc1tpbmRleF0gPT09IGxhYmVsKSB7XG4gICAgICAgICAgbGFiZWxzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gICAgfVxuICAgIHN1cGVyLmluaXQoc2NhbGVPcHRpb25zKTtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgaW5kZXggPSBpc0Zpbml0ZShpbmRleCkgJiYgbGFiZWxzW2luZGV4XSA9PT0gcmF3ID8gaW5kZXhcbiAgICAgIDogZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIHZhbHVlT3JEZWZhdWx0KGluZGV4LCByYXcpLCB0aGlzLl9hZGRlZExhYmVscyk7XG4gICAgcmV0dXJuIHZhbGlkSW5kZXgoaW5kZXgsIGxhYmVscy5sZW5ndGggLSAxKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IHRoaXMuZ2V0TGFiZWxzKCkubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9wdGlvbnMub2Zmc2V0O1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgbGV0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgbGFiZWxzID0gKG1pbiA9PT0gMCAmJiBtYXggPT09IGxhYmVscy5sZW5ndGggLSAxKSA/IGxhYmVscyA6IGxhYmVscy5zbGljZShtaW4sIG1heCArIDEpO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBNYXRoLm1heChsYWJlbHMubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSwgMSk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMubWluIC0gKG9mZnNldCA/IDAuNSA6IDApO1xuICAgIGZvciAobGV0IHZhbHVlID0gbWluOyB2YWx1ZSA8PSBtYXg7IHZhbHVlKyspIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlfSk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBpZiAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8IGxhYmVscy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBsYWJlbHNbdmFsdWVdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuICAgIGlmICghdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9ICF0aGlzLl9yZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh2YWx1ZSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmJvdHRvbTtcbiAgfVxufVxuQ2F0ZWdvcnlTY2FsZS5pZCA9ICdjYXRlZ29yeSc7XG5DYXRlZ29yeVNjYWxlLmRlZmF1bHRzID0ge1xuICB0aWNrczoge1xuICAgIGNhbGxiYWNrOiBDYXRlZ29yeVNjYWxlLnByb3RvdHlwZS5nZXRMYWJlbEZvclZhbHVlXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MkMShnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGNvbnN0IE1JTl9TUEFDSU5HID0gMWUtMTQ7XG4gIGNvbnN0IHtib3VuZHMsIHN0ZXAsIG1pbiwgbWF4LCBwcmVjaXNpb24sIGNvdW50LCBtYXhUaWNrcywgbWF4RGlnaXRzLCBpbmNsdWRlQm91bmRzfSA9IGdlbmVyYXRpb25PcHRpb25zO1xuICBjb25zdCB1bml0ID0gc3RlcCB8fCAxO1xuICBjb25zdCBtYXhTcGFjZXMgPSBtYXhUaWNrcyAtIDE7XG4gIGNvbnN0IHttaW46IHJtaW4sIG1heDogcm1heH0gPSBkYXRhUmFuZ2U7XG4gIGNvbnN0IG1pbkRlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtaW4pO1xuICBjb25zdCBtYXhEZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWF4KTtcbiAgY29uc3QgY291bnREZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYoY291bnQpO1xuICBjb25zdCBtaW5TcGFjaW5nID0gKHJtYXggLSBybWluKSAvIChtYXhEaWdpdHMgKyAxKTtcbiAgbGV0IHNwYWNpbmcgPSBuaWNlTnVtKChybWF4IC0gcm1pbikgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gIGxldCBmYWN0b3IsIG5pY2VNaW4sIG5pY2VNYXgsIG51bVNwYWNlcztcbiAgaWYgKHNwYWNpbmcgPCBNSU5fU1BBQ0lORyAmJiAhbWluRGVmaW5lZCAmJiAhbWF4RGVmaW5lZCkge1xuICAgIHJldHVybiBbe3ZhbHVlOiBybWlufSwge3ZhbHVlOiBybWF4fV07XG4gIH1cbiAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAtIE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpO1xuICBpZiAobnVtU3BhY2VzID4gbWF4U3BhY2VzKSB7XG4gICAgc3BhY2luZyA9IG5pY2VOdW0obnVtU3BhY2VzICogc3BhY2luZyAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgfVxuICBpZiAoIWlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSkge1xuICAgIGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIH1cbiAgaWYgKGJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgIG5pY2VNaW4gPSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gICAgbmljZU1heCA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgKiBzcGFjaW5nO1xuICB9IGVsc2Uge1xuICAgIG5pY2VNaW4gPSBybWluO1xuICAgIG5pY2VNYXggPSBybWF4O1xuICB9XG4gIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQgJiYgc3RlcCAmJiBhbG1vc3RXaG9sZSgobWF4IC0gbWluKSAvIHN0ZXAsIHNwYWNpbmcgLyAxMDAwKSkge1xuICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQoTWF0aC5taW4oKG1heCAtIG1pbikgLyBzcGFjaW5nLCBtYXhUaWNrcykpO1xuICAgIHNwYWNpbmcgPSAobWF4IC0gbWluKSAvIG51bVNwYWNlcztcbiAgICBuaWNlTWluID0gbWluO1xuICAgIG5pY2VNYXggPSBtYXg7XG4gIH0gZWxzZSBpZiAoY291bnREZWZpbmVkKSB7XG4gICAgbmljZU1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiBuaWNlTWluO1xuICAgIG5pY2VNYXggPSBtYXhEZWZpbmVkID8gbWF4IDogbmljZU1heDtcbiAgICBudW1TcGFjZXMgPSBjb3VudCAtIDE7XG4gICAgc3BhY2luZyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBudW1TcGFjZXM7XG4gIH0gZWxzZSB7XG4gICAgbnVtU3BhY2VzID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIHNwYWNpbmc7XG4gICAgaWYgKGFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKG51bVNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xuICAgIH1cbiAgfVxuICBjb25zdCBkZWNpbWFsUGxhY2VzID0gTWF0aC5tYXgoXG4gICAgX2RlY2ltYWxQbGFjZXMoc3BhY2luZyksXG4gICAgX2RlY2ltYWxQbGFjZXMobmljZU1pbilcbiAgKTtcbiAgZmFjdG9yID0gTWF0aC5wb3coMTAsIGlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSA/IGRlY2ltYWxQbGFjZXMgOiBwcmVjaXNpb24pO1xuICBuaWNlTWluID0gTWF0aC5yb3VuZChuaWNlTWluICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgbmljZU1heCA9IE1hdGgucm91bmQobmljZU1heCAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIGxldCBqID0gMDtcbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBpZiAoaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWluICE9PSBtaW4pIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtaW59KTtcbiAgICAgIGlmIChuaWNlTWluIDwgbWluKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICAgIGlmIChhbG1vc3RFcXVhbHMoTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3IsIG1pbiwgcmVsYXRpdmVMYWJlbFNpemUobWluLCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgIGorKztcbiAgICB9XG4gIH1cbiAgZm9yICg7IGogPCBudW1TcGFjZXM7ICsraikge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3Rvcn0pO1xuICB9XG4gIGlmIChtYXhEZWZpbmVkICYmIGluY2x1ZGVCb3VuZHMgJiYgbmljZU1heCAhPT0gbWF4KSB7XG4gICAgaWYgKHRpY2tzLmxlbmd0aCAmJiBhbG1vc3RFcXVhbHModGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUsIG1heCwgcmVsYXRpdmVMYWJlbFNpemUobWF4LCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSA9IG1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWU6IG1heH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICghbWF4RGVmaW5lZCB8fCBuaWNlTWF4ID09PSBtYXgpIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbmljZU1heH0pO1xuICB9XG4gIHJldHVybiB0aWNrcztcbn1cbmZ1bmN0aW9uIHJlbGF0aXZlTGFiZWxTaXplKHZhbHVlLCBtaW5TcGFjaW5nLCB7aG9yaXpvbnRhbCwgbWluUm90YXRpb259KSB7XG4gIGNvbnN0IHJhZCA9IHRvUmFkaWFucyhtaW5Sb3RhdGlvbik7XG4gIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihyYWQpIDogTWF0aC5jb3MocmFkKSkgfHwgMC4wMDE7XG4gIGNvbnN0IGxlbmd0aCA9IDAuNzUgKiBtaW5TcGFjaW5nICogKCcnICsgdmFsdWUpLmxlbmd0aDtcbiAgcmV0dXJuIE1hdGgubWluKG1pblNwYWNpbmcgLyByYXRpbywgbGVuZ3RoKTtcbn1cbmNsYXNzIExpbmVhclNjYWxlQmFzZSBleHRlbmRzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZW5kVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoKHR5cGVvZiByYXcgPT09ICdudW1iZXInIHx8IHJhdyBpbnN0YW5jZW9mIE51bWJlcikgJiYgIWlzRmluaXRlKCtyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICtyYXc7XG4gIH1cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7YmVnaW5BdFplcm99ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuICAgIGlmIChiZWdpbkF0WmVybykge1xuICAgICAgY29uc3QgbWluU2lnbiA9IHNpZ24obWluKTtcbiAgICAgIGNvbnN0IG1heFNpZ24gPSBzaWduKG1heCk7XG4gICAgICBpZiAobWluU2lnbiA8IDAgJiYgbWF4U2lnbiA8IDApIHtcbiAgICAgICAgc2V0TWF4KDApO1xuICAgICAgfSBlbHNlIGlmIChtaW5TaWduID4gMCAmJiBtYXhTaWduID4gMCkge1xuICAgICAgICBzZXRNaW4oMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgbGV0IG9mZnNldCA9IDE7XG4gICAgICBpZiAobWF4ID49IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IG1pbiA8PSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLmFicyhtYXggKiAwLjA1KTtcbiAgICAgIH1cbiAgICAgIHNldE1heChtYXggKyBvZmZzZXQpO1xuICAgICAgaWYgKCFiZWdpbkF0WmVybykge1xuICAgICAgICBzZXRNaW4obWluIC0gb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cbiAgZ2V0VGlja0xpbWl0KCkge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGxldCB7bWF4VGlja3NMaW1pdCwgc3RlcFNpemV9ID0gdGlja09wdHM7XG4gICAgbGV0IG1heFRpY2tzO1xuICAgIGlmIChzdGVwU2l6ZSkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLmNlaWwodGhpcy5tYXggLyBzdGVwU2l6ZSkgLSBNYXRoLmZsb29yKHRoaXMubWluIC8gc3RlcFNpemUpICsgMTtcbiAgICAgIGlmIChtYXhUaWNrcyA+IDEwMDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBzY2FsZXMuJHt0aGlzLmlkfS50aWNrcy5zdGVwU2l6ZTogJHtzdGVwU2l6ZX0gd291bGQgcmVzdWx0IGdlbmVyYXRpbmcgdXAgdG8gJHttYXhUaWNrc30gdGlja3MuIExpbWl0aW5nIHRvIDEwMDAuYCk7XG4gICAgICAgIG1heFRpY2tzID0gMTAwMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4VGlja3MgPSB0aGlzLmNvbXB1dGVUaWNrTGltaXQoKTtcbiAgICAgIG1heFRpY2tzTGltaXQgPSBtYXhUaWNrc0xpbWl0IHx8IDExO1xuICAgIH1cbiAgICBpZiAobWF4VGlja3NMaW1pdCkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLm1pbihtYXhUaWNrc0xpbWl0LCBtYXhUaWNrcyk7XG4gICAgfVxuICAgIHJldHVybiBtYXhUaWNrcztcbiAgfVxuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcbiAgICBsZXQgbWF4VGlja3MgPSB0aGlzLmdldFRpY2tMaW1pdCgpO1xuICAgIG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuICAgIGNvbnN0IG51bWVyaWNHZW5lcmF0b3JPcHRpb25zID0ge1xuICAgICAgbWF4VGlja3MsXG4gICAgICBib3VuZHM6IG9wdHMuYm91bmRzLFxuICAgICAgbWluOiBvcHRzLm1pbixcbiAgICAgIG1heDogb3B0cy5tYXgsXG4gICAgICBwcmVjaXNpb246IHRpY2tPcHRzLnByZWNpc2lvbixcbiAgICAgIHN0ZXA6IHRpY2tPcHRzLnN0ZXBTaXplLFxuICAgICAgY291bnQ6IHRpY2tPcHRzLmNvdW50LFxuICAgICAgbWF4RGlnaXRzOiB0aGlzLl9tYXhEaWdpdHMoKSxcbiAgICAgIGhvcml6b250YWw6IHRoaXMuaXNIb3Jpem9udGFsKCksXG4gICAgICBtaW5Sb3RhdGlvbjogdGlja09wdHMubWluUm90YXRpb24gfHwgMCxcbiAgICAgIGluY2x1ZGVCb3VuZHM6IHRpY2tPcHRzLmluY2x1ZGVCb3VuZHMgIT09IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBkYXRhUmFuZ2UgPSB0aGlzLl9yYW5nZSB8fCB0aGlzO1xuICAgIGNvbnN0IHRpY2tzID0gZ2VuZXJhdGVUaWNrcyQxKG51bWVyaWNHZW5lcmF0b3JPcHRpb25zLCBkYXRhUmFuZ2UpO1xuICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICB9XG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWF4O1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5taW47XG4gICAgbGV0IGVuZCA9IHRoaXMubWF4O1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0ICYmIHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gKGVuZCAtIHN0YXJ0KSAvIE1hdGgubWF4KHRpY2tzLmxlbmd0aCAtIDEsIDEpIC8gMjtcbiAgICAgIHN0YXJ0IC09IG9mZnNldDtcbiAgICAgIGVuZCArPSBvZmZzZXQ7XG4gICAgfVxuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBzdGFydDtcbiAgICB0aGlzLl9lbmRWYWx1ZSA9IGVuZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gZW5kIC0gc3RhcnQ7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG59XG5cbmNsYXNzIExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgdGhpcy5taW4gPSBpc051bWJlckZpbml0ZShtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgPyBtYXggOiAxO1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgbGVuZ3RoID0gaG9yaXpvbnRhbCA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodDtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRvUmFkaWFucyh0aGlzLm9wdGlvbnMudGlja3MubWluUm90YXRpb24pO1xuICAgIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihtaW5Sb3RhdGlvbikgOiBNYXRoLmNvcyhtaW5Sb3RhdGlvbikpIHx8IDAuMDAxO1xuICAgIGNvbnN0IHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGxlbmd0aCAvIE1hdGgubWluKDQwLCB0aWNrRm9udC5saW5lSGVpZ2h0IC8gcmF0aW8pKTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiB0aGlzLl92YWx1ZVJhbmdlO1xuICB9XG59XG5MaW5lYXJTY2FsZS5pZCA9ICdsaW5lYXInO1xuTGluZWFyU2NhbGUuZGVmYXVsdHMgPSB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICB9XG59O1xuXG5mdW5jdGlvbiBpc01ham9yKHRpY2tWYWwpIHtcbiAgY29uc3QgcmVtYWluID0gdGlja1ZhbCAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsKSkpKTtcbiAgcmV0dXJuIHJlbWFpbiA9PT0gMTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuICBjb25zdCBlbmRFeHAgPSBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5tYXgpKTtcbiAgY29uc3QgZW5kU2lnbmlmaWNhbmQgPSBNYXRoLmNlaWwoZGF0YVJhbmdlLm1heCAvIE1hdGgucG93KDEwLCBlbmRFeHApKTtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgbGV0IHRpY2tWYWwgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChkYXRhUmFuZ2UubWluKSkpKTtcbiAgbGV0IGV4cCA9IE1hdGguZmxvb3IobG9nMTAodGlja1ZhbCkpO1xuICBsZXQgc2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKHRpY2tWYWwgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG4gIGxldCBwcmVjaXNpb24gPSBleHAgPCAwID8gTWF0aC5wb3coMTAsIE1hdGguYWJzKGV4cCkpIDogMTtcbiAgZG8ge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiB0aWNrVmFsLCBtYWpvcjogaXNNYWpvcih0aWNrVmFsKX0pO1xuICAgICsrc2lnbmlmaWNhbmQ7XG4gICAgaWYgKHNpZ25pZmljYW5kID09PSAxMCkge1xuICAgICAgc2lnbmlmaWNhbmQgPSAxO1xuICAgICAgKytleHA7XG4gICAgICBwcmVjaXNpb24gPSBleHAgPj0gMCA/IDEgOiBwcmVjaXNpb247XG4gICAgfVxuICAgIHRpY2tWYWwgPSBNYXRoLnJvdW5kKHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICB9IHdoaWxlIChleHAgPCBlbmRFeHAgfHwgKGV4cCA9PT0gZW5kRXhwICYmIHNpZ25pZmljYW5kIDwgZW5kU2lnbmlmaWNhbmQpKTtcbiAgY29uc3QgbGFzdFRpY2sgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCB0aWNrVmFsKTtcbiAgdGlja3MucHVzaCh7dmFsdWU6IGxhc3RUaWNrLCBtYWpvcjogaXNNYWpvcih0aWNrVmFsKX0pO1xuICByZXR1cm4gdGlja3M7XG59XG5jbGFzcyBMb2dhcml0aG1pY1NjYWxlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgY29uc3QgdmFsdWUgPSBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLnBhcnNlLmFwcGx5KHRoaXMsIFtyYXcsIGluZGV4XSk7XG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBpc051bWJlckZpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgPiAwID8gdmFsdWUgOiBudWxsO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuICAgIHRoaXMubWluID0gaXNOdW1iZXJGaW5pdGUobWluKSA/IE1hdGgubWF4KDAsIG1pbikgOiBudWxsO1xuICAgIHRoaXMubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSA/IE1hdGgubWF4KDAsIG1heCkgOiBudWxsO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYmVnaW5BdFplcm8pIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCBtaW4gPSB0aGlzLm1pbjtcbiAgICBsZXQgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcbiAgICBjb25zdCBleHAgPSAodiwgbSkgPT4gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAodikpICsgbSk7XG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICBpZiAobWluIDw9IDApIHtcbiAgICAgICAgc2V0TWluKDEpO1xuICAgICAgICBzZXRNYXgoMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0TWluKGV4cChtaW4sIC0xKSk7XG4gICAgICAgIHNldE1heChleHAobWF4LCArMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWluIDw9IDApIHtcbiAgICAgIHNldE1pbihleHAobWF4LCAtMSkpO1xuICAgIH1cbiAgICBpZiAobWF4IDw9IDApIHtcbiAgICAgIHNldE1heChleHAobWluLCArMSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5femVybyAmJiB0aGlzLm1pbiAhPT0gdGhpcy5fc3VnZ2VzdGVkTWluICYmIG1pbiA9PT0gZXhwKHRoaXMubWluLCAwKSkge1xuICAgICAgc2V0TWluKGV4cChtaW4sIC0xKSk7XG4gICAgfVxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBnZW5lcmF0aW9uT3B0aW9ucyA9IHtcbiAgICAgIG1pbjogdGhpcy5fdXNlck1pbixcbiAgICAgIG1heDogdGhpcy5fdXNlck1heFxuICAgIH07XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCB0aGlzKTtcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuICAgIGlmIChvcHRzLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5tYXg7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gJzAnXG4gICAgICA6IGZvcm1hdE51bWJlcih2YWx1ZSwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5taW47XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IGxvZzEwKHN0YXJ0KTtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gbG9nMTAodGhpcy5tYXgpIC0gbG9nMTAoc3RhcnQpO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgdmFsdWUgPSB0aGlzLm1pbjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKHZhbHVlID09PSB0aGlzLm1pblxuICAgICAgPyAwXG4gICAgICA6IChsb2cxMCh2YWx1ZSkgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpO1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhcnRWYWx1ZSArIGRlY2ltYWwgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxufVxuTG9nYXJpdGhtaWNTY2FsZS5pZCA9ICdsb2dhcml0aG1pYyc7XG5Mb2dhcml0aG1pY1NjYWxlLmRlZmF1bHRzID0ge1xuICB0aWNrczoge1xuICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljLFxuICAgIG1ham9yOiB7XG4gICAgICBlbmFibGVkOiB0cnVlXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykge1xuICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG4gIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIG9wdHMuZGlzcGxheSkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcodGlja09wdHMuYmFja2Ryb3BQYWRkaW5nKTtcbiAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udCAmJiB0aWNrT3B0cy5mb250LnNpemUsIGRlZmF1bHRzLmZvbnQuc2l6ZSkgKyBwYWRkaW5nLmhlaWdodDtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIG1lYXN1cmVMYWJlbFNpemUoY3R4LCBmb250LCBsYWJlbCkge1xuICBsYWJlbCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwgOiBbbGFiZWxdO1xuICByZXR1cm4ge1xuICAgIHc6IF9sb25nZXN0VGV4dChjdHgsIGZvbnQuc3RyaW5nLCBsYWJlbCksXG4gICAgaDogbGFiZWwubGVuZ3RoICogZm9udC5saW5lSGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvcywgc2l6ZSwgbWluLCBtYXgpIHtcbiAgaWYgKGFuZ2xlID09PSBtaW4gfHwgYW5nbGUgPT09IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gKHNpemUgLyAyKSxcbiAgICAgIGVuZDogcG9zICsgKHNpemUgLyAyKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoYW5nbGUgPCBtaW4gfHwgYW5nbGUgPiBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBvcyAtIHNpemUsXG4gICAgICBlbmQ6IHBvc1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcG9zLFxuICAgIGVuZDogcG9zICsgc2l6ZVxuICB9O1xufVxuZnVuY3Rpb24gZml0V2l0aFBvaW50TGFiZWxzKHNjYWxlKSB7XG4gIGNvbnN0IG9yaWcgPSB7XG4gICAgbDogc2NhbGUubGVmdCArIHNjYWxlLl9wYWRkaW5nLmxlZnQsXG4gICAgcjogc2NhbGUucmlnaHQgLSBzY2FsZS5fcGFkZGluZy5yaWdodCxcbiAgICB0OiBzY2FsZS50b3AgKyBzY2FsZS5fcGFkZGluZy50b3AsXG4gICAgYjogc2NhbGUuYm90dG9tIC0gc2NhbGUuX3BhZGRpbmcuYm90dG9tXG4gIH07XG4gIGNvbnN0IGxpbWl0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWcpO1xuICBjb25zdCBsYWJlbFNpemVzID0gW107XG4gIGNvbnN0IHBhZGRpbmcgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IHBvaW50TGFiZWxPcHRzID0gc2NhbGUub3B0aW9ucy5wb2ludExhYmVscztcbiAgY29uc3QgYWRkaXRpb25hbEFuZ2xlID0gcG9pbnRMYWJlbE9wdHMuY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuICAgIGNvbnN0IG9wdHMgPSBwb2ludExhYmVsT3B0cy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBwYWRkaW5nW2ldID0gb3B0cy5wYWRkaW5nO1xuICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHNjYWxlLmRyYXdpbmdBcmVhICsgcGFkZGluZ1tpXSwgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBwbEZvbnQgPSB0b0ZvbnQob3B0cy5mb250KTtcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IG1lYXN1cmVMYWJlbFNpemUoc2NhbGUuY3R4LCBwbEZvbnQsIHNjYWxlLl9wb2ludExhYmVsc1tpXSk7XG4gICAgbGFiZWxTaXplc1tpXSA9IHRleHRTaXplO1xuICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IF9ub3JtYWxpemVBbmdsZShzY2FsZS5nZXRJbmRleEFuZ2xlKGkpICsgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQodG9EZWdyZWVzKGFuZ2xlUmFkaWFucykpO1xuICAgIGNvbnN0IGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcbiAgICBjb25zdCB2TGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLnksIHRleHRTaXplLmgsIDkwLCAyNzApO1xuICAgIHVwZGF0ZUxpbWl0cyhsaW1pdHMsIG9yaWcsIGFuZ2xlUmFkaWFucywgaExpbWl0cywgdkxpbWl0cyk7XG4gIH1cbiAgc2NhbGUuc2V0Q2VudGVyUG9pbnQoXG4gICAgb3JpZy5sIC0gbGltaXRzLmwsXG4gICAgbGltaXRzLnIgLSBvcmlnLnIsXG4gICAgb3JpZy50IC0gbGltaXRzLnQsXG4gICAgbGltaXRzLmIgLSBvcmlnLmJcbiAgKTtcbiAgc2NhbGUuX3BvaW50TGFiZWxJdGVtcyA9IGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUxpbWl0cyhsaW1pdHMsIG9yaWcsIGFuZ2xlLCBoTGltaXRzLCB2TGltaXRzKSB7XG4gIGNvbnN0IHNpbiA9IE1hdGguYWJzKE1hdGguc2luKGFuZ2xlKSk7XG4gIGNvbnN0IGNvcyA9IE1hdGguYWJzKE1hdGguY29zKGFuZ2xlKSk7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBpZiAoaExpbWl0cy5zdGFydCA8IG9yaWcubCkge1xuICAgIHggPSAob3JpZy5sIC0gaExpbWl0cy5zdGFydCkgLyBzaW47XG4gICAgbGltaXRzLmwgPSBNYXRoLm1pbihsaW1pdHMubCwgb3JpZy5sIC0geCk7XG4gIH0gZWxzZSBpZiAoaExpbWl0cy5lbmQgPiBvcmlnLnIpIHtcbiAgICB4ID0gKGhMaW1pdHMuZW5kIC0gb3JpZy5yKSAvIHNpbjtcbiAgICBsaW1pdHMuciA9IE1hdGgubWF4KGxpbWl0cy5yLCBvcmlnLnIgKyB4KTtcbiAgfVxuICBpZiAodkxpbWl0cy5zdGFydCA8IG9yaWcudCkge1xuICAgIHkgPSAob3JpZy50IC0gdkxpbWl0cy5zdGFydCkgLyBjb3M7XG4gICAgbGltaXRzLnQgPSBNYXRoLm1pbihsaW1pdHMudCwgb3JpZy50IC0geSk7XG4gIH0gZWxzZSBpZiAodkxpbWl0cy5lbmQgPiBvcmlnLmIpIHtcbiAgICB5ID0gKHZMaW1pdHMuZW5kIC0gb3JpZy5iKSAvIGNvcztcbiAgICBsaW1pdHMuYiA9IE1hdGgubWF4KGxpbWl0cy5iLCBvcmlnLmIgKyB5KTtcbiAgfVxufVxuZnVuY3Rpb24gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCBleHRyYSA9IGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSAvIDI7XG4gIGNvbnN0IG91dGVyRGlzdGFuY2UgPSBzY2FsZS5kcmF3aW5nQXJlYTtcbiAgY29uc3QgYWRkaXRpb25hbEFuZ2xlID0gb3B0cy5wb2ludExhYmVscy5jZW50ZXJQb2ludExhYmVscyA/IFBJIC8gdmFsdWVDb3VudCA6IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgY29uc3QgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBvdXRlckRpc3RhbmNlICsgZXh0cmEgKyBwYWRkaW5nW2ldLCBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yb3VuZCh0b0RlZ3JlZXMoX25vcm1hbGl6ZUFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi5hbmdsZSArIEhBTEZfUEkpKSk7XG4gICAgY29uc3Qgc2l6ZSA9IGxhYmVsU2l6ZXNbaV07XG4gICAgY29uc3QgeSA9IHlGb3JBbmdsZShwb2ludExhYmVsUG9zaXRpb24ueSwgc2l6ZS5oLCBhbmdsZSk7XG4gICAgY29uc3QgdGV4dEFsaWduID0gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpO1xuICAgIGNvbnN0IGxlZnQgPSBsZWZ0Rm9yVGV4dEFsaWduKHBvaW50TGFiZWxQb3NpdGlvbi54LCBzaXplLncsIHRleHRBbGlnbik7XG4gICAgaXRlbXMucHVzaCh7XG4gICAgICB4OiBwb2ludExhYmVsUG9zaXRpb24ueCxcbiAgICAgIHksXG4gICAgICB0ZXh0QWxpZ24sXG4gICAgICBsZWZ0LFxuICAgICAgdG9wOiB5LFxuICAgICAgcmlnaHQ6IGxlZnQgKyBzaXplLncsXG4gICAgICBib3R0b206IHkgKyBzaXplLmhcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xuICAgIHJldHVybiAnY2VudGVyJztcbiAgfSBlbHNlIGlmIChhbmdsZSA8IDE4MCkge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH1cbiAgcmV0dXJuICdyaWdodCc7XG59XG5mdW5jdGlvbiBsZWZ0Rm9yVGV4dEFsaWduKHgsIHcsIGFsaWduKSB7XG4gIGlmIChhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggLT0gdztcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3IC8gMik7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiB5Rm9yQW5nbGUoeSwgaCwgYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSA5MCB8fCBhbmdsZSA9PT0gMjcwKSB7XG4gICAgeSAtPSAoaCAvIDIpO1xuICB9IGVsc2UgaWYgKGFuZ2xlID4gMjcwIHx8IGFuZ2xlIDwgOTApIHtcbiAgICB5IC09IGg7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbHMoc2NhbGUsIGxhYmVsQ291bnQpIHtcbiAgY29uc3Qge2N0eCwgb3B0aW9uczoge3BvaW50TGFiZWxzfX0gPSBzY2FsZTtcbiAgZm9yIChsZXQgaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gcG9pbnRMYWJlbHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgIGNvbnN0IHt4LCB5LCB0ZXh0QWxpZ24sIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zW2ldO1xuICAgIGNvbnN0IHtiYWNrZHJvcENvbG9yfSA9IG9wdHNBdEluZGV4O1xuICAgIGlmICghaXNOdWxsT3JVbmRlZihiYWNrZHJvcENvbG9yKSkge1xuICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QobGVmdCAtIHBhZGRpbmcubGVmdCwgdG9wIC0gcGFkZGluZy50b3AsIHJpZ2h0IC0gbGVmdCArIHBhZGRpbmcud2lkdGgsIGJvdHRvbSAtIHRvcCArIHBhZGRpbmcuaGVpZ2h0KTtcbiAgICB9XG4gICAgcmVuZGVyVGV4dChcbiAgICAgIGN0eCxcbiAgICAgIHNjYWxlLl9wb2ludExhYmVsc1tpXSxcbiAgICAgIHgsXG4gICAgICB5ICsgKHBsRm9udC5saW5lSGVpZ2h0IC8gMiksXG4gICAgICBwbEZvbnQsXG4gICAgICB7XG4gICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5jb2xvcixcbiAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZSdcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBwYXRoUmFkaXVzTGluZShzY2FsZSwgcmFkaXVzLCBjaXJjdWxhciwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4fSA9IHNjYWxlO1xuICBpZiAoY2lyY3VsYXIpIHtcbiAgICBjdHguYXJjKHNjYWxlLnhDZW50ZXIsIHNjYWxlLnlDZW50ZXIsIHJhZGl1cywgMCwgVEFVKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oMCwgcmFkaXVzKTtcbiAgICBjdHgubW92ZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xuICAgICAgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgcmFkaXVzKTtcbiAgICAgIGN0eC5saW5lVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZHJhd1JhZGl1c0xpbmUoc2NhbGUsIGdyaWRMaW5lT3B0cywgcmFkaXVzLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IGN0eCA9IHNjYWxlLmN0eDtcbiAgY29uc3QgY2lyY3VsYXIgPSBncmlkTGluZU9wdHMuY2lyY3VsYXI7XG4gIGNvbnN0IHtjb2xvciwgbGluZVdpZHRofSA9IGdyaWRMaW5lT3B0cztcbiAgaWYgKCghY2lyY3VsYXIgJiYgIWxhYmVsQ291bnQpIHx8ICFjb2xvciB8fCAhbGluZVdpZHRoIHx8IHJhZGl1cyA8IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gIGN0eC5zZXRMaW5lRGFzaChncmlkTGluZU9wdHMuYm9yZGVyRGFzaCk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0O1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguc3Ryb2tlKCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVQb2ludExhYmVsQ29udGV4dChwYXJlbnQsIGluZGV4LCBsYWJlbCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBsYWJlbCxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAncG9pbnRMYWJlbCdcbiAgfSk7XG59XG5jbGFzcyBSYWRpYWxMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy54Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueUNlbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BvaW50TGFiZWxzID0gW107XG4gICAgdGhpcy5fcG9pbnRMYWJlbEl0ZW1zID0gW107XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSAvIDIpO1xuICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aCAtIHBhZGRpbmcud2lkdGg7XG4gICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBwYWRkaW5nLmhlaWdodDtcbiAgICB0aGlzLnhDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMubGVmdCArIHcgLyAyICsgcGFkZGluZy5sZWZ0KTtcbiAgICB0aGlzLnlDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMudG9wICsgaCAvIDIgKyBwYWRkaW5nLnRvcCk7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IE1hdGguZmxvb3IoTWF0aC5taW4odywgaCkgLyAyKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heChmYWxzZSk7XG4gICAgdGhpcy5taW4gPSBpc051bWJlckZpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiAwO1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykpO1xuICB9XG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUuZ2VuZXJhdGVUaWNrTGFiZWxzLmNhbGwodGhpcywgdGlja3MpO1xuICAgIHRoaXMuX3BvaW50TGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKVxuICAgICAgLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gY2FsbGJhY2sodGhpcy5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBbdmFsdWUsIGluZGV4XSwgdGhpcyk7XG4gICAgICAgIHJldHVybiBsYWJlbCB8fCBsYWJlbCA9PT0gMCA/IGxhYmVsIDogJyc7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigodiwgaSkgPT4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSk7XG4gIH1cbiAgZml0KCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKG9wdHMuZGlzcGxheSAmJiBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGZpdFdpdGhQb2ludExhYmVscyh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDZW50ZXJQb2ludCgwLCAwLCAwLCAwKTtcbiAgICB9XG4gIH1cbiAgc2V0Q2VudGVyUG9pbnQobGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpIHtcbiAgICB0aGlzLnhDZW50ZXIgKz0gTWF0aC5mbG9vcigobGVmdE1vdmVtZW50IC0gcmlnaHRNb3ZlbWVudCkgLyAyKTtcbiAgICB0aGlzLnlDZW50ZXIgKz0gTWF0aC5mbG9vcigodG9wTW92ZW1lbnQgLSBib3R0b21Nb3ZlbWVudCkgLyAyKTtcbiAgICB0aGlzLmRyYXdpbmdBcmVhIC09IE1hdGgubWluKHRoaXMuZHJhd2luZ0FyZWEgLyAyLCBNYXRoLm1heChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkpO1xuICB9XG4gIGdldEluZGV4QW5nbGUoaW5kZXgpIHtcbiAgICBjb25zdCBhbmdsZU11bHRpcGxpZXIgPSBUQVUgLyAodGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoIHx8IDEpO1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLm9wdGlvbnMuc3RhcnRBbmdsZSB8fCAwO1xuICAgIHJldHVybiBfbm9ybWFsaXplQW5nbGUoaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyB0b1JhZGlhbnMoc3RhcnRBbmdsZSkpO1xuICB9XG4gIGdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBjb25zdCBzY2FsaW5nRmFjdG9yID0gdGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHJldHVybiAodGhpcy5tYXggLSB2YWx1ZSkgKiBzY2FsaW5nRmFjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gKHZhbHVlIC0gdGhpcy5taW4pICogc2NhbGluZ0ZhY3RvcjtcbiAgfVxuICBnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlcihkaXN0YW5jZSkge1xuICAgIGlmIChpc051bGxPclVuZGVmKGRpc3RhbmNlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGVkRGlzdGFuY2UgPSBkaXN0YW5jZSAvICh0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJldmVyc2UgPyB0aGlzLm1heCAtIHNjYWxlZERpc3RhbmNlIDogdGhpcy5taW4gKyBzY2FsZWREaXN0YW5jZTtcbiAgfVxuICBnZXRQb2ludExhYmVsQ29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IHBvaW50TGFiZWxzID0gdGhpcy5fcG9pbnRMYWJlbHMgfHwgW107XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBwb2ludExhYmVscy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBvaW50TGFiZWwgPSBwb2ludExhYmVsc1tpbmRleF07XG4gICAgICByZXR1cm4gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBwb2ludExhYmVsKTtcbiAgICB9XG4gIH1cbiAgZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyLCBhZGRpdGlvbmFsQW5nbGUgPSAwKSB7XG4gICAgY29uc3QgYW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoaW5kZXgpIC0gSEFMRl9QSSArIGFkZGl0aW9uYWxBbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy54Q2VudGVyLFxuICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy55Q2VudGVyLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG4gIGdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uKGluZGV4LCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSk7XG4gIH1cbiAgZ2V0QmFzZVBvc2l0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4IHx8IDAsIHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG4gIGdldFBvaW50TGFiZWxQb3NpdGlvbihpbmRleCkge1xuICAgIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gdGhpcy5fcG9pbnRMYWJlbEl0ZW1zW2luZGV4XTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgIH07XG4gIH1cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2JhY2tncm91bmRDb2xvciwgZ3JpZDoge2NpcmN1bGFyfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgcGF0aFJhZGl1c0xpbmUodGhpcywgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLl9lbmRWYWx1ZSksIGNpcmN1bGFyLCB0aGlzLl9wb2ludExhYmVscy5sZW5ndGgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBkcmF3R3JpZCgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHthbmdsZUxpbmVzLCBncmlkfSA9IG9wdHM7XG4gICAgY29uc3QgbGFiZWxDb3VudCA9IHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgICBsZXQgaSwgb2Zmc2V0LCBwb3NpdGlvbjtcbiAgICBpZiAob3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBkcmF3UG9pbnRMYWJlbHModGhpcywgbGFiZWxDb3VudCk7XG4gICAgfVxuICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aWNrLnZhbHVlKTtcbiAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXggLSAxKSk7XG4gICAgICAgICAgZHJhd1JhZGl1c0xpbmUodGhpcywgb3B0c0F0SW5kZXgsIG9mZnNldCwgbGFiZWxDb3VudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYW5nbGVMaW5lcy5kaXNwbGF5KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgZm9yIChpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gYW5nbGVMaW5lcy5zZXRDb250ZXh0KHRoaXMuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgICAgICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBvcHRzQXRJbmRleDtcbiAgICAgICAgaWYgKCFsaW5lV2lkdGggfHwgIWNvbG9yKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChvcHRzQXRJbmRleC5ib3JkZXJEYXNoKTtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaE9mZnNldDtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnRpY2tzLnJldmVyc2UgPyB0aGlzLm1pbiA6IHRoaXMubWF4KTtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50UG9zaXRpb24oaSwgb2Zmc2V0KTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZHJhd0JvcmRlcigpIHt9XG4gIGRyYXdMYWJlbHMoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG4gICAgaWYgKCF0aWNrT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoMCk7XG4gICAgbGV0IG9mZnNldCwgd2lkdGg7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNsYXRlKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICBjdHgucm90YXRlKHN0YXJ0QW5nbGUpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGluZGV4ID09PSAwICYmICFvcHRzLnJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSB0aWNrT3B0cy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMudGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcbiAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGljay5sYWJlbCkud2lkdGg7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAtd2lkdGggLyAyIC0gcGFkZGluZy5sZWZ0LFxuICAgICAgICAgIC1vZmZzZXQgLSB0aWNrRm9udC5zaXplIC8gMiAtIHBhZGRpbmcudG9wLFxuICAgICAgICAgIHdpZHRoICsgcGFkZGluZy53aWR0aCxcbiAgICAgICAgICB0aWNrRm9udC5zaXplICsgcGFkZGluZy5oZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlbmRlclRleHQoY3R4LCB0aWNrLmxhYmVsLCAwLCAtb2Zmc2V0LCB0aWNrRm9udCwge1xuICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGRyYXdUaXRsZSgpIHt9XG59XG5SYWRpYWxMaW5lYXJTY2FsZS5pZCA9ICdyYWRpYWxMaW5lYXInO1xuUmFkaWFsTGluZWFyU2NhbGUuZGVmYXVsdHMgPSB7XG4gIGRpc3BsYXk6IHRydWUsXG4gIGFuaW1hdGU6IHRydWUsXG4gIHBvc2l0aW9uOiAnY2hhcnRBcmVhJyxcbiAgYW5nbGVMaW5lczoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgbGluZVdpZHRoOiAxLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuICB9LFxuICBncmlkOiB7XG4gICAgY2lyY3VsYXI6IGZhbHNlXG4gIH0sXG4gIHN0YXJ0QW5nbGU6IDAsXG4gIHRpY2tzOiB7XG4gICAgc2hvd0xhYmVsQmFja2Ryb3A6IHRydWUsXG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICB9LFxuICBwb2ludExhYmVsczoge1xuICAgIGJhY2tkcm9wQ29sb3I6IHVuZGVmaW5lZCxcbiAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBmb250OiB7XG4gICAgICBzaXplOiAxMFxuICAgIH0sXG4gICAgY2FsbGJhY2sobGFiZWwpIHtcbiAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9LFxuICAgIHBhZGRpbmc6IDUsXG4gICAgY2VudGVyUG9pbnRMYWJlbHM6IGZhbHNlXG4gIH1cbn07XG5SYWRpYWxMaW5lYXJTY2FsZS5kZWZhdWx0Um91dGVzID0ge1xuICAnYW5nbGVMaW5lcy5jb2xvcic6ICdib3JkZXJDb2xvcicsXG4gICdwb2ludExhYmVscy5jb2xvcic6ICdjb2xvcicsXG4gICd0aWNrcy5jb2xvcic6ICdjb2xvcidcbn07XG5SYWRpYWxMaW5lYXJTY2FsZS5kZXNjcmlwdG9ycyA9IHtcbiAgYW5nbGVMaW5lczoge1xuICAgIF9mYWxsYmFjazogJ2dyaWQnXG4gIH1cbn07XG5cbmNvbnN0IElOVEVSVkFMUyA9IHtcbiAgbWlsbGlzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEsIHN0ZXBzOiAxMDAwfSxcbiAgc2Vjb25kOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAxMDAwLCBzdGVwczogNjB9LFxuICBtaW51dGU6IHtjb21tb246IHRydWUsIHNpemU6IDYwMDAwLCBzdGVwczogNjB9LFxuICBob3VyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzNjAwMDAwLCBzdGVwczogMjR9LFxuICBkYXk6IHtjb21tb246IHRydWUsIHNpemU6IDg2NDAwMDAwLCBzdGVwczogMzB9LFxuICB3ZWVrOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNjA0ODAwMDAwLCBzdGVwczogNH0sXG4gIG1vbnRoOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAyLjYyOGU5LCBzdGVwczogMTJ9LFxuICBxdWFydGVyOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNy44ODRlOSwgc3RlcHM6IDR9LFxuICB5ZWFyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzLjE1NGUxMH1cbn07XG5jb25zdCBVTklUUyA9IChPYmplY3Qua2V5cyhJTlRFUlZBTFMpKTtcbmZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn1cbmZ1bmN0aW9uIHBhcnNlKHNjYWxlLCBpbnB1dCkge1xuICBpZiAoaXNOdWxsT3JVbmRlZihpbnB1dCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gIGNvbnN0IHtwYXJzZXIsIHJvdW5kLCBpc29XZWVrZGF5fSA9IHNjYWxlLl9wYXJzZU9wdHM7XG4gIGxldCB2YWx1ZSA9IGlucHV0O1xuICBpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcbiAgfVxuICBpZiAoIWlzTnVtYmVyRmluaXRlKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdHlwZW9mIHBhcnNlciA9PT0gJ3N0cmluZydcbiAgICAgID8gYWRhcHRlci5wYXJzZSh2YWx1ZSwgcGFyc2VyKVxuICAgICAgOiBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocm91bmQpIHtcbiAgICB2YWx1ZSA9IHJvdW5kID09PSAnd2VlaycgJiYgKGlzTnVtYmVyKGlzb1dlZWtkYXkpIHx8IGlzb1dlZWtkYXkgPT09IHRydWUpXG4gICAgICA/IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgJ2lzb1dlZWsnLCBpc29XZWVrZGF5KVxuICAgICAgOiBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsIHJvdW5kKTtcbiAgfVxuICByZXR1cm4gK3ZhbHVlO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyhtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcbiAgY29uc3QgaWxlbiA9IFVOSVRTLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGkgPCBpbGVuIC0gMTsgKytpKSB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBJTlRFUlZBTFNbVU5JVFNbaV1dO1xuICAgIGNvbnN0IGZhY3RvciA9IGludGVydmFsLnN0ZXBzID8gaW50ZXJ2YWwuc3RlcHMgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICBpZiAoaW50ZXJ2YWwuY29tbW9uICYmIE1hdGguY2VpbCgobWF4IC0gbWluKSAvIChmYWN0b3IgKiBpbnRlcnZhbC5zaXplKSkgPD0gY2FwYWNpdHkpIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHNjYWxlLCBudW1UaWNrcywgbWluVW5pdCwgbWluLCBtYXgpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmxlbmd0aCAtIDE7IGkgPj0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaS0tKSB7XG4gICAgY29uc3QgdW5pdCA9IFVOSVRTW2ldO1xuICAgIGlmIChJTlRFUlZBTFNbdW5pdF0uY29tbW9uICYmIHNjYWxlLl9hZGFwdGVyLmRpZmYobWF4LCBtaW4sIHVuaXQpID49IG51bVRpY2tzIC0gMSkge1xuICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBVTklUU1ttaW5Vbml0ID8gVU5JVFMuaW5kZXhPZihtaW5Vbml0KSA6IDBdO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaWYgKElOVEVSVkFMU1tVTklUU1tpXV0uY29tbW9uKSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKSB7XG4gIGlmICghdGltZXN0YW1wcykge1xuICAgIHRpY2tzW3RpbWVdID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgIGNvbnN0IHtsbywgaGl9ID0gX2xvb2t1cCh0aW1lc3RhbXBzLCB0aW1lKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lc3RhbXBzW2xvXSA+PSB0aW1lID8gdGltZXN0YW1wc1tsb10gOiB0aW1lc3RhbXBzW2hpXTtcbiAgICB0aWNrc1t0aW1lc3RhbXBdID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KSB7XG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3QgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKHRpY2tzWzBdLnZhbHVlLCBtYWpvclVuaXQpO1xuICBjb25zdCBsYXN0ID0gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWU7XG4gIGxldCBtYWpvciwgaW5kZXg7XG4gIGZvciAobWFqb3IgPSBmaXJzdDsgbWFqb3IgPD0gbGFzdDsgbWFqb3IgPSArYWRhcHRlci5hZGQobWFqb3IsIDEsIG1ham9yVW5pdCkpIHtcbiAgICBpbmRleCA9IG1hcFttYWpvcl07XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRpY2tzW2luZGV4XS5tYWpvciA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aWNrcztcbn1cbmZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHMoc2NhbGUsIHZhbHVlcywgbWFqb3JVbml0KSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBjb25zdCBpbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgbGV0IGksIHZhbHVlO1xuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgbWFwW3ZhbHVlXSA9IGk7XG4gICAgdGlja3MucHVzaCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIG1ham9yOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAoaWxlbiA9PT0gMCB8fCAhbWFqb3JVbml0KSA/IHRpY2tzIDogc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KTtcbn1cbmNsYXNzIFRpbWVTY2FsZSBleHRlbmRzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcbiAgICB0aGlzLl91bml0ID0gJ2RheSc7XG4gICAgdGhpcy5fbWFqb3JVbml0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29mZnNldHMgPSB7fTtcbiAgICB0aGlzLl9ub3JtYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fcGFyc2VPcHRzID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXQoc2NhbGVPcHRzLCBvcHRzKSB7XG4gICAgY29uc3QgdGltZSA9IHNjYWxlT3B0cy50aW1lIHx8IChzY2FsZU9wdHMudGltZSA9IHt9KTtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlciA9IG5ldyBhZGFwdGVycy5fZGF0ZShzY2FsZU9wdHMuYWRhcHRlcnMuZGF0ZSk7XG4gICAgbWVyZ2VJZih0aW1lLmRpc3BsYXlGb3JtYXRzLCBhZGFwdGVyLmZvcm1hdHMoKSk7XG4gICAgdGhpcy5fcGFyc2VPcHRzID0ge1xuICAgICAgcGFyc2VyOiB0aW1lLnBhcnNlcixcbiAgICAgIHJvdW5kOiB0aW1lLnJvdW5kLFxuICAgICAgaXNvV2Vla2RheTogdGltZS5pc29XZWVrZGF5XG4gICAgfTtcbiAgICBzdXBlci5pbml0KHNjYWxlT3B0cyk7XG4gICAgdGhpcy5fbm9ybWFsaXplZCA9IG9wdHMubm9ybWFsaXplZDtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKHJhdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlKHRoaXMsIHJhdyk7XG4gIH1cbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHN1cGVyLmJlZm9yZUxheW91dCgpO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHVuaXQgPSBvcHRpb25zLnRpbWUudW5pdCB8fCAnZGF5JztcbiAgICBsZXQge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGZ1bmN0aW9uIF9hcHBseUJvdW5kcyhib3VuZHMpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1pbikpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBib3VuZHMubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1heCkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBib3VuZHMubWF4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtaW5EZWZpbmVkIHx8ICFtYXhEZWZpbmVkKSB7XG4gICAgICBfYXBwbHlCb3VuZHModGhpcy5fZ2V0TGFiZWxCb3VuZHMoKSk7XG4gICAgICBpZiAob3B0aW9ucy5ib3VuZHMgIT09ICd0aWNrcycgfHwgb3B0aW9ucy50aWNrcy5zb3VyY2UgIT09ICdsYWJlbHMnKSB7XG4gICAgICAgIF9hcHBseUJvdW5kcyh0aGlzLmdldE1pbk1heChmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBtaW4gPSBpc051bWJlckZpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogK2FkYXB0ZXIuc3RhcnRPZihEYXRlLm5vdygpLCB1bml0KTtcbiAgICBtYXggPSBpc051bWJlckZpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogK2FkYXB0ZXIuZW5kT2YoRGF0ZS5ub3coKSwgdW5pdCkgKyAxO1xuICAgIHRoaXMubWluID0gTWF0aC5taW4obWluLCBtYXggLSAxKTtcbiAgICB0aGlzLm1heCA9IE1hdGgubWF4KG1pbiArIDEsIG1heCk7XG4gIH1cbiAgX2dldExhYmVsQm91bmRzKCkge1xuICAgIGNvbnN0IGFyciA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgbGV0IG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgICBtaW4gPSBhcnJbMF07XG4gICAgICBtYXggPSBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aWNrT3B0cy5zb3VyY2UgPT09ICdsYWJlbHMnID8gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKSA6IHRoaXMuX2dlbmVyYXRlKCk7XG4gICAgaWYgKG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLm1pbiA9IHRoaXMuX3VzZXJNaW4gfHwgdGltZXN0YW1wc1swXTtcbiAgICAgIHRoaXMubWF4ID0gdGhpcy5fdXNlck1heCB8fCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IHRpY2tzID0gX2ZpbHRlckJldHdlZW4odGltZXN0YW1wcywgbWluLCBtYXgpO1xuICAgIHRoaXMuX3VuaXQgPSB0aW1lT3B0cy51bml0IHx8ICh0aWNrT3B0cy5hdXRvU2tpcFxuICAgICAgPyBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKVxuICAgICAgOiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyh0aGlzLCB0aWNrcy5sZW5ndGgsIHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCkpO1xuICAgIHRoaXMuX21ham9yVW5pdCA9ICF0aWNrT3B0cy5tYWpvci5lbmFibGVkIHx8IHRoaXMuX3VuaXQgPT09ICd5ZWFyJyA/IHVuZGVmaW5lZFxuICAgICAgOiBkZXRlcm1pbmVNYWpvclVuaXQodGhpcy5fdW5pdCk7XG4gICAgdGhpcy5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIHRpY2tzLCB0aGlzLl9tYWpvclVuaXQpO1xuICB9XG4gIGluaXRPZmZzZXRzKHRpbWVzdGFtcHMpIHtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAwO1xuICAgIGxldCBmaXJzdCwgbGFzdDtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgZmlyc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzBdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdGFydCA9IDEgLSBmaXJzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gKHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbMV0pIC0gZmlyc3QpIC8gMjtcbiAgICAgIH1cbiAgICAgIGxhc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0pO1xuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVuZCA9IGxhc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSAobGFzdCAtIHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAyXSkpIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGltaXQgPSB0aW1lc3RhbXBzLmxlbmd0aCA8IDMgPyAwLjUgOiAwLjI1O1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoc3RhcnQsIDAsIGxpbWl0KTtcbiAgICBlbmQgPSBfbGltaXRWYWx1ZShlbmQsIDAsIGxpbWl0KTtcbiAgICB0aGlzLl9vZmZzZXRzID0ge3N0YXJ0LCBlbmQsIGZhY3RvcjogMSAvIChzdGFydCArIDEgKyBlbmQpfTtcbiAgfVxuICBfZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICBjb25zdCBtaW5vciA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtaW4sIG1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKTtcbiAgICBjb25zdCBzdGVwU2l6ZSA9IHZhbHVlT3JEZWZhdWx0KHRpbWVPcHRzLnN0ZXBTaXplLCAxKTtcbiAgICBjb25zdCB3ZWVrZGF5ID0gbWlub3IgPT09ICd3ZWVrJyA/IHRpbWVPcHRzLmlzb1dlZWtkYXkgOiBmYWxzZTtcbiAgICBjb25zdCBoYXNXZWVrZGF5ID0gaXNOdW1iZXIod2Vla2RheSkgfHwgd2Vla2RheSA9PT0gdHJ1ZTtcbiAgICBjb25zdCB0aWNrcyA9IHt9O1xuICAgIGxldCBmaXJzdCA9IG1pbjtcbiAgICBsZXQgdGltZSwgY291bnQ7XG4gICAgaWYgKGhhc1dlZWtkYXkpIHtcbiAgICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgJ2lzb1dlZWsnLCB3ZWVrZGF5KTtcbiAgICB9XG4gICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCBoYXNXZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG4gICAgaWYgKGFkYXB0ZXIuZGlmZihtYXgsIG1pbiwgbWlub3IpID4gMTAwMDAwICogc3RlcFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtaW4gKyAnIGFuZCAnICsgbWF4ICsgJyBhcmUgdG9vIGZhciBhcGFydCB3aXRoIHN0ZXBTaXplIG9mICcgKyBzdGVwU2l6ZSArICcgJyArIG1pbm9yKTtcbiAgICB9XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IG9wdGlvbnMudGlja3Muc291cmNlID09PSAnZGF0YScgJiYgdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGZvciAodGltZSA9IGZpcnN0LCBjb3VudCA9IDA7IHRpbWUgPCBtYXg7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSwgY291bnQrKykge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuICAgIGlmICh0aW1lID09PSBtYXggfHwgb3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgfHwgY291bnQgPT09IDEpIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXModGlja3MpLnNvcnQoKGEsIGIpID0+IGEgLSBiKS5tYXAoeCA9PiAreCk7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgaWYgKHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpIHtcbiAgICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMudG9vbHRpcEZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMuZGlzcGxheUZvcm1hdHMuZGF0ZXRpbWUpO1xuICB9XG4gIF90aWNrRm9ybWF0RnVuY3Rpb24odGltZSwgaW5kZXgsIHRpY2tzLCBmb3JtYXQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgdW5pdCA9IHRoaXMuX3VuaXQ7XG4gICAgY29uc3QgbWFqb3JVbml0ID0gdGhpcy5fbWFqb3JVbml0O1xuICAgIGNvbnN0IG1pbm9yRm9ybWF0ID0gdW5pdCAmJiBmb3JtYXRzW3VuaXRdO1xuICAgIGNvbnN0IG1ham9yRm9ybWF0ID0gbWFqb3JVbml0ICYmIGZvcm1hdHNbbWFqb3JVbml0XTtcbiAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgIGNvbnN0IG1ham9yID0gbWFqb3JVbml0ICYmIG1ham9yRm9ybWF0ICYmIHRpY2sgJiYgdGljay5tYWpvcjtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuX2FkYXB0ZXIuZm9ybWF0KHRpbWUsIGZvcm1hdCB8fCAobWFqb3IgPyBtYWpvckZvcm1hdCA6IG1pbm9yRm9ybWF0KSk7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gb3B0aW9ucy50aWNrcy5jYWxsYmFjaztcbiAgICByZXR1cm4gZm9ybWF0dGVyID8gY2FsbGJhY2soZm9ybWF0dGVyLCBbbGFiZWwsIGluZGV4LCB0aWNrc10sIHRoaXMpIDogbGFiZWw7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbih0aWNrLnZhbHVlLCBpLCB0aWNrcyk7XG4gICAgfVxuICB9XG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgob2Zmc2V0cy5zdGFydCArIHBvcykgKiBvZmZzZXRzLmZhY3Rvcik7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIHRoaXMubWluICsgcG9zICogKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICB9XG4gIF9nZXRMYWJlbFNpemUobGFiZWwpIHtcbiAgICBjb25zdCB0aWNrc09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGlja0xhYmVsV2lkdGggPSB0aGlzLmN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG4gICAgY29uc3QgYW5nbGUgPSB0b1JhZGlhbnModGhpcy5pc0hvcml6b250YWwoKSA/IHRpY2tzT3B0cy5tYXhSb3RhdGlvbiA6IHRpY2tzT3B0cy5taW5Sb3RhdGlvbik7XG4gICAgY29uc3QgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgY29uc3Qgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgY29uc3QgdGlja0ZvbnRTaXplID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5zaXplO1xuICAgIHJldHVybiB7XG4gICAgICB3OiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pLFxuICAgICAgaDogKHRpY2tMYWJlbFdpZHRoICogc2luUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIGNvc1JvdGF0aW9uKVxuICAgIH07XG4gIH1cbiAgX2dldExhYmVsQ2FwYWNpdHkoZXhhbXBsZVRpbWUpIHtcbiAgICBjb25zdCB0aW1lT3B0cyA9IHRoaXMub3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IGRpc3BsYXlGb3JtYXRzID0gdGltZU9wdHMuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgZm9ybWF0ID0gZGlzcGxheUZvcm1hdHNbdGltZU9wdHMudW5pdF0gfHwgZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XG4gICAgY29uc3QgZXhhbXBsZUxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKGV4YW1wbGVUaW1lLCAwLCB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIFtleGFtcGxlVGltZV0sIHRoaXMuX21ham9yVW5pdCksIGZvcm1hdCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldExhYmVsU2l6ZShleGFtcGxlTGFiZWwpO1xuICAgIGNvbnN0IGNhcGFjaXR5ID0gTWF0aC5mbG9vcih0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCAvIHNpemUudyA6IHRoaXMuaGVpZ2h0IC8gc2l6ZS5oKSAtIDE7XG4gICAgcmV0dXJuIGNhcGFjaXR5ID4gMCA/IGNhcGFjaXR5IDogMTtcbiAgfVxuICBnZXREYXRhVGltZXN0YW1wcygpIHtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmRhdGEgfHwgW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgaWYgKHRoaXMuX25vcm1hbGl6ZWQgJiYgbWV0YXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSBtZXRhc1swXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmNvbmNhdChtZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5fY2FjaGUuZGF0YSA9IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuICBnZXRMYWJlbFRpbWVzdGFtcHMoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmxhYmVscyB8fCBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzLnB1c2gocGFyc2UodGhpcywgbGFiZWxzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5fY2FjaGUubGFiZWxzID0gdGhpcy5fbm9ybWFsaXplZCA/IHRpbWVzdGFtcHMgOiB0aGlzLm5vcm1hbGl6ZSh0aW1lc3RhbXBzKSk7XG4gIH1cbiAgbm9ybWFsaXplKHZhbHVlcykge1xuICAgIHJldHVybiBfYXJyYXlVbmlxdWUodmFsdWVzLnNvcnQoc29ydGVyKSk7XG4gIH1cbn1cblRpbWVTY2FsZS5pZCA9ICd0aW1lJztcblRpbWVTY2FsZS5kZWZhdWx0cyA9IHtcbiAgYm91bmRzOiAnZGF0YScsXG4gIGFkYXB0ZXJzOiB7fSxcbiAgdGltZToge1xuICAgIHBhcnNlcjogZmFsc2UsXG4gICAgdW5pdDogZmFsc2UsXG4gICAgcm91bmQ6IGZhbHNlLFxuICAgIGlzb1dlZWtkYXk6IGZhbHNlLFxuICAgIG1pblVuaXQ6ICdtaWxsaXNlY29uZCcsXG4gICAgZGlzcGxheUZvcm1hdHM6IHt9XG4gIH0sXG4gIHRpY2tzOiB7XG4gICAgc291cmNlOiAnYXV0bycsXG4gICAgbWFqb3I6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh0YWJsZSwgdmFsLCByZXZlcnNlKSB7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gIGxldCBwcmV2U291cmNlLCBuZXh0U291cmNlLCBwcmV2VGFyZ2V0LCBuZXh0VGFyZ2V0O1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnBvcyAmJiB2YWwgPD0gdGFibGVbaGldLnBvcykge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAncG9zJywgdmFsKSk7XG4gICAgfVxuICAgICh7cG9zOiBwcmV2U291cmNlLCB0aW1lOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHtwb3M6IG5leHRTb3VyY2UsIHRpbWU6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS50aW1lICYmIHZhbCA8PSB0YWJsZVtoaV0udGltZSkge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAndGltZScsIHZhbCkpO1xuICAgIH1cbiAgICAoe3RpbWU6IHByZXZTb3VyY2UsIHBvczogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xuICAgICh7dGltZTogbmV4dFNvdXJjZSwgcG9zOiBuZXh0VGFyZ2V0fSA9IHRhYmxlW2hpXSk7XG4gIH1cbiAgY29uc3Qgc3BhbiA9IG5leHRTb3VyY2UgLSBwcmV2U291cmNlO1xuICByZXR1cm4gc3BhbiA/IHByZXZUYXJnZXQgKyAobmV4dFRhcmdldCAtIHByZXZUYXJnZXQpICogKHZhbCAtIHByZXZTb3VyY2UpIC8gc3BhbiA6IHByZXZUYXJnZXQ7XG59XG5jbGFzcyBUaW1lU2VyaWVzU2NhbGUgZXh0ZW5kcyBUaW1lU2NhbGUge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLl90YWJsZSA9IFtdO1xuICAgIHRoaXMuX21pblBvcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90YWJsZVJhbmdlID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXRPZmZzZXRzKCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLl9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKTtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuX3RhYmxlID0gdGhpcy5idWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpO1xuICAgIHRoaXMuX21pblBvcyA9IGludGVycG9sYXRlKHRhYmxlLCB0aGlzLm1pbik7XG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IGludGVycG9sYXRlKHRhYmxlLCB0aGlzLm1heCkgLSB0aGlzLl9taW5Qb3M7XG4gICAgc3VwZXIuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG4gIH1cbiAgYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCB0YWJsZSA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBwcmV2LCBjdXJyLCBuZXh0O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY3VyciA9IHRpbWVzdGFtcHNbaV07XG4gICAgICBpZiAoY3VyciA+PSBtaW4gJiYgY3VyciA8PSBtYXgpIHtcbiAgICAgICAgaXRlbXMucHVzaChjdXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt0aW1lOiBtaW4sIHBvczogMH0sXG4gICAgICAgIHt0aW1lOiBtYXgsIHBvczogMX1cbiAgICAgIF07XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG5leHQgPSBpdGVtc1tpICsgMV07XG4gICAgICBwcmV2ID0gaXRlbXNbaSAtIDFdO1xuICAgICAgY3VyciA9IGl0ZW1zW2ldO1xuICAgICAgaWYgKE1hdGgucm91bmQoKG5leHQgKyBwcmV2KSAvIDIpICE9PSBjdXJyKSB7XG4gICAgICAgIHRhYmxlLnB1c2goe3RpbWU6IGN1cnIsIHBvczogaSAvIChpbGVuIC0gMSl9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9XG4gIF9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgfHwgW107XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgaWYgKGRhdGEubGVuZ3RoICYmIGxhYmVsLmxlbmd0aCkge1xuICAgICAgdGltZXN0YW1wcyA9IHRoaXMubm9ybWFsaXplKGRhdGEuY29uY2F0KGxhYmVsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVzdGFtcHMgPSBkYXRhLmxlbmd0aCA/IGRhdGEgOiBsYWJlbDtcbiAgICB9XG4gICAgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmFsbCA9IHRpbWVzdGFtcHM7XG4gICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gIH1cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgdmFsdWUpIC0gdGhpcy5fbWluUG9zKSAvIHRoaXMuX3RhYmxlUmFuZ2U7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgZGVjaW1hbCAqIHRoaXMuX3RhYmxlUmFuZ2UgKyB0aGlzLl9taW5Qb3MsIHRydWUpO1xuICB9XG59XG5UaW1lU2VyaWVzU2NhbGUuaWQgPSAndGltZXNlcmllcyc7XG5UaW1lU2VyaWVzU2NhbGUuZGVmYXVsdHMgPSBUaW1lU2NhbGUuZGVmYXVsdHM7XG5cbnZhciBzY2FsZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5DYXRlZ29yeVNjYWxlOiBDYXRlZ29yeVNjYWxlLFxuTGluZWFyU2NhbGU6IExpbmVhclNjYWxlLFxuTG9nYXJpdGhtaWNTY2FsZTogTG9nYXJpdGhtaWNTY2FsZSxcblJhZGlhbExpbmVhclNjYWxlOiBSYWRpYWxMaW5lYXJTY2FsZSxcblRpbWVTY2FsZTogVGltZVNjYWxlLFxuVGltZVNlcmllc1NjYWxlOiBUaW1lU2VyaWVzU2NhbGVcbn0pO1xuXG5jb25zdCByZWdpc3RlcmFibGVzID0gW1xuICBjb250cm9sbGVycyxcbiAgZWxlbWVudHMsXG4gIHBsdWdpbnMsXG4gIHNjYWxlcyxcbl07XG5cbmV4cG9ydCB7IEFuaW1hdGlvbiwgQW5pbWF0aW9ucywgQXJjRWxlbWVudCwgQmFyQ29udHJvbGxlciwgQmFyRWxlbWVudCwgQmFzZVBsYXRmb3JtLCBCYXNpY1BsYXRmb3JtLCBCdWJibGVDb250cm9sbGVyLCBDYXRlZ29yeVNjYWxlLCBDaGFydCwgRGF0YXNldENvbnRyb2xsZXIsIHBsdWdpbl9kZWNpbWF0aW9uIGFzIERlY2ltYXRpb24sIERvbVBsYXRmb3JtLCBEb3VnaG51dENvbnRyb2xsZXIsIEVsZW1lbnQsIHBsdWdpbl9maWxsZXIgYXMgRmlsbGVyLCBJbnRlcmFjdGlvbiwgcGx1Z2luX2xlZ2VuZCBhcyBMZWdlbmQsIExpbmVDb250cm9sbGVyLCBMaW5lRWxlbWVudCwgTGluZWFyU2NhbGUsIExvZ2FyaXRobWljU2NhbGUsIFBpZUNvbnRyb2xsZXIsIFBvaW50RWxlbWVudCwgUG9sYXJBcmVhQ29udHJvbGxlciwgUmFkYXJDb250cm9sbGVyLCBSYWRpYWxMaW5lYXJTY2FsZSwgU2NhbGUsIFNjYXR0ZXJDb250cm9sbGVyLCBwbHVnaW5fc3VidGl0bGUgYXMgU3ViVGl0bGUsIFRpY2tzLCBUaW1lU2NhbGUsIFRpbWVTZXJpZXNTY2FsZSwgcGx1Z2luX3RpdGxlIGFzIFRpdGxlLCBwbHVnaW5fdG9vbHRpcCBhcyBUb29sdGlwLCBhZGFwdGVycyBhcyBfYWRhcHRlcnMsIF9kZXRlY3RQbGF0Zm9ybSwgYW5pbWF0b3IsIGNvbnRyb2xsZXJzLCBlbGVtZW50cywgbGF5b3V0cywgcGx1Z2lucywgcmVnaXN0ZXJhYmxlcywgcmVnaXN0cnksIHNjYWxlcyB9O1xuIiwgIjxzY3JpcHQ+XG4gIGltcG9ydCB7b25Nb3VudCwgYWZ0ZXJVcGRhdGUsIG9uRGVzdHJveX0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IHtjbGVhbn0gZnJvbSAnLi91dGlscyc7XG4gIGltcG9ydCB7Q2hhcnQsIHJlZ2lzdGVyYWJsZXN9IGZyb20gJ2NoYXJ0LmpzL2Rpc3QvY2hhcnQuZXNtJztcbiAgQ2hhcnQucmVnaXN0ZXIoLi4ucmVnaXN0ZXJhYmxlcyk7XG5cbiAgLy8gIEV4cGVjdGVkIGRhdGFcbiAgZXhwb3J0IGxldCBkYXRhID0ge1xuICAgIGxhYmVsczogW10sXG4gICAgZGF0YXNldHM6IFtcbiAgICAgIHtkYXRhOiBbXX1cbiAgICBdLFxuICAgIHlNYXJrZXJzOiB7fSxcbiAgICB5UmVnaW9uczogW10sXG4gIH07XG4gIGV4cG9ydCBsZXQgdHlwZSA9ICdsaW5lJztcbiAgZXhwb3J0IGxldCBvcHRpb25zID0ge307XG4gIGV4cG9ydCBsZXQgcGx1Z2lucyA9IFtdO1xuICBsZXQgY2hhcnQgPSBudWxsO1xuICBsZXQgY2hhcnRSZWY7XG4gIGxldCBwcm9wcyA9IGNsZWFuKCQkcHJvcHMsIFtcImRhdGFcIiwgXCJ0eXBlXCIsIFwib3B0aW9uc1wiLCBcInBsdWdpbnNcIl0pO1xuICBvbk1vdW50KCgpID0+IHtcbiAgICBjaGFydCA9IG5ldyBDaGFydChjaGFydFJlZiwge1xuICAgICAgdHlwZSxcbiAgICAgIGRhdGEsXG4gICAgICBvcHRpb25zLFxuICAgICAgcGx1Z2luc1xuICAgIH0pO1xuICB9KTtcbiAgYWZ0ZXJVcGRhdGUoKCkgPT4ge1xuICAgIGlmICghY2hhcnQpIHJldHVybjtcblxuICAgIGNoYXJ0LmRhdGEgPSBkYXRhO1xuICAgIGNoYXJ0LnR5cGUgPSB0eXBlO1xuICAgIGNoYXJ0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIGNoYXJ0LnBsdWdpbnMgPSBwbHVnaW5zO1xuICAgIGNoYXJ0LnVwZGF0ZSgpXG4gIH0pO1xuXG4gIG9uRGVzdHJveSgoKSA9PiB7XG4gICAgY2hhcnQgPSBudWxsO1xuICB9KTtcbjwvc2NyaXB0PlxuXG48Y2FudmFzIGJpbmQ6dGhpcz17Y2hhcnRSZWZ9IHsuLi5wcm9wc30+PC9jYW52YXM+XG4iLCAiPHNjcmlwdD5cbiAgaW1wb3J0IEJhc2UgZnJvbSAnLi9CYXNlLnN2ZWx0ZSc7XG48L3NjcmlwdD5cbjxCYXNlIHsuLi4kJHByb3BzfSB0eXBlPVwic2NhdHRlclwiIC8+XG4iLCAiLyoqXHJcbiAqIENvbXB1dGUgdGhlIFBlYXJzb24gY29ycmVsYXRpb24gY29lZmZpY2llbnQgYmV0d2VlbiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXHJcbiAqIEBwYXJhbSB7YXJyYXl0eXBlfSB4cyAtIHRoZSBmaXJzdCBhcnJheSBvZiBudW1iZXJzXHJcbiAqIEBwYXJhbSB7YXJyYXl0eXBlfSB5cyAtIHRoZSBhcnJheSBvZiB5IHZhbHVlc1xyXG4gKiBAcmV0dXJucyBUaGUgY29ycmVsYXRpb24gY29lZmZpY2llbnQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGVhcnNvbkNvcnJlbGF0aW9uKHhzOiBudW1iZXJbXSwgeXM6IG51bWJlcltdKSB7XHJcblx0Y29uc3QgbiA9IHhzLmxlbmd0aDtcclxuXHRpZiAobiAhPT0geXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgbXVzdCBiZSB0aGUgc2FtZSBsZW5ndGhcIik7XHJcblxyXG5cdGxldCBzdW1feCA9IDA7XHJcblx0bGV0IHN1bV95ID0gMDtcclxuXHRsZXQgc3VtX3h5ID0gMDtcclxuXHRsZXQgc3VtX3h4ID0gMDtcclxuXHRsZXQgc3VtX3l5ID0gMDtcclxuXHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdGNvbnN0IHggPSB4c1tpXTtcclxuXHRcdGNvbnN0IHkgPSB5c1tpXTtcclxuXHRcdHN1bV94ICs9IHg7XHJcblx0XHRzdW1feSArPSB5O1xyXG5cdFx0c3VtX3h4ICs9IHggKiB4O1xyXG5cdFx0c3VtX3l5ICs9IHkgKiB5O1xyXG5cdFx0c3VtX3h5ICs9IHggKiB5O1xyXG5cdH1cclxuXHJcblx0Y29uc3QgY29yciA9XHJcblx0XHQobiAqIHN1bV94eSAtIHN1bV94ICogc3VtX3kpIC9cclxuXHRcdE1hdGguc3FydCgobiAqIHN1bV94eCAtIHN1bV94ICogc3VtX3gpICogKG4gKiBzdW1feXkgLSBzdW1feSAqIHN1bV95KSk7XHJcblxyXG5cdHJldHVybiBjb3JyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9pbnRCaXNlcmlhbENvcnJlbGF0aW9uKFxyXG5cdHhzOiAobnVtYmVyIHwgYm9vbGVhbilbXSxcclxuXHR5czogbnVtYmVyW11cclxuKSB7XHJcblx0aWYgKHhzLmxlbmd0aCA8PSAxIHx8IHlzLmxlbmd0aCA8PSAxIHx8ICghaXNCaW5hcnkoeHMpICYmICFpc1F1YW50KHlzKSkpXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0Y29uc3QgbTAgPSBbXSxcclxuXHRcdG0xID0gW107XHJcblx0eHMuZm9yRWFjaCgoeCwgaSkgPT4ge1xyXG5cdFx0Y29uc3QgeSA9IHlzW2ldO1xyXG5cdFx0aWYgKCF4KSBtMC5wdXNoKHkpO1xyXG5cdFx0ZWxzZSBtMS5wdXNoKHkpO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gKFxyXG5cdFx0KChtMS5sZW5ndGggLSBtMC5sZW5ndGgpIC8gZ2V0U3RkRGV2KHlzKSkgKlxyXG5cdFx0TWF0aC5zcXJ0KChtMS5sZW5ndGggKiBtMC5sZW5ndGgpIC8geHMubGVuZ3RoKVxyXG5cdCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYWxsIHZhbHVlcyBpbiBgeHNgIGFyZSBudW1iZXJzXHJcbiAqIEBwYXJhbSB7YXJyYXl0eXBlfSB4cyAtIG51bWJlcltdXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzUXVhbnQoeHM6IG51bWJlcltdKTogYm9vbGVhbiB7XHJcblx0cmV0dXJuIHhzLmxlbmd0aCAmJiB4cy5ldmVyeSgoeCkgPT4gdHlwZW9mIHggPT09IFwibnVtYmVyXCIpO1xyXG59XHJcblxyXG4vKipcclxuICogYGlzQmluYXJ5YCBjaGVja3MgaWYgdGhlIGdpdmVuIGFycmF5IG9ubHkgY29udGFpbnMgYDBgJ3MgYW5kIGAxYCdzLlxyXG4gKiBAcGFyYW0ge2FycmF5dHlwZX0geHMgLSBudW1iZXJbXVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0JpbmFyeSh4czogKG51bWJlciB8IGJvb2xlYW4pW10pOiBib29sZWFuIHtcclxuXHRyZXR1cm4gKFxyXG5cdFx0eHMubGVuZ3RoICYmXHJcblx0XHR4cy5ldmVyeSgoeCkgPT4geCA9PT0gMCB8fCB4ID09PSAxIHx8IHggPT09IGZhbHNlIHx8IHggPT09IHRydWUpXHJcblx0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgdGhlIG1lYW4gb2YgYSBsaXN0IG9mIG51bWJlcnMuXHJcbiAqIEBwYXJhbSB7YXJyYXl0eXBlfSB4cyAtIG51bWJlcltdXHJcbiAqIEByZXR1cm5zIFRoZSBtZWFuIG9mIHRoZSBudW1iZXJzIGluIHRoZSBhcnJheS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNZWFuKHhzOiBudW1iZXJbXSkge1xyXG5cdGlmICghaXNRdWFudCh4cykpIHJldHVybiBudWxsO1xyXG5cdHJldHVybiB4cy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKSAvIHhzLmxlbmd0aDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgbGlzdCBvZiBudW1iZXJzLCByZXR1cm4gdGhlIG1lZGlhbiBvZiB0aGUgbGlzdC5cclxuICogQHBhcmFtIHthcnJheXR5cGV9IHhzIC0gdGhlIGFycmF5IG9mIG51bWJlcnMgdG8gYmUgc29ydGVkXHJcbiAqIEByZXR1cm5zIFRoZSBtZWRpYW4gb2YgdGhlIGFycmF5LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1lZGlhbih4czogbnVtYmVyW10pIHtcclxuXHRpZiAoIWlzUXVhbnQoeHMpKSByZXR1cm4gbnVsbDtcclxuXHRjb25zdCBzb3J0ZWQgPSB4cy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcclxuXHRjb25zdCBtaWQgPSBNYXRoLmZsb29yKHNvcnRlZC5sZW5ndGggLyAyKTtcclxuXHRyZXR1cm4gc29ydGVkW21pZF07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIGxpc3Qgb2YgaXRlbXMsIHJldHVybiB0aGUgbW9zdCBjb21tb24gaXRlbS5cclxuICogQHBhcmFtIHthcnJheXR5cGV9IHhzIC0gVGhlIGFycmF5IG9mIHZhbHVlcyB0byBjb3VudC5cclxuICogQHJldHVybnMge3N0cmluZ1tdfSBUaGUgbW9kZShzKSBvZiB0aGUgYXJyYXkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW9kZShcclxuXHR4czogKHN0cmluZyB8IG51bWJlciB8IHN0cmluZ1tdIHwgbnVtYmVyW10pW11cclxuKTogc3RyaW5nW10ge1xyXG5cdGNvbnN0IGZsYXR0ZW5lZCA9IHhzLmZsYXQoKTtcclxuXHRjb25zdCBjb3VudHM6IHsgW2l0ZW06IHN0cmluZyB8IG51bWJlcl06IG51bWJlciB9ID0ge307XHJcblx0ZmxhdHRlbmVkLmZvckVhY2goKHgpID0+IHtcclxuXHRcdGlmIChjb3VudHNbeF0pIGNvdW50c1t4XSA9IGNvdW50c1t4XSArIDE7XHJcblx0XHRlbHNlIGNvdW50c1t4XSA9IDE7XHJcblx0fSk7XHJcblx0Y29uc3QgbWF4ID0gTWF0aC5tYXgoLi4uT2JqZWN0LnZhbHVlcyhjb3VudHMpKTtcclxuXHRyZXR1cm4gT2JqZWN0LmtleXMoY291bnRzKS5maWx0ZXIoKHgpID0+IGNvdW50c1t4XSA9PT0gbWF4KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSB0aGUgdmFyaWFuY2Ugb2YgYSBzZXQgb2YgbnVtYmVycy5cclxuICogQHBhcmFtIHthcnJheXR5cGV9IHhzIC0gdGhlIGFycmF5IG9mIG51bWJlcnMgdG8gYmUgYW5hbHl6ZWRcclxuICogQHJldHVybnMgVGhlIHZhcmlhbmNlIG9mIHRoZSBhcnJheS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWYXJpYW5jZSh4czogbnVtYmVyW10pIHtcclxuXHRpZiAoIWlzUXVhbnQoeHMpKSByZXR1cm4gbnVsbDtcclxuXHRjb25zdCBtZWFuX3ggPSBnZXRNZWFuKHhzKTtcclxuXHRyZXR1cm4geHMucmVkdWNlKChhLCBiKSA9PiBhICsgTWF0aC5wb3coYiAtIG1lYW5feCwgMiksIDApIC8geHMubGVuZ3RoO1xyXG59XHJcblxyXG4vKipcclxuICogQ29tcHV0ZSB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIGEgc2V0IG9mIG51bWJlcnMuXHJcbiAqIEBwYXJhbSB7YXJyYXl0eXBlfSB4cyAtIHRoZSBhcnJheSBvZiBudW1iZXJzIHRvIGJlIGFuYWx5emVkXHJcbiAqIEByZXR1cm5zIFRoZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlIGFycmF5LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0ZERldih4czogbnVtYmVyW10pIHtcclxuXHRpZiAoIWlzUXVhbnQoeHMpKSByZXR1cm4gbnVsbDtcclxuXHRyZXR1cm4gTWF0aC5zcXJ0KGdldFZhcmlhbmNlKHhzKSk7XHJcbn1cclxuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XHJcblx0aW1wb3J0IHsgQ2hhcnRNb2RhbCB9IGZyb20gXCJzcmMvQ2hhcnRNb2RhbFwiO1xyXG5cdGltcG9ydCBDaGVja2JveGVzIGZyb20gXCIuL0NoZWNrYm94ZXMuc3ZlbHRlXCI7XHJcblx0aW1wb3J0IENoYXJ0T3B0aW9ucyBmcm9tIFwiLi9DaGFydE9wdGlvbnMuc3ZlbHRlXCI7XHJcblx0aW1wb3J0IFNjYXR0ZXIgZnJvbSBcInN2ZWx0ZS1jaGFydGpzL3NyYy9TY2F0dGVyLnN2ZWx0ZVwiO1xyXG5cdGltcG9ydCB7IGdldFBlYXJzb25Db3JyZWxhdGlvbiB9IGZyb20gXCJzcmMvYW5hbHlzZXNcIjtcclxuXHRpbXBvcnQgeyBEYXRlVGltZSB9IGZyb20gXCJvYnNpZGlhbi1kYXRhdmlld1wiO1xyXG5cclxuXHRleHBvcnQgbGV0IG1vZGFsOiBDaGFydE1vZGFsO1xyXG5cclxuXHRjb25zdCB7IGFwcCwgcGx1Z2luIH0gPSBtb2RhbDtcclxuXHRjb25zdCB7IGluZGV4LCBzZXR0aW5ncyB9ID0gcGx1Z2luO1xyXG5cdGNvbnN0IHsgZmllbGRzVG9DaGVjayB9ID0gc2V0dGluZ3M7XHJcblxyXG5cdGxldCBhbGxGaWVsZHMgPSBmaWVsZHNUb0NoZWNrO1xyXG5cdGxldCBzZWxlY3RlZDogc3RyaW5nW10gPSBbXTtcclxuXHJcblx0bGV0IGNvbG91ciA9IFwiIzE1YTI1MlwiO1xyXG5cdGxldCBzdGFydERhdGUgPSBpbmRleC5taW5EYXRlO1xyXG5cdGxldCBlbmREYXRlID0gaW5kZXgubWF4RGF0ZTtcclxuXHRsZXQgZG5Pbmx5ID0gZmFsc2U7XHJcblxyXG5cdGZ1bmN0aW9uIGlzVmFsaWRTZWxlY3Rpb24oc2VsZWN0ZWQ6IHN0cmluZ1tdKSB7XHJcblx0XHRyZXR1cm4gc2VsZWN0ZWQubGVuZ3RoID09PSAyO1xyXG5cdH1cclxuXHJcblx0aW50ZXJmYWNlIERhdHVtMmQge1xyXG5cdFx0eDogbnVtYmVyO1xyXG5cdFx0eTogbnVtYmVyO1xyXG5cdFx0bmFtZTogc3RyaW5nO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaElubmVyRGF0YShcclxuXHRcdHNlbGVjdGVkOiBzdHJpbmdbXSxcclxuXHRcdGRuT25seTogYm9vbGVhbixcclxuXHRcdHN0YXJ0RGF0ZTogRGF0ZVRpbWUsXHJcblx0XHRlbmREYXRlOiBEYXRlVGltZVxyXG5cdCk6IERhdHVtMmRbXSB7XHJcblx0XHRjb25zdCBmaWxlUmFuZ2UgPSBkbk9ubHlcclxuXHRcdFx0PyBpbmRleC5kYXRhLmZpbHRlcigoaXRlbSkgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgeyBkYXkgfTogeyBkYXk6IERhdGVUaW1lIH0gPSBpdGVtLmZpbGU7XHJcblx0XHRcdFx0XHRyZXR1cm4gKFxyXG5cdFx0XHRcdFx0XHRkYXkgJiYgc3RhcnREYXRlLnRzIDw9IGRheS50cyAmJiBkYXkudHMgPD0gZW5kRGF0ZS50c1xyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0ICB9KVxyXG5cdFx0XHQ6IGluZGV4LmRhdGE7XHJcblxyXG5cdFx0Y29uc3QgaW5uZXJEYXRhID0gZmlsZVJhbmdlXHJcblx0XHRcdC5tYXAoKHBhZ2UpID0+IHtcclxuXHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0eDogcGFnZVtzZWxlY3RlZFswXV0gYXMgbnVtYmVyLFxyXG5cdFx0XHRcdFx0eTogcGFnZVtzZWxlY3RlZFsxXV0gYXMgbnVtYmVyLFxyXG5cdFx0XHRcdFx0bmFtZTogcGFnZS5maWxlLm5hbWUsXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmZpbHRlcigocG9pbnQpID0+IHtcclxuXHRcdFx0XHRyZXR1cm4gcG9pbnQueCAmJiBwb2ludC55O1xyXG5cdFx0XHR9KTtcclxuXHRcdHJldHVybiBpbm5lckRhdGE7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoQ29ycmVsYXRpb24oc2VsZWN0ZWQ6IHN0cmluZ1tdLCBpbm5lckRhdGE6IERhdHVtMmRbXSkge1xyXG5cdFx0cmV0dXJuIGlzVmFsaWRTZWxlY3Rpb24oc2VsZWN0ZWQpXHJcblx0XHRcdD8gZ2V0UGVhcnNvbkNvcnJlbGF0aW9uKFxyXG5cdFx0XHRcdFx0aW5uZXJEYXRhLm1hcCgocCkgPT4gcC54KSxcclxuXHRcdFx0XHRcdGlubmVyRGF0YS5tYXAoKHApID0+IHAueSlcclxuXHRcdFx0ICApXHJcblx0XHRcdDogbnVsbDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hEYXRhKGNvbG91cjogc3RyaW5nLCBpbm5lckRhdGE6IERhdHVtMmRbXSkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0bGFiZWxzOiBbXCJTY2F0dGVyXCJdLFxyXG5cdFx0XHRkYXRhc2V0czogW1xyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGJvcmRlckNvbG9yOiBjb2xvdXIsXHJcblx0XHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGNvbG91cixcclxuXHRcdFx0XHRcdGxhYmVsOiBcIlYobm9kZTIpXCIsXHJcblx0XHRcdFx0XHRkYXRhOiBpbm5lckRhdGEsXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XSxcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoQ2hhcnRPcHRpb25zKHNlbGVjdGVkOiBzdHJpbmdbXSkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dGl0bGU6IHtcclxuXHRcdFx0XHRkaXNwbGF5OiB0cnVlLFxyXG5cdFx0XHRcdHRleHQ6IFwiU2NhdHRlciBDaGFydCAtIExvZ2FyaXRobWljIFgtQXhpc1wiLFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRzY2FsZXM6IHtcclxuXHRcdFx0XHR4QXhlczoge1xyXG5cdFx0XHRcdFx0dGl0bGU6IHtcclxuXHRcdFx0XHRcdFx0ZGlzcGxheTogaXNWYWxpZFNlbGVjdGlvbihzZWxlY3RlZCksXHJcblx0XHRcdFx0XHRcdHRleHQ6IHNlbGVjdGVkWzBdID8/IFwiXCIsXHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0dHlwZTogXCJsaW5lYXJcIixcclxuXHRcdFx0XHRcdHBvc2l0aW9uOiBcImJvdHRvbVwiLFxyXG5cdFx0XHRcdFx0c2NhbGVMYWJlbDoge1xyXG5cdFx0XHRcdFx0XHRsYWJlbFN0cmluZzogXCJGcmVxdWVuY3lcIixcclxuXHRcdFx0XHRcdFx0ZGlzcGxheTogdHJ1ZSxcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0eUF4ZXM6IHtcclxuXHRcdFx0XHRcdHR5cGU6IFwibGluZWFyXCIsXHJcblx0XHRcdFx0XHRzY2FsZUxhYmVsOiB7XHJcblx0XHRcdFx0XHRcdGxhYmVsU3RyaW5nOiBcIlZvbHRhZ2VcIixcclxuXHRcdFx0XHRcdFx0ZGlzcGxheTogdHJ1ZSxcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHR0aXRsZToge1xyXG5cdFx0XHRcdFx0XHRkaXNwbGF5OiBpc1ZhbGlkU2VsZWN0aW9uKHNlbGVjdGVkKSxcclxuXHRcdFx0XHRcdFx0dGV4dDogc2VsZWN0ZWRbMV0gPz8gXCJcIixcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0fSxcclxuXHRcdFx0cGx1Z2luczoge1xyXG5cdFx0XHRcdHRvb2x0aXA6IHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrczoge1xyXG5cdFx0XHRcdFx0XHRsYWJlbDogZnVuY3Rpb24gKHRvb2x0aXBJdGVtOiBEYXR1bTJkKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29uc3QgeyByYXcgfSA9IHRvb2x0aXBJdGVtO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBgJHtyYXcubmFtZX06XFxuKCR7cmF3Lnh9LCAke3Jhdy55fSlgO1xyXG5cdFx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHR9LFxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdCQ6IGlubmVyRGF0YSA9IHJlZnJlc2hJbm5lckRhdGEoc2VsZWN0ZWQsIGRuT25seSwgc3RhcnREYXRlLCBlbmREYXRlKTtcclxuXHQkOiBjb3JyZWxhdGlvbiA9IHJlZnJlc2hDb3JyZWxhdGlvbihzZWxlY3RlZCwgaW5uZXJEYXRhKTtcclxuXHQkOiBkYXRhID0gcmVmcmVzaERhdGEoY29sb3VyLCBpbm5lckRhdGEpO1xyXG5cdCQ6IGNoYXJ0T3B0aW9ucyA9IHJlZnJlc2hDaGFydE9wdGlvbnMoc2VsZWN0ZWQpO1xyXG48L3NjcmlwdD5cclxuXHJcbjxkaXYgY2xhc3M9XCJjaGVja2JveGVzXCI+XHJcblx0PENoZWNrYm94ZXMgb3B0aW9ucz17YWxsRmllbGRzfSB7cGx1Z2lufSBiaW5kOnNlbGVjdGVkIC8+XHJcbjwvZGl2PlxyXG5cclxuPENoYXJ0T3B0aW9ucyBiaW5kOmNvbG91ciBiaW5kOnN0YXJ0RGF0ZSBiaW5kOmVuZERhdGUgYmluZDpkbk9ubHkgLz5cclxuPFNjYXR0ZXIge2RhdGF9IG9wdGlvbnM9e2NoYXJ0T3B0aW9uc30gLz5cclxuXHJcbjxkaXY+Q29ycmVsYXRpb246IHtjb3JyZWxhdGlvbj8udG9GaXhlZCg0KSA/PyBcIlNlbGVjdCAyIGZpZWxkc1wifTwvZGl2PlxyXG5cclxuPHN0eWxlPlxyXG5cdGRpdi5jaGVja2JveGVzIHtcclxuXHRcdGJvcmRlci1yYWRpdXM6IDVweDtcclxuXHRcdGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItYm9yZGVyKTtcclxuXHR9XHJcbjwvc3R5bGU+XHJcbiIsICJpbXBvcnQgeyBTZXR0aW5ncyB9IGZyb20gXCIuL2ludGVyZmFjZXNcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBTZXR0aW5ncyA9IHtcclxuXHRmaWVsZHNUb0NoZWNrOiBbXSxcclxuXHRmaWVsZExpc3RzOiBbXSxcclxuXHRkYXRlRm9ybWF0OiBcIllZWVktTU0tRERcIixcclxuXHRkZWZhdWx0U2F2ZVBhdGg6IFwiL1wiLFxyXG5cdG51bGxWYWx1ZTogXCJudWxsXCIsXHJcblx0dW5kZWZpbmVkVmFsdWU6IFwidW5kZWZpbmVkXCIsXHJcblx0YWRkRmlsZURhdGE6IGZhbHNlLFxyXG5cdGFkZE5vdGVDb250ZW50OiBmYWxzZSxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzcGxpdExpbmtzUmVnZXggPSBuZXcgUmVnRXhwKC9cXFtcXFsoLio/KVxcXVxcXS9nKTtcclxuZXhwb3J0IGNvbnN0IGRyb3BIZWFkZXJPckFsaWFzID0gbmV3IFJlZ0V4cCgvXFxbXFxbKFteI3xdKilcXF1cXF0vKTtcclxuIiwgImltcG9ydCB7IEFwcCwgTm90aWNlLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7IERFRkFVTFRfU0VUVElOR1MgfSBmcm9tIFwiLi9jb25zdFwiO1xyXG5pbXBvcnQgRGF0YUFuYWx5c2lzUGx1Z2luIGZyb20gXCIuL21haW5cIjtcclxuaW1wb3J0IHsgc3BsaXRBbmRUcmltIH0gZnJvbSBcIi4vdXRpbHNcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XHJcblx0cGx1Z2luOiBEYXRhQW5hbHlzaXNQbHVnaW47XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IERhdGFBbmFseXNpc1BsdWdpbikge1xyXG5cdFx0c3VwZXIoYXBwLCBwbHVnaW4pO1xyXG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcblx0fVxyXG5cclxuXHRkaXNwbGF5KCk6IHZvaWQge1xyXG5cdFx0bGV0IHsgY29udGFpbmVyRWwsIHBsdWdpbiB9ID0gdGhpcztcclxuXHRcdGNvbnN0IHsgc2V0dGluZ3MgfSA9IHBsdWdpbjtcclxuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblxyXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcblx0XHRcdC5zZXRDbGFzcyhcImZpZWxkcy10by1jaGVja1wiKVxyXG5cdFx0XHQuc2V0TmFtZShcIkZpZWxkcyB0byBDaGVja1wiKVxyXG5cdFx0XHQuc2V0RGVzYyhcIkEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZmllbGRzIHRvIGxvb2sgZm9yIGRhdGEgaW4uXCIpXHJcblx0XHRcdC5hZGRUZXh0QXJlYSgodGV4dCkgPT4ge1xyXG5cdFx0XHRcdHRleHQuc2V0VmFsdWUoc2V0dGluZ3MuZmllbGRzVG9DaGVjay5qb2luKFwiLCBcIikpO1xyXG5cdFx0XHRcdHRleHQuaW5wdXRFbC5vbmJsdXIgPSBhc3luYyAoKSA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBzcGxpdHMgPSBzcGxpdEFuZFRyaW0odGV4dC5nZXRWYWx1ZSgpKTtcclxuXHRcdFx0XHRcdHNldHRpbmdzLmZpZWxkc1RvQ2hlY2sgPSBzcGxpdHM7XHJcblx0XHRcdFx0XHRhd2FpdCBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHRhd2FpdCBwbHVnaW4ucmVmcmVzaEluZGV4KFxyXG5cdFx0XHRcdFx0XHRwbHVnaW4uYXBwLnBsdWdpbnMucGx1Z2lucy5kYXRhdmlldz8uYXBpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdH0pO1xyXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcblx0XHRcdC5zZXROYW1lKFwiQWRkIEFsbCBOdW1lcmljIEZpZWxkc1wiKVxyXG5cdFx0XHQuc2V0RGVzYyhcclxuXHRcdFx0XHRcIkFkZCBhbGwgZmllbGRzIHdpdGggbnVtZXJpYyB2YWx1ZXMgdG8gdGhlIGxpc3Qgb2YgZmllbGRzIHRvIGNoZWNrXCJcclxuXHRcdFx0KVxyXG5cdFx0XHQuYWRkQnV0dG9uKChidXQpID0+IHtcclxuXHRcdFx0XHRidXQuc2V0QnV0dG9uVGV4dChcIkFkZFwiKS5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHsgZGF0YSB9ID0gcGx1Z2luLmluZGV4O1xyXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBwYWdlIG9mIGRhdGEpIHtcclxuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBmaWVsZCBpbiBwYWdlKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKFxyXG5cdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHBhZ2VbZmllbGRdID09PSBcIm51bWJlclwiICYmXHJcblx0XHRcdFx0XHRcdFx0XHQhc2V0dGluZ3MuZmllbGRzVG9DaGVjay5pbmNsdWRlcyhmaWVsZClcclxuXHRcdFx0XHRcdFx0XHQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHNldHRpbmdzLmZpZWxkc1RvQ2hlY2sucHVzaChmaWVsZCk7XHJcblx0XHRcdFx0XHRcdFx0XHRhd2FpdCBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5kaXNwbGF5KCk7XHJcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiTnVtZXJpYyBmaWVsZHMgYWRkZWRcIik7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG5cdFx0XHQuc2V0TmFtZShcIkZpZWxkIExpc3RzXCIpXHJcblx0XHRcdC5zZXREZXNjKFxyXG5cdFx0XHRcdFwiQSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBmaWxlcyB0aGF0IHlvdSBrZWVwIGZpZWxkcyBpbi4gRWFjaCBmaWVsZCBtdXN0IGJlIG9uIGEgbmV3IGxpbmUuIEl0IGNhbiBiZSBhIHdpa2lsaW5rLCBvciBub3QuXCJcclxuXHRcdFx0KVxyXG5cdFx0XHQuYWRkVGV4dCgodGV4dCkgPT4ge1xyXG5cdFx0XHRcdHRleHQuc2V0VmFsdWUoc2V0dGluZ3MuZmllbGRMaXN0cy5qb2luKFwiLCBcIikpO1xyXG5cdFx0XHRcdHRleHQuaW5wdXRFbC5vbmJsdXIgPSBhc3luYyAoKSA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBzcGxpdHMgPSBzcGxpdEFuZFRyaW0odGV4dC5nZXRWYWx1ZSgpKTtcclxuXHRcdFx0XHRcdHNldHRpbmdzLmZpZWxkTGlzdHMgPSBzcGxpdHM7XHJcblx0XHRcdFx0XHRhd2FpdCBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHRhd2FpdCBwbHVnaW4ucmVmcmVzaEluZGV4KFxyXG5cdFx0XHRcdFx0XHR0aGlzLmFwcC5wbHVnaW5zLnBsdWdpbnMuZGF0YXZpZXc/LmFwaVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9KTtcclxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG5cdFx0XHQuc2V0TmFtZShcIkRhdGUgRm9ybWF0XCIpXHJcblx0XHRcdC5zZXREZXNjKFwiVGhlIGRhdGUgZm9ybWF0IHlvdSB1c2UgaW4geW91ciB2YXVsdC5cIilcclxuXHRcdFx0LmFkZE1vbWVudEZvcm1hdCgoZm9ybWF0KSA9PiB7XHJcblx0XHRcdFx0Zm9ybWF0XHJcblx0XHRcdFx0XHQuc2V0RGVmYXVsdEZvcm1hdChERUZBVUxUX1NFVFRJTkdTLmRhdGVGb3JtYXQpXHJcblx0XHRcdFx0XHQuc2V0VmFsdWUoc2V0dGluZ3MuZGF0ZUZvcm1hdClcclxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuXHRcdFx0XHRcdFx0c2V0dGluZ3MuZGF0ZUZvcm1hdCA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRhd2FpdCBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IFwiRXhwb3J0aW5nIERhdGFcIiB9KTtcclxuXHJcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0LnNldE5hbWUoXCJEZWZhdWx0IHNhdmUgcGF0aFwiKVxyXG5cdFx0XHQuc2V0RGVzYyhcclxuXHRcdFx0XHQnVGhlIGZ1bGwgZmlsZSBwYXRoIHRvIHNhdmUgdGhlIG1ldGFkYXRhZnJhbWUgdG8uIERvblxcJ3QgaW5jbHVkZSB0aGUgZmlsZSBleHRlbnNpb24uIEZvciBleGFtcGxlLCB0aGlzIGlzIGEgY29ycmVjdCBmaWxlIHBhdGg6IFN1YkZvbGRlci9tZXRhZGF0YWZyYW1lLiBVc2UgXCIvXCIgdG8gc2F2ZSB0byB0aGUgcm9vdCBvZiB5b3VyIHZhdWx0LidcclxuXHRcdFx0KVxyXG5cdFx0XHQuYWRkVGV4dCgodGV4dCkgPT5cclxuXHRcdFx0XHR0ZXh0XHJcblx0XHRcdFx0XHQuc2V0VmFsdWUoc2V0dGluZ3MuZGVmYXVsdFNhdmVQYXRoKVxyXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdFx0XHRzZXR0aW5ncy5kZWZhdWx0U2F2ZVBhdGggPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0YXdhaXQgcGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0KTtcclxuXHJcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0LnNldE5hbWUoXCJOdWxsIHZhbHVlXCIpXHJcblx0XHRcdC5zZXREZXNjKFxyXG5cdFx0XHRcdFwiV2hhdCBzaG91bGQgdGhlIGRlZmF1bHQgdmFsdWUgYmUgZm9yIG1pc3NpbmcgZmllbGQgdmFsdWVzPyBEZWZhdWx0IGlzICdudWxsJy4gRG9uJ3QgdXNlIHF1b3RlcywganVzdCBlbnRlciB0aGUgdmFsdWUuXCJcclxuXHRcdFx0KVxyXG5cdFx0XHQuYWRkVGV4dCgodGV4dCkgPT5cclxuXHRcdFx0XHR0ZXh0LnNldFZhbHVlKHNldHRpbmdzLm51bGxWYWx1ZSkub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcblx0XHRcdFx0XHRzZXR0aW5ncy5udWxsVmFsdWUgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdGF3YWl0IHBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG5cdFx0XHQuc2V0TmFtZShcIkFkZCBpbmhlcmVudCBmaWxlIG1ldGFkYXRhXCIpXHJcblx0XHRcdC5zZXREZXNjKFxyXG5cdFx0XHRcdFwiRWFjaCBmaWxlIGhhcyBhbG90IG9mIGluaGVyZW50IG1ldGFkYXRhIHRvIGl0IChiZXNpZGVzIHRoZSBmaWVsZHMgeW91IGFkZCkuIFNob3VsZCBtZXRhZGF0YWZyYW1lIGFkZCB0aGVzZSBmaWVsZHMgdG9vPyBJdCBjYW4gYmUgYWxvdCwgc28gdGhlcmUgaXMgdGhlIG9wdGlvbiB0byBkaXNhYmxlIHRoaXMgYmVoYXZpb3VyLlwiXHJcblx0XHRcdClcclxuXHRcdFx0LmFkZFRvZ2dsZSgodG9nZ2xlKSA9PlxyXG5cdFx0XHRcdHRvZ2dsZVxyXG5cdFx0XHRcdFx0LnNldFZhbHVlKHNldHRpbmdzLmFkZEZpbGVEYXRhKVxyXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdFx0XHRzZXR0aW5ncy5hZGRGaWxlRGF0YSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRhd2FpdCBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG5cdFx0XHQuc2V0TmFtZShcIkFkZCBjb250ZW50IG9mIGVhY2ggbm90ZVwiKVxyXG5cdFx0XHQuc2V0RGVzYyhcclxuXHRcdFx0XHRcIkFkZCBhIGNvbHVtbiBmb3IgdGhlIGNvbnRlbnQgb2YgZWFjaCBub3RlLiBUaGlzIHdpbGwgYWRkIGFsb3Qgb2Ygc2l6ZSB0byB0aGUgQ1NWIGZpbGUsIHNvIGl0IGlzIG9mZiBieSBkZWZhdWx0LlwiXHJcblx0XHRcdClcclxuXHRcdFx0LmFkZFRvZ2dsZSgodG9nZ2xlKSA9PlxyXG5cdFx0XHRcdHRvZ2dsZVxyXG5cdFx0XHRcdFx0LnNldFZhbHVlKHNldHRpbmdzLmFkZE5vdGVDb250ZW50KVxyXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdFx0XHRzZXR0aW5ncy5hZGROb3RlQ29udGVudCA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRhd2FpdCBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHQpO1xyXG5cdH1cclxufVxyXG4iLCAiZXhwb3J0IGNvbnN0IHNwbGl0QW5kVHJpbSA9IChmaWVsZHM6IHN0cmluZyk6IHN0cmluZ1tdID0+IHtcclxuXHRpZiAoZmllbGRzID09PSBcIlwiKSByZXR1cm4gW107XHJcblx0ZWxzZSByZXR1cm4gZmllbGRzLnNwbGl0KFwiLFwiKS5tYXAoKHN0cikgPT4gc3RyLnRyaW0oKSk7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWFrZUFycjxUPihpbnB1dDogVCB8IFRbXSk6IFRbXSB7XHJcblx0cmV0dXJuIFtpbnB1dF0uZmxhdCgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9OdWxsT3JVbmRlZmluZWQoY3VycmVudDogc3RyaW5nKSB7XHJcblx0aWYgKGN1cnJlbnQgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiB1bmRlZmluZWQ7XHJcblx0ZWxzZSBpZiAoY3VycmVudCA9PT0gXCJudWxsXCIpIHJldHVybiBudWxsO1xyXG5cdGVsc2UgcmV0dXJuIGN1cnJlbnQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhcnJheU92ZXJsYXA8VD4oQTogVFtdLCBCOiBUW10pOiBbVFtdLCBUW11dIHtcclxuXHRjb25zdCBpQTogbnVtYmVyW10gPSBbXTtcclxuXHRBLmZvckVhY2goKGEsIGkpID0+IHtcclxuXHRcdGlmIChhICE9PSB1bmRlZmluZWQpIGlBLnB1c2goaSk7XHJcblx0fSk7XHJcblx0Y29uc3QgaUI6IG51bWJlcltdID0gW107XHJcblx0Qi5mb3JFYWNoKChiLCBpKSA9PiB7XHJcblx0XHRpZiAoYiAhPT0gdW5kZWZpbmVkKSBpQi5wdXNoKGkpO1xyXG5cdH0pO1xyXG5cclxuXHRjb25zdCBhT3ZlcmxhcCA9IEEuZmlsdGVyKChhLCBpKSA9PiBpQS5pbmNsdWRlcyhpKSAmJiBpQi5pbmNsdWRlcyhpKSk7XHJcblx0Y29uc3QgYk92ZXJsYXAgPSBCLmZpbHRlcigoYiwgaSkgPT4gaUEuaW5jbHVkZXMoaSkgJiYgaUIuaW5jbHVkZXMoaSkpO1xyXG5cclxuXHRpZiAoIWFPdmVybGFwLmxlbmd0aCB8fCAhYk92ZXJsYXAubGVuZ3RoKSByZXR1cm4gW1tdLCBbXV07XHJcblx0cmV0dXJuIFthT3ZlcmxhcCwgYk92ZXJsYXBdO1xyXG59XHJcbiIsICJpbXBvcnQgeyBBcHAsIE1vZGFsIH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCBTdGF0cyBmcm9tIFwiLi9Db21wb25lbnRzL1N0YXRzLnN2ZWx0ZVwiO1xyXG5pbXBvcnQgdHlwZSBEYXRhQW5hbHlzaXNQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFN0YXRzTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XHJcblx0cGx1Z2luOiBEYXRhQW5hbHlzaXNQbHVnaW47XHJcblx0bW9kYWw6IFN0YXRzTW9kYWw7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IERhdGFBbmFseXNpc1BsdWdpbikge1xyXG5cdFx0c3VwZXIoYXBwKTtcclxuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG5cdFx0dGhpcy5tb2RhbCA9IHRoaXM7XHJcblx0fVxyXG5cclxuXHRvbk9wZW4oKSB7XHJcblx0XHRjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcclxuXHRcdGNvbnRlbnRFbC5lbXB0eSgpO1xyXG5cclxuXHRcdG5ldyBTdGF0cyh7XHJcblx0XHRcdHRhcmdldDogY29udGVudEVsLFxyXG5cdFx0XHRwcm9wczoge1xyXG5cdFx0XHRcdG1vZGFsOiB0aGlzLFxyXG5cdFx0XHR9LFxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRvbkNsb3NlKCkge1xyXG5cdFx0dGhpcy5jb250ZW50RWwuZW1wdHkoKTtcclxuXHR9XHJcbn1cclxuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XHJcblx0aW1wb3J0IHsgZ2V0TWVhbiwgZ2V0TWVkaWFuLCBnZXRNb2RlLCBnZXRTdGREZXYgfSBmcm9tIFwic3JjL2FuYWx5c2VzXCI7XHJcblx0aW1wb3J0IHsgU3RhdHNNb2RhbCB9IGZyb20gXCIuLi9TdGF0c01vZGFsXCI7XHJcblxyXG5cdGV4cG9ydCBsZXQgbW9kYWw6IFN0YXRzTW9kYWw7XHJcblxyXG5cdGNvbnN0IHsgYXBwLCBwbHVnaW4gfSA9IG1vZGFsO1xyXG5cdGNvbnN0IHsgaW5kZXgsIHNldHRpbmdzIH0gPSBwbHVnaW47XHJcblx0Y29uc3QgeyBmaWVsZHNUb0NoZWNrIH0gPSBzZXR0aW5ncztcclxuXHJcblx0bGV0IGZpZWxkID0gZmllbGRzVG9DaGVja1swXTtcclxuXHJcblx0Y29uc3QgdXBkYXRlRGF0YSA9IChmaWVsZDogc3RyaW5nKSA9PlxyXG5cdFx0aW5kZXguZGF0YS5tYXAoKGQpID0+IGRbZmllbGRdKS5maWx0ZXIoKGQpID0+IGQpO1xyXG5cclxuXHQkOiBkYXRhID0gdXBkYXRlRGF0YShmaWVsZCk7XHJcblx0JDogbWVhbiA9IGdldE1lYW4oZGF0YSk7XHJcblx0JDogbWVkaWFuID0gZ2V0TWVkaWFuKGRhdGEpO1xyXG5cdCQ6IG1vZGUgPSBnZXRNb2RlKGRhdGEpO1xyXG5cdCQ6IHN0ZCA9IGdldFN0ZERldihkYXRhKTtcclxuXHJcblx0JDogc3RhdHMgPSBbXHJcblx0XHRtZWFuID8gW1wiTWVhblwiLCBtZWFuXSA6IG51bGwsXHJcblx0XHRtZWRpYW4gPyBbXCJNZWRpYW5cIiwgbWVkaWFuXSA6IG51bGwsXHJcblx0XHRbXCJNb2RlXCIsIG1vZGVdLFxyXG5cdFx0c3RkID8gW1wiU3RkIERldi5cIiwgc3RkPy50b0ZpeGVkKDQpXSA6IG51bGwsXHJcblx0XTtcclxuXHQkOiBjb25zb2xlLmxvZyh7IHN0YXRzIH0pO1xyXG48L3NjcmlwdD5cclxuXHJcbjxsYWJlbD5cclxuXHRGaWVsZDpcclxuXHQ8c2VsZWN0IGNsYXNzPVwiZHJvcGRvd25cIiBiaW5kOnZhbHVlPXtmaWVsZH0+XHJcblx0XHR7I2VhY2ggZmllbGRzVG9DaGVjayBhcyBmaWVsZH1cclxuXHRcdFx0PG9wdGlvbiB2YWx1ZT17ZmllbGR9PntmaWVsZH08L29wdGlvbj5cclxuXHRcdHsvZWFjaH1cclxuXHQ8L3NlbGVjdD5cclxuPC9sYWJlbD5cclxuXHJcbjx0YWJsZT5cclxuXHQ8dGhlYWQ+XHJcblx0XHQ8dHI+XHJcblx0XHRcdDx0aD5TdGF0PC90aD5cclxuXHRcdFx0PHRoPlZhbHVlPC90aD5cclxuXHRcdDwvdHI+XHJcblx0PC90aGVhZD5cclxuXHR7I2VhY2ggc3RhdHMgYXMgc3RhdH1cclxuXHRcdHsjaWYgc3RhdH1cclxuXHRcdFx0PHRyPlxyXG5cdFx0XHRcdDx0ZD57c3RhdFswXX08L3RkPlxyXG5cdFx0XHRcdDx0ZD57c3RhdFsxXX08L3RkPlxyXG5cdFx0XHQ8L3RyPlxyXG5cdFx0ey9pZn1cclxuXHR7L2VhY2h9XHJcbjwvdGFibGU+XHJcblxyXG48c3R5bGU+XHJcblx0dGFibGUge1xyXG5cdFx0bWFyZ2luLXRvcDogNXB4O1xyXG5cdFx0Ym9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcclxuXHR9XHJcblx0dGgsXHJcblx0dGQge1xyXG5cdFx0Ym9yZGVyOiAxcHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpO1xyXG5cdH1cclxuXHR0ZCB7XHJcblx0XHRwYWRkaW5nOiAwLjJyZW0gMC41cmVtO1xyXG5cdH1cclxuXHR0ZDpmaXJzdC1jaGlsZCB7XHJcblx0XHR0ZXh0LWFsaWduOiByaWdodDtcclxuXHR9XHJcbjwvc3R5bGU+XHJcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQTtBQUVKLElBQU0sUUFBUTtBQUFBLEVBQ2IsUUFBUTtBQUFBLEVBQ1IsYUFBYTtBQUFBLEVBQ2IsTUFBTTtBQUFBLEVBQ04sV0FBVztBQUFBLEVBQ1gsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsY0FBYztBQUFBLEVBQ2QsSUFBSTtBQUFBLEVBQ0osU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sV0FBVztBQUFBLEVBQ1gsUUFBUTtBQUFBLEVBQ1IsVUFBVTtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsYUFBYTtBQUFBLEVBQ2IsU0FBUztBQUFBLEVBQ1QsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sUUFBUTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsV0FBVztBQUFBLEVBQ1gsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsU0FBUztBQUFBLEVBQ1QsUUFBUTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsT0FBTztBQUFBLEVBQ1AsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsUUFBUTtBQUFBLEVBQ1IsV0FBVztBQUFBLEVBQ1gsU0FBUztBQUFBLEVBQ1QsWUFBWTtBQUFBLEVBQ1osS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsV0FBVztBQUFBLEVBQ1gsTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsWUFBWTtBQUFBLEVBQ1osS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1AsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sV0FBVztBQUFBLEVBQ1gsS0FBSztBQUFBLEVBQ0wsVUFBVTtBQUFBLEVBQ1YsWUFBWTtBQUFBLEVBQ1osU0FBUztBQUFBLEVBQ1QsVUFBVTtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsWUFBWTtBQUFBLEVBQ1os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
